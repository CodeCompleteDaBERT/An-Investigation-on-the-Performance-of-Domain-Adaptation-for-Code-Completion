publisher, long n) {<z>
(Operators.validate(n)) {<z>
(DEMAND_FIELD_UPDATER, publisher, n);<z>
.changeToDemandState(this);<z>
... paramTypes) {<z>
"Class must not be null");<z>
notNull(name, "Method name must not be null");<z>
searchType = clazz;<z>
null) {<z>
isInterface() ? searchType.getMethods() :<z>
getDeclaredMethods(searchType, false));<z>
) {<z>
)) {<z>
method;<z>
.getSuperclass();<z>
null;<z>
) throws AopConfigException {<z>
.notNull(a, "Advisor a must not be null");<z>
Assert.notNull(b, "Advisor b must not be null");<z>
;<z>
1) {<z>
;<z>
;<z>
(index, b);<z>
return true;<z>
AbortException {<z>
getKind();<z>
DEBUG) {<z>
{<z>
;<z>
return true;<z>
.INFO || messageKind == IMessage.WEAVEINFO) {<z>
logger.isInfoEnabled()) {<z>
info(makeMessageFor(message));<z>
;<z>
.WARNING) {<z>
{<z>
;<z>
;<z>
== IMessage.ERROR) {<z>
()) {<z>
;<z>
return true;<z>
) {<z>
logger.isFatalEnabled()) {<z>
logger.fatal(makeMessageFor(message));<z>
;<z>
false;<z>
protected ResourceHttpRequestHandler getRequestHandler() {<z>
);<z>
if (this.resourceChainRegistration != null) {<z>
;<z>
));<z>
.locationValues);<z>
handler.setLocations(this.locationsResources);<z>
null) {<z>
this.cacheControl);<z>
else if (this.cachePeriod != null) {<z>
cachePeriod);<z>
this.useLastModified);<z>
);<z>
handler;<z>
createDocumentBuilder(DocumentBuilderFactory factory)<z>
throws ParserConfigurationException {<z>
newDocumentBuilder();<z>
) {<z>
;<z>
;<z>
prefix) {<z>
"Request must not be null");<z>
request.getParameterNames();<z>
> params = new TreeMap<>();<z>
(prefix == null) {<z>
;<z>
()) {<z>
paramNames.nextElement();<z>
(prefix)) {<z>
prefix.length());<z>
request.getParameterValues(paramName);<z>
0) {<z>
else if (values.length > 1) {<z>
;<z>
;<z>
params;<z>
(URL url) {<z>
();<z>
) || URL_PROTOCOL_VFSFILE.equals(protocol) ||<z>
.equals(protocol));<z>
extends Cache> caches,<z>
, Class<?> targetClass, Method targetMethod,<z>
) {<z>
new CacheExpressionRootObject(<z>
targetClass);<z>
(<z>
args, getParameterNameDiscoverer());<z>
RESULT_UNAVAILABLE) {<z>
;<z>
(result != NO_RESULT) {<z>
.setVariable(RESULT_VARIABLE, result);<z>
) {<z>
new BeanFactoryResolver(beanFactory));<z>
return evaluationContext;<z>
int maxResults)<z>
throws DataAccessException {<z>
, "Example entity must not be null");<z>
session -> {<z>
= (entityName != null ?<z>
;<z>
exampleEntity));<z>
executableCriteria);<z>
if (firstResult >= 0) {<z>
);<z>
) {<z>
.setMaxResults(maxResults);<z>
.list();<z>
);<z>
Object candidate) {<z>
{<z>
) candidate).getTargetSource();<z>
(targetSource instanceof SingletonTargetSource) {<z>
();<z>
null;<z>
void stopBeans() {<z>
();<z>
phases = new HashMap<>();<z>
bean) -> {<z>
);<z>
LifecycleGroup group = phases.get(shutdownPhase);<z>
{<z>
timeoutPerShutdownPhase, lifecycleBeans, false);<z>
group);<z>
bean);<z>
);<z>
(!phases.isEmpty()) {<z>
phases.keySet());<z>
.sort(Collections.reverseOrder());<z>
{<z>
.get(key).stop();<z>
public String getParameterName() {<z>
.parameterIndex < 0) {<z>
null;<z>
ParameterNameDiscoverer discoverer = this.parameterNameDiscoverer;<z>
(discoverer != null) {<z>
[] parameterNames = null;<z>
.executable instanceof Method) {<z>
);<z>
if (this.executable instanceof Constructor) {<z>
);<z>
(parameterNames != null) {<z>
;<z>
parameterNameDiscoverer = null;<z>
this.parameterName;<z>
majorVersion, final String className) {<z>
= majorVersion;<z>
className = className;<z>
).index;<z>
(MethodInvocation mi) {<z>
.getMethod());<z>
null) {<z>
return rememberedResult;<z>
getMethod().getDeclaringClass());<z>
);<z>
result;<z>
protected ListenableFuture<WebSocketSession> doHandshakeInternal(WebSocketHandler webSocketHandler,<z>
List<String> protocols,<z>
<String, Object> attributes) {<z>
int port = getPort(uri);<z>
(), port);<z>
, port);<z>
new StandardWebSocketSession(headers,<z>
, localAddress, remoteAddress);<z>
ClientEndpointConfig endpointConfig = ClientEndpointConfig.Builder.create()<z>
configurator(new StandardWebSocketClientConfigurator(headers))<z>
protocols)<z>
).build();<z>
().putAll(getUserProperties());<z>
webSocketHandler, session);<z>
{<z>
, uri);<z>
return session;<z>
.taskExecutor != null) {<z>
(connectTask);<z>
new ListenableFutureTask<>(connectTask);<z>
);<z>
;<z>
String identityName) {<z>
2);<z>
.IDENTITY_NAME, identityName);<z>
null);<z>
?> contextClass, HttpInputMessage inputMessage)<z>
{<z>
;<z>
readJavaType(javaType, inputMessage);<z>
staxSource) throws JAXBException {<z>
;<z>
streamReader != null) {<z>
(this.mappedClass != null ?<z>
.mappedClass).getValue() :<z>
streamReader));<z>
.getXMLEventReader(staxSource);<z>
!= null) {<z>
null ?<z>
) :<z>
unmarshal(eventReader));<z>
IllegalArgumentException("StaxSource contains neither XMLStreamReader nor XMLEventReader");<z>
isQualifierMatch(<z>
) {<z>
test(beanName)) {<z>
;<z>
{<z>
beanFactory.getAliases(beanName)) {<z>
(qualifier.test(alias)) {<z>
;<z>
(beanName);<z>
) {<z>
beanName);<z>
bd instanceof AbstractBeanDefinition abd) {<z>
getName());<z>
!= null) {<z>
.getAttribute(AutowireCandidateQualifier.VALUE_KEY);<z>
value.toString())) {<z>
true;<z>
) {<z>
) bd).getResolvedFactoryMethod();<z>
) {<z>
;<z>
null) {<z>
test(targetAnnotation.value());<z>
(beanType != null) {<z>
(beanType, Qualifier.class);<z>
{<z>
.value());<z>
) {<z>
false;<z>
Annotation> annotationClass) {<z>
{<z>
{<z>
;<z>
false;<z>
{<z>
);<z>
{<z>
.fireTestIgnored(description);<z>
statement;<z>
);<z>
{<z>
= new Fail(ex);<z>
);<z>
) {<z>
);<z>
(UndeclaredThrowableException ex) {<z>
handleError(ex.getUndeclaredThrowable());<z>
{<z>
;<z>
) throws BeansException {<z>
return BeanFactoryUtils.beanOfTypeIncludingAncestors(<z>
, false);<z>
(NoSuchBeanDefinitionException ex) {<z>
+<z>
;<z>
@Nullable ModelAndViewContainer mavContainer,<z>
Exception {<z>
, "RedirectAttributes argument only supported on regular handler methods");<z>
;<z>
if (binderFactory != null) {<z>
(webRequest, null, DataBinder.DEFAULT_OBJECT_NAME);<z>
RedirectAttributesModelMap(dataBinder);<z>
;<z>
mavContainer.setRedirectModel(redirectAttributes);<z>
;<z>
String sessionId) {<z>
;<z>
.userRegistry.getUser(userName);<z>
user != null) {<z>
{<z>
.singleton(sessionId);<z>
> sessions = user.getSessions();<z>
sessions.size());<z>
: sessions) {<z>
session.getId());<z>
.emptySet();<z>
sessionIds;<z>
public static DataUnit fromSuffix(String suffix) {<z>
(DataUnit candidate : values()) {<z>
.equals(suffix)) {<z>
;<z>
suffix + "'");<z>
, String version) {<z>
) {<z>
;<z>
)) {<z>
+ path;<z>
path;<z>
> T doWithMatchingMappingIgnoringException(<z>
{<z>
return doWithMatchingMapping(request, true, matchHandler);<z>
) {<z>
"HandlerMapping exception not suppressed", ex);<z>
{<z>
1 : 0);<z>
('/', 1);<z>
!= -1) {<z>
);<z>
path.substring(endOffset + 1);<z>
);<z>
webJarPath != null) {<z>
substring(WEBJARS_LOCATION_LENGTH);<z>
null;<z>
Nullable MediaType mediaType) {<z>
.isAssignableFrom(clazz)) {<z>
return false;<z>
) {<z>
return true;<z>
)) {<z>
supportedMediaType.isCompatibleWith(mediaType)) {<z>
return true;<z>
;<z>
void registerMessagingAdvice(MessagingAdviceBean bean) {<z>
> type = bean.getBeanType();<z>
type != null) {<z>
new AnnotationExceptionHandlerMethodResolver(type);<z>
) {<z>
);<z>
isTraceEnabled()) {<z>
+ bean);<z>
(<z>
HttpHeaders headers, HttpStatus status, WebRequest request) {<z>
);<z>
T body, @Nullable Type type) {<z>
if (this.uri != null) {<z>
, this.uri, type);<z>
this.uriTemplate != null){<z>
,<z>
.uriVarsMap);<z>
IllegalStateException("Neither URI nor URI template");<z>
{<z>
getSslSession();<z>
if (session != null) {<z>
);<z>
null;<z>
String decodeAndCleanUriString(HttpServletRequest request, String uri) {<z>
removeSemicolonContent(uri);<z>
(request, uri);<z>
uri = getSanitizedPath(uri);<z>
uri;<z>
String name, ResolvableType typeToMatch, boolean allowFactoryBeanInit)<z>
NoSuchBeanDefinitionException {<z>
name);<z>
= BeanFactoryUtils.isFactoryDereference(name);<z>
beanName, false);<z>
) != NullBean.class) {<z>
(beanInstance instanceof FactoryBean) {<z>
if (!isFactoryDereference) {<z>
((FactoryBean<?>) beanInstance);<z>
);<z>
if (!isFactoryDereference) {<z>
.isInstance(beanInstance)) {<z>
;<z>
(beanName)) {<z>
(beanName);<z>
.getUserClass(beanInstance)) {<z>
classToMatch = typeToMatch.resolve();<z>
(beanInstance)) {<z>
return false;<z>
(typeToMatch.isAssignableFrom(targetType)) {<z>
return true;<z>
ResolvableType resolvableType = mbd.targetType;<z>
resolvableType == null) {<z>
factoryMethodReturnType;<z>
;<z>
;<z>
containsBeanDefinition(beanName)) {<z>
;<z>
parentBeanFactory = getParentBeanFactory();<z>
beanName)) {<z>
isTypeMatch(originalBeanName(name), typeToMatch);<z>
RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);<z>
.getDecoratedDefinition();<z>
> classToMatch = typeToMatch.resolve();<z>
classToMatch == null) {<z>
FactoryBean.class;<z>
= (FactoryBean.class == classToMatch ?<z>
.class, classToMatch});<z>
;<z>
null && isFactoryBean(beanName, mbd)) {<z>
{<z>
tbd, typesToMatch);<z>
)) {<z>
predictedType = targetType;<z>
) {<z>
, typesToMatch);<z>
) {<z>
false;<z>
ResolvableType beanType = null;<z>
) {<z>
beanInstance == null && !isFactoryDereference) {<z>
(beanName, mbd, allowFactoryBeanInit);<z>
predictedType = beanType.resolve();<z>
null) {<z>
;<z>
) {<z>
.class);<z>
FactoryBean.class.isAssignableFrom(predictedType)) {<z>
;<z>
) {<z>
targetType;<z>
null) {<z>
factoryMethodReturnType;<z>
definedType.resolve() == predictedType) {<z>
beanType = definedType;<z>
!= null) {<z>
);<z>
(predictedType);<z>
<?> message, MessageChannel channel,<z>
, @Nullable Exception ex) {<z>
{<z>
ChannelInterceptor interceptor = interceptors.get(i);<z>
sent, ex);<z>
{<z>
+ interceptor, ex2);<z>
(String beanName) {<z>
{<z>
.singletonObjects.remove(beanName);<z>
beanName);<z>
remove(beanName);<z>
this.registeredSingletons.remove(beanName);<z>
HttpSession getSession(ServerHttpRequest request) {<z>
serverRequest) {<z>
());<z>
null;<z>
{<z>
filter, "ExchangeFilterFunction must not be null");<z>
().add(filter);<z>
return this;<z>
?> message) {<z>
= message.getHeaders();<z>
(NativeMessageHeaderAccessor.getFirstNativeHeader(<z>
.ORIGINAL_DESTINATION, headers) != null) {<z>
;<z>
accessor.getDestination();<z>
(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION, destination);<z>
.setLeaveMutable(true);<z>
));<z>
)) {<z>
+ " -> " + getBroadcastDestination());<z>
getBroadcastDestination(), message);<z>
(<z>
) {<z>
(clientInboundChannel, clientOutboundChannel).getPathMatcher();<z>
registry) {<z>
.delegates) {<z>
(registry);<z>
> RouterFunction<T> nest(<z>
RouterFunction<T> routerFunction) {<z>
, routerFunction);<z>
long maxByteCount) {<z>
, next) -><z>
(request).map(response -><z>
response.mutate()<z>
, maxByteCount))<z>
);<z>
) {<z>
.entrySet()) {<z>
equalsIgnoreCase(HttpHeaders.CONTENT_LENGTH)) {<z>
.getValue()) {<z>
value);<z>
.containsKey(HttpHeaders.ACCEPT)) {<z>
.header(HttpHeaders.ACCEPT, "*/*");<z>
public void setArgumentNamesFromStringArray(String... args) {<z>
= new String[args.length];<z>
.length; i++) {<z>
();<z>
)) {<z>
throw new IllegalArgumentException(<z>
i] + "' that is not a valid Java identifier");<z>
argumentNames != null) {<z>
== this.argumentNames.length + 1) {<z>
.getParameterTypes()[0];<z>
.class ||<z>
class ||<z>
JoinPoint.StaticPart.class) {<z>
[] oldNames = this.argumentNames;<z>
[oldNames.length + 1];<z>
0] = "THIS_JOIN_POINT";<z>
length);<z>
) throws IntrospectionException {<z>
), original.getWriteMethod(),<z>
, original.getIndexedWriteMethod());<z>
this);<z>
) {<z>
logger.isDebugEnabled()) {<z>
+ "'");<z>
if (getBeanFactory() instanceof ConfigurableBeanFactory) {<z>
(), target);<z>
{<z>
target).destroy();<z>
ex) {<z>
() + "' threw an exception", ex);<z>
, MediaType mediaType) {<z>
{<z>
name);<z>
);<z>
equalsIgnoreCase(s2)) {<z>
false;<z>
true;<z>
BeanFactory beanFactory) {<z>
(beanFactory instanceof ConfigurableListableBeanFactory)) {<z>
IllegalArgumentException(<z>
"DefaultLifecycleProcessor requires a ConfigurableListableBeanFactory: " + beanFactory);<z>
;<z>
resolveArgumentValue(MethodParameter parameter, BindingContext bindingContext,<z>
ServerWebExchange exchange) {<z>
, String>> matrixVariables =<z>
MATRIX_VARIABLES_ATTRIBUTE);<z>
.isEmpty(matrixVariables)) {<z>
();<z>
);<z>
class);<z>
, "No MatrixVariable annotation");<z>
pathVar();<z>
)) {<z>
(pathVariable);<z>
{<z>
.emptyMap();<z>
(mapForPathVariable);<z>
values()) {<z>
) -> {<z>
String value : values) {<z>
;<z>
});<z>
map.toSingleValueMap() : map);<z>
, Collection<TransportHandler> handlers) {<z>
(scheduler);<z>
)) {<z>
.warn("No transport handlers specified for TransportHandlingSockJsService");<z>
handler : handlers) {<z>
initialize(this);<z>
(), handler);<z>
jackson2Present) {<z>
new Jackson2SockJsMessageCodec();<z>
static void registerBeanDefByName(<z>
, @Nullable Object source) {<z>
setSource(source);<z>
setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
;<z>
new BeanComponentDefinition(beanDef, name));<z>
{<z>
String beanName = transformedBeanName(name);<z>
getSingleton(beanName, false);<z>
!= null) {<z>
FactoryBean);<z>
&& getParentBeanFactory() instanceof ConfigurableBeanFactory) {<z>
);<z>
(beanName));<z>
public boolean supportsReturnType(MethodParameter returnType) {<z>
()) ?<z>
resolve() :<z>
returnType.getParameterType();<z>
.class.isAssignableFrom(bodyType) ||<z>
bodyType)));<z>
{<z>
null) {<z>
getApplicationContext());<z>
>();<z>
ControllerAdviceBean adviceBean : adviceBeans) {<z>
();<z>
) {<z>
("Unresolvable type for ControllerAdviceBean: " + adviceBean);<z>
selectMethods(beanType, MODEL_ATTRIBUTE_METHODS);<z>
) {<z>
modelAttributeAdviceCache.put(adviceBean, attrMethods);<z>
= MethodIntrospector.selectMethods(beanType, INIT_BINDER_METHODS);<z>
(!binderMethods.isEmpty()) {<z>
.initBinderAdviceCache.put(adviceBean, binderMethods);<z>
(beanType)) {<z>
adviceBean);<z>
{<z>
, requestResponseBodyAdviceBeans);<z>
.isDebugEnabled()) {<z>
modelAttributeAdviceCache.size();<z>
= this.initBinderAdviceCache.size();<z>
class);<z>
getBodyAdviceCount(ResponseBodyAdvice.class);<z>
== 0) {<z>
"ControllerAdvice beans: none");<z>
modelSize + " @ModelAttribute, " + binderSize +<z>
+ " RequestBodyAdvice, " + resCount + " ResponseBodyAdvice");<z>
<?> message, MessageChannel channel) {<z>
= message;<z>
for (ChannelInterceptor interceptor : interceptors) {<z>
channel);<z>
== null) {<z>
return null;<z>
return messageToUse;<z>
{<z>
(base != null) {<z>
) {<z>
();<z>
if (logger.isDebugEnabled()) {<z>
("Attempting to resolve property '" + beanName + "' in root WebApplicationContext");<z>
.containsBean(beanName)) {<z>
{<z>
debug("Successfully resolved property '" + beanName + "' in root WebApplicationContext");<z>
elContext.setPropertyResolved(true);<z>
getType(beanName);<z>
ex) {<z>
);<z>
null;<z>
(WEB_APPLICATION_CONTEXT_VARIABLE_NAME.equals(property)) {<z>
;<z>
WebApplicationContext.class;<z>
return null;<z>
public boolean equals(@Nullable Object other) {<z>
(this == other) {<z>
return true;<z>
)) {<z>
;<z>
getContent());<z>
public ObjectOptimisticLockingFailureException(<z>
, String msg, @Nullable Throwable cause) {<z>
(msg, cause);<z>
persistentClass;<z>
identifier;<z>
MediaType removeQualityValue() {<z>
getParameters().containsKey(PARAM_QUALITY_FACTOR)) {<z>
;<z>
());<z>
remove(PARAM_QUALITY_FACTOR);<z>
return new MediaType(this, params);<z>
HttpMessageWriter<?>> writers,<z>
) {<z>
resolver, registry);<z>
;<z>
(NativeWebRequest request, ModelAndViewContainer container) throws Exception {<z>
ModelMap defaultModel = container.getDefaultModel();<z>
isComplete()){<z>
.sessionAttributesHandler.cleanupAttributes(request);<z>
storeAttributes(request, defaultModel);<z>
&& container.getModel() == defaultModel) {<z>
updateBindingResult(request, defaultModel);<z>
throws MailParseException {<z>
helper.setBcc(bcc);<z>
catch (MessagingException ex) {<z>
ex);<z>
() {<z>
this.contextMap) {<z>
contextMap.clear();<z>
this.hierarchyMap.clear();<z>
extractCacheManager(Element element) {<z>
) ?<z>
:<z>
);<z>
> propertyType) {<z>
propertyDescriptors) {<z>
Class<?> candidateType;<z>
final String candidateName = pd.getName();<z>
{<z>
ipd.getIndexedPropertyType();<z>
) &&<z>
.getComponentType()))) {<z>
;<z>
pd.getPropertyType();<z>
if (candidateName.equals(propertyName) &&<z>
.getComponentType()))) {<z>
;<z>
null;<z>
void registerContainedBean(String containedBeanName, String containingBeanName) {<z>
{<z>
String> containedBeans =<z>
LinkedHashSet<>(8));<z>
{<z>
registerDependentBean(containedBeanName, containingBeanName);<z>
) {<z>
.getBeanClassName()) &&<z>
.getFactoryBeanName()) &&<z>
previous.getFactoryMethodName())) {<z>
;<z>
targetType;<z>
targetType.equals(previousTargetType)) {<z>
= previousTargetType;<z>
previous.isFactoryBean;<z>
.resolvedTargetType = previous.resolvedTargetType;<z>
factoryMethodReturnType;<z>
;<z>
columnLabel) throws InvalidResultSetAccessException {<z>
= this.columnLabelMap.get(columnLabel);<z>
!= null) {<z>
;<z>
);<z>
SQLException se) {<z>
throw new InvalidResultSetAccessException(se);<z>
, Object concurrentResult) {<z>
HttpServletRequest.class);<z>
request != null) {<z>
, null);<z>
> strategyInterface) {<z>
{<z>
;<z>
);<z>
catch (IOException ex) {<z>
ex.getMessage());<z>
strategyInterface.getName();<z>
= defaultStrategies.getProperty(key);<z>
) {<z>
StringUtils.commaDelimitedListToStringArray(value);<z>
new ArrayList<>(classNames.length);<z>
classNames) {<z>
class.getClassLoader());<z>
strategy = createDefaultStrategy(context, clazz);<z>
((T) strategy);<z>
{<z>
throw new BeanInitializationException(<z>
+ className +<z>
"]", ex);<z>
(LinkageError err) {<z>
(<z>
err);<z>
;<z>
return Collections.emptyList();<z>
synchronized void compile() throws InvalidDataAccessApiUsageException {<z>
if (!isCompiled()) {<z>
() == null) {<z>
;<z>
();<z>
IllegalArgumentException ex) {<z>
(ex.getMessage());<z>
compileInternal();<z>
this.compiled = true;<z>
isDebugEnabled()) {<z>
+ getTableName() + "] compiled");<z>
boolean isDigit(char ch) {<z>
{<z>
false;<z>
;<z>
void clear() {<z>
().lock();<z>
cache.clear();<z>
clear();<z>
this.size = 0;<z>
().unlock();<z>
() {<z>
+ "' on field '" + this.field +<z>
nullSafeToString(this.rejectedValue) + "]; " +<z>
);<z>
throws BeansException {<z>
instanceof ServletContextAware) {<z>
));<z>
ServletConfigAware) {<z>
());<z>
return bean;<z>
(<z>
String className,<z>
,<z>
String descriptor,<z>
codeSize) {<z>
"." + methodName + " " + descriptor);<z>
.className = className;<z>
;<z>
this.descriptor = descriptor;<z>
codeSize = codeSize;<z>
eldest) {<z>
getMaxSize()) {<z>
.getKey(), HierarchyMode.CURRENT_LEVEL);<z>
false;<z>
(Object returnValue) {<z>
1);<z>
returnValue = returnValue;<z>
returnType = (returnValue instanceof ReactiveTypeHandler.CollectedValuesList ?<z>
:<z>
.isSuspendingFunction(super.getMethod()) ?<z>
ResolvableType.forMethodParameter(getReturnType()) :<z>
()).getGeneric());<z>
static WildcardBounds get(ResolvableType type) {<z>
type;<z>
instanceof WildcardType)) {<z>
resolveToWildcard == NONE) {<z>
null;<z>
);<z>
= (WildcardType) resolveToWildcard.type;<z>
);<z>
;<z>
[bounds.length];<z>
; i++) {<z>
variableResolver);<z>
;<z>
[]> message) {<z>
updateLastWriteTime();<z>
>();<z>
.session;<z>
, "No WebSocketSession available");<z>
message, session.getClass()));<z>
;<z>
Throwable ex) {<z>
(ex);<z>
();<z>
return future;<z>
classLoader,<z>
,<z>
{<z>
, rootAttributes, valueExtractor, aggregateIndex, null);<z>
Builder builder() {<z>
builder = new DefaultHandlerStrategiesBuilder();<z>
;<z>
builder;<z>
getResponseHeaders() {<z>
{<z>
return HttpHeaders.EMPTY;<z>
new HttpHeaders();<z>
this.supportedMediaTypes);<z>
headers;<z>
{<z>
null) {<z>
targetType);<z>
.convert(source);<z>
{<z>
switch (method.getName()) {<z>
:<z>
);<z>
"hashCode":<z>
();<z>
:<z>
;<z>
if (targetClass == null) {<z>
target;<z>
)) {<z>
return proxy;<z>
case "getOutputParameterValue":<z>
(this.entityManager == null) {<z>
key = args[0];<z>
containsKey(key)) {<z>
("OUT/INOUT parameter not available: " + key);<z>
);<z>
instanceof IllegalArgumentException) {<z>
value;<z>
value;<z>
invoke(this.target, args);<z>
== 3 &&<z>
2] == ParameterMode.INOUT)) {<z>
(this.outputParameters == null) {<z>
new LinkedHashMap<>();<z>
);<z>
proxy : retVal);<z>
{<z>
ex.getTargetException();<z>
.getName())) {<z>
storedProc) {<z>
outputParameters.entrySet()) {<z>
);<z>
) {<z>
);<z>
()));<z>
) {<z>
setValue(ex);<z>
EntityManagerFactoryUtils.closeEntityManager(this.entityManager);<z>
;<z>
() {<z>
) {<z>
put(type, new DateTimeFormatterFactory());<z>
> createDeferredResult(HttpServletRequest request, HttpServletResponse response,<z>
) {<z>
);<z>
) -> {<z>
{<z>
() != null) {<z>
();<z>
ServerResponse errorResponse = errorResponse(ex, request);<z>
null) {<z>
setResult(errorResponse);<z>
;<z>
;<z>
);<z>
writeException) {<z>
writeException);<z>
return null;<z>
);<z>
return result;<z>
private StompHeaderAccessor createHeaderAccessor(StompCommand command) {<z>
accessor = StompHeaderAccessor.create(command);<z>
setSessionId(this.sessionId);<z>
;<z>
return accessor;<z>
)<z>
XPathExpressionException {<z>
namespaces, args);<z>
public static ResponseCreator withException(IOException ex) {<z>
return request -> {<z>
;<z>
String beanName) {<z>
this.prototypesCurrentlyInCreation.get();<z>
(curVal != null &&<z>
);<z>
(@Nullable List<TransactionSynchronization> synchronizations) {<z>
(synchronizations != null) {<z>
: synchronizations) {<z>
;<z>
<String> fieldList) {<z>
add(field);<z>
plainField = field;<z>
= plainField.lastIndexOf('[');<z>
keyIndex != -1) {<z>
= plainField.indexOf(']', keyIndex);<z>
) {<z>
;<z>
fieldList.add(plainField);<z>
);<z>
-1;<z>
setAutoGrowNestedPaths(boolean autoGrowNestedPaths) {<z>
this.bindingResult == null,<z>
;<z>
.autoGrowNestedPaths = autoGrowNestedPaths;<z>
int[] types) {<z>
;<z>
(sql);<z>
(types);<z>
) throws IllegalStateException {<z>
(false, true)) {<z>
new IllegalStateException(<z>
;<z>
(getId());<z>
Object unwrapCachedValue(Object cached) {<z>
currentKey instanceof EnhancerKey) {<z>
();<z>
return data;<z>
cached);<z>
public long lastModified() throws IOException {<z>
this.path).toMillis();<z>
T> methods) {<z>
String packageName = ClassUtils.getPackageName(userType);<z>
(packageName) ?<z>
(packageName.split("\\."))<z>
substring(0, 1))<z>
())) :<z>
userType.getSimpleName());<z>
getParameterTypes())<z>
)<z>
"(", ")"));<z>
.entrySet().stream()<z>
.map(e -> {<z>
getKey();<z>
(method);<z>
":" + "\n\t", ""));<z>
void computeExitTypeDescriptor() {<z>
null &&<z>
].exitTypeDescriptor != null) {<z>
;<z>
children[1].exitTypeDescriptor;<z>
.nullSafeEquals(conditionDescriptor, ifNullValueDescriptor)) {<z>
= conditionDescriptor;<z>
"Ljava/lang/Object";<z>
{<z>
applicationContext;<z>
resourceLoader == null) {<z>
);<z>
ResourceHandlerRegistry(resourceLoader);<z>
);<z>
(registry);<z>
= registry.getHandlerMapping();<z>
{<z>
;<z>
;<z>
handlerMapping;<z>
@Nullable String name, @Nullable PatternsRequestCondition patterns,<z>
@Nullable ParamsRequestCondition params,<z>
@Nullable ConsumesRequestCondition consumes,<z>
, @Nullable RequestCondition<?> custom,<z>
BuilderConfiguration options) {<z>
;<z>
patterns != null ? patterns : EMPTY_PATTERNS);<z>
(methods != null ? methods : EMPTY_REQUEST_METHODS);<z>
!= null ? params : EMPTY_PARAMS);<z>
? headers : EMPTY_HEADERS);<z>
consumes != null ? consumes : EMPTY_CONSUMES);<z>
: EMPTY_PRODUCES);<z>
? new RequestConditionHolder(custom) : EMPTY_CUSTOM);<z>
this.options = options;<z>
= calculateHashCode(<z>
, this.paramsCondition, this.headersCondition,<z>
this.producesCondition, this.customConditionHolder);<z>
{<z>
this.asyncSendTimeout != null) {<z>
setAsyncSendTimeout(this.asyncSendTimeout);<z>
null) {<z>
.setDefaultMaxSessionIdleTimeout(this.maxSessionIdleTimeout);<z>
{<z>
.setDefaultMaxTextMessageBufferSize(this.maxTextMessageBufferSize);<z>
!= null) {<z>
;<z>
ServerWebExchange exchange) {<z>
this.handlerMappings == null) {<z>
createNotFoundError();<z>
{<z>
exchange);<z>
fromIterable(this.handlerMappings)<z>
)<z>
)<z>
(createNotFoundError())<z>
, handler))<z>
handleResult(exchange, result));<z>
static AnnotationTypeMappings forAnnotationType(<z>
? extends Annotation> annotationType, AnnotationFilter annotationFilter) {<z>
), annotationFilter);<z>
,<z>
exchange) {<z>
ContentChunkInfo> contentChunkInfos = parseContent(cssContent);<z>
()) {<z>
.just(resource);<z>
)<z>
-> {<z>
getContent(cssContent);<z>
) && !hasScheme(contentChunk)) {<z>
= toAbsolutePath(contentChunk, exchange);<z>
resource, chain).defaultIfEmpty(contentChunk);<z>
just(contentChunk);<z>
{<z>
;<z>
;<z>
{<z>
getBytes(DEFAULT_CHARSET);<z>
TransformedResource(resource, newContent);<z>
});<z>
throws SQLException {<z>
;<z>
{<z>
{<z>
.actualSql, generatedKeysColumnNames);<z>
, Statement.RETURN_GENERATED_KEYS);<z>
== ResultSet.TYPE_FORWARD_ONLY && !updatableResults) {<z>
actualSql);<z>
,<z>
ResultSet.CONCUR_UPDATABLE : ResultSet.CONCUR_READ_ONLY);<z>
);<z>
return ps;<z>
sourceTypeDescriptor, TypeDescriptor targetTypeDescriptor) {<z>
conversionService.canConvert(sourceTypeDescriptor, targetTypeDescriptor)) {<z>
return true;<z>
> sourceType = sourceTypeDescriptor.getObjectType();<z>
targetType = targetTypeDescriptor.getObjectType();<z>
, targetType);<z>
Properties splitArrayElementsIntoProperties(<z>
, @Nullable String charsToDelete) {<z>
) {<z>
null;<z>
= new Properties();<z>
: array) {<z>
(charsToDelete != null) {<z>
element, charsToDelete);<z>
] splittedElement = split(element, delimiter);<z>
== null) {<z>
1].trim());<z>
return result;<z>
statusCode, HttpHeaders headers,<z>
String, Object> model) {<z>
cookies);<z>
;<z>
<>(model));<z>
getDescription() {<z>
getTestClass().getJavaClass())) {<z>
);<z>
();<z>
) {<z>
(this == other) {<z>
return true;<z>
otherEntry)) {<z>
false;<z>
otherEntry.getKey()) &&<z>
), otherEntry.getValue()));<z>
(WebSocketMessage message) throws IOException {<z>
asByteBuffer();<z>
.getType())) {<z>
.setReadyToSend(false);<z>
UTF_8);<z>
text, new SendProcessorCallback());<z>
))) {<z>
).setReadyToSend(false);<z>
());<z>
)) {<z>
;<z>
) {<z>
.sendPong(buffer);<z>
+ message.getType());<z>
true;<z>
(<z>
importedResources) {<z>
>();<z>
.forEach((resource, readerClass) -> {<z>
BeanDefinitionReader.class == readerClass) {<z>
endsWithIgnoreCase(resource, ".groovy")) {<z>
readerClass = GroovyBeanDefinitionReader.class;<z>
else if (shouldIgnoreXml) {<z>
);<z>
XmlBeanDefinitionReader.class;<z>
readerClass);<z>
== null) {<z>
this.registry);<z>
) {<z>
(this.resourceLoader);<z>
.environment);<z>
reader);<z>
Throwable ex) {<z>
IllegalStateException(<z>
() + "]");<z>
);<z>
});<z>
, String... fields) {<z>
);<z>
fieldType = adapter.getFieldType();<z>
isEmpty(fields)) {<z>
, adapter);<z>
fields) {<z>
(fieldType, field, adapter);<z>
path) {<z>
end = path.indexOf('?');<z>
path.indexOf('#');<z>
-1 || fragmentIndex < end)) {<z>
= fragmentIndex;<z>
if (end == -1) {<z>
length();<z>
return end;<z>
getImports(SourceClass sourceClass) throws IOException {<z>
imports = new LinkedHashSet<>();<z>
;<z>
imports, visited);<z>
return imports;<z>
String destinationName, boolean pubSubDomain)<z>
JMSException {<z>
;<z>
(destinationName);<z>
(dest != null) {<z>
, pubSubDomain);<z>
Destination.class);<z>
dest, destinationName, pubSubDomain);<z>
ex) {<z>
(logger.isDebugEnabled()) {<z>
destinationName + "] not found in JNDI", ex);<z>
) {<z>
;<z>
(<z>
);<z>
) {<z>
.put(destinationName, dest);<z>
;<z>
Session session) {<z>
();<z>
isEmpty(configs)) {<z>
.size());<z>
ExtensionConfig config : configs) {<z>
);<z>
unmodifiableList(result);<z>
();<z>
ResponseSpec onStatus(Predicate<HttpStatus> statusPredicate,<z>
<? extends Throwable>> exceptionFunction) {<z>
toIntPredicate(statusPredicate), exceptionFunction);<z>
Object value) {<z>
hasLength(name, "Name must not be empty");<z>
;<z>
) {<z>
("attributes can only be called after any other method (GET, path, etc.)");<z>
;<z>
(lastIdx)<z>
value);<z>
.set(lastIdx, attributed);<z>
;<z>
SQLException {<z>
this)) {<z>
T) this;<z>
unwrap(iface);<z>
String getDestinationString() {<z>
) {<z>
destination.toString();<z>
return this.destinationString;<z>
sessionId, MethodParameter returnType) {<z>
;<z>
) {<z>
;<z>
null) {<z>
;<z>
, returnType);<z>
;<z>
getMessageHeaders();<z>
@Nullable MethodFilter mf) {<z>
methods = new ArrayList<>(20);<z>
(leafClass, method -> {<z>
;<z>
null;<z>
for (Method existingMethod : methods) {<z>
) &&<z>
.getParameterCount() &&<z>
.getParameterTypes())) {<z>
.getReturnType() &&<z>
getReturnType())) {<z>
= existingMethod;<z>
;<z>
null) {<z>
.remove(methodBeingOverriddenWithCovariantReturnType);<z>
!isCglibRenamedMethod(method)) {<z>
);<z>
;<z>
;<z>
bh) {<z>
{<z>
path));<z>
{<z>
);<z>
1 : 0);<z>
isAscending() ? 1 : 0);<z>
return hashCode;<z>
void setMessageListener(@Nullable Object messageListener) {<z>
messageListener);<z>
;<z>
this.subscriptionName == null) {<z>
(messageListener);<z>
HttpServletRequest request, String requestPath,<z>
Resource> locations, ResourceResolverChain chain) {<z>
, request, locations);<z>
beanName, Class<?>... typesToMatch)<z>
{<z>
mbd.hasBeanClass()) {<z>
getBeanClass();<z>
mbd, typesToMatch);<z>
ClassNotFoundException ex) {<z>
), ex);<z>
catch (LinkageError err) {<z>
getBeanClassName(), err);<z>
{<z>
annotation : getAnnotations()) {<z>
() == annotationClass) {<z>
) annotation;<z>
;<z>
{<z>
.notNull(source, "Source List must not be null");<z>
;<z>
);<z>
.sortUsed = null;<z>
> sourceClass)<z>
throws SQLException {<z>
columnName);<z>
if (xmlObject == null) {<z>
;<z>
DOMSource.class));<z>
(<z>
FormattingConversionService mvcConversionService,<z>
{<z>
;<z>
);<z>
patternParser != null) {<z>
patternParser);<z>
);<z>
) {<z>
;<z>
setUseTrailingSlashMatch(useTrailingSlashPatternMatch);<z>
.setOrder(0);<z>
mvcResourceUrlProvider));<z>
return handlerMapping;<z>
{<z>
provider = provider;<z>
method.getName();<z>
.declaringClass = method.getDeclaringClass();<z>
index = index;<z>
method = method;<z>
destination, Object payload) {<z>
;<z>
;<z>
payload);<z>
ClientHttpResponse validateRequest(ClientHttpRequest request) throws IOException {<z>
expectation;<z>
) {<z>
.requests.isEmpty()) {<z>
;<z>
;<z>
{<z>
request, ex);<z>
throw ex;<z>
add(request);<z>
createResponse(request);<z>
{<z>
.getFactoryMethodName();<z>
!= null) {<z>
(factoryMethodName);<z>
(!factoryMethodName.equals(resolvedName)) {<z>
beanDefinition.setFactoryMethodName(resolvedName);<z>
(SimpUser user) {<z>
getName();<z>
= user.getSessions();<z>
sessions.size());<z>
sessions) {<z>
));<z>
(Class<?> clazz) {<z>
StringBuilder sb = new StringBuilder();<z>
(clazz.isArray()) {<z>
while (clazz.isArray()) {<z>
append('[');<z>
;<z>
if (clazz.isPrimitive()) {<z>
if (clazz == Boolean.TYPE) {<z>
append('Z');<z>
.TYPE) {<z>
.append('B');<z>
clazz == Character.TYPE) {<z>
('C');<z>
.TYPE) {<z>
.append('D');<z>
Float.TYPE) {<z>
);<z>
== Integer.TYPE) {<z>
sb.append('I');<z>
) {<z>
append('J');<z>
== Short.TYPE) {<z>
append('S');<z>
else if (clazz == Void.TYPE) {<z>
sb.append('V');<z>
);<z>
'/'));<z>
;<z>
sb.toString();<z>
> handleConnectionSetupPayload(ConnectionSetupPayload payload) {<z>
);<z>
return handle(payload, FrameType.SETUP);<z>
newState) {<z>
newState);<z>
)) {<z>
" -> " + newState);<z>
return result;<z>
Class<?> clazz, HttpInputMessage inputMessage)<z>
, HttpMessageNotReadableException {<z>
inputMessage);<z>
void onComplete() {<z>
()) {<z>
.logPrefix + "onComplete");<z>
.completionFlag, this.asyncContext::complete);<z>
{<z>
this.id = id;<z>
this.name = name;<z>
= driversLicense;<z>
throws ServletException {<z>
);<z>
"No target bean name set");<z>
.class);<z>
{<z>
init(getFilterConfig());<z>
delegate;<z>
) {<z>
count = this.partCount.incrementAndGet();<z>
&& count > this.maxParts) {<z>
.maxParts + " allowed)"));<z>
;<z>
return false;<z>
isUrl(@Nullable String resourceLocation) {<z>
null) {<z>
return false;<z>
CLASSPATH_URL_PREFIX)) {<z>
return true;<z>
);<z>
return true;<z>
MalformedURLException ex) {<z>
false;<z>
messageSupplier) {<z>
text)) {<z>
(nullSafeGet(messageSupplier));<z>
) {<z>
pathPatternsCondition != null) {<z>
<T>) this.pathPatternsCondition;<z>
null) {<z>
.patternsCondition;<z>
);<z>
) {<z>
) {<z>
.servletContext));<z>
ignoreDependencyInterface(ServletContextAware.class);<z>
.registerWebApplicationScopes(beanFactory, this.servletContext);<z>
;<z>
void initialize() throws JmsException {<z>
) {<z>
;<z>
notifyAll();<z>
doInitialize();<z>
) {<z>
synchronized (this.sharedConnectionMonitor) {<z>
autoStartup);<z>
= null;<z>
convertJmsAccessException(ex);<z>
T> instanceSupplier) {<z>
());<z>
beanDefinition.setBeanClass(beanClass);<z>
instanceSupplier);<z>
;<z>
PointcutExpression buildPointcutExpression(@Nullable ClassLoader classLoader) {<z>
(classLoader);<z>
;<z>
.length; i++) {<z>
parser.createPointcutParameter(<z>
);<z>
)),<z>
pointcutDeclarationScope, pointcutParameters);<z>
<T> processor, Throwable ex) {<z>
COMPLETED)) {<z>
ex);<z>
().onError(processor, ex);<z>
EvaluationException {<z>
CompiledExpression compiledAst = this.compiledAst;<z>
!= null) {<z>
));<z>
if (expectedResultType == null) {<z>
result;<z>
ExpressionUtils.convertTypedValue(<z>
, new TypedValue(result), expectedResultType);<z>
) {<z>
.MIXED) {<z>
compiledAst = null;<z>
);<z>
SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);<z>
=<z>
;<z>
getTypedValue(expressionState);<z>
expressionState);<z>
return ExpressionUtils.convertTypedValue(<z>
typedResultValue, expectedResultType);<z>
maxAge(String name, int maxAge) {<z>
result -> {<z>
);<z>
, cookie.getMaxAge());<z>
MessageConversionException {<z>
instanceof TextMessage) {<z>
((TextMessage) message);<z>
{<z>
) message);<z>
message instanceof MapMessage) {<z>
);<z>
ObjectMessage) {<z>
return extractSerializableFromMessage((ObjectMessage) message);<z>
return message;<z>
Blackhole bh) {<z>
{<z>
data.patterns) {<z>
pattern, path));<z>
parserContext) {<z>
);<z>
, source);<z>
compDefinition);<z>
();<z>
= element.getAttribute("mode");<z>
("aspectj".equals(mode)) {<z>
);<z>
ASYNC_ANNOTATION_PROCESSOR_BEAN_NAME)) {<z>
().error(<z>
);<z>
= BeanDefinitionBuilder.genericBeanDefinition(<z>
"org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessor");<z>
);<z>
getAttribute("executor");<z>
.hasText(executor)) {<z>
.addPropertyReference("executor", executor);<z>
.getAttribute("exception-handler");<z>
if (StringUtils.hasText(exceptionHandler)) {<z>
;<z>
{<z>
true);<z>
, builder, TaskManagementConfigUtils.ASYNC_ANNOTATION_PROCESSOR_BEAN_NAME);<z>
containsBeanDefinition(TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)) {<z>
).error(<z>
source);<z>
builder = BeanDefinitionBuilder.genericBeanDefinition(<z>
"org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor");<z>
.getRawBeanDefinition().setSource(source);<z>
.getAttribute("scheduler");<z>
StringUtils.hasText(scheduler)) {<z>
"scheduler", scheduler);<z>
.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME);<z>
.popAndRegisterContainingComponent();<z>
;<z>
static Msg parseFrom(<z>
data,<z>
.protobuf.ExtensionRegistryLite extensionRegistry)<z>
com.google.protobuf.InvalidProtocolBufferException {<z>
);<z>
extension) {<z>
if (extension.contains(",")) {<z>
);<z>
;<z>
parts[0].trim();<z>
= null;<z>
(parts.length > 1) {<z>
);<z>
.length; i++) {<z>
i];<z>
'=');<z>
eqIndex != -1) {<z>
, eqIndex);<z>
= parameter.substring(eqIndex + 1);<z>
attribute, value);<z>
(name, parameters);<z>
public WebResponse build() throws IOException {<z>
webResponseData = webResponseData();<z>
;<z>
.startTime);<z>
<String, Object> model, Channel channel,<z>
HttpServletRequest request, HttpServletResponse response) throws Exception {<z>
model, request, response);<z>
setItems(items);<z>
throws AccessException {<z>
ReflectionHelper.convertArguments(<z>
ctor, this.varargsPosition);<z>
{<z>
.setupArgumentsForVarargsInvocation(<z>
arguments);<z>
);<z>
newInstance(arguments));<z>
ex) {<z>
);<z>
() {<z>
ToStringCreator(this)<z>
("name", getName())<z>
"value", getValue())<z>
.append("Path", getPath())<z>
("Domain", getDomain())<z>
.append("Version", getVersion())<z>
())<z>
append("Secure", getSecure())<z>
("HttpOnly", isHttpOnly())<z>
("SameSite", this.sameSite)<z>
getMaxAge())<z>
("Expires", (this.expires != null ?<z>
)<z>
.toString();<z>
Token> tokens, int maxParts, int maxInMemorySize,<z>
, boolean streaming, Mono<Path> fileStorageDirectory,<z>
blockingOperationScheduler) {<z>
return Flux.create(sink -> {<z>
maxInMemorySize, maxDiskUsagePerPart, streaming,<z>
, blockingOperationScheduler);<z>
onCancel(generator::onSinkCancel);<z>
;<z>
.subscribe(generator);<z>
;<z>
public void setSubscriptionDurable(boolean subscriptionDurable) {<z>
;<z>
if (subscriptionDurable) {<z>
true;<z>
public void setScheduler(@Nullable Object scheduler) {<z>
{<z>
.taskScheduler = null;<z>
{<z>
(TaskScheduler) scheduler;<z>
(scheduler instanceof ScheduledExecutorService) {<z>
ScheduledExecutorService) scheduler));<z>
);<z>
doRollbackOnCommitException(TransactionSynchronizationManager synchronizationManager,<z>
{<z>
defer(() -> {<z>
()) {<z>
if (status.isDebug()) {<z>
;<z>
;<z>
(status.hasTransaction()) {<z>
(status.isDebug()) {<z>
logger.debug("Marking existing transaction as rollback-only after commit exception", ex);<z>
status);<z>
;<z>
onErrorResume(ErrorPredicates.RUNTIME_OR_ERROR, rbex -> {<z>
);<z>
STATUS_UNKNOWN)<z>
then(Mono.error(rbex));<z>
status, TransactionSynchronization.STATUS_ROLLED_BACK));<z>
body(DataBuffer dataBuffer) {<z>
readableByteCount());<z>
|| count <= PartGenerator.this.maxDiskUsagePerPart) {<z>
this.closeOnDispose = false;<z>
WritingFileState newState = new WritingFileState(this);<z>
(changeState(this, newState)) {<z>
newState.writeBuffer(dataBuffer);<z>
this.channel);<z>
.release(dataBuffer);<z>
(dataBuffer);<z>
(new DataBufferLimitException(<z>
.this.maxDiskUsagePerPart +<z>
" bytes"));<z>
public boolean isFile() {<z>
(this.uri != null) {<z>
super.isFile(this.uri);<z>
isFile();<z>
public static JndiLocatorDelegate createDefaultResourceRefLocator() {<z>
JndiLocatorDelegate jndiLocator = new JndiLocatorDelegate();<z>
jndiLocator.setResourceRef(true);<z>
;<z>
() {<z>
this.sockJsTaskScheduler == null) {<z>
;<z>
) {<z>
)<z>
;<z>
;<z>
) {<z>
("advice", new TxAdviceBeanDefinitionParser());<z>
("annotation-driven", new AnnotationDrivenBeanDefinitionParser());<z>
));<z>
attributes) {<z>
> annotationType = attributes.annotationType();<z>
.getModifiers()) &&<z>
(annotationType)) {<z>
(annotationType);<z>
.forEach(attributes::putIfAbsent);<z>
getPriority(Object obj) {<z>
if (obj instanceof Class) {<z>
) obj);<z>
.getClass());<z>
{<z>
.getDecoratedClass());<z>
;<z>
FileNotFoundException {<z>
.notNull(servletContext, "ServletContext must not be null");<z>
"/")) {<z>
"/" + path;<z>
getRealPath(path);<z>
) {<z>
throw new FileNotFoundException(<z>
+ path + "] cannot be resolved to absolute file path - " +<z>
;<z>
;<z>
requestEntity,<z>
ParameterizedTypeReference<T> responseType) throws RestClientException {<z>
;<z>
httpEntityCallback(requestEntity, type);<z>
);<z>
url, method, requestCallback, responseExtractor));<z>
ExecutorService initializeExecutor(<z>
RejectedExecutionHandler rejectedExecutionHandler) {<z>
threadFactory, rejectedExecutionHandler);<z>
scheduledPoolExecutor) {<z>
) {<z>
true);<z>
continueExistingPeriodicTasksAfterShutdownPolicy) {<z>
true);<z>
if (!this.executeExistingDelayedTasksAfterShutdownPolicy) {<z>
;<z>
scheduledExecutor;<z>
) {<z>
.size()) {<z>
;<z>
{<z>
RequestMethod.GET)) {<z>
1;<z>
HEAD)) {<z>
;<z>
;<z>
BeanDefinitionRegistry registry, Environment environment) {<z>
.notNull(registry, "BeanDefinitionRegistry must not be null");<z>
Assert.notNull(environment, "Environment must not be null");<z>
= registry;<z>
(registry, environment, null);<z>
this.registry);<z>
void openConnection() {<z>
) -> {<z>
()) {<z>
+ getUri());<z>
endpointToUse = this.endpoint;<z>
{<z>
null, "No endpoint set");<z>
);<z>
build();<z>
endpointToUse, endpointConfig, getUri());<z>
logger.info("Successfully connected to WebSocket");<z>
{<z>
("Failed to connect to WebSocket", ex);<z>
});<z>
provider) {<z>
() {<z>
SQLXML xmlObject) throws SQLException, IOException {<z>
(xmlObject.setBinaryStream());<z>
) {<z>
StringBuilder sb = new StringBuilder("ModelAndViewContainer: ");<z>
()) {<z>
isViewReference()) {<z>
.view).append('\'');<z>
append(']');<z>
)) {<z>
"; default model ");<z>
);<z>
sb.append(getModel());<z>
append("Request handled directly");<z>
sb.toString();<z>
String value) {<z>
&& StringUtils.hasText(value)) {<z>
(name, value);<z>
this;<z>
Properties props)<z>
{<z>
valueResolver = new PlaceholderResolvingStringValueResolver(props);<z>
valueResolver);<z>
DefaultTransactionStatus status) throws TransactionException {<z>
(<z>
"returns true, appropriate 'doSetRollbackOnly' behavior must be provided");<z>
MultipartRequest resolveMultipartRequest(NativeWebRequest webRequest) {<z>
= webRequest.getNativeRequest(MultipartRequest.class);<z>
) {<z>
return multipartRequest;<z>
class);<z>
servletRequest != null && isMultipartContent(servletRequest)) {<z>
);<z>
return null;<z>
{<z>
, classLoader);<z>
factoryImplementationClass)) {<z>
(<z>
"]");<z>
factoryImplementationClass).newInstance();<z>
ex) {<z>
(<z>
"] for factory type [" + factoryType.getName() + "]",<z>
;<z>
?>> messageConverters) {<z>
;<z>
addAll(messageConverters);<z>
;<z>
) {<z>
class || hasPlainJavaAnnotationsOnly(baseType)) {<z>
;<z>
get(baseType);<z>
) {<z>
baseType.isInterface();<z>
;<z>
0;<z>
i < methods.length; i++) {<z>
.getModifiers())) ||<z>
]) ||<z>
) {<z>
null;<z>
cleared++;<z>
methods.length) {<z>
methods = NO_METHODS;<z>
);<z>
;<z>
String, Object> attributes,<z>
,<z>
Nullable Principal user) {<z>
attributes);<z>
;<z>
());<z>
.handshakeHeaders = HttpHeaders.readOnlyHttpHeaders(headers);<z>
= user;<z>
;<z>
remoteAddress = remoteAddress;<z>
(Element element, ParserContext parserContext) {<z>
element);<z>
.registerCacheAdvisor(element, parserContext);<z>
) {<z>
JCacheCachingConfigurer.registerCacheAdvisor(element, parserContext);<z>
() {<z>
.typeConverter == null) {<z>
;<z>
;<z>
{<z>
if (synch) {<z>
);<z>
("Flushing Hibernate Session on explicit request");<z>
.flush();<z>
{<z>
;<z>
{<z>
instanceof HibernateException) {<z>
(HibernateException) ex.getCause());<z>
ex;<z>
public void destroy() {<z>
!= null) {<z>
sessionFactory.close();<z>
<T> NamedBeanHolder<T> resolveNamedBean(<z>
{<z>
requiredType, "Required type must not be null");<z>
] candidateNames = getBeanNamesForType(requiredType);<z>
{<z>
length);<z>
beanName : candidateNames) {<z>
)) {<z>
add(beanName);<z>
autowireCandidates.isEmpty()) {<z>
;<z>
{<z>
candidateNames[0], requiredType, args);<z>
> 1) {<z>
);<z>
(String beanName : candidateNames) {<z>
(beanName) && args == null) {<z>
= getBean(beanName);<z>
;<z>
, getType(beanName));<z>
requiredType.toClass());<z>
candidateName == null) {<z>
(candidates, requiredType.toClass());<z>
!= null) {<z>
;<z>
{<z>
;<z>
instanceof Class) {<z>
(candidateName, requiredType, args);<z>
, (T) beanInstance);<z>
if (!nonUniqueAsNull) {<z>
;<z>
return null;<z>
{<z>
hasPathResolver) {<z>
(this.resolvers);<z>
hasWebjarsResolver) {<z>
add(new WebJarsResourceResolver());<z>
(new PathResourceResolver());<z>
return result;<z>
;<z>
) {<z>
oldTransactionInfo);<z>
{<z>
.formatMessage(inserts));<z>
message = message;<z>
inserts = inserts;<z>
nestingLevel) {<z>
!= 1) {<z>
throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +<z>
"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal");<z>
(methodParameter), nestingLevel);<z>
public String getTargetTypeName() {<z>
;<z>
) {<z>
>) targetTypeValue).getName();<z>
String) targetTypeValue;<z>
{<z>
Session session = super.buildOrObtainSession();<z>
{<z>
);<z>
session;<z>
UrlBasedViewResolverRegistration jsp(String prefix, String suffix) {<z>
();<z>
.setPrefix(prefix);<z>
suffix);<z>
;<z>
);<z>
boolean equals(final Object object) {<z>
this) {<z>
return true;<z>
(!(object instanceof ConstantDynamic)) {<z>
return false;<z>
constantDynamic = (ConstantDynamic) object;<z>
name.equals(constantDynamic.name)<z>
&& descriptor.equals(constantDynamic.descriptor)<z>
&& bootstrapMethod.equals(constantDynamic.bootstrapMethod)<z>
equals(bootstrapMethodArguments, constantDynamic.bootstrapMethodArguments);<z>
public JCacheInterceptor cacheInterceptor(JCacheOperationSource jCacheOperationSource) {<z>
.errorHandler);<z>
.setCacheOperationSource(jCacheOperationSource);<z>
return interceptor;<z>
Object> handleMissingServletRequestParameter(<z>
HttpStatus status, WebRequest request) {<z>
);<z>
values) {<z>
isEmpty(values)) {<z>
()<z>
)<z>
toList());<z>
: values);<z>
String cacheName) {<z>
method = method;<z>
= Collections.unmodifiableSet(<z>
;<z>
this.cacheAnnotation = cacheAnnotation;<z>
= cacheName;<z>
, HttpOutputMessage outputMessage)<z>
throws IOException, HttpMessageNotWritableException {<z>
resource.getInputStream();<z>
getBody());<z>
NullPointerException ex) {<z>
);<z>
) {<z>
FileNotFoundException ex) {<z>
(XmlBeanDefinitionReader reader) throws IOException {<z>
configLocations = getConfigLocations();<z>
configLocations != null) {<z>
String configLocation : configLocations) {<z>
;<z>
Object throwsAdvice) {<z>
);<z>
this.throwsAdvice = throwsAdvice;<z>
.getClass().getMethods();<z>
(Method method : methods) {<z>
) &&<z>
) {<z>
- 1];<z>
.class.isAssignableFrom(throwableParam)) {<z>
.put(throwableParam, method);<z>
logger.isDebugEnabled()) {<z>
("Found exception handler method on throws advice: " + method);<z>
.exceptionHandlerMap.isEmpty()) {<z>
throw new IllegalArgumentException(<z>
;<z>
private void handleComment() throws SAXException {<z>
getLexicalHandler() != null) {<z>
getTextCharacters(),<z>
this.reader.getTextLength());<z>
statusText,<z>
) {<z>
, headers, body, charset);<z>
{<z>
getSingletonMutex()) {<z>
);<z>
clear();<z>
styler) {<z>
);<z>
this.object = obj;<z>
(styler != null ? styler : DEFAULT_TO_STRING_STYLER);<z>
.object);<z>
) {<z>
TestBean tb = new TestBean();<z>
setName("defaultInstance");<z>
);<z>
{<z>
element);<z>
this.parsers.get(localName);<z>
{<z>
).fatal(<z>
+ "]", element);<z>
;<z>
) throws IOException {<z>
.singleton) {<z>
this.singletonInstance = createProperties();<z>
(<z>
definition, Object transaction, boolean debugEnabled)<z>
TransactionException {<z>
.PROPAGATION_NEVER) {<z>
throw new IllegalTransactionStateException(<z>
;<z>
== TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {<z>
debugEnabled) {<z>
("Suspending current transaction");<z>
suspendedResources = suspend(transaction);<z>
= (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);<z>
prepareTransactionStatus(<z>
suspendedResources);<z>
{<z>
{<z>
.debug("Suspending current transaction, creating new transaction with name [" +<z>
"]");<z>
suspend(transaction);<z>
, debugEnabled, suspendedResources);<z>
Error beginEx) {<z>
(transaction, suspendedResources, beginEx);<z>
beginEx;<z>
== TransactionDefinition.PROPAGATION_NESTED) {<z>
!isNestedTransactionAllowed()) {<z>
NestedTransactionNotSupportedException(<z>
);<z>
{<z>
+ "]");<z>
(useSavepointForNestedTransaction()) {<z>
DefaultTransactionStatus status =<z>
false, debugEnabled, null);<z>
status.createAndHoldSavepoint();<z>
;<z>
(definition, transaction, debugEnabled, null);<z>
debugEnabled) {<z>
;<z>
)) {<z>
) != TransactionDefinition.ISOLATION_DEFAULT) {<z>
TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();<z>
|| currentIsolationLevel != definition.getIsolationLevel()) {<z>
.constants;<z>
+<z>
+ "] specifies isolation level which is incompatible with existing transaction: " +<z>
currentIsolationLevel != null ?<z>
currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :<z>
));<z>
if (!definition.isReadOnly()) {<z>
{<z>
new IllegalTransactionStateException("Participating transaction with definition [" +<z>
definition + "] is not marked as read-only but existing transaction is");<z>
;<z>
, debugEnabled, null);<z>
() {<z>
> result = new ArrayList<>();<z>
).keySet());<z>
defaultCodecs.getBaseTypedWriters());<z>
;<z>
(this.defaultCodecs.getBaseObjectWriters());<z>
;<z>
;<z>
{<z>
result.getReturnTypeSource())) {<z>
true;<z>
result.getReturnType().toClass();<z>
ReactiveAdapter adapter = getAdapter(result);<z>
(adapter != null) {<z>
.isNoValue()) {<z>
return true;<z>
getGeneric().toClass();<z>
(type) ||<z>
||<z>
||<z>
type) ||<z>
class.isAssignableFrom(type) ||<z>
));<z>
throws Exception {<z>
logger.isDebugEnabled()) {<z>
;<z>
{<z>
);<z>
clientInboundChannel);<z>
boolean supports(Class<?> beanClass) {<z>
Method method : beanClass.getMethods()) {<z>
)) {<z>
true;<z>
false;<z>
request, Message response, Session session)<z>
{<z>
);<z>
null) {<z>
= resolveDefaultResponseDestination(session);<z>
replyTo == null) {<z>
new InvalidDestinationException("Cannot determine response destination: " +<z>
"Request message does not contain reply-to destination, and no default response destination set.");<z>
;<z>
state, Object newArray, TypeConverter typeConverter,<z>
{<z>
) newArray;<z>
i++) {<z>
).getTypedValue(state);<z>
);<z>
@Nullable LockMode lockMode)<z>
DataAccessException {<z>
executeWithNativeSession(session -> {<z>
(session);<z>
entity);<z>
(lockMode != null) {<z>
, entity);<z>
;<z>
);<z>
Nullable Class<?> requiredType,<z>
Nullable Set<ValueHolder> usedValueHolders) {<z>
.isTrue(index >= 0, "Index must not be negative");<z>
requiredType, requiredName);<z>
(valueHolder == null) {<z>
, usedValueHolders);<z>
;<z>
boolean validated) {<z>
Assert.notNull(annotationType, "'annotationType' must not be null");<z>
= annotationType;<z>
.getName();<z>
validated;<z>
private boolean validateIfNoneMatch(@Nullable String etag) {<z>
etag)) {<z>
false;<z>
Enumeration<String> ifNoneMatch;<z>
().getHeaders(HttpHeaders.IF_NONE_MATCH);<z>
{<z>
;<z>
{<z>
return false;<z>
padEtagIfNecessary(etag);<z>
)) {<z>
2);<z>
{<z>
;<z>
clientETags);<z>
(etagMatcher.find()) {<z>
etagMatcher.group(3))) {<z>
;<z>
true;<z>
) throws IOException, ClassNotFoundException {<z>
.defaultReadObject();<z>
PARAM_CHARSET);<z>
if (charsetName != null) {<z>
));<z>
<String>> nativeHeaders) {<z>
isEmpty(nativeHeaders)) {<z>
LinkedMultiValueMap<>(nativeHeaders));<z>
() {<z>
null) {<z>
);<z>
();<z>
) {<z>
) {<z>
asCharacters().getData();<z>
getEventType() == XMLStreamConstants.COMMENT) {<z>
.getText();<z>
throw new IllegalStateException();<z>
String extension, MediaType mediaType) {<z>
(extension, mediaType);<z>
(previous == null) {<z>
addFileExtension(mediaType, extension);<z>
allFileExtensions.add(extension);<z>
enlistInCurrentTransaction() {<z>
= this.target.getTransaction();<z>
);<z>
isDebugEnabled()) {<z>
+<z>
target + "]");<z>
=<z>
exceptionTranslator);<z>
.bindResource(this.target, extendedEntityManagerSynchronization);<z>
.registerSynchronization(extendedEntityManagerSynchronization);<z>
delegateTimeout(AsyncListener listener, AsyncEvent event) {<z>
);<z>
Exception ex) {<z>
ParserContext parserContext) {<z>
compositeDef =<z>
, parserContext.extractSource(element));<z>
(compositeDef);<z>
, parserContext);<z>
, parserContext);<z>
= element.getAttribute(FACTORY_ID_ATTRIBUTE);<z>
{<z>
= createContainerFactory(<z>
, commonProperties, specificProperties);<z>
) {<z>
setSource(parserContext.extractSource(element));<z>
);<z>
getChildNodes();<z>
(); i++) {<z>
.item(i);<z>
ELEMENT_NODE) {<z>
(child);<z>
if (LISTENER_ELEMENT.equals(localName)) {<z>
child, parserContext, commonProperties, specificProperties);<z>
();<z>
null;<z>
) throws IOException {<z>
(request);<z>
null) {<z>
!this.expectationIterator.hasNext()) {<z>
;<z>
this.expectationIterator.next();<z>
.match(request);<z>
this.repeatExpectations.update(expectation);<z>
return expectation;<z>
Object target, Method method) {<z>
() == 0, "Only no-arg methods may be annotated with @Scheduled");<z>
(method, target.getClass());<z>
);<z>
temporal) {<z>
get(temporal);<z>
current);<z>
if (next == -1) {<z>
.rollForward(temporal);<z>
(0);<z>
(next == current) {<z>
temporal;<z>
;<z>
(temporal);<z>
) {<z>
().elapseUntil(temporal, next);<z>
type().get(temporal);<z>
current);<z>
-1) {<z>
(temporal);<z>
0);<z>
count >= CronExpression.MAX_ATTEMPTS) {<z>
return null;<z>
return type().reset(temporal);<z>
) {<z>
: null);<z>
responseClass != null) {<z>
canRead(responseClass, null);<z>
else if (converter instanceof GenericHttpMessageConverter) {<z>
= (GenericHttpMessageConverter<?>) converter;<z>
.canRead(responseType, null, null);<z>
return false;<z>
boolean readable, boolean writable) {<z>
= propertyType;<z>
readable;<z>
.writable = writable;<z>
protected ServletContext getServletContext() {<z>
{<z>
getServletConfig().getServletContext();<z>
;<z>
) {<z>
jdk8ModuleClass = (Class<? extends Module>)<z>
forName("com.fasterxml.jackson.datatype.jdk8.Jdk8Module", this.moduleClassLoader);<z>
Module jdk8Module = BeanUtils.instantiateClass(jdk8ModuleClass);<z>
), jdk8Module);<z>
(ClassNotFoundException ex) {<z>
? extends Module>)<z>
, this.moduleClassLoader);<z>
instantiateClass(javaTimeModuleClass);<z>
(javaTimeModule.getTypeId(), javaTimeModule);<z>
) {<z>
)) {<z>
)<z>
moduleClassLoader);<z>
kotlinModule = BeanUtils.instantiateClass(kotlinModuleClass);<z>
getTypeId(), kotlinModule);<z>
{<z>
) throws EvaluationException {<z>
(this.value == null) {<z>
);<z>
i++) {<z>
.getValue();<z>
"$"))) {<z>
.append('.');<z>
(value);<z>
new TypedValue(sb.toString());<z>
return this.value;<z>
args) throws Exception {<z>
invoke(getBean(), args);<z>
) {<z>
, args);<z>
;<z>
args), ex);<z>
(InvocationTargetException ex) {<z>
getTargetException();<z>
RuntimeException) {<z>
;<z>
(targetException instanceof Error) {<z>
Error) targetException;<z>
) {<z>
(Exception) targetException;<z>
, targetException);<z>
(int pos, Advisor advisor) throws AopConfigException {<z>
;<z>
isFrozen()) {<z>
AopConfigException("Cannot add advisor: Configuration is frozen.");<z>
)) {<z>
(<z>
advisors.size());<z>
pos, advisor);<z>
();<z>
{<z>
this.ssp = ssp;<z>
);<z>
this;<z>
LinkedCaseInsensitiveMap(LinkedCaseInsensitiveMap<V> other) {<z>
.targetMap.clone();<z>
);<z>
this.locale = other.locale;<z>
{<z>
);<z>
) {<z>
= nativeRequest.getNativeRequest(MultipartRequest.class);<z>
) {<z>
multipartRequest.getMultiFileMap(), mpvs);<z>
startsWithIgnoreCase(<z>
.CONTENT_TYPE), MediaType.MULTIPART_FORM_DATA_VALUE)) {<z>
= nativeRequest.getNativeRequest(HttpServletRequest.class);<z>
) {<z>
isBindEmptyMultipartFiles());<z>
doBind(mpvs);<z>
) {<z>
;<z>
) -> {<z>
!values.isEmpty()) {<z>
0));<z>
});<z>
singleValueMap;<z>
{<z>
{<z>
candidate;<z>
())) {<z>
defaults.cacheName();<z>
;<z>
) {<z>
).getSimpleName();<z>
);<z>
();<z>
getMethod() + " " + path;<z>
columnType, boolean function) {<z>
(function) {<z>
columnType == DatabaseMetaData.functionColumnIn ||<z>
.functionColumnInOut ||<z>
.functionColumnOut);<z>
.procedureColumnIn ||<z>
||<z>
== DatabaseMetaData.procedureColumnOut);<z>
]> clientMessage, Throwable ex) {<z>
StompCommand.ERROR);<z>
ex.getMessage());<z>
;<z>
= null;<z>
if (clientMessage != null) {<z>
StompHeaderAccessor.class);<z>
(clientHeaderAccessor != null) {<z>
;<z>
!= null) {<z>
(receiptId);<z>
, EMPTY_PAYLOAD, ex, clientHeaderAccessor);<z>
(<z>
handler, @Nullable ModelAndView modelAndView)<z>
ServletException {<z>
.getAttribute("test2x") != null) {<z>
new ServletException("Wrong interceptor order");<z>
)) {<z>
("Incorrect request attribute");<z>
("test1x");<z>
render(<z>
ServerWebExchange exchange) {<z>
= getObjectToRender(model);<z>
());<z>
() throws IllegalArgumentException, NamingException {<z>
super.afterPropertiesSet();<z>
{<z>
!= null) {<z>
throw new IllegalArgumentException(<z>
);<z>
.jndiObject = JndiObjectProxyFactory.createJndiObjectProxy(this);<z>
() != null &&<z>
.isInstance(this.defaultObject)) {<z>
converter = (this.beanFactory != null ?<z>
() : new SimpleTypeConverter());<z>
));<z>
(TypeMismatchException ex) {<z>
IllegalArgumentException("Default object [" + this.defaultObject + "] of type [" +<z>
().getName() + "] is not of expected type [" +<z>
, ex);<z>
= lookupWithFallback();<z>
] args) throws Throwable {<z>
getName()) {<z>
:<z>
proxy == args[0]);<z>
case "hashCode":<z>
(proxy);<z>
:<z>
return this.objectFactory.toString();<z>
.getObject(), args);<z>
) {<z>
();<z>
public RequestMethodsRequestCondition getMatchingCondition(HttpServletRequest request) {<z>
CorsUtils.isPreFlightRequest(request)) {<z>
return matchPreFlight(request);<z>
) {<z>
) &&<z>
())) {<z>
return null;<z>
;<z>
());<z>
basicAuthentication(String username, String password) {<z>
username, password, null);<z>
request, next) -><z>
.exchange(ClientRequest.from(request)<z>
))<z>
);<z>
{<z>
getDeclaredMethods();<z>
;<z>
i++) {<z>
)) {<z>
;<z>
--;<z>
== 0) {<z>
return NONE;<z>
;<z>
Arrays.copyOf(methods, size);<z>
(annotationType, attributeMethods);<z>
BeanFactoryCacheOperationSourceAdvisor cacheAdvisor(<z>
CacheInterceptor cacheInterceptor) {<z>
BeanFactoryCacheOperationSourceAdvisor();<z>
);<z>
.setAdvice(cacheInterceptor);<z>
{<z>
);<z>
return advisor;<z>
, HttpServletRequest request,<z>
throws Exception {<z>
);<z>
request, response);<z>
Locale locale = RequestContextUtils.getLocale(request);<z>
locale), fmModel, response);<z>
) {<z>
lifecycleMonitor) {<z>
;<z>
unwrapOptional(@Nullable Object obj) {<z>
{<z>
?>) obj;<z>
()) {<z>
return null;<z>
Object result = optional.get();<z>
(result instanceof Optional), "Multi-level Optional usage not supported");<z>
result;<z>
return obj;<z>
> getDefaultInitBinderArgumentResolvers() {<z>
>(20);<z>
), false));<z>
add(new RequestParamMapMethodArgumentResolver());<z>
);<z>
PathVariableMapMethodArgumentResolver());<z>
(new MatrixVariableMethodArgumentResolver());<z>
));<z>
()));<z>
resolvers.add(new SessionAttributeMethodArgumentResolver());<z>
());<z>
add(new ServletRequestMethodArgumentResolver());<z>
ServletResponseMethodArgumentResolver());<z>
) != null) {<z>
);<z>
);<z>
getBeanFactory(), true));<z>
;<z>
IOException {<z>
;<z>
();<z>
();<z>
{<z>
httpMethod = HttpMethod.GET;<z>
);<z>
catch (URISyntaxException ex) {<z>
;<z>
DataAccessException {<z>
session -> {<z>
session);<z>
.update(entity);<z>
{<z>
(entity);<z>
return null;<z>
;<z>
)<z>
throws BeansException {<z>
(this.beanNameSeparator);<z>
== -1) {<z>
+ key +<z>
);<z>
key.substring(0, separatorIndex);<z>
.substring(separatorIndex + 1);<z>
(beanName);<z>
, beanName, beanProperty, value);<z>
(logger.isDebugEnabled()) {<z>
value + "]");<z>
exchangeFunction, UriBuilderFactory uriBuilderFactory,<z>
,<z>
<?>> defaultRequest, DefaultWebClientBuilder builder) {<z>
;<z>
;<z>
.defaultHeaders = defaultHeaders;<z>
.defaultCookies = defaultCookies;<z>
.defaultRequest = defaultRequest;<z>
builder;<z>
channel, Void context) {<z>
;<z>
).setReadyToSend(true);<z>
getSendProcessor().onWritePossible();<z>
message)<z>
Exception {<z>
= getReturnValueHandler(returnType);<z>
{<z>
.getParameterType());<z>
{<z>
+ handler);<z>
message);<z>
protected AbstractJCacheKeyOperation(CacheMethodDetails<A> methodDetails,<z>
{<z>
, cacheResolver);<z>
;<z>
.keyParameterDetails = initializeKeyParameterDetails(this.allParameterDetails);<z>
{<z>
if (value instanceof MultipartFile multipartFile) {<z>
);<z>
) {<z>
IllegalArgumentException("Cannot read contents of multipart file", ex);<z>
else if (value instanceof byte[]) {<z>
value);<z>
: null);<z>
public PathPatternMatchableHandlerMapping(MatchableHandlerMapping delegate) {<z>
);<z>
delegate.getPatternParser(), "PatternParser is required.");<z>
delegate = delegate;<z>
delegate.getPatternParser();<z>
createTemplateClassLoader() throws IOException {<z>
commaDelimitedListToStringArray(getResourceLoaderPath());<z>
>();<z>
path : paths) {<z>
getResources(path);<z>
> 0) {<z>
resource : resources) {<z>
()) {<z>
);<z>
).getClassLoader();<z>
!= null, "No ClassLoader");<z>
: classLoader);<z>
bufferFactory,<z>
{<z>
);<z>
.isLoggingSuppressed(hints)) {<z>
= Hints.getLogPrefix(hints);<z>
);<z>
return dataBuffer;<z>
, String message) {<z>
{<z>
new IllegalArgumentException(message);<z>
) {<z>
{<z>
getResponse();<z>
response), expectedValue);<z>
String getScheme(TransportType transportType) {<z>
this.sockJsUrl.getScheme();<z>
equals(transportType)) {<z>
!scheme.startsWith("ws")) {<z>
;<z>
.startsWith("http")) {<z>
"http");<z>
;<z>
<Route> routes) {<z>
= new PathPatternParser();<z>
.forEach(route -> {<z>
;<z>
(PathContainer.parsePath(path)));<z>
});<z>
, Method bridgeMethod) {<z>
!candidateMethod.equals(bridgeMethod) &&<z>
(bridgeMethod.getName()) &&<z>
getParameterCount());<z>
> predicate,<z>
ServerRequest, Mono<ServerResponse>> responseProvider) {<z>
.notNull(predicate, "Predicate must not be null");<z>
"ResponseProvider must not be null");<z>
)<z>
request)));<z>
this;<z>
propertySource) {<z>
);<z>
this.environment).getPropertySources();<z>
name)) {<z>
existing = propertySources.get(name);<z>
!= null) {<z>
propertySource instanceof ResourcePropertySource ?<z>
.withResourceName() : propertySource);<z>
existing instanceof CompositePropertySource) {<z>
addFirstPropertySource(newSource);<z>
instanceof ResourcePropertySource) {<z>
withResourceName();<z>
name);<z>
.addPropertySource(newSource);<z>
(existing);<z>
;<z>
this.propertySourceNames.isEmpty()) {<z>
;<z>
propertySourceNames.size() - 1);<z>
.addBefore(firstProcessed, propertySource);<z>
.propertySourceNames.add(name);<z>
> targetClass) {<z>
)) {<z>
return null;<z>
;<z>
= findCacheOperations(specificMethod);<z>
(opDef != null) {<z>
opDef;<z>
(specificMethod.getDeclaringClass());<z>
{<z>
return opDef;<z>
specificMethod != method) {<z>
;<z>
(opDef != null) {<z>
return opDef;<z>
= findCacheOperations(method.getDeclaringClass());<z>
&& ClassUtils.isUserLevelMethod(method)) {<z>
return opDef;<z>
null;<z>
, @Nullable String beanName) {<z>
required);<z>
;<z>
1);<z>
state(beanFactory != null, "No BeanFactory available");<z>
getTypeConverter();<z>
value;<z>
;<z>
ex) {<z>
);<z>
this) {<z>
if (!this.cached) {<z>
null;<z>
{<z>
cachedFieldValue = desc;<z>
);<z>
autowiredBeanNames.size() == 1) {<z>
.iterator().next();<z>
if (beanFactory.containsBean(autowiredBeanName) &&<z>
getType())) {<z>
new ShortcutDependencyDescriptor(<z>
, field.getType());<z>
= cachedFieldValue;<z>
.cached = true;<z>
value;<z>
destroyMethod) {<z>
postProcessingLock) {<z>
(this.externallyManagedDestroyMethods != null &&<z>
(destroyMethod));<z>
Builder<T> cookie(ResponseCookie cookie) {<z>
, "ResponseCookie must not be null");<z>
), cookie);<z>
;<z>
ObjectFactory<?> objectFactory) {<z>
.getAttribute(name);<z>
(scopedObject == null) {<z>
.getObject();<z>
servletContext.setAttribute(name, scopedObject);<z>
scopedObject;<z>
Nullable Map<String, Object> userProperties) {<z>
(userProperties != null) {<z>
;<z>
@Nullable Class<?> sourceType) {<z>
(eventType, "Event type must not be null");<z>
eventType = eventType;<z>
= sourceType;<z>
class, Collections.emptyList()) {<z>
<?> clazz) {<z>
false;<z>
) {<z>
{<z>
@Nullable PropertyValues pvs) {<z>
{<z>
);<z>
false);<z>
, false);<z>
objectMapper;<z>
rewriteCallStack(<z>
Throwable exception, String className, String methodName) {<z>
(exception);<z>
clone == null) {<z>
;<z>
new Exception().getStackTrace();<z>
.getStackTrace();<z>
findCommonAncestorIndex(callStack, className, methodName);<z>
findCommonAncestorIndex(cachedCallStack, className, methodName);<z>
|| cachedIndex == -1) {<z>
CacheOperationInvoker.ThrowableWrapper(exception);<z>
callStack.length - index];<z>
, result, 0, cachedIndex);<z>
- index);<z>
clone.setStackTrace(result);<z>
;<z>
{<z>
(this.executor != null) {<z>
.executor;<z>
(this.executorName != null) {<z>
null, "BeanFactory is required to look up an executor bean by name");<z>
.class);<z>
null;<z>
ConfigurableBeanFactory factory,<z>
ReactiveAdapterRegistry registry) {<z>
;<z>
columnType,<z>
boolean nullable) {<z>
function;<z>
parameterName = columnName;<z>
.parameterType = columnType;<z>
this.sqlType = sqlType;<z>
;<z>
nullable;<z>
] extractValidationHints(MethodParameter parameter) {<z>
.getParameterAnnotations();<z>
) {<z>
] hints = ValidationAnnotationUtils.determineValidationHints(ann);<z>
hints != null) {<z>
return hints;<z>
return null;<z>
(<z>
td)<z>
throws TypeMismatchException {<z>
, td);<z>
Object getAsyncResult(long timeToWait) {<z>
) != null && timeToWait == -1) {<z>
.getAsyncContext().getTimeout();<z>
1 ? Long.MAX_VALUE : requestTimeout;<z>
{<z>
"]" +<z>
;<z>
result = this.asyncResult.get();<z>
.handler + "] was not set");<z>
asyncResult.get();<z>
String path) {<z>
"//");<z>
-1) {<z>
;<z>
toCharArray();<z>
int slowIndex = start;<z>
< content.length; fastIndex++) {<z>
[slowIndex] != '/') {<z>
[fastIndex];<z>
, 0, slowIndex + 1);<z>
<? extends ByteBuffer> inputStream,<z>
ResolvableType elementType, @Nullable MimeType mimeType,<z>
Map<String, Object> hints) {<z>
map(byteBuffer -><z>
));<z>
() {<z>
)).stream()<z>
map(name -> {<z>
);<z>
<>(name, value);<z>
.collect(Collectors.toSet());<z>
{<z>
URL url = request.getUrl();<z>
host = url.getHost();<z>
contains(host)) {<z>
;<z>
getPort();<z>
port == -1) {<z>
;<z>
hostAndPort = host + ":" + port;<z>
hosts.contains(hostAndPort);<z>
{<z>
interceptors.size() + 1);<z>
interceptors.addAll(this.interceptors);<z>
;<z>
;<z>
.isEmpty(this.allowedOriginPatterns)) {<z>
);<z>
.toArray(new HandshakeInterceptor[0]);<z>
exchange) {<z>
handler -> {<z>
logger.isDebugEnabled()) {<z>
+ "Mapped to " + handler);<z>
);<z>
)) {<z>
= (this.corsConfigurationSource != null ?<z>
null);<z>
getCorsConfiguration(handler, exchange);<z>
: handlerConfig);<z>
) {<z>
.validateAllowCredentials();<z>
|| CorsUtils.isPreFlightRequest(request)) {<z>
return NO_OP_HANDLER;<z>
handler;<z>
;<z>
handler, ServerWebExchange exchange) {<z>
;<z>
{<z>
(handlerMethod.equals(PREFLIGHT_AMBIGUOUS_MATCH)) {<z>
return ALLOW_CORS_CONFIG;<z>
.getCorsConfiguration(handlerMethod);<z>
methodConfig) : methodConfig);<z>
;<z>
)<z>
throws DataAccessException {<z>
paramMap), elementType);<z>
> message) {<z>
this.messages.peek();<z>
== message) {<z>
.remove();<z>
true;<z>
return false;<z>
() {<z>
[size];<z>
);<z>
return result;<z>
{<z>
(key);<z>
actualKey);<z>
) {<z>
new IllegalStateException("No value for key [" + actualKey + "] bound to context");<z>
value;<z>
RequestMappingInfo> infos, ServerWebExchange exchange) {<z>
addAll(infos.stream().<z>
getMatchingCondition(exchange) != null).<z>
)).<z>
collect(Collectors.toList()));<z>
) {<z>
) -> {<z>
;<z>
);<z>
);<z>
ParameterNameDiscoverer discoverer, Configuration<?> configuration) {<z>
final ParameterNameProvider defaultProvider = configuration.getDefaultParameterNameProvider();<z>
parameterNameProvider(new ParameterNameProvider() {<z>
{<z>
getParameterNames(constructor);<z>
:<z>
);<z>
> getParameterNames(Method method) {<z>
discoverer.getParameterNames(method);<z>
:<z>
);<z>
;<z>
String className, ClassWriter classWriter) {<z>
= className;<z>
= classWriter;<z>
compilationScopes = new ArrayDeque<>();<z>
);<z>
) {<z>
{<z>
for (FieldAdder fieldAdder : this.fieldAdders) {<z>
(this.classWriter, this);<z>
if (this.clinitAdders != null) {<z>
null, null);<z>
.visitCode();<z>
nextFreeVariableId = 0;<z>
) {<z>
clinitAdder.generateCode(mv, this);<z>
visitInsn(RETURN);<z>
);<z>
visitEnd();<z>
{<z>
UriComponentsBuilder builder = ServletUriComponentsBuilder.fromCurrentServletMapping();<z>
).getPath();<z>
path != null ? path : "";<z>
boolean checkDependencies(ModelAndViewContainer mavContainer) {<z>
name : this.dependencies) {<z>
.containsAttribute(name)) {<z>
return false;<z>
true;<z>
public boolean equals(@Nullable Object other) {<z>
{<z>
;<z>
instanceof UnionMethodMatcher that)) {<z>
false;<z>
);<z>
void initObjectWriters() {<z>
clear();<z>
this.registerDefaults) {<z>
.objectWriters.addAll(getBaseObjectWriters());<z>
.objectWriters);<z>
MethodProxy methodProxy) throws Throwable {<z>
null;<z>
);<z>
args);<z>
this.target, method, retVal);<z>
oldProxy);<z>
RSocketConnectorConfigurer> connectorConfigurers,<z>
MimeType metaMimeType, MimeType dataMimeType, RSocketStrategies rsocketStrategies) {<z>
);<z>
));<z>
(rsocketStrategies.dataBufferFactory() instanceof NettyDataBufferFactory) {<z>
);<z>
());<z>
toString());<z>
(dataMimeType, metaMimeType, rsocketStrategies);<z>
setupPayloadMono != EMPTY_SETUP_PAYLOAD) {<z>
.setupPayload(setupPayloadMono);<z>
connector;<z>
) {<z>
) {<z>
"Property 'serviceLocatorInterface' is required");<z>
(<z>
getClassLoader(),<z>
[] {this.serviceLocatorInterface},<z>
ServiceLocatorInvocationHandler());<z>
public Builder mergeBlah(SecondMsg value) {<z>
if (blahBuilder_ == null) {<z>
== 0x00000002) &&<z>
SecondMsg.getDefaultInstance()) {<z>
value).buildPartial();<z>
else {<z>
blah_ = value;<z>
;<z>
{<z>
blahBuilder_.mergeFrom(value);<z>
bitField0_ |= 0x00000002;<z>
;<z>
void connect() throws IOException {<z>
;<z>
.serviceUrl, this.environment);<z>
getMBeanServerConnection();<z>
throws DataAccessException {<z>
request)) {<z>
SessionHolder sessionHolder =<z>
));<z>
"Closing Hibernate Session in OpenSessionInViewInterceptor");<z>
());<z>
String primitiveDescriptor) {<z>
) {<z>
case 'I': return "Ljava/lang/Integer";<z>
case 'J': return "Ljava/lang/Long";<z>
"Ljava/lang/Float";<z>
'D': return "Ljava/lang/Double";<z>
;<z>
'C': return "Ljava/lang/Character";<z>
case 'S': return "Ljava/lang/Short";<z>
case 'Z': return "Ljava/lang/Boolean";<z>
new IllegalArgumentException("Unexpected non primitive descriptor " + primitiveDescriptor);<z>
> codecConsumer) {<z>
(this.codecConsumer != null ?<z>
: codecConsumer);<z>
initReaders();<z>
();<z>
entity, ReplicationMode replicationMode)<z>
{<z>
{<z>
);<z>
entityName, entity, replicationMode);<z>
null;<z>
;<z>
Void> doCleanupAfterCompletion(TransactionSynchronizationManager synchronizationManager,<z>
Object transaction) {<z>
(() -> {<z>
= (ConnectionFactoryTransactionObject) transaction;<z>
if (txObject.isNewConnectionHolder()) {<z>
());<z>
.getConnectionHolder().getConnection();<z>
;<z>
{<z>
setAutoCommit(true)));<z>
getPreviousIsolationLevel() != null) {<z>
afterCleanup = afterCleanup<z>
);<z>
(() -> {<z>
txObject.isNewConnectionHolder()) {<z>
()) {<z>
con + "] after transaction");<z>
());<z>
txObject.getConnectionHolder().clear();<z>
Mono.empty();<z>
}));<z>
);<z>
, final boolean visible) {<z>
visible) {<z>
=<z>
;<z>
{<z>
return lastRuntimeInvisibleAnnotation =<z>
);<z>
location) {<z>
(this.resourceLoaderPaths != null) {<z>
resourceLoaderPaths) {<z>
+ location);<z>
exists()) {<z>
return resource;<z>
null;<z>
other) {<z>
if (this == other) {<z>
;<z>
) {<z>
;<z>
) &&<z>
equals(otherHolder.beanName) &&<z>
.aliases);<z>
{<z>
0) {<z>
;<z>
return info;<z>
private boolean emitCachedSignals() {<z>
) {<z>
onError(this.error);<z>
);<z>
;<z>
;<z>
.item = null;<z>
item != null) {<z>
.onNext(item);<z>
if (this.completed) {<z>
).onComplete();<z>
return true;<z>
return false;<z>
request) {<z>
isAsyncDispatch(request) && shouldNotFilterAsyncDispatch()) {<z>
;<z>
)) {<z>
true;<z>
false;<z>
static byte[] getResponseBody(ClientHttpResponse response) {<z>
(response.getBody());<z>
catch (IOException ex) {<z>
0];<z>
) {<z>
get(session);<z>
null) {<z>
session);<z>
handler;<z>
private void assertMetadataEntryCount() {<z>
{<z>
.metadataEntries.size();<z>
isTrue(count < 2, "Composite metadata required for multiple metadata entries.");<z>
() {<z>
);<z>
("local-slsb", new LocalStatelessSessionBeanDefinitionParser());<z>
registerBeanDefinitionParser("remote-slsb", new RemoteStatelessSessionBeanDefinitionParser());<z>
append(String value) throws JspException {<z>
(value));<z>
this;<z>
IOException ex) {<z>
throw new JspException("Unable to write to JspWriter", ex);<z>
Nullable Map<String, ?> model) {<z>
) {<z>
null;<z>
entrySet().stream()<z>
.filter(this::isMatch)<z>
getValue));<z>
isEmpty()) {<z>
;<z>
1) {<z>
.next();<z>
) {<z>
;<z>
result + " but " +<z>
().getName());<z>
(@Nullable PropertyValues other) {<z>
null) {<z>
);<z>
pv : pvs) {<z>
);<z>
;<z>
initLogger(Decoder<?> decoder) {<z>
(decoder instanceof AbstractDecoder &&<z>
startsWith("org.springframework.core.codec")) {<z>
decoder).getLogger());<z>
) decoder).setLogger(logger);<z>
String... params) {<z>
paramsCondition = (ObjectUtils.isEmpty(params) ?<z>
new ParamsRequestCondition(params));<z>
this;<z>
multipart, @Nullable String encoding)<z>
{<z>
);<z>
{<z>
);<z>
.javascriptEnabled);<z>
driver.getWebClient()));<z>
= driver;<z>
return this;<z>
... modelAttributes) {<z>
)<z>
.statusCode)<z>
.headers)<z>
cookies))<z>
(modelAttributes)<z>
build()<z>
(Function.identity());<z>
) {<z>
) {<z>
return null;<z>
;<z>
);<z>
{<z>
return null;<z>
(ReactiveAdapter adapter : this.adapters) {<z>
getReactiveType() == clazz) {<z>
return adapter;<z>
.adapters) {<z>
{<z>
adapter;<z>
return null;<z>
proxiedInterfaces) {<z>
?> proxiedInterface : proxiedInterfaces) {<z>
= proxiedInterface.getDeclaredMethods();<z>
Method method : methods) {<z>
.isEqualsMethod(method)) {<z>
;<z>
)) {<z>
= true;<z>
hashCodeDefined) {<z>
, Object valueBean) throws DataAccessException {<z>
<?>>) session -> {<z>
queryString);<z>
;<z>
);<z>
();<z>
;<z>
, MethodParameter returnType,<z>
webRequest) throws Exception {<z>
(returnValue == null) {<z>
mavContainer.setRequestHandled(true);<z>
= webRequest.getNativeResponse(HttpServletResponse.class);<z>
!= null, "No HttpServletResponse");<z>
;<z>
{<z>
responseEntity = (ResponseEntity<?>) returnValue;<z>
());<z>
));<z>
returnValue = responseEntity.getBody();<z>
);<z>
== null) {<z>
;<z>
);<z>
class);<z>
null, "No ServletRequest");<z>
emitter;<z>
instanceof ResponseBodyEmitter) {<z>
returnValue;<z>
(returnValue, returnType, mavContainer, webRequest);<z>
emitter == null) {<z>
.forEach((headerName, headerValues) -> {<z>
for (String headerValue : headerValues) {<z>
.addHeader(headerName, headerValue);<z>
});<z>
);<z>
;<z>
outputMessage);<z>
HttpMessageConvertingHandler handler;<z>
.getTimeout());<z>
.startDeferredResultProcessing(deferredResult, mavContainer);<z>
(outputMessage, deferredResult);<z>
(Throwable ex) {<z>
);<z>
;<z>
initialize(handler);<z>
Nullable String beanName) {<z>
)) {<z>
beanClass) ?<z>
FACTORY_BEAN_PREFIX + beanName : beanName);<z>
beanClass;<z>
> createException() {<z>
bodyToMono(byte[].class)<z>
(EMPTY)<z>
EMPTY)<z>
-> {<z>
.get();<z>
(null);<z>
int statusCode = rawStatusCode();<z>
(statusCode);<z>
httpStatus != null) {<z>
.create(<z>
getReasonPhrase(),<z>
.asHttpHeaders(),<z>
);<z>
new UnknownHttpStatusCodeException(<z>
(),<z>
request);<z>
);<z>
JMSException {<z>
;<z>
)) {<z>
jms.IllegalStateException("'targetConnectionFactory' is no QueueConnectionFactory");<z>
target).createQueueConnection();<z>
(targetConnection);<z>
public void convertAndSend(<z>
MessagePostProcessor postProcessor)<z>
JmsException {<z>
session -> {<z>
.toMessage(message, session);<z>
(msg);<z>
;<z>
{<z>
(producer != null) {<z>
close();<z>
) {<z>
);<z>
{<z>
, ex);<z>
) {<z>
if (this.inputStream != null) {<z>
this.inputStream;<z>
reader != null) {<z>
IllegalStateException(<z>
"Cannot call getInputStream() after getReader() has already been called for the current request") ;<z>
this.content != null ?<z>
(this.content)) :<z>
EMPTY_SERVLET_INPUT_STREAM);<z>
.inputStream;<z>
, boolean inheritable) {<z>
{<z>
;<z>
inheritable) {<z>
attributes);<z>
.remove();<z>
requestAttributesHolder.set(attributes);<z>
inheritableRequestAttributesHolder.remove();<z>
Nullable MediaType contentType) throws IOException {<z>
)) {<z>
;<z>
resource.contentLength();<z>
< 0 ? null : contentLength);<z>
, String field, String errorCode,<z>
[] errorArgs, @Nullable String defaultMessage) {<z>
);<z>
= errors.getFieldValue(field);<z>
))) {<z>
, errorCode, errorArgs, defaultMessage);<z>
final void visitPermittedSubclass(final String permittedSubclass) {<z>
if (permittedSubclasses == null) {<z>
new ByteVector();<z>
;<z>
addConstantClass(permittedSubclass).index);<z>
void dispose() {<z>
{<z>
content.forEach(DataBufferUtils::release);<z>
Element parentElement, ParserContext context) {<z>
= new ManagedList<>();<z>
{<z>
;<z>
"ref")) {<z>
(beanElement, null));<z>
;<z>
?> loadClassForOverriding(String name) throws ClassNotFoundException {<z>
name);<z>
{<z>
byte[] bytes = loadBytesForClass(name);<z>
!= null) {<z>
0, bytes.length);<z>
result;<z>
[] aggregateIndex, Class<?> source,<z>
, boolean includeEnclosing) {<z>
[0]);<z>
result != null) {<z>
;<z>
(hasPlainJavaAnnotationsOnly(source)) {<z>
return null;<z>
] annotations = getDeclaredAnnotations(source, false);<z>
, annotations);<z>
!= null) {<z>
return result;<z>
]++;<z>
) {<z>
interfaceType : source.getInterfaces()) {<z>
interfacesResult = processClassHierarchy(context, aggregateIndex,<z>
);<z>
{<z>
;<z>
?> superclass = source.getSuperclass();<z>
&& superclass != null) {<z>
R superclassResult = processClassHierarchy(context, aggregateIndex,<z>
);<z>
!= null) {<z>
return superclassResult;<z>
) {<z>
;<z>
!= null) {<z>
aggregateIndex,<z>
includeInterfaces, true);<z>
!= null) {<z>
enclosingResult;<z>
catch (Throwable ex) {<z>
AnnotationUtils.handleIntrospectionFailure(source, ex);<z>
) {<z>
);<z>
;<z>
inputMessage)<z>
throws IOException, HttpMessageNotReadableException {<z>
(clazz, inputMessage);<z>
> serializer, HttpOutputMessage outputMessage)<z>
throws IOException, HttpMessageNotWritableException {<z>
;<z>
().getContentType();<z>
));<z>
outputMessage.getBody().flush();<z>
{<z>
;<z>
) {<z>
+ ex.getMessage(), ex);<z>
{<z>
this.outputStream, SockJsFrame.CHARSET);<z>
;<z>
)) {<z>
("XHR content received: " + content);<z>
(!PRELUDE.equals(content)) {<z>
;<z>
next() throws InvalidResultSetAccessException {<z>
);<z>
se) {<z>
InvalidResultSetAccessException(se);<z>
) {<z>
);<z>
!type.isInstance(obj)) {<z>
));<z>
public static ContentDisposition parse(String contentDisposition) {<z>
String> parts = tokenize(contentDisposition);<z>
parts.get(0);<z>
= null;<z>
= null;<z>
Charset charset = null;<z>
;<z>
;<z>
= null;<z>
readDate = null;<z>
(); i++) {<z>
(i);<z>
int eqIndex = part.indexOf('=');<z>
1) {<z>
;<z>
part.endsWith("\"") ?<z>
.length() - 1) :<z>
1));<z>
{<z>
= value;<z>
.equals("filename*") ) {<z>
);<z>
('\'', idx1 + 1);<z>
) {<z>
).trim());<z>
ISO_8859_1.equals(charset),<z>
);<z>
, charset);<z>
;<z>
(filename == null)) {<z>
if (value.startsWith("=?") ) {<z>
matcher = BASE64_ENCODED_PATTERN.matcher(value);<z>
matcher.find()) {<z>
);<z>
.group(2);<z>
));<z>
;<z>
= value;<z>
) {<z>
value);<z>
if (attribute.equals("creation-date")) {<z>
.parse(value, RFC_1123_DATE_TIME);<z>
(DateTimeParseException ex) {<z>
("modification-date")) {<z>
.parse(value, RFC_1123_DATE_TIME);<z>
ex) {<z>
attribute.equals("read-date")) {<z>
(value, RFC_1123_DATE_TIME);<z>
ex) {<z>
new IllegalArgumentException("Invalid content disposition format");<z>
creationDate, modificationDate, readDate);<z>
{<z>
this.headersWritten) {<z>
-> {<z>
headerValues) {<z>
;<z>
;<z>
() != null) {<z>
));<z>
getContentType() != null &&<z>
.getCharset() != null) {<z>
));<z>
contentLength = getHeaders().getContentLength();<z>
!= -1) {<z>
setContentLengthLong(contentLength);<z>
headersWritten = true;<z>
create(Class<T> ifc) {<z>
ifc);<z>
if (impl == null) {<z>
;<z>
(T) BeanUtils.instantiateClass(impl);<z>
, ParserContext parserContext, BeanDefinitionBuilder builder) {<z>
(element, builder.getRawBeanDefinition());<z>
;<z>
"map-class");<z>
mapClass)) {<z>
("targetMapClass", mapClass);<z>
element.getAttribute(SCOPE_ATTRIBUTE);<z>
(scope)) {<z>
scope);<z>
createTypeFiltersFor(AnnotationAttributes filterAttributes, Environment environment,<z>
registry) {<z>
ArrayList<>();<z>
getEnum("type");<z>
{<z>
{<z>
ANNOTATION:<z>
(Annotation.class, filterClass,<z>
);<z>
@SuppressWarnings("unchecked")<z>
;<z>
);<z>
case ASSIGNABLE_TYPE:<z>
);<z>
case CUSTOM:<z>
(TypeFilter.class, filterClass,<z>
);<z>
.instantiateClass(filterClass, TypeFilter.class,<z>
resourceLoader, registry);<z>
filter);<z>
filterType);<z>
.getStringArray("pattern")) {<z>
{<z>
ASPECTJ:<z>
expression, resourceLoader.getClassLoader()));<z>
:<z>
(expression)));<z>
);<z>
;<z>
bodyClass(Type type) {<z>
type instanceof Class<?> clazz) {<z>
return clazz;<z>
type instanceof ParameterizedType parameterizedType &&<z>
<?> rawType) {<z>
return rawType;<z>
Object.class;<z>
int countIterator(Iterator iterator) {<z>
int count = 0;<z>
hasNext()) {<z>
.next();<z>
count++;<z>
count;<z>
Nullable String[] patterns, String str) {<z>
!= null) {<z>
{<z>
simpleMatch(pattern, str)) {<z>
true;<z>
false;<z>
void handleTransportError(Throwable error) {<z>
.isErrorEnabled()) {<z>
, error);<z>
.handleTransportError(this, error);<z>
(Throwable ex) {<z>
.error("WebSocketHandler.handleTransportError threw an exception", ex);<z>
boolean equals(@Nullable Object other) {<z>
this == other) {<z>
true;<z>
(other instanceof PropertyCacheKey otherKey)) {<z>
;<z>
) &&<z>
== otherKey.targetIsClass);<z>
, File out) throws IOException {<z>
(in, "No input File specified");<z>
.notNull(out, "No output File specified");<z>
));<z>
Type, String> encoder) {<z>
));<z>
this.pathComponents) {<z>
;<z>
return new PathComponentComposite(encodedComponents);<z>
specified) {<z>
new ArrayList<>(specified.length);<z>
for (Object obj : specified) {<z>
obj);<z>
return instances;<z>
() {<z>
return context -> {<z>
.class)) {<z>
()));<z>
return context;<z>
(final Attribute attribute) {<z>
;<z>
;<z>
Object createSavepoint() throws TransactionException {<z>
) {<z>
(<z>
);<z>
;<z>
, final List list) {<z>
) {<z>
);<z>
asList(type.getDeclaredMethods()));<z>
);<z>
!= null) {<z>
list);<z>
);<z>
i++) {<z>
interfaces[i], list);<z>
;<z>
byte[] delimiter) {<z>
[delimiter.length];<z>
;<z>
i++) {<z>
int j = result[i - 1];<z>
j]) {<z>
;<z>
i] == delimiter[j]) {<z>
++;<z>
= j;<z>
result;<z>
) {<z>
cause);<z>
this.resourceDescription = resourceDescription;<z>
beanName = null;<z>
source, String requestUrl,<z>
,<z>
Throwable failureCause, int statusCode) {<z>
sessionId, userName, processingTimeMillis, failureCause);<z>
;<z>
this.clientAddress = clientAddress;<z>
method;<z>
.servletName = servletName;<z>
.statusCode = statusCode;<z>
) {<z>
.notNull(rowMapper, "RowMapper is required");<z>
this.rowMapper = rowMapper;<z>
rowsExpected;<z>
HttpServletRequest request, HttpServletResponse response,<z>
failureCause, WebAsyncManager asyncManager) {<z>
.isDebugEnabled()) {<z>
request.getDispatcherType();<z>
initialDispatch = (dispatchType == DispatcherType.REQUEST);<z>
) {<z>
initialDispatch) {<z>
(logger.isDebugEnabled()) {<z>
"Unresolved failure from \"" + dispatchType + "\" dispatch: " + failureCause);<z>
) {<z>
failureCause);<z>
("Failed to complete request: " + failureCause);<z>
{<z>
debug("Exiting but response remains open for further handling");<z>
.getStatus();<z>
"";<z>
(logger.isTraceEnabled()) {<z>
= response.getHeaderNames();<z>
) {<z>
)<z>
.joining(", "));<z>
() ? "" : "masked";<z>
headers + "}";<z>
initialDispatch) {<z>
headers);<z>
);<z>
: status) + headers);<z>
int initialCapacity) {<z>
collectionType.isInterface()) {<z>
accessibleConstructor(collectionType).newInstance();<z>
) {<z>
(<z>
ex);<z>
.class == collectionType) {<z>
<>(initialCapacity);<z>
.class == collectionType) {<z>
TreeSet<>();<z>
new LinkedHashSet<>(initialCapacity);<z>
(@Nullable Object other) {<z>
) {<z>
true;<z>
!(other instanceof ParameterizedType otherType)) {<z>
;<z>
&&<z>
));<z>
) {<z>
if (value instanceof Class) {<z>
getName();<z>
isArray()) {<z>
;<z>
i++) {<z>
> 0) {<z>
;<z>
.get(value, i)));<z>
append(']');<z>
return builder.toString();<z>
valueOf(value);<z>
T payload, @Nullable ResolvableType payloadType) {<z>
source);<z>
Assert.notNull(payload, "Payload must not be null");<z>
payload = payload;<z>
);<z>
Publisher<?> input, ResolvableType elementType,<z>
Object> hints) {<z>
toClass()) ?<z>
) : elementType);<z>
).map(element -> {<z>
<?> sse = (element instanceof ServerSentEvent ?<z>
);<z>
StringBuilder();<z>
;<z>
event = sse.event();<z>
sse.retry();<z>
.comment();<z>
;<z>
if (id != null) {<z>
("id", id, sb);<z>
(event != null) {<z>
sb);<z>
{<z>
retry.toMillis(), sb);<z>
) {<z>
append('\n');<z>
data != null) {<z>
;<z>
Flux<DataBuffer> result;<z>
data == null) {<z>
mediaType, factory));<z>
instanceof String) {<z>
);<z>
, factory));<z>
factory, hints);<z>
.class, DataBufferUtils::release);<z>
;<z>
int opcode) {<z>
length;<z>
opcode);<z>
(currentBasicBlock != null) {<z>
== COMPUTE_INSERTED_FRAMES) {<z>
null);<z>
{<z>
= relativeStackSize + STACK_SIZE_DELTA[opcode];<z>
if (size > maxRelativeStackSize) {<z>
maxRelativeStackSize = size;<z>
;<z>
opcode == Opcodes.ATHROW) {<z>
endCurrentBasicBlockWithNoSuccessor();<z>
boolean isFirst() throws InvalidResultSetAccessException {<z>
.resultSet.isFirst();<z>
se) {<z>
new InvalidResultSetAccessException(se);<z>
MarkupTemplateEngine autodetectMarkupTemplateEngine() throws BeansException {<z>
obtainApplicationContext(),<z>
false).getTemplateEngine();<z>
{<z>
new ApplicationContextException("Expected a single GroovyMarkupConfig bean in the current " +<z>
"the usual implementation. This bean may have any name.", ex);<z>
isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {<z>
;<z>
() ||<z>
getName()))));<z>
BeansException {<z>
= obtainApplicationContext();<z>
(this.detectHandlersInAncestorContexts ?<z>
beanNamesForTypeIncludingAncestors(applicationContext, Object.class) :<z>
);<z>
) {<z>
);<z>
{<z>
registerHandler(urls, beanName);<z>
{<z>
());<z>
)) || logger.isTraceEnabled()) {<z>
+ formatMappingName());<z>
... operands) {<z>
("--", startPos, endPos, operands);<z>
.postfix = postfix;<z>
Assert.notEmpty(operands, "Operands must not be empty");<z>
AbstractBeanDefinition definition, ParserContext parserContext)<z>
{<z>
)) {<z>
(definition);<z>
(ID_ATTRIBUTE);<z>
) && shouldGenerateIdAsFallback()) {<z>
.generateBeanName(definition);<z>
return id;<z>
methodBlock(FrameworkMethod frameworkMethod) {<z>
Object testInstance;<z>
{<z>
) throws Throwable {<z>
();<z>
();<z>
) {<z>
new Fail(ex);<z>
;<z>
;<z>
);<z>
;<z>
, testInstance, statement);<z>
statement);<z>
frameworkMethod, testInstance, statement);<z>
);<z>
);<z>
statement;<z>
static MergedAnnotations findRepeatableAnnotations(AnnotatedElement element,<z>
<? extends Annotation> annotationType) {<z>
;<z>
(element, SearchStrategy.TYPE_HIERARCHY, repeatableContainers);<z>
@Nullable MessageHeaders headers) {<z>
(MessageHeaders.CONTENT_TYPE) == null) {<z>
defaultMimeType;<z>
MessageHeaders.CONTENT_TYPE);<z>
if (value == null) {<z>
return null;<z>
if (value instanceof MimeType) {<z>
MimeType) value;<z>
if (value instanceof String) {<z>
value);<z>
(<z>
value.getClass());<z>
String beanName, ObjectName objectName) {<z>
.notificationListeners != null) {<z>
notificationListener : this.notificationListeners) {<z>
.replaceObjectName(beanName, objectName);<z>
throws BeansException {<z>
tokens = (PropertyTokenHolder) pv.resolvedTokens;<z>
null) {<z>
String propertyName = pv.getName();<z>
AbstractNestablePropertyAccessor nestedPa;<z>
= getPropertyAccessorForPropertyPath(propertyName);<z>
(NotReadablePropertyException ex) {<z>
,<z>
"' does not exist", ex);<z>
));<z>
== this) {<z>
;<z>
tokens, pv);<z>
);<z>
Nullable String charsToDelete) {<z>
(charsToDelete)) {<z>
return inString;<z>
int lastCharIndex = 0;<z>
;<z>
.length(); i++) {<z>
char c = inString.charAt(i);<z>
.indexOf(c) == -1) {<z>
++] = c;<z>
(lastCharIndex == inString.length()) {<z>
return inString;<z>
);<z>
, WebSocketHandler webSocketHandler) {<z>
Assert.notNull(sockJsService, "SockJsService must not be null");<z>
;<z>
this.sockJsService = sockJsService;<z>
.webSocketHandler =<z>
);<z>
() throws IOException {<z>
this.headersWritten) {<z>
headers.entrySet()) {<z>
);<z>
) {<z>
(headerValueString);<z>
);<z>
;<z>
outputStream.write(' ');<z>
headerValue);<z>
this.outputStream);<z>
outputStream);<z>
headersWritten = true;<z>
public void requestDestroyed(ServletRequestEvent requestEvent) {<z>
ServletRequestAttributes attributes = null;<z>
);<z>
(reqAttr instanceof ServletRequestAttributes) {<z>
= (ServletRequestAttributes) reqAttr;<z>
threadAttributes = RequestContextHolder.getRequestAttributes();<z>
(threadAttributes != null) {<z>
;<z>
RequestContextHolder.resetRequestAttributes();<z>
== null && threadAttributes instanceof ServletRequestAttributes) {<z>
= (ServletRequestAttributes) threadAttributes;<z>
!= null) {<z>
requestCompleted();<z>
, MetadataReaderFactory readerFactory) throws IOException {<z>
) {<z>
reader, readerFactory)) {<z>
true;<z>
return false;<z>
> configurers) {<z>
.of(() -> {<z>
.collect(Collectors.toList());<z>
)) {<z>
return null;<z>
1) {<z>
throw new IllegalStateException("Only one AsyncConfigurer may exist");<z>
candidates.get(0);<z>
});<z>
, AsyncConfigurer::getAsyncExecutor);<z>
, AsyncConfigurer::getAsyncUncaughtExceptionHandler);<z>
getSession(ServerWebExchange exchange) {<z>
exchange)<z>
(createWebSession())<z>
, session))));<z>
int getTypeAnnotationBytecodeOffset(<z>
, final int typeAnnotationIndex) {<z>
null<z>
|| typeAnnotationIndex >= typeAnnotationOffsets.length<z>
) {<z>
-1;<z>
readUnsignedShort(typeAnnotationOffsets[typeAnnotationIndex] + 1);<z>
void setProperty(String property, Object newValue) {<z>
PARENT.equals(property)) {<z>
setParent(newValue);<z>
bd = getBeanDefinition();<z>
property)) {<z>
("byName".equals(newValue)) {<z>
);<z>
equals(newValue)) {<z>
AUTOWIRE_BY_TYPE);<z>
"constructor".equals(newValue)) {<z>
bd.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);<z>
.equals(newValue)) {<z>
;<z>
args) {<z>
ConstructorArgumentValues cav = new ConstructorArgumentValues();<z>
: args) {<z>
;<z>
setConstructorArgumentValues(cav);<z>
property)) {<z>
) {<z>
);<z>
FACTORY_METHOD.equals(property)) {<z>
newValue != null) {<z>
);<z>
INIT_METHOD.equals(property)) {<z>
(newValue != null) {<z>
setInitMethodName(newValue.toString());<z>
property)) {<z>
newValue != null) {<z>
.setDestroyMethodName(newValue.toString());<z>
{<z>
(newValue) ?<z>
);<z>
) {<z>
property, newValue);<z>
, newValue);<z>
parsePutAnnotation(<z>
ae, DefaultCacheConfig defaultConfig, CachePut cachePut) {<z>
Builder builder = new CachePutOperation.Builder();<z>
;<z>
.cacheNames());<z>
condition());<z>
setUnless(cachePut.unless());<z>
());<z>
));<z>
cachePut.cacheManager());<z>
;<z>
builder);<z>
.build();<z>
);<z>
op;<z>
, RequestMapping.class) &&<z>
;<z>
(ControllerMethodResolver.class);<z>
SyncHandlerMethodArgumentResolver> initBinderResolvers;<z>
;<z>
final List<HandlerMethodArgumentResolver> requestMappingResolvers;<z>
> exceptionHandlerResolvers;<z>
final ReactiveAdapterRegistry reactiveAdapterRegistry;<z>
<>(64);<z>
new ConcurrentHashMap<>(64);<z>
<>(64);<z>
;<z>
LinkedHashMap<>(64);<z>
exceptionHandlerAdviceCache =<z>
new LinkedHashMap<>(64);<z>
ConcurrentHashMap<>(64);<z>
customResolvers, ReactiveAdapterRegistry adapterRegistry,<z>
List<HttpMessageReader<?>> readers) {<z>
Assert.notNull(customResolvers, "ArgumentResolverConfigurer is required");<z>
Assert.notNull(adapterRegistry, "ReactiveAdapterRegistry is required");<z>
notNull(context, "ApplicationContext is required");<z>
"HttpMessageReader List is required");<z>
adapterRegistry, context);<z>
= modelMethodResolvers(customResolvers, adapterRegistry, context);<z>
;<z>
, adapterRegistry, context);<z>
this.reactiveAdapterRegistry = adapterRegistry;<z>
(context);<z>
Enumeration<String> getParameterNames() {<z>
multipartParameterNames == null) {<z>
();<z>
this.multipartParameterNames.isEmpty()) {<z>
super.getParameterNames();<z>
LinkedHashSet<>();<z>
getParameterNames();<z>
hasMoreElements()) {<z>
add(paramEnum.nextElement());<z>
this.multipartParameterNames);<z>
;<z>
Nullable String namespace) {<z>
this.namespace = namespace;<z>
) {<z>
"'");<z>
(InjectionPoint original) {<z>
original.methodParameter != null ?<z>
;<z>
.field = original.field;<z>
.fieldAnnotations;<z>
) {<z>
!= null) {<z>
(this::addTransactionalMethod);<z>
{<z>
-> {<z>
).getCharacterEncoding();<z>
);<z>
) throws IOException {<z>
scriptBuilder = new StringBuilder();<z>
String currentLine = lineNumberReader.readLine();<z>
while (currentLine != null) {<z>
) {<z>
'\n');<z>
.append(currentLine);<z>
.readLine();<z>
appendSeparatorToScriptIfNecessary(scriptBuilder, separator);<z>
);<z>
parserContext) {<z>
class);<z>
);<z>
addConstructorArgValue(declareParentsElement.getAttribute(TYPE_PATTERN));<z>
defaultImpl = declareParentsElement.getAttribute(DEFAULT_IMPL);<z>
delegateRef = declareParentsElement.getAttribute(DELEGATE_REF);<z>
.hasText(delegateRef)) {<z>
builder.addConstructorArgValue(defaultImpl);<z>
defaultImpl)) {<z>
(delegateRef);<z>
).error(<z>
" attributes must be specified",<z>
.snapshot());<z>
;<z>
(parserContext.extractSource(declareParentsElement));<z>
registerWithGeneratedName(definition);<z>
;<z>
, Class<T> valueType) throws IllegalStateException {<z>
T value = getProperty(key, valueType);<z>
(value == null) {<z>
IllegalStateException("Required key '" + key + "' not found");<z>
;<z>
() {<z>
ConfigurableMimeFileTypeMap();<z>
);<z>
;<z>
getMostSpecificMediaType(MediaType acceptType, MediaType produceType) {<z>
.copyQualityValue(acceptType);<z>
acceptType.isLessSpecific(produceTypeToUse)) {<z>
produceTypeToUse;<z>
acceptType;<z>
MethodParameter parameter,<z>
bindingContext, ServerWebExchange exchange) {<z>
);<z>
), parameter);<z>
{<z>
("Conversion not supported.", parameter, ex);<z>
) {<z>
ex);<z>
return value;<z>
> completable() {<z>
this);<z>
(completable::complete);<z>
;<z>
;<z>
> result) throws IOException {<z>
if (logger.isTraceEnabled()) {<z>
.getAbsolutePath() +<z>
"] for files matching pattern [" + fullPattern + "]");<z>
listDirectory(dir)) {<z>
, "/");<z>
, currPath + "/")) {<z>
{<z>
)) {<z>
() +<z>
"] because the application is not allowed to read the directory");<z>
, result);<z>
match(fullPattern, currPath)) {<z>
;<z>
) {<z>
;<z>
basePackages);<z>
this.includeAnnotationConfig) {<z>
;<z>
beanCountAtScanStart);<z>
?>... componentClasses) {<z>
);<z>
.getApplicationStartup().start("spring.context.component-classes.register")<z>
toString(componentClasses));<z>
reader.register(componentClasses);<z>
registerComponentClass.end();<z>
, Class<?> targetClass) {<z>
) {<z>
true;<z>
) {<z>
false;<z>
= AopUtils.getMostSpecificMethod(method, targetClass);<z>
);<z>
formatter) throws DateTimeParseException {<z>
.getFormatter(formatter, locale);<z>
this.temporalAccessorType) {<z>
text, Instant::from);<z>
== this.temporalAccessorType) {<z>
parse(text, formatterToUse);<z>
== this.temporalAccessorType) {<z>
LocalTime.parse(text, formatterToUse);<z>
this.temporalAccessorType) {<z>
text, formatterToUse);<z>
.temporalAccessorType) {<z>
.parse(text, formatterToUse);<z>
temporalAccessorType) {<z>
(text, formatterToUse);<z>
class == this.temporalAccessorType) {<z>
text, formatterToUse);<z>
this.temporalAccessorType) {<z>
, formatterToUse);<z>
.temporalAccessorType) {<z>
, formatterToUse);<z>
);<z>
public void validate() {<z>
);<z>
!= null, "No target to validate");<z>
;<z>
)) {<z>
.validate(target, bindingResult);<z>
onError(Throwable ex) {<z>
.error = ex;<z>
true;<z>
;<z>
equals(Object obj) {<z>
{<z>
true;<z>
obj instanceof Parameter)) {<z>
;<z>
Parameter other = (Parameter) obj;<z>
other.value) &&<z>
;<z>
) throws BeansException {<z>
if (bean instanceof AopInfrastructureBean || bean instanceof JmsListenerContainerFactory ||<z>
JmsListenerEndpointRegistry) {<z>
;<z>
= AopProxyUtils.ultimateTargetClass(bean);<z>
&&<z>
, JmsListener.class)) {<z>
annotatedMethods = MethodIntrospector.selectMethods(targetClass,<z>
>) method -> {<z>
.getMergedRepeatableAnnotations(<z>
.class, JmsListeners.class);<z>
? listenerMethods : null);<z>
;<z>
(annotatedMethods.isEmpty()) {<z>
);<z>
)) {<z>
logger.trace("No @JmsListener annotations found on bean type: " + targetClass);<z>
method, listeners) -><z>
));<z>
if (logger.isDebugEnabled()) {<z>
annotatedMethods.size() + " @JmsListener methods processed on bean '" + beanName +<z>
+ annotatedMethods);<z>
bean;<z>
{<z>
)) {<z>
getModifiers())) {<z>
method.getParameterTypes());<z>
catch (NoSuchMethodException ex) {<z>
return method;<z>
=<z>
, method.getParameterTypes());<z>
(specificMethod != null ? specificMethod : method);<z>
ex) {<z>
method;<z>
{<z>
isEmpty()) {<z>
contextPath + "' must start with '/'.");<z>
);<z>
String> consumer) {<z>
getRequiredValue(name);<z>
consumer.accept(value));<z>
this.responseSpec;<z>
Object> getSystemEnvironment() {<z>
()) {<z>
return Collections.emptyMap();<z>
) System.getenv();<z>
super Source> matcher) {<z>
{<z>
getResponse().getContentAsString();<z>
(content, matcher);<z>
public void setAsText(String text) throws IllegalArgumentException {<z>
this.resourceEditor.setAsText(text);<z>
;<z>
;<z>
(IOException ex) {<z>
ex.getMessage());<z>
AnnotationTypeFilter(<z>
boolean considerInterfaces) {<z>
isAnnotationPresent(Inherited.class), considerInterfaces);<z>
annotationType;<z>
considerMetaAnnotations;<z>
T> responseType)<z>
{<z>
request, responseType);<z>
HttpMessageConverterExtractor<T> responseExtractor =<z>
, getMessageConverters());<z>
PATCH, requestCallback, responseExtractor);<z>
?>> annotations) {<z>
(annotations, "Annotations must not be null");<z>
annotations.isEmpty()) {<z>
.NONE;<z>
return new MergedAnnotationsCollection(annotations);<z>
contextPath) {<z>
.contextPath.equals(contextPath)) {<z>
this;<z>
get(contextPath);<z>
Nullable Object other) {<z>
== other) {<z>
return true;<z>
PointcutAdvisor otherAdvisor)) {<z>
;<z>
(), otherAdvisor.getAdvice()) &&<z>
()));<z>
) {<z>
, "'concurrentConsumers' value must be at least 1 (one)");<z>
(this.lifecycleMonitor) {<z>
this.concurrentConsumers = concurrentConsumers;<z>
concurrentConsumers) {<z>
this.maxConcurrentConsumers = concurrentConsumers;<z>
> clazz) {<z>
if (clazz.isPrimitive()) {<z>
if (clazz == Integer.TYPE) {<z>
return INT_TYPE;<z>
(clazz == Void.TYPE) {<z>
return VOID_TYPE;<z>
clazz == Boolean.TYPE) {<z>
return BOOLEAN_TYPE;<z>
clazz == Byte.TYPE) {<z>
BYTE_TYPE;<z>
== Character.TYPE) {<z>
CHAR_TYPE;<z>
{<z>
;<z>
) {<z>
;<z>
clazz == Float.TYPE) {<z>
FLOAT_TYPE;<z>
else if (clazz == Long.TYPE) {<z>
return LONG_TYPE;<z>
else {<z>
;<z>
} else {<z>
getDescriptor(clazz));<z>
(<z>
, @Nullable Object source) {<z>
RuntimeBeanReference handlerRef;<z>
= DomUtils.getChildElementByTagName(element, "handshake-handler");<z>
!= null) {<z>
("ref"));<z>
defaultHandlerDef = new RootBeanDefinition(DefaultHandshakeHandler.class);<z>
source);<z>
.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
.registerWithGeneratedName(defaultHandlerDef);<z>
handlerRef = new RuntimeBeanReference(handlerName);<z>
;<z>
RootBeanDefinition mbd) {<z>
synchronized (getSingletonMutex()) {<z>
(beanName);<z>
null) {<z>
>) bw.getWrappedInstance();<z>
false);<z>
) {<z>
return (FactoryBean<?>) beanInstance;<z>
if (isSingletonCurrentlyInCreation(beanName) ||<z>
)) {<z>
null;<z>
instance;<z>
(beanName);<z>
(beanName, mbd);<z>
== null) {<z>
mbd, null);<z>
getWrappedInstance();<z>
UnsatisfiedDependencyException ex) {<z>
throw ex;<z>
(BeanCreationException ex) {<z>
class)) {<z>
ex;<z>
(logger.isDebugEnabled()) {<z>
.debug("Bean creation exception on singleton FactoryBean type check: " + ex);<z>
;<z>
return null;<z>
);<z>
(beanName, instance);<z>
!= null) {<z>
(beanName, bw);<z>
;<z>
{<z>
size());<z>
{<z>
= (String) en.nextElement();<z>
(beanKey));<z>
= resolveClassNames(classNames, beanKey);<z>
beanKey, classes);<z>
;<z>
protected void populateAttributeDescriptor(<z>
Method setter, String beanKey) {<z>
!= null) {<z>
);<z>
metric != null) {<z>
populateMetricDescriptor(desc, metric);<z>
getManagedAttribute(getter) : null);<z>
).getManagedAttribute(setter) : null);<z>
(desc,<z>
.EMPTY),<z>
: ManagedAttribute.EMPTY));<z>
(List<Resource> locations) {<z>
locations.toString()<z>
, "classpath")<z>
"ServletContext");<z>
merge(ConfigurableEnvironment parent) {<z>
getPropertySources()) {<z>
)) {<z>
.addLast(ps);<z>
[] parentActiveProfiles = parent.getActiveProfiles();<z>
isEmpty(parentActiveProfiles)) {<z>
(this.activeProfiles) {<z>
this.activeProfiles, parentActiveProfiles);<z>
);<z>
parentDefaultProfiles)) {<z>
this.defaultProfiles) {<z>
defaultProfiles.remove(RESERVED_DEFAULT_PROFILE_NAME);<z>
);<z>
exception) {<z>
exception));<z>
Exception ex) {<z>
return null;<z>
(final int tag, final int value) {<z>
hashCode = hash(tag, value);<z>
= get(hashCode);<z>
{<z>
== hashCode && entry.data == value) {<z>
entry;<z>
= entry.next;<z>
(tag).putInt(value);<z>
, tag, value, hashCode));<z>
Nullable String message, @Nullable Throwable cause) {<z>
) {<z>
message;<z>
new StringBuilder(64);<z>
if (message != null) {<z>
append("; ");<z>
append("nested exception is ").append(cause);<z>
return sb.toString();<z>
public void afterCompletion(int status) {<z>
;<z>
== STATUS_COMMITTED) {<z>
();<z>
status == STATUS_ROLLED_BACK) {<z>
;<z>
) {<z>
();<z>
, @Nullable Object source) {<z>
().containsBeanDefinition(HANDLER_MAPPING_BEAN_NAME)) {<z>
getBeanDefinition(HANDLER_MAPPING_BEAN_NAME);<z>
.class);<z>
beanDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
().registerBeanDefinition(HANDLER_MAPPING_BEAN_NAME, beanDef);<z>
HANDLER_MAPPING_BEAN_NAME));<z>
setSource(source);<z>
"order", "1");<z>
context, source));<z>
registerUrlPathHelper(null, context, source));<z>
context, source);<z>
.add("corsConfigurations", corsConfigurationsRef);<z>
;<z>
String name, double defaultVal) {<z>
getParameter(name) == null) {<z>
defaultVal;<z>
, name);<z>
ex) {<z>
return defaultVal;<z>
createSynthesized() {<z>
.rootAttributes) && !isSynthesizable()) {<z>
rootAttributes;<z>
, getType());<z>
) {<z>
notNull(resource, "Resource must not be null");<z>
resource;<z>
this.source = source;<z>
> tokenize(String mimeTypes) {<z>
{<z>
emptyList();<z>
<>();<z>
false;<z>
= 0;<z>
i = 0;<z>
(i < mimeTypes.length()) {<z>
i)) {<z>
'"':<z>
!inQuotes;<z>
',':<z>
) {<z>
, i));<z>
1;<z>
:<z>
i++;<z>
i++;<z>
(mimeTypes.substring(startIndex));<z>
tokens;<z>
Nullable CorsConfiguration config, HttpServletRequest request,<z>
IOException {<z>
HttpHeaders.VARY);<z>
varyHeaders.contains(HttpHeaders.ORIGIN)) {<z>
.ORIGIN);<z>
.ACCESS_CONTROL_REQUEST_METHOD)) {<z>
);<z>
HttpHeaders.ACCESS_CONTROL_REQUEST_HEADERS)) {<z>
HttpHeaders.ACCESS_CONTROL_REQUEST_HEADERS);<z>
!CorsUtils.isCorsRequest(request)) {<z>
;<z>
{<z>
("Skip: response already contains \"Access-Control-Allow-Origin\"");<z>
true;<z>
;<z>
config == null) {<z>
) {<z>
;<z>
return false;<z>
true;<z>
;<z>
ServerWebExchange exchange, WebSocketHandler handler,<z>
HandshakeInfo> handshakeInfoFactory) {<z>
(exchange.getRequest());<z>
());<z>
new Hybi13Handshake(protocols, false);<z>
= Collections.singletonList(handshake);<z>
HandshakeInfo handshakeInfo = handshakeInfoFactory.get();<z>
getResponse().bufferFactory();<z>
.getResponse().setComplete()<z>
contextView -> {<z>
new DefaultCallback(<z>
.decorate(handler, contextView),<z>
;<z>
.handleRequest(httpExchange);<z>
Exception ex) {<z>
);<z>
();<z>
;<z>
{<z>
session.isDisconnected()) {<z>
isDebugEnabled()) {<z>
.debug("SockJS sockJsSession closed, closing response.");<z>
(this.connection);<z>
session.getId(), null);<z>
{<z>
;<z>
= pooled.getBuffer();<z>
;<z>
(buffer);<z>
flip();<z>
r == 0) {<z>
else if (r == -1) {<z>
();<z>
()) {<z>
buffer.get();<z>
== '\n') {<z>
);<z>
(b);<z>
r > 0);<z>
(IOException exc) {<z>
;<z>
) {<z>
1;<z>
, start);<z>
, true));<z>
+ 1;<z>
,<z>
MessagePostProcessor postProcessor) {<z>
headers, postProcessor);<z>
requestMessage);<z>
(replyMessage, targetClass) : null);<z>
IOException {<z>
(b, off, len);<z>
;<z>
;<z>
SockJsService getSockJsService() {<z>
= createSockJsService();<z>
);<z>
{<z>
.setSockJsClientLibraryUrl(this.clientLibraryUrl);<z>
this.streamBytesLimit != null) {<z>
streamBytesLimit);<z>
this.sessionCookieNeeded != null) {<z>
service.setSessionCookieNeeded(this.sessionCookieNeeded);<z>
!= null) {<z>
);<z>
!= null) {<z>
(this.disconnectDelay);<z>
if (this.httpMessageCacheSize != null) {<z>
);<z>
) {<z>
.webSocketEnabled);<z>
(this.suppressCors != null) {<z>
setSuppressCors(this.suppressCors);<z>
);<z>
.setAllowedOriginPatterns(this.allowedOriginPatterns);<z>
if (this.messageCodec != null) {<z>
.setMessageCodec(this.messageCodec);<z>
service;<z>
JspException {<z>
"input");<z>
;<z>
Object> attributes = getDynamicAttributes();<z>
("type")) {<z>
());<z>
(tagWriter);<z>
, SIZE_ATTRIBUTE, getSize());<z>
));<z>
tagWriter, ALT_ATTRIBUTE, getAlt());<z>
));<z>
getAutocomplete());<z>
();<z>
;<z>
body, MethodParameter returnType, MediaType contentType,<z>
converterType,<z>
ServerHttpRequest request, ServerHttpResponse response) {<z>
(returnType, ResponseBodyAdvice.class)) {<z>
, converterType)) {<z>
beforeBodyWrite((T) body, returnType,<z>
request, response);<z>
body;<z>
Class<?> handlerType) {<z>
= createRequestMappingInfo(method);<z>
(info != null) {<z>
RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);<z>
) {<z>
info);<z>
);<z>
) {<z>
);<z>
;<z>
String... values) {<z>
: values) {<z>
);<z>
;<z>
(<z>
, @Nullable String stackDescriptor) {<z>
null) {<z>
(targetDescriptor) {<z>
case 'D':<z>
equals("Ljava/lang/Object")) {<z>
.visitTypeInsn(CHECKCAST, "java/lang/Number");<z>
"java/lang/Number", "doubleValue", "()D", false);<z>
:<z>
stackDescriptor.equals("Ljava/lang/Object")) {<z>
visitTypeInsn(CHECKCAST, "java/lang/Number");<z>
, "floatValue", "()F", false);<z>
:<z>
.equals("Ljava/lang/Object")) {<z>
(CHECKCAST, "java/lang/Number");<z>
"longValue", "()J", false);<z>
'I':<z>
{<z>
, "java/lang/Number");<z>
"java/lang/Number", "intValue", "()I", false);<z>
"Unboxing should not be attempted for descriptor '" + targetDescriptor + "'");<z>
> beanType, BeanDefinition beanDefinition) {<z>
new StringBuilder();<z>
(beanType);<z>
" ['");<z>
builder.append(beanName);<z>
('\'');<z>
.getResourceDescription();<z>
)) {<z>
builder.append(" in ");<z>
append(resourceDescription);<z>
);<z>
(builder.toString());<z>
<String> declaredMethods) {<z>
size());<z>
declaredMethods.isEmpty()) {<z>
.values()) {<z>
(method != HttpMethod.TRACE) {<z>
result.add(method);<z>
) {<z>
valueOf(method);<z>
(httpMethod);<z>
(httpMethod == HttpMethod.GET) {<z>
HEAD);<z>
OPTIONS);<z>
;<z>
access, final int version) {<z>
super( Opcodes.ASM9);<z>
symbolTable = symbolTable;<z>
.moduleNameIndex = name;<z>
access;<z>
this.moduleVersionIndex = version;<z>
new ByteVector();<z>
new ByteVector();<z>
new ByteVector();<z>
usesIndex = new ByteVector();<z>
.provides = new ByteVector();<z>
;<z>
name, Collection<ValueHolder> values) {<z>
for (ValueHolder holder : values) {<z>
())) {<z>
return true;<z>
false;<z>
T> T initProxy(<z>
controllerType, @Nullable ControllerMethodInvocationInterceptor interceptor) {<z>
!= null ?<z>
interceptor : new ControllerMethodInvocationInterceptor(controllerType);<z>
class) {<z>
T) interceptor;<z>
) {<z>
ProxyFactory(EmptyTargetSource.INSTANCE);<z>
;<z>
(MethodInvocationInfo.class);<z>
(interceptor);<z>
return (T) factory.getProxy();<z>
new Enhancer();<z>
enhancer.setSuperclass(controllerType);<z>
>[] {MethodInvocationInfo.class});<z>
enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);<z>
proxy.MethodInterceptor.class);<z>
();<z>
null;<z>
.isWorthTrying()) {<z>
.getUseCache());<z>
) {<z>
.debug("Failed to create controller proxy, falling back on default constructor", ex);<z>
(proxy == null) {<z>
proxyClass).newInstance();<z>
Throwable ex) {<z>
IllegalStateException(<z>
"Failed to create controller proxy or use default constructor", ex);<z>
new Callback[] {interceptor});<z>
(T) proxy;<z>
, int bufferSizeLimit) {<z>
stompDecoder, "StompDecoder is required");<z>
.isTrue(bufferSizeLimit > 0, "Buffer size limit must be greater than 0");<z>
this.stompDecoder = stompDecoder;<z>
.bufferSizeLimit = bufferSizeLimit;<z>
mav) throws Exception {<z>
getViewName() : null);<z>
;<z>
) == 0) {<z>
.printValue("Model", null);<z>
{<z>
(BindingResult.MODEL_KEY_PREFIX)) {<z>
getModel().get(name);<z>
.printer.printValue("Attribute", name);<z>
);<z>
);<z>
!= null) {<z>
("errors", errors.getAllErrors());<z>
validateConfiguration() {<z>
validateConfiguration();<z>
concurrentConsumers != 1) {<z>
"Only 1 concurrent consumer supported for durable subscription");<z>
@Nullable MediaType contentType) {<z>
.getCharset() != null) {<z>
();<z>
));<z>
!= null) {<z>
encoding;<z>
UTF8;<z>
public void start() throws SchedulingException {<z>
null) {<z>
startupDelay);<z>
) {<z>
);<z>
{<z>
this.expressions.size();<z>
!= 0) {<z>
result;<z>
) - getValueMatchCount(this.expressions));<z>
T> errorHandler) {<z>
(predicate, "Predicate must not be null");<z>
notNull(errorHandler, "ErrorHandler must not be null");<z>
request, next) -> {<z>
request);<z>
t instanceof ErrorHandlingServerResponse) {<z>
, errorHandler);<z>
t;<z>
Throwable throwable) {<z>
.test(throwable)) {<z>
(throwable, request);<z>
throw throwable;<z>
(Method attribute, Object value,<z>
factory, Adapt[] adaptations) {<z>
if (value instanceof MergedAnnotation) {<z>
;<z>
.ANNOTATION_TO_MAP.isIn(adaptations) ?<z>
adaptations) : annotation.synthesize());<z>
[]) {<z>
>[]) value;<z>
.isIn(adaptations)) {<z>
);<z>
{<z>
, adaptations));<z>
return result;<z>
Array.newInstance(<z>
, annotations.length);<z>
.length; i++) {<z>
i].synthesize());<z>
;<z>
;<z>
) {<z>
.notNull(cookie, "ResponseCookie must not be null");<z>
.COMMITTED) {<z>
("Can't add the cookie " + cookie +<z>
);<z>
(cookie.getName(), cookie);<z>
) throws IOException {<z>
!= this.location.getClass()) {<z>
false;<z>
String resourcePath;<z>
String locationPath;<z>
(resource instanceof UrlResource) {<z>
.toExternalForm();<z>
;<z>
resource instanceof ClassPathResource) {<z>
();<z>
);<z>
;<z>
;<z>
.equals(resourcePath)) {<z>
return true;<z>
+ "/");<z>
) {<z>
false;<z>
return !resourcePath.contains("%") ||<z>
).contains("../");<z>
{<z>
.pathsCount);<z>
);<z>
{<z>
add(createSamplePath(random));<z>
protected ConnectionHandlingStompSession createSession(<z>
, StompSessionHandler handler) {<z>
= processConnectHeaders(connectHeaders);<z>
session = new DefaultStompSession(handler, connectHeaders);<z>
(getMessageConverter());<z>
;<z>
getReceiptTimeLimit());<z>
;<z>
() {<z>
= getContentType();<z>
: null);<z>
charset != null ? charset : DEFAULT_CHARSET);<z>
public void destroy() {<z>
null) {<z>
()) {<z>
getPersistenceUnitName() + "'");<z>
entityManagerFactory.close();<z>
ExpressionState state) throws EvaluationException {<z>
state, getLeftOperand())) {<z>
.FALSE;<z>
));<z>
value) throws URISyntaxException {<z>
indexOf(':');<z>
{<z>
1);<z>
, colonIndex);<z>
)));<z>
;<z>
, ssp, fragment);<z>
value);<z>
, final String name, final String descriptor) {<z>
) {<z>
(owner, name, descriptor);<z>
a) {<z>
);<z>
result);<z>
result;<z>
{<z>
return "\n" +<z>
+ " " + getUrl() + "\n" +<z>
"\n> ") + "\n" +<z>
) + "\n" +<z>
getStatus().getReasonPhrase() + "\n" +<z>
getResponseHeaders(), "\n< ") + "\n" +<z>
) +"\n" +<z>
);<z>
resolvedType, HttpInputMessage inputMessage)<z>
, HttpMessageNotReadableException {<z>
Reader reader = getReader(inputMessage);<z>
(resolvedType, reader);<z>
Exception ex) {<z>
getMessage(), ex, inputMessage);<z>
<TokenBuffer> result) {<z>
) {<z>
()) {<z>
byteCount = 0;<z>
{<z>
;<z>
currentBufferSize;<z>
.maxInMemorySize) {<z>
();<z>
{<z>
{<z>
;<z>
)) {<z>
false;<z>
otherKey.element) &&<z>
));<z>
TagWriter tagWriter) throws JspException {<z>
writeAttribute("type", getInputType());<z>
getValue());<z>
;<z>
) {<z>
synchronized (this.scheduledTasks) {<z>
);<z>
String originalBeanName(String name) {<z>
beanName = transformedBeanName(name);<z>
FACTORY_BEAN_PREFIX)) {<z>
beanName = FACTORY_BEAN_PREFIX + beanName;<z>
beanName;<z>
Nullable String messageSelector)<z>
{<z>
)) {<z>
, isPubSubNoLocal());<z>
(destination, messageSelector);<z>
BeansException {<z>
());<z>
invokeInitMethods(bean, beanName);<z>
catch (InvocationTargetException ex) {<z>
));<z>
) {<z>
new BeanCreationException(beanName, "Failed to invoke init method", ex);<z>
;<z>
() {<z>
.postProcessingLock) {<z>
this.externallyManagedDestroyMethods != null ?<z>
<>(this.externallyManagedDestroyMethods)) :<z>
Collections.emptySet());<z>
source, TypeDescriptor sourceType, TypeDescriptor targetType) {<z>
(source == null) {<z>
return null;<z>
<?>) source;<z>
.getElementTypeDescriptor();<z>
;<z>
));<z>
i = 0;<z>
) {<z>
conversionService.convert(sourceElement,<z>
sourceType.elementTypeDescriptor(sourceElement), targetElementType);<z>
set(array, i++, targetElement);<z>
return array;<z>
protected MessageListenerContainer createListenerContainer(JmsListenerEndpoint endpoint,<z>
factory) {<z>
(endpoint);<z>
if (listenerContainer instanceof InitializingBean) {<z>
;<z>
(Exception ex) {<z>
, ex);<z>
();<z>
MAX_VALUE) {<z>
{<z>
throw new IllegalStateException("Encountered phase mismatch between container factory definitions: " +<z>
" vs " + containerPhase);<z>
= listenerContainer.getPhase();<z>
listenerContainer;<z>
{<z>
String timeoutString = this.timeoutString;<z>
StringUtils.hasText(timeoutString)) {<z>
resolver != null) {<z>
timeoutString);<z>
{<z>
Integer.parseInt(timeoutString));<z>
{<z>
throw new IllegalArgumentException(<z>
);<z>
) {<z>
{<z>
this.qualifier);<z>
);<z>
for (String label : this.labels) {<z>
.resolveStringValue(label));<z>
this.labels = resolvedLabels;<z>
MalformedObjectNameException {<z>
{<z>
objectName;<z>
instanceof String)) {<z>
new MalformedObjectNameException("Invalid ObjectName value type [" +<z>
.getName() + "]: only ObjectName and String supported.");<z>
String) objectName);<z>
) {<z>
setBeanFactory(beanFactory);<z>
this.exceptionHandler);<z>
null) {<z>
.asyncAnnotationType);<z>
beanFactory);<z>
advisor;<z>
public ConstantDynamic(<z>
,<z>
String descriptor,<z>
bootstrapMethod,<z>
{<z>
this.name = name;<z>
= descriptor;<z>
;<z>
bootstrapMethodArguments = bootstrapMethodArguments;<z>
Nullable Object map, int capacity) {<z>
(map instanceof EnumMap enumMap) {<z>
enumMap);<z>
copy.clear();<z>
return copy;<z>
map instanceof SortedMap sortedMap) {<z>
comparator());<z>
new LinkedHashMap<>(capacity);<z>
@Nullable ClassLoader classLoader) {<z>
);<z>
= getAnnotationType(annotationType, classLoader);<z>
annotationType;<z>
) {<z>
Lifecycle) {<z>
).start();<z>
{<z>
{<z>
{<z>
null) {<z>
if (ref != null) {<z>
();<z>
entry.value;<z>
null;<z>
});<z>
) {<z>
;<z>
);<z>
== classLoader || target == null) {<z>
return true;<z>
{<z>
;<z>
current = classLoader;<z>
while (current != null) {<z>
current = current.getParent();<z>
current == target) {<z>
;<z>
(target != null) {<z>
= target.getParent();<z>
== classLoader) {<z>
;<z>
{<z>
isLoadable(clazz, classLoader));<z>
) {<z>
= eatRelationalExpression();<z>
) {<z>
takeToken();<z>
SpelNodeImpl rhExpr = eatRelationalExpression();<z>
t, expr, rhExpr);<z>
, t.endPos, expr, rhExpr);<z>
return expr;<z>
, Class<T> targetClass)<z>
throws IllegalArgumentException {<z>
(number, "Number must not be null");<z>
(targetClass, "Target class must not be null");<z>
.isInstance(number)) {<z>
(T) number;<z>
.class == targetClass) {<z>
value = checkedLongValue(number, targetClass);<z>
.MIN_VALUE || value > Byte.MAX_VALUE) {<z>
raiseOverflowException(number, targetClass);<z>
number.byteValue());<z>
) {<z>
, targetClass);<z>
.MIN_VALUE || value > Short.MAX_VALUE) {<z>
targetClass);<z>
number.shortValue());<z>
{<z>
, targetClass);<z>
value > Integer.MAX_VALUE) {<z>
;<z>
));<z>
else if (Long.class == targetClass) {<z>
, targetClass);<z>
Long.valueOf(value);<z>
BigInteger.class == targetClass) {<z>
instanceof BigDecimal) {<z>
) number).toBigInteger();<z>
.longValue());<z>
) {<z>
valueOf(number.floatValue());<z>
== targetClass) {<z>
doubleValue());<z>
{<z>
new BigDecimal(number.toString());<z>
+ number + "] of type [" +<z>
getName() + "]");<z>
,<z>
) {<z>
);<z>
?> factoryType, @Nullable ClassLoader classLoader) {<z>
;<z>
) {<z>
.class.getClassLoader();<z>
String factoryTypeName = factoryType.getName();<z>
.emptyList());<z>
(BeanDefinitionBuilder definitionBuilder, Element element) {<z>
ENVIRONMENT);<z>
envValue != null) {<z>
.addPropertyValue(JNDI_ENVIRONMENT, envValue);<z>
.getAttribute(ENVIRONMENT_REF);<z>
)) {<z>
);<z>
LAZY_INIT_ATTRIBUTE);<z>
{<z>
));<z>
String... expectedValues) {<z>
request -> {<z>
, expectedValues.length);<z>
get(name);<z>
, "No header values");<z>
; i++) {<z>
, headerValues.get(i));<z>
Object[] args, Locale locale) {<z>
(ObjectUtils.isEmpty(args)) {<z>
args, locale);<z>
args.length);<z>
arg : args) {<z>
) {<z>
MessageSourceResolvable) arg, locale));<z>
(arg);<z>
resolvedArgs.toArray();<z>
{<z>
boolean proxyTargetClass = true;<z>
) {<z>
{<z>
(PROXY_TARGET_CLASS));<z>
BeanDefinitionHolder holder =<z>
.getRegistry(), proxyTargetClass);<z>
getBeanName());<z>
fireComponentRegistered(<z>
definition.getBeanDefinition(), targetBeanName));<z>
;<z>
filename, Charset charset) {<z>
Assert.hasText(filename, "No filename");<z>
filename;<z>
= charset;<z>
return this;<z>
MessageDigest messageDigest, int len) throws IOException {<z>
int data;<z>
bytesRead = 0;<z>
!= -1) {<z>
) data);<z>
++;<z>
{<z>
) {<z>
return false;<z>
) {<z>
;<z>
.name()));<z>
;<z>
{<z>
.getAdvice();<z>
.getClass()));<z>
boolean appended = false;<z>
Ordered) {<z>
));<z>
true;<z>
) {<z>
);<z>
ajAdvice = (AbstractAspectJAdvice) advice;<z>
.append("aspect name = ");<z>
());<z>
", declaration order = ");<z>
.getDeclarationOrder());<z>
toString();<z>
contentType) {<z>
!= null) {<z>
.getCharset();<z>
.values()) {<z>
)) {<z>
encoding;<z>
.UTF8;<z>
(Class<?> clazz) {<z>
return (String.class == clazz ||<z>
class.isAssignableFrom(clazz) ||<z>
clazz) ||<z>
.isAssignableFrom(clazz) ||<z>
||<z>
QName.class.isAssignableFrom(clazz) ||<z>
.class == clazz ||<z>
.class.isAssignableFrom(clazz) ||<z>
) ||<z>
== clazz ||<z>
||<z>
class == clazz);<z>
tokens, PropertyValue pv) throws BeansException {<z>
if (tokens.keys != null) {<z>
(tokens, pv);<z>
processLocalProperty(tokens, pv);<z>
MethodParameter parameter) {<z>
if (this.validator == null) {<z>
;<z>
()) {<z>
;<z>
getSimpleName().startsWith("Valid")) {<z>
);<z>
] {hints});<z>
name = Conventions.getVariableNameForParameter(parameter);<z>
{<z>
;<z>
) {<z>
validate(target, bindingResult, validationHints);<z>
, bindingResult);<z>
(bindingResult.hasErrors()) {<z>
;<z>
;<z>
) {<z>
= beanEle.getChildNodes();<z>
i++) {<z>
nl.item(i);<z>
)) {<z>
) node, bd);<z>
classFileOffset, final boolean checkClassVersion) {<z>
classFileBuffer = classFileBuffer;<z>
this.b = classFileBuffer;<z>
Opcodes.V19) {<z>
throw new IllegalArgumentException(<z>
;<z>
+ 8);<z>
constantPoolCount];<z>
[constantPoolCount];<z>
int currentCpInfoIndex = 1;<z>
+ 10;<z>
int currentMaxStringLength = 0;<z>
false;<z>
boolean hasConstantDynamic = false;<z>
{<z>
] = currentCpInfoOffset + 1;<z>
cpInfoSize;<z>
{<z>
case Symbol.CONSTANT_FIELDREF_TAG:<z>
CONSTANT_METHODREF_TAG:<z>
CONSTANT_INTERFACE_METHODREF_TAG:<z>
case Symbol.CONSTANT_INTEGER_TAG:<z>
:<z>
Symbol.CONSTANT_NAME_AND_TYPE_TAG:<z>
cpInfoSize = 5;<z>
case Symbol.CONSTANT_DYNAMIC_TAG:<z>
5;<z>
true;<z>
true;<z>
case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:<z>
;<z>
= true;<z>
Symbol.CONSTANT_LONG_TAG:<z>
.CONSTANT_DOUBLE_TAG:<z>
= 9;<z>
currentCpInfoIndex++;<z>
case Symbol.CONSTANT_UTF8_TAG:<z>
+ readUnsignedShort(currentCpInfoOffset + 1);<z>
cpInfoSize > currentMaxStringLength) {<z>
currentMaxStringLength = cpInfoSize;<z>
case Symbol.CONSTANT_METHOD_HANDLE_TAG:<z>
cpInfoSize = 4;<z>
case Symbol.CONSTANT_CLASS_TAG:<z>
:<z>
.CONSTANT_METHOD_TYPE_TAG:<z>
case Symbol.CONSTANT_PACKAGE_TAG:<z>
case Symbol.CONSTANT_MODULE_TAG:<z>
cpInfoSize = 3;<z>
new IllegalArgumentException();<z>
cpInfoSize;<z>
= currentMaxStringLength;<z>
currentCpInfoOffset;<z>
[constantPoolCount] : null;<z>
hasBootstrapMethods ? readBootstrapMethodsAttribute(currentMaxStringLength) : null;<z>
(MethodVisitor mv, @Nullable String descriptor) {<z>
{<z>
descriptor.charAt(0) == '[') {<z>
)) {<z>
;<z>
, descriptor + ";");<z>
)) {<z>
(1));<z>
protected DataSource createDataSource(<z>
{<z>
) {<z>
() throws IOException {<z>
);<z>
{<z>
new UnsupportedOperationException("Read-only jakarta.activation.DataSource");<z>
getContentType() {<z>
return contentType;<z>
) {<z>
return name;<z>
response) {<z>
response.getHeaders();<z>
= headers.getContentType();<z>
);<z>
<?> candidateAspectClass) {<z>
> aspectJAnnotation =<z>
findAspectJAnnotationOnMethod(candidateAdviceMethod);<z>
aspectJAnnotation == null) {<z>
null;<z>
ajexp =<z>
]);<z>
setExpression(aspectJAnnotation.getPointcutExpression());<z>
null) {<z>
(this.beanFactory);<z>
;<z>
factoryBean) {<z>
;<z>
;<z>
;<z>
void setPersistenceUnitName(@Nullable String persistenceUnitName) {<z>
super.setPersistenceUnitName(persistenceUnitName);<z>
persistenceUnitName != null) {<z>
);<z>
ClientHttpRequestFactory requestFactory,<z>
interceptors) {<z>
(requestFactory);<z>
? interceptors : Collections.emptyList());<z>
(WebSocketSession session, Throwable exception) throws Exception {<z>
) {<z>
session, exception);<z>
handleTransportError(session, exception);<z>
protected List<HandlerMethodArgumentResolver> initArgumentResolvers() {<z>
);<z>
context instanceof ConfigurableApplicationContext ?<z>
() : null);<z>
new ArrayList<>();<z>
, beanFactory));<z>
));<z>
conversionService));<z>
resolvers.add(new PrincipalMethodArgumentResolver());<z>
new MessageMethodArgumentResolver(this.messageConverter));<z>
resolvers.addAll(getCustomArgumentResolvers());<z>
.validator));<z>
;<z>
property) throws ELException {<z>
{<z>
base instanceof WebApplicationContext wac) {<z>
property.toString();<z>
if (logger.isTraceEnabled()) {<z>
trace("Attempting to resolve property '" + beanName + "' in root WebApplicationContext");<z>
if (wac.containsBean(beanName)) {<z>
)) {<z>
("Successfully resolved property '" + beanName + "' in root WebApplicationContext");<z>
;<z>
;<z>
) {<z>
throw new ELException(ex);<z>
null;<z>
WEB_APPLICATION_CONTEXT_VARIABLE_NAME.equals(property)) {<z>
(true);<z>
elContext);<z>
null;<z>
public ReactiveResourceSynchronization(<z>
, K resourceKey, TransactionSynchronizationManager synchronizationManager) {<z>
= resourceObject;<z>
= resourceKey;<z>
this.synchronizationManager = synchronizationManager;<z>
?> clazz, final int maxDistance) {<z>
();<z>
, field -> {<z>
field.getName();<z>
, possibleAlternative) <= maxDistance) {<z>
add(possibleAlternative);<z>
);<z>
.sort(candidates);<z>
toStringArray(candidates);<z>
definition)<z>
NotSupportedException, SystemException {<z>
getIsolationLevel());<z>
= determineTimeout(definition);<z>
);<z>
begin();<z>
MultipartException {<z>
);<z>
Part part : request.getParts()) {<z>
) {<z>
);<z>
return parts;<z>
catch (Exception ex) {<z>
ex);<z>
public void onNext(T t) {<z>
subscription != null, "No subscription");<z>
servletResponse, this.context);<z>
;<z>
subscription.request(1);<z>
) {<z>
.cancel();<z>
);<z>
type) throws IllegalStateException {<z>
"EmbeddedDatabaseType is required");<z>
{<z>
:<z>
;<z>
:<z>
.getInstance();<z>
case DERBY:<z>
;<z>
;<z>
ClassNotFoundException | NoClassDefFoundError ex) {<z>
"Driver for test database type [" + type + "] is not available", ex);<z>
final Label[] labels) {<z>
) {<z>
|= Label.FLAG_DEBUG_ONLY;<z>
userRegistry(<z>
) {<z>
brokerRegistry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);<z>
);<z>
= brokerRegistry.getUserRegistryBroadcast() != null;<z>
) : userRegistry);<z>
{<z>
sql, "SQL must not be null");<z>
.notNull(rse, "ResultSetExtractor must not be null");<z>
(logger.isDebugEnabled()) {<z>
sql + "]");<z>
>, SqlProvider {<z>
Statement stmt) throws SQLException {<z>
= null;<z>
sql);<z>
;<z>
rs);<z>
public String getSql() {<z>
return sql;<z>
(), true);<z>
buffer) {<z>
.isTraceEnabled()) {<z>
trace("Emitting body: " + buffer);<z>
BodyToken(buffer));<z>
Nullable Session session, String destinationName, boolean pubSubDomain)<z>
{<z>
(this.beanFactory != null, "BeanFactory is required");<z>
.getBean(destinationName, Destination.class);<z>
{<z>
DestinationResolutionException(<z>
"'", ex);<z>
<?> writer) {<z>
add(writer);<z>
();<z>
return this;<z>
UriComponentsBuilder replacePath(@Nullable String path) {<z>
;<z>
) {<z>
.pathBuilder.addPath(path);<z>
resetSchemeSpecificPart();<z>
return this;<z>
HttpServletRequest request,<z>
ResourceTransformerChain transformerChain) {<z>
if (resourcePath.startsWith("/")) {<z>
findResourceUrlProvider(request);<z>
request, resourcePath) : null);<z>
.resolveUrlPath(<z>
));<z>
final int var, final int increment) {<z>
) {<z>
, increment);<z>
,<z>
@Nullable MethodParameter methodParam) throws TypeMismatchException {<z>
);<z>
(<z>
{<z>
contexts) {<z>
CacheEvictOperation) context.metadata.operation;<z>
) {<z>
, result);<z>
() {<z>
{<z>
"Factory called postProcessAfterInit before afterPropertiesSet");<z>
.initedViaDeclaredInitMethod) {<z>
;<z>
{<z>
throw new RuntimeException("Factory called postProcessAfterInit twice");<z>
;<z>
createNamedValueInfo(MethodParameter parameter) {<z>
);<z>
null, "No CookieValue annotation");<z>
return new CookieValueNamedValueInfo(ann);<z>
) {<z>
Assert.notNull(environment, "Environment must not be null");<z>
.environment = environment;<z>
null;<z>
List<DestructionAwareBeanPostProcessor> postProcessors) {<z>
Assert.notNull(bean, "Disposable bean must not be null");<z>
this.bean = bean;<z>
);<z>
= true;<z>
;<z>
(postProcessors, bean);<z>
{<z>
;<z>
checkRequiredFields(mpvs);<z>
);<z>
parts, byte[] boundary) throws IOException {<z>
)) {<z>
name = entry.getKey();<z>
.getValue()) {<z>
part != null) {<z>
os, boundary);<z>
os);<z>
);<z>
() {<z>
);<z>
target != null, "No 'targetConnectionFactory' set");<z>
;<z>
(<z>
) {<z>
emfInfo, false, synchronizedWithTransaction);<z>
<?> message, long timeout) {<z>
= message;<z>
;<z>
();<z>
errorDescription = null;<z>
(this.hasTimedOut) {<z>
errorDescription = "Reply message received but the receiving thread has exited due to a timeout";<z>
{<z>
;<z>
{<z>
errorDescription = "Reply message received but the receiving thread has exited due to " +<z>
(errorDescription != null) {<z>
.isWarnEnabled()) {<z>
+ message);<z>
this.throwExceptionOnLateReply) {<z>
, errorDescription);<z>
true;<z>
File getFile(URI uri) throws IOException {<z>
{<z>
uri).getFile();<z>
);<z>
) {<z>
(WebAsyncManager.this) {<z>
concurrentResult = RESULT_NONE;<z>
concurrentResultContext = null;<z>
final void visitOuterClass(<z>
final String name, final String descriptor) {<z>
addConstantClass(owner).index;<z>
!= null && descriptor != null) {<z>
.addConstantNameAndType(name, descriptor);<z>
() {<z>
)) {<z>
{<z>
();<z>
) {<z>
);<z>
getFile() throws IOException {<z>
this.file;<z>
file != null) {<z>
file;<z>
);<z>
file = file;<z>
file;<z>
) {<z>
(originalPath);<z>
!cleanedPath.equals(originalPath)) {<z>
new URL(cleanedPath);<z>
) {<z>
;<z>
> annotationType) {<z>
.isInstance(annotation)) {<z>
(A) annotation, annotationType);<z>
.hasPlainJavaAnnotationsOnly(annotation)) {<z>
;<z>
, RepeatableContainers.none())<z>
.get(annotationType).withNonMergedAttributes()<z>
isSingleLevelPresent).orElse(null);<z>
{<z>
()) {<z>
("TCP connection opened in session=" + getSessionId());<z>
tcpConnection = connection;<z>
onReadInactivity(() -> {<z>
!= null && !this.isStompConnected) {<z>
("No CONNECTED frame received in " +<z>
null);<z>
);<z>
.getMessageHeaders()));<z>
other) {<z>
) {<z>
;<z>
instanceof GenericMessage)) {<z>
return false;<z>
GenericMessage<?>) other;<z>
otherMsg.headers));<z>
) {<z>
entryCount++;<z>
length;<z>
.next = entries[index];<z>
entries[index] = entry;<z>
String> toSingleValueMap() {<z>
this.headers.size());<z>
)));<z>
return singleValueMap;<z>
messageSupplier) {<z>
{<z>
new IllegalArgumentException(nullSafeGet(messageSupplier));<z>
public MockRestServiceServer build() {<z>
) {<z>
);<z>
);<z>
void remove() {<z>
(this.currentName == null) {<z>
);<z>
) {<z>
this.currentName);<z>
currentName);<z>
{<z>
().generateBeanName(beanDef);<z>
, context, source);<z>
return name;<z>
headers) {<z>
() == null) {<z>
return null;<z>
getSelectorHeaderName(), headers);<z>
selector == null) {<z>
;<z>
null;<z>
= this.expressionParser.parseExpression(selector);<z>
;<z>
{<z>
+ "]");<z>
catch (Throwable ex) {<z>
if (logger.isDebugEnabled()) {<z>
);<z>
;<z>
isInitialized() {<z>
memoizedIsInitialized;<z>
== 1;<z>
memoizedIsInitialized = 1;<z>
;<z>
Class<?>... supportedTypes) {<z>
(supportedTypes)) {<z>
emptySet();<z>
(supportedTypes, "'supportedTypes' must not contain null elements");<z>
(Class::getName)<z>
.collect(Collectors.toUnmodifiableSet());<z>
, String pattern) throws IOException {<z>
!rootDir.exists()) {<z>
)) {<z>
) + "] because it does not exist");<z>
Collections.emptySet();<z>
.isDirectory()) {<z>
{<z>
) + "] because it does not denote a directory");<z>
return Collections.emptySet();<z>
.canRead()) {<z>
logger.isInfoEnabled()) {<z>
() +<z>
"] because the application is not allowed to read the directory");<z>
return Collections.emptySet();<z>
separator, "/");<z>
"/")) {<z>
+= "/";<z>
"/");<z>
LinkedHashSet<>(8);<z>
);<z>
return result;<z>
) {<z>
new HashSet<>();<z>
this.users.values()) {<z>
(TransferSimpSession session : user.sessions) {<z>
.subscriptions) {<z>
{<z>
;<z>
;<z>
message, Object... inserts) {<z>
;<z>
message;<z>
.inserts = inserts;<z>
) {<z>
{<z>
request;<z>
(key)) {<z>
;<z>
;<z>
throws Exception {<z>
(method);<z>
beanName = tryGetBeanName(args);<z>
beanFactory != null, "No BeanFactory available");<z>
hasLength(beanName)) {<z>
);<z>
serviceLocatorMethodReturnType);<z>
) {<z>
null) {<z>
ex);<z>
;<z>
(<z>
final int opcode,<z>
,<z>
final String name,<z>
final String descriptor,<z>
isInterface) {<z>
Opcodes.SOURCE_DEPRECATED) == 0) {<z>
{<z>
);<z>
, descriptor);<z>
) {<z>
name, descriptor, isInterface);<z>
void afterPropertiesSet() {<z>
if (this.name == null) {<z>
.name = this.beanName;<z>
== null) {<z>
DEFAULT_GROUP;<z>
if (this.jobDetail != null) {<z>
);<z>
|| this.startTime == null) {<z>
.startDelay);<z>
SimpleTriggerImpl sti = new SimpleTriggerImpl();<z>
: toString());<z>
.setGroup(this.group);<z>
(this.jobDetail != null) {<z>
this.jobDetail.getKey());<z>
;<z>
);<z>
this.repeatInterval);<z>
(this.repeatCount);<z>
);<z>
sti.setMisfireInstruction(this.misfireInstruction);<z>
sti.setDescription(this.description);<z>
= sti;<z>
(<z>
exchange, SyncInvocableHandlerMethod binderMethod) {<z>
;<z>
getReturnValue() != null) {<z>
IllegalStateException(<z>
);<z>
) {<z>
new IllegalStateException(<z>
"@InitBinder methods are not allowed to add model attributes: " + binderMethod);<z>
{<z>
;<z>
if (this.txManager != null) {<z>
this.txManager);<z>
return txAspect;<z>
Method method) {<z>
Class<?> clazz : ASPECTJ_ANNOTATION_CLASSES) {<z>
;<z>
) {<z>
foundAnnotation;<z>
;<z>
@Nullable Principal user) {<z>
(source);<z>
Assert.notNull(message, "Message must not be null");<z>
;<z>
= user;<z>
(IntervalTask task) {<z>
? (FixedRateTask) task :<z>
task.getInitialDelay()));<z>
);<z>
void afterPropertiesSet() throws Exception {<z>
(this.messageWriters)) {<z>
;<z>
{<z>
remove(handler);<z>
if (result) {<z>
) {<z>
) + " removed " + handler);<z>
return result;<z>
private String determineTransactionAspectClass() {<z>
?<z>
:<z>
);<z>
<HttpMessageConverter<?>> messageConverters) {<z>
;<z>
>(messageConverters));<z>
getHeaders());<z>
new ServletParametersMap(servletRequest));<z>
attributes = new ServletAttributesMap(servletRequest);<z>
servletRequest) ?<z>
.getParsedRequestPath(servletRequest) :<z>
));<z>
UnsupportedEncodingException {<z>
(from, "From address must not be null");<z>
(getEncoding() != null ?<z>
, personal));<z>
.RESULT_OF_SELECTION_CRITERIA_IS_NOT_BOOLEAN);<z>
SpelMessage.RESULT_OF_SELECTION_CRITERIA_IS_NOT_BOOLEAN);<z>
() {<z>
) {<z>
if (!this.running) {<z>
);<z>
.state(resourceAdapter != null, "No ResourceAdapter set");<z>
(), getActivationSpec());<z>
ResourceException ex) {<z>
);<z>
running = true;<z>
ApplicationContext applicationContext) {<z>
applicationContext = applicationContext;<z>
!= null) {<z>
containsBean("mvcContentNegotiationManager"),<z>
;<z>
, String value) {<z>
;<z>
.notNull(value, "Value must not be null");<z>
name;<z>
.valuePredicate = value::equals;<z>
this.value = value;<z>
String> createHeaders(HttpServletRequest servletRequest) {<z>
servletRequest);<z>
build(request.getHttpFields());<z>
;<z>
defaultTypeName, Element entryEle) {<z>
= buildTypedStringValue(value, defaultTypeName);<z>
);<z>
return typedValue;<z>
(ClassNotFoundException ex) {<z>
+ defaultTypeName + "] not found for Map key/value type", entryEle, ex);<z>
value;<z>
getErrorCount(ModelMap model) {<z>
int count = 0;<z>
value : model.values()) {<z>
value instanceof Errors) {<z>
();<z>
;<z>
String code, Locale locale) {<z>
);<z>
(String basename : basenames) {<z>
);<z>
bundle != null) {<z>
, code);<z>
null) {<z>
return result;<z>
;<z>
result) {<z>
?> returnValueMono;<z>
bodyParameter;<z>
);<z>
actualParameter = result.getReturnTypeSource();<z>
!= null) {<z>
);<z>
getReturnValue()));<z>
&&<z>
;<z>
().nested());<z>
;<z>
;<z>
flatMap(returnValue -> {<z>
> httpEntity;<z>
if (returnValue instanceof HttpEntity) {<z>
?>) returnValue;<z>
{<z>
returnValue, HttpStatus.OK);<z>
(<z>
returnValue.getClass());<z>
ResponseEntity) {<z>
setRawStatusCode(<z>
>) httpEntity).getStatusCodeValue());<z>
();<z>
.getResponse().getHeaders();<z>
isEmpty()) {<z>
stream()<z>
getValue()));<z>
HttpHeaders) {<z>
getResponse().setComplete();<z>
= entityHeaders.getETag();<z>
.ofEpochMilli(entityHeaders.getLastModified());<z>
getRequest().getMethod();<z>
.checkNotModified(etag, lastModified)) {<z>
).setComplete();<z>
, exchange);<z>
);<z>
(Object target) {<z>
);<z>
target));<z>
);<z>
(<z>
String themeName) {<z>
);<z>
<?> getKotlinSerializationJsonDecoder() {<z>
) {<z>
.kotlinSerializationJsonDecoder = new KotlinSerializationJsonDecoder();<z>
kotlinSerializationJsonDecoder;<z>
doGetTransaction() {<z>
;<z>
setSavepointAllowed(isNestedTransactionAllowed());<z>
sessionFactory = obtainSessionFactory();<z>
sessionHolder =<z>
sessionFactory);<z>
if (sessionHolder != null) {<z>
) {<z>
.getSession() + "] for Hibernate transaction");<z>
(sessionHolder);<z>
) {<z>
);<z>
isDebugEnabled()) {<z>
session + "] for Spring-managed transaction");<z>
txObject.setExistingSession(session);<z>
HibernateException ex) {<z>
DataAccessResourceFailureException(<z>
, ex);<z>
) != null) {<z>
)<z>
());<z>
.setConnectionHolder(conHolder);<z>
txObject;<z>
{<z>
.path.length() == 0) {<z>
;<z>
String sanitized = getSanitizedPath(this.path);<z>
);<z>
clazz) {<z>
StringBuilder();<z>
stringBuilder);<z>
toString();<z>
throws XmlMappingException {<z>
= saxResult.getHandler();<z>
Assert.notNull(contentHandler, "ContentHandler not set on SAXResult");<z>
LexicalHandler lexicalHandler = saxResult.getLexicalHandler();<z>
, contentHandler, lexicalHandler);<z>
{<z>
result = new StringBuilder();<z>
nextIsUpper = false;<z>
&& name.length() > 0) {<z>
(1) == '_') {<z>
)));<z>
0)));<z>
i++) {<z>
c = name.charAt(i);<z>
c == '_') {<z>
true;<z>
if (nextIsUpper) {<z>
));<z>
;<z>
Character.toLowerCase(c));<z>
return result.toString();<z>
throws SQLException {<z>
;<z>
if (this.wrapAsLob) {<z>
.getBlob(columnIndex);<z>
.length());<z>
return rs.getBytes(columnIndex);<z>
) {<z>
, "Cookie must not be null");<z>
.cookies.clear();<z>
.cookies.add(cookie);<z>
true);<z>
@Nullable MethodParameter actualParam,<z>
BindingContext bindingContext, ServerWebExchange exchange) {<z>
bodyParam);<z>
(actualParam) : bodyType);<z>
= bodyType.resolve();<z>
resolvedType) : null);<z>
.getGeneric() : bodyType);<z>
&& !adapter.supportsEmpty());<z>
);<z>
);<z>
getHeaders().getContentType();<z>
MediaType.APPLICATION_OCTET_STREAM);<z>
);<z>
.isCompatibleWith(MediaType.APPLICATION_FORM_URLENCODED)) {<z>
)) {<z>
("Form data is accessed via ServerWebExchange.getFormData() in WebFlux.");<z>
);<z>
if (logger.isDebugEnabled()) {<z>
) + (contentType != null ?<z>
contentType :<z>
MediaType.APPLICATION_OCTET_STREAM));<z>
reader : getMessageReaders()) {<z>
) {<z>
));<z>
.isMultiValue()) {<z>
{<z>
;<z>
request, response, readHints);<z>
handleReadError(bodyParam, ex)));<z>
if (isBodyRequired) {<z>
bodyParam)));<z>
hints != null) {<z>
= flux.doOnNext(target -><z>
, bodyParam, bindingContext, exchange));<z>
just(adapter.fromPublisher(flux));<z>
)) {<z>
;<z>
response, readHints);<z>
);<z>
{<z>
-> handleMissingBody(bodyParam)));<z>
!= null) {<z>
.doOnNext(target -><z>
, bodyParam, bindingContext, exchange));<z>
.from(mono));<z>
.getMethod();<z>
(method)) {<z>
{<z>
release(buffer);<z>
UnsupportedMediaTypeStatusException(<z>
(elementType), elementType);<z>
);<z>
isBodyRequired) {<z>
);<z>
Mono.from(body));<z>
UnsupportedMediaTypeStatusException(<z>
, elementType));<z>
stream, int length, LobHandler lobHandler) {<z>
.content = stream;<z>
.length = length;<z>
;<z>
void initServletContext(ServletContext servletContext) {<z>
).values()) {<z>
if (handler instanceof ServletContextAware) {<z>
.setServletContext(servletContext);<z>
beanKey) {<z>
method);<z>
{<z>
(method, beanKey);<z>
length];<z>
methodParameters = method.getParameterTypes();<z>
) {<z>
i];<z>
i] =<z>
());<z>
;<z>
{<z>
elementClass, "Class must not be null");<z>
response -><z>
));<z>
public ResourceLoader getResourceLoader() {<z>
null) {<z>
this.resourcePatternResolver = new PathMatchingResourcePatternResolver();<z>
.resourcePatternResolver;<z>
cleanupAfterCompletion(TransactionSynchronizationManager synchronizationManager,<z>
) {<z>
return Mono.defer(() -> {<z>
status.setCompleted();<z>
isNewSynchronization()) {<z>
();<z>
();<z>
)) {<z>
);<z>
{<z>
)) {<z>
("Resuming suspended transaction after completion of inner transaction");<z>
: null);<z>
.then(resume(synchronizationManager, transaction,<z>
));<z>
cleanup;<z>
;<z>
Locale parseLocale(String localeValue) {<z>
;<z>
{<z>
(localeValue);<z>
localeValue);<z>
> 0) {<z>
;<z>
;<z>
args) throws Throwable {<z>
;<z>
setProxyContext = false;<z>
= this.advised.targetSource;<z>
Object target = null;<z>
&& AopUtils.isEqualsMethod(method)) {<z>
args[0]);<z>
)) {<z>
hashCode();<z>
DecoratingProxy.class) {<z>
AopProxyUtils.ultimateTargetClass(this.advised);<z>
isInterface() &&<z>
.class)) {<z>
(this.advised, method, args);<z>
retVal;<z>
) {<z>
(proxy);<z>
true;<z>
();<z>
: null);<z>
targetClass);<z>
{<z>
args);<z>
method, argsToUse);<z>
=<z>
args, targetClass, chain);<z>
();<z>
> returnType = method.getReturnType();<z>
&& retVal == target &&<z>
proxy) &&<z>
) {<z>
proxy;<z>
&& returnType.isPrimitive()) {<z>
throw new AopInvocationException(<z>
"Null return value from advice does not match primitive return type for: " + method);<z>
retVal;<z>
)) {<z>
);<z>
(setProxyContext) {<z>
);<z>
getInterceptors(Advisor advisor) throws UnknownAdviceTypeException {<z>
new ArrayList<>(3);<z>
Advice advice = advisor.getAdvice();<z>
if (advice instanceof MethodInterceptor) {<z>
) advice);<z>
this.adapters) {<z>
(adapter.supportsAdvice(advice)) {<z>
add(adapter.getInterceptor(advisor));<z>
) {<z>
));<z>
]);<z>
{<z>
;<z>
null, "No SessionFactory set");<z>
);<z>
) {<z>
String headerName) {<z>
(headerName);<z>
{<z>
return new ArrayList<>(removed);<z>
return null;<z>
Symbol addConstantDynamicOrInvokeDynamicReference(<z>
) {<z>
, name, descriptor, bootstrapMethodIndex);<z>
);<z>
!= null) {<z>
entry.tag == tag<z>
hashCode<z>
&& entry.data == bootstrapMethodIndex<z>
&& entry.name.equals(name)<z>
descriptor)) {<z>
return entry;<z>
entry = entry.next;<z>
bootstrapMethodIndex, addConstantNameAndType(name, descriptor));<z>
return put(<z>
(<z>
bootstrapMethodIndex, hashCode));<z>
) {<z>
add(Qualifier.class);<z>
.forName("jakarta.inject.Qualifier",<z>
);<z>
{<z>
String, Object>> attributesConsumer) {<z>
notNull(attributesConsumer, "AttributesConsumer must not be null");<z>
;<z>
attributesConsumer.accept(attributes);<z>
;<z>
) {<z>
;<z>
++) {<z>
variables[i]);<z>
resolvedVariable, variableToCompare)) {<z>
];<z>
null;<z>
) {<z>
).getObjectWrapper();<z>
.DEFAULT_INCOMPATIBLE_IMPROVEMENTS;<z>
());<z>
(HttpServletRequest request) {<z>
= request.getScheme();<z>
);<z>
= request.getServerPort();<z>
= new ServletUriComponentsBuilder();<z>
scheme(scheme);<z>
builder.host(host);<z>
&& port != 443)) {<z>
);<z>
;<z>
sourceType, ResolvableType targetType) {<z>
;<z>
));<z>
.targetType = targetType;<z>
void setETag(@Nullable String etag) {<z>
) {<z>
) || etag.startsWith("W/"),<z>
);<z>
endsWith("\""), "Invalid ETag: does not end with \"");<z>
ETAG, etag);<z>
;<z>
Nullable WorkManager workManager, @Nullable XATerminator xaTerminator,<z>
) {<z>
.workManager = workManager;<z>
.xaTerminator = xaTerminator;<z>
= transactionSynchronizationRegistry;<z>
(<z>
boolean proxyTargetClass) {<z>
.createScopedProxy(definitionHolder, registry, proxyTargetClass);<z>
) {<z>
.indexOf('-');<z>
!= -1) {<z>
);<z>
));<z>
{<z>
+ "]: only " +<z>
"always keep a fixed number of consumers according to the maximum value.");<z>
)<z>
{<z>
);<z>
true;<z>
) {<z>
{<z>
));<z>
(currencyTimeLimit == 0) {<z>
);<z>
applyDefaultCurrencyTimeLimit(desc);<z>
toString() {<z>
(this.isNegated) {<z>
;<z>
;<z>
void retrieveMBeanInfo(MBeanServerConnection server) throws MBeanInfoRetrievalException {<z>
server.getMBeanInfo(this.objectName);<z>
] attributeInfo = info.getAttributes();<z>
CollectionUtils.newHashMap(attributeInfo.length);<z>
{<z>
), infoEle);<z>
);<z>
.length);<z>
{<z>
.beanClassLoader);<z>
), paramTypes), infoEle);<z>
ClassNotFoundException ex) {<z>
throw new MBeanInfoRetrievalException("Unable to locate class specified in method signature", ex);<z>
catch (IntrospectionException ex) {<z>
this.objectName + "]", ex);<z>
{<z>
objectName +<z>
);<z>
{<z>
objectName + "]", ex);<z>
(IOException ex) {<z>
MBeanInfoRetrievalException("An IOException occurred when communicating with the " +<z>
);<z>
{<z>
(); i++) {<z>
clazz = APC_PRIORITY_LIST.get(i);<z>
(className)) {<z>
return i;<z>
throw new IllegalArgumentException(<z>
"Class name [" + className + "] is not a known auto-proxy creator class");<z>
<?> getNestedParameterType() {<z>
.nestingLevel > 1) {<z>
Type type = getGenericParameterType();<z>
i++) {<z>
instanceof ParameterizedType) {<z>
ParameterizedType) type).getActualTypeArguments();<z>
index = getTypeIndexForLevel(i);<z>
: args.length - 1];<z>
type instanceof Class) {<z>
Class<?>) type;<z>
ParameterizedType) {<z>
.getRawType();<z>
if (arg instanceof Class) {<z>
Class<?>) arg;<z>
return Object.class;<z>
;<z>
TransactionDefinition transactionDefinition) {<z>
);<z>
transactionManager, "TransactionDefinition must not be null");<z>
transactionManager;<z>
transactionDefinition = transactionDefinition;<z>
() {<z>
if (this.previousPageStatus != null) {<z>
, PageContext.PAGE_SCOPE);<z>
if (this.previousRequestStatus != null) {<z>
.previousRequestStatus, PageContext.REQUEST_SCOPE);<z>
.removeAttribute(STATUS_VARIABLE_NAME, PageContext.REQUEST_SCOPE);<z>
;<z>
MockMvcHtmlUnitDriverBuilder webAppContextSetup(WebApplicationContext context,<z>
MockMvcConfigurer configurer) {<z>
(context, "WebApplicationContext must not be null");<z>
"MockMvcConfigurer must not be null");<z>
configurer);<z>
@Nullable String value) {<z>
{<z>
.add(key, value);<z>
) {<z>
;<z>
!= SqlParameterSource.TYPE_UNKNOWN) {<z>
source.getValue(parameterName));<z>
return source.getValue(parameterName);<z>
(ServerHttpRequest request, ServerHttpResponse response,<z>
,<z>
Object> attrs)<z>
HandshakeFailureException {<z>
);<z>
null;<z>
();<z>
Exception ex) {<z>
InetSocketAddress remoteAddr = null;<z>
.getRemoteAddress();<z>
{<z>
, user);<z>
StandardWebSocketHandlerAdapter(wsHandler, session);<z>
= new ArrayList<>();<z>
for (WebSocketExtension extension : selectedExtensions) {<z>
add(new WebSocketToStandardExtensionAdapter(extension));<z>
endpoint);<z>
Nullable CrossOrigin annotation) {<z>
annotation == null) {<z>
()) {<z>
(origin));<z>
) {<z>
));<z>
methods()) {<z>
method.name());<z>
header : annotation.allowedHeaders()) {<z>
;<z>
exposedHeaders()) {<z>
.addExposedHeader(resolveCorsAnnotationValue(header));<z>
.allowCredentials());<z>
("true".equalsIgnoreCase(allowCredentials)) {<z>
setAllowCredentials(true);<z>
("false".equalsIgnoreCase(allowCredentials)) {<z>
;<z>
if (!allowCredentials.isEmpty()) {<z>
+<z>
);<z>
0 ) {<z>
.setMaxAge(annotation.maxAge());<z>
{<z>
urlDecode) {<z>
return vars;<z>
size());<z>
value)));<z>
;<z>
Nullable SessionHolder sessionHolder) {<z>
.sessionHolder = sessionHolder;<z>
= false;<z>
false;<z>
{<z>
== other) {<z>
return true;<z>
(!super.equals(other)) {<z>
;<z>
= (DependencyDescriptor) other;<z>
== otherDesc.eager &&<z>
containingClass == otherDesc.containingClass);<z>
{<z>
MappingJacksonValue mappingJacksonValue) {<z>
object = mappingJacksonValue.getValue();<z>
contentType);<z>
candidateName,<z>
requiredType) {<z>
) {<z>
;<z>
instanceof NullBean)) {<z>
put(candidateName, beanInstance);<z>
StreamDependencyDescriptor &&<z>
)) {<z>
resolveCandidate(candidateName, requiredType, this);<z>
));<z>
getType(candidateName));<z>
<String>>> entrySet() {<z>
).stream()<z>
entry -> {<z>
getValue());<z>
entry.getKey(), value);<z>
toSet());<z>
static Flux<DataBuffer> readByteChannel(<z>
int bufferSize) {<z>
"'channelSupplier' must not be null");<z>
Assert.notNull(bufferFactory, "'dataBufferFactory' must not be null");<z>
(bufferSize > 0, "'bufferSize' must be > 0");<z>
Flux.using(channelSupplier,<z>
)),<z>
);<z>
, Throwable ex, Method method) throws Throwable {<z>
handlerArgs;<z>
.getParameterCount() == 1) {<z>
= new Object[] {ex};<z>
;<z>
throwsAdvice, handlerArgs);<z>
catch (InvocationTargetException targetEx) {<z>
.getTargetException();<z>
{<z>
newProxyInstance(DatabaseClient.class.getClassLoader(),<z>
,<z>
con));<z>
TypeDescriptor targetType) {<z>
null) {<z>
null;<z>
("unchecked")<z>
source;<z>
getType().isInstance(source);<z>
) {<z>
;<z>
TypeDescriptor keyDesc = targetType.getMapKeyTypeDescriptor();<z>
.getMapValueTypeDescriptor();<z>
());<z>
: sourceMap.entrySet()) {<z>
();<z>
;<z>
;<z>
, sourceType, valueDesc);<z>
);<z>
(sourceKey != targetKey || sourceValue != targetValue) {<z>
= true;<z>
{<z>
;<z>
CollectionFactory.createMap(targetType.getType(),<z>
null), sourceMap.size());<z>
targetEntries) {<z>
);<z>
targetMap;<z>
Nullable ConstructorArgumentValues other) {<z>
!= null) {<z>
other.indexedArgumentValues.forEach(<z>
.copy())<z>
genericArgumentValues.stream()<z>
.genericArgumentValues.contains(valueHolder))<z>
)));<z>
(TransactionSynchronizationManager synchronizationManager,<z>
, @Nullable SuspendedResourcesHolder suspendedResources, Throwable beginEx) {<z>
String exMessage = "Inner transaction begin exception overridden by outer transaction resume exception";<z>
(ErrorPredicates.RUNTIME_OR_ERROR,<z>
.error(exMessage, beginEx));<z>
private ClassLoader getClassLoader() {<z>
if (this.classLoader != null) {<z>
return this.classLoader;<z>
{<z>
.source instanceof Class) {<z>
source).getClassLoader();<z>
this.source instanceof Member) {<z>
getDeclaringClass().getClassLoader();<z>
;<z>
RequestConditionHolder getMatchingCondition(ServerWebExchange exchange) {<z>
) {<z>
return this;<z>
condition.getMatchingCondition(exchange);<z>
) : null);<z>
protected void startInternal() {<z>
if (this.tcpClient == null) {<z>
.tcpClient = initTcpClient();<z>
.isInfoEnabled()) {<z>
info("Starting \"system\" session, " + toString());<z>
StompCommand.CONNECT);<z>
;<z>
(this.systemLogin);<z>
);<z>
.systemHeartbeatSendInterval, this.systemHeartbeatReceiveInterval);<z>
virtualHost = getVirtualHost();<z>
!= null) {<z>
setHost(virtualHost);<z>
);<z>
) {<z>
"Forwarding " + accessor.getShortLogMessage(EMPTY_PAYLOAD));<z>
= new SystemSessionConnectionHandler(accessor);<z>
, handler);<z>
.incrementConnectCount();<z>
FixedIntervalReconnectStrategy(5000));<z>
(this.taskScheduler != null) {<z>
, 5000);<z>
String, Object> hints) {<z>
) -> {<z>
(message);<z>
(boundary == null) {<z>
DecodingException("No multipart boundary found in Content-Type: \"" +<z>
;<z>
,<z>
.headersCharset);<z>
maxDiskUsagePerPart,<z>
.directory(), this.blockingOperationScheduler);<z>
;<z>
allowEagerInit)<z>
throws BeansException {<z>
(type, includeNonSingletons, allowEagerInit);<z>
getWriterToUse() {<z>
.getOut() : this.writer);<z>
null, "No Writer available");<z>
;<z>
public void validateRequiredProperties() {<z>
= new MissingRequiredPropertiesException();<z>
{<z>
.getProperty(key) == null) {<z>
;<z>
) {<z>
;<z>
MediaType contentType) {<z>
) {<z>
DEFAULT_FORM_DATA_MEDIA_TYPE;<z>
() == null) {<z>
;<z>
return contentType;<z>
@Nullable WebBindingInitializer initializer,<z>
binderMethods) {<z>
);<z>
= binderMethods;<z>
= new BindingContext(initializer);<z>
public void stop() throws JmsException {<z>
);<z>
catch (JMSException ex) {<z>
);<z>
<T> action) throws TransactionException {<z>
this.transactionManager != null, "No PlatformTransactionManager set");<z>
{<z>
, action);<z>
this.transactionManager.getTransaction(this);<z>
T result;<z>
.doInTransaction(status);<z>
RuntimeException | Error ex) {<z>
status, ex);<z>
ex;<z>
catch (Throwable ex) {<z>
(status, ex);<z>
(ex, "TransactionCallback threw undeclared checked exception");<z>
.transactionManager.commit(status);<z>
return result;<z>
ServletRequestBindingException {<z>
);<z>
length];<z>
< values.length; i++) {<z>
);<z>
return parameters;<z>
{<z>
super.hashCode();<z>
.targetRequestPath);<z>
);<z>
result;<z>
loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {<z>
);<z>
if (logger.isTraceEnabled()) {<z>
);<z>
.resourcesCurrentlyBeingLoaded.get();<z>
(encodedResource)) {<z>
throw new BeanDefinitionStoreException(<z>
;<z>
).getInputStream()) {<z>
(inputStream);<z>
null) {<z>
));<z>
));<z>
) {<z>
(<z>
ex);<z>
.remove(encodedResource);<z>
)) {<z>
.remove();<z>
{<z>
;<z>
{<z>
{<z>
.schemaMappings;<z>
null) {<z>
logger.isTraceEnabled()) {<z>
schemaMappingsLocation + "]");<z>
=<z>
(this.schemaMappingsLocation, this.classLoader);<z>
if (logger.isTraceEnabled()) {<z>
.trace("Loaded schema mappings: " + mappings);<z>
size());<z>
(mappings, schemaMappings);<z>
schemaMappings = schemaMappings;<z>
ex) {<z>
(<z>
schemaMappingsLocation + "]", ex);<z>
schemaMappings;<z>
void validateValueIfApplicable(WebDataBinder binder, MethodParameter parameter,<z>
) {<z>
) {<z>
);<z>
validationHints != null) {<z>
validator : binder.getValidators()) {<z>
) {<z>
fieldName, value,<z>
, validationHints);<z>
{<z>
ps) {<z>
synchronized (ps) {<z>
) + "; nested PropertyAccessException details (" +<z>
") are:");<z>
.length; i++) {<z>
) + ":");<z>
ps);<z>
boolean forceMultiple() throws JspException {<z>
= getBindStatus();<z>
;<z>
{<z>
return true;<z>
!= null) {<z>
;<z>
.getClass())) {<z>
;<z>
return false;<z>
BeanWrapper autowireConstructor(<z>
ctors, @Nullable Object[] explicitArgs) {<z>
, ctors, explicitArgs);<z>
) {<z>
System.currentTimeMillis();<z>
.values()) {<z>
updateClientSendMessageCount(now);<z>
int opcode) {<z>
IALOAD || opcode == Opcodes.IASTORE) {<z>
sort) {<z>
:<z>
case BYTE:<z>
.IALOAD);<z>
:<z>
IALOAD);<z>
:<z>
IALOAD);<z>
case INT:<z>
opcode;<z>
case FLOAT:<z>
Opcodes.IALOAD);<z>
case LONG:<z>
LALOAD - Opcodes.IALOAD);<z>
:<z>
);<z>
case ARRAY:<z>
case OBJECT:<z>
case INTERNAL:<z>
(Opcodes.AALOAD - Opcodes.IALOAD);<z>
METHOD:<z>
:<z>
();<z>
new AssertionError();<z>
else {<z>
) {<z>
case VOID:<z>
!= Opcodes.IRETURN) {<z>
();<z>
return Opcodes.RETURN;<z>
BOOLEAN:<z>
:<z>
:<z>
SHORT:<z>
case INT:<z>
opcode;<z>
case FLOAT:<z>
(Opcodes.FRETURN - Opcodes.IRETURN);<z>
:<z>
(Opcodes.LRETURN - Opcodes.IRETURN);<z>
DOUBLE:<z>
- Opcodes.IRETURN);<z>
ARRAY:<z>
case OBJECT:<z>
INTERNAL:<z>
{<z>
UnsupportedOperationException();<z>
;<z>
case METHOD:<z>
new UnsupportedOperationException();<z>
);<z>
clazz) throws CodecException {<z>
-> {<z>
;<z>
{<z>
CodecException(<z>
getMessage(), ex);<z>
);<z>
ScopeMetadata resolveScopeMetadata(BeanDefinition definition) {<z>
metadata = new ScopeMetadata();<z>
annDef) {<z>
attributes = AnnotationConfigUtils.attributesFor(<z>
.getMetadata(), this.scopeAnnotationType);<z>
attributes != null) {<z>
));<z>
ScopedProxyMode proxyMode = attributes.getEnum("proxyMode");<z>
{<z>
proxyMode = this.defaultProxyMode;<z>
);<z>
return metadata;<z>
getSimpleTypeConverter() {<z>
{<z>
SimpleTypeConverter();<z>
) {<z>
setConversionService(this.conversionService);<z>
return this.typeConverter;<z>
, Object testInstance, Statement next) {<z>
null;<z>
;<z>
= getJUnitTimeout(frameworkMethod);<z>
> 0 && junitTimeout > 0) {<z>
String.format("Test method [%s] has been configured with Spring's @Timed(millis=%s) and " +<z>
springTimeout, junitTimeout);<z>
;<z>
new IllegalStateException(msg);<z>
else if (springTimeout > 0) {<z>
next, springTimeout);<z>
(junitTimeout > 0) {<z>
.MILLISECONDS).build(next);<z>
next;<z>
statement;<z>
{<z>
);<z>
) {<z>
;<z>
= pathHelper.getRequestUri(request);<z>
UrlPathHelper.getResolvedLookupPath(request);<z>
.indexOf(lookupPath);<z>
{<z>
curr;<z>
this.triggerContextMonitor) {<z>
curr = obtainCurrentFuture();<z>
get();<z>
createProxy(<z>
ClassLoader cl,<z>
@Nullable PersistenceExceptionTranslator exceptionTranslator, @Nullable Boolean jta,<z>
) {<z>
;<z>
?>[] interfaces;<z>
{<z>
key -> {<z>
class.equals(key)) {<z>
?>[] {key};<z>
.class};<z>
;<z>
getClass(), key -> {<z>
key, cl));<z>
.class);<z>
ClassUtils.toClassArray(ifcs);<z>
);<z>
newProxyInstance(<z>
),<z>
ExtendedEntityManagerInvocationHandler(<z>
, containerManaged, synchronizedWithTransaction));<z>
(String arraytype) {<z>
arraytype.charAt(0)) {<z>
'I': return T_INT;<z>
return T_LONG;<z>
;<z>
T_DOUBLE;<z>
return T_BYTE;<z>
T_CHAR;<z>
case 'S': return T_SHORT;<z>
;<z>
);<z>
String expected) {<z>
name).getPath();<z>
) -> {<z>
" path";<z>
;<z>
});<z>
;<z>
{<z>
<>();<z>
this.source.specs()) {<z>
);<z>
{<z>
add(lastOption);<z>
.toStringArray(names);<z>
{<z>
).size();<z>
);<z>
;<z>
url) {<z>
(method, "HTTP method is required. " +<z>
);<z>
return new DefaultBodyBuilder(method, url);<z>
void enlarge(final int size) {<z>
{<z>
);<z>
data.length;<z>
;<z>
minimalCapacity];<z>
, 0, newData, 0, length);<z>
;<z>
matchers) {<z>
{<z>
.getHeaders(), matchers.length);<z>
;<z>
null, "No header values");<z>
{<z>
), matchers[i]);<z>
, TypeDescriptor targetType) {<z>
(source == null) {<z>
);<z>
this.converter.convert(source);<z>
> extractMapFromMessage(MapMessage message) throws JMSException {<z>
HashMap<>();<z>
en = message.getMapNames();<z>
{<z>
en.nextElement();<z>
, message.getObject(key));<z>
;<z>
{<z>
();<z>
null) {<z>
return null;<z>
isNumericRelationalOperator()) {<z>
return t;<z>
t.isIdentifier()) {<z>
= t.stringValue();<z>
("instanceof")) {<z>
asInstanceOfToken();<z>
equalsIgnoreCase("matches")) {<z>
t.asMatchesToken();<z>
if (idString.equalsIgnoreCase("between")) {<z>
asBetweenToken();<z>
return null;<z>
"' is neither an array nor a List nor a Map; returned value was [" + propValue + "]");<z>
BindMarker bind(Object value) {<z>
;<z>
();<z>
value));<z>
return marker;<z>
, String> parseQueryParams(URI uri) {<z>
<>();<z>
();<z>
null) {<z>
);<z>
matcher.find()) {<z>
1), StandardCharsets.UTF_8);<z>
group(2);<z>
;<z>
value != null) {<z>
.decode(value, StandardCharsets.UTF_8);<z>
eq) ? "" : null);<z>
);<z>
return queryParams;<z>
Throwable {<z>
{<z>
(method)) {<z>
proxyToString(proxy);<z>
(ReflectionUtils.isEqualsMethod(method)) {<z>
0]);<z>
if (ReflectionUtils.isHashCodeMethod(method)) {<z>
(proxy);<z>
) {<z>
case "unwrap":<z>
this.connection;<z>
"close":<z>
(this.connection, this.targetConnectionFactory)<z>
this.closed = true);<z>
"isClosed":<z>
closed;<z>
{<z>
("Connection handle already closed");<z>
);<z>
) {<z>
;<z>
ApplicationContext parent) {<z>
<?> contextClass = getContextClass();<z>
ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {<z>
new ApplicationContextException(<z>
getServletName() +<z>
.getName() +<z>
);<z>
=<z>
) BeanUtils.instantiateClass(contextClass);<z>
);<z>
.setParent(parent);<z>
();<z>
!= null) {<z>
setConfigLocation(configLocation);<z>
wac);<z>
wac;<z>
{<z>
requiredType, args, nonUniqueAsNull);<z>
namedBean != null) {<z>
.getBeanInstance();<z>
BeanFactory parent = getParentBeanFactory();<z>
{<z>
);<z>
parent != null) {<z>
;<z>
if (args != null) {<z>
);<z>
.getIfAvailable());<z>
;<z>
void evaluate() throws Throwable {<z>
testMethod == null) {<z>
{<z>
class);<z>
new AssumptionViolatedException(String.format(<z>
;<z>
this.testMethod, this.testClass)) {<z>
AssumptionViolatedException(String.format(<z>
.testMethod));<z>
.evaluate();<z>
{<z>
Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod();<z>
) &&<z>
currentlyInvoked.getParameterTypes()));<z>
void onComplete() {<z>
1 || this.multiValueSource) {<z>
);<z>
== 1) {<z>
.get(0));<z>
);<z>
static Float getFloatParameter(ServletRequest request, String name)<z>
ServletRequestBindingException {<z>
request.getParameter(name) == null) {<z>
return null;<z>
return getRequiredFloatParameter(request, name);<z>
{<z>
beanDefinition.hashCode();<z>
;<z>
.aliases);<z>
return hashCode;<z>
?> message, long timeout) {<z>
, "MessageChannel is required");<z>
Message<?> messageToSend = message;<z>
getAccessor(message, MessageHeaderAccessor.class);<z>
accessor.isMutable()) {<z>
sendTimeoutHeader);<z>
receiveTimeoutHeader);<z>
;<z>
.containsKey(this.sendTimeoutHeader)<z>
this.receiveTimeoutHeader)) {<z>
fromMessage(message)<z>
, null)<z>
setHeader(this.receiveTimeoutHeader, null)<z>
build();<z>
: channel.send(messageToSend));<z>
!sent) {<z>
new MessageDeliveryException(message,<z>
"Failed to send message to channel '" + channel + "' within timeout: " + timeout);<z>
, @Nullable A annotation, ValueExtractor valueExtractor) {<z>
;<z>
Object lastValue = null;<z>
; i++) {<z>
(this.indexes[i]);<z>
(attribute, annotation);<z>
null ||<z>
(attribute, value, valueExtractor));<z>
ObjectUtils.nullSafeEquals(lastValue, value)) {<z>
if (result == -1) {<z>
this.indexes[i];<z>
, value)) {<z>
source : "";<z>
(<z>
getName(), on,<z>
),<z>
.getName(),<z>
(lastValue),<z>
;<z>
result = this.indexes[i];<z>
lastValue = value;<z>
result;<z>
int startPos, int endPos) {<z>
endPos);<z>
.nullSafe = nullSafe;<z>
= propertyOrFieldName;<z>
(String value, DefaultSeparator separator) {<z>
()) ?<z>
.value()) : value;<z>
valueToMatch);<z>
Integer> fields) {<z>
field : fields) {<z>
? 1 : 0);<z>
returnValue, MethodParameter returnType,<z>
webRequest) throws Exception {<z>
{<z>
view);<z>
.isRedirectView()) {<z>
true);<z>
{<z>
throw new UnsupportedOperationException("Unexpected return type: " +<z>
));<z>
trigger) {<z>
);<z>
errorHandler;<z>
errorHandler == null) {<z>
= TaskUtils.getDefaultErrorHandler(true);<z>
.schedule();<z>
(RejectedExecutionException ex) {<z>
;<z>
directory) {<z>
, null, ".multipart");<z>
)) {<z>
tempFile);<z>
WRITE);<z>
this, tempFile, channel);<z>
catch (IOException ex) {<z>
+ directory, ex);<z>
, String dependentBeanName) {<z>
synchronized (this.dependentBeanMap) {<z>
;<z>
{<z>
if (blahBuilder_ == null) {<z>
return blah_;<z>
else {<z>
blahBuilder_.getMessage();<z>
String localName, Object value) throws JspException {<z>
== null) {<z>
= new HashMap<>();<z>
(!isValidDynamicAttribute(localName, value)) {<z>
(<z>
localName + "=\"" + value + "\" is not allowed");<z>
localName, value);<z>
boolean close)<z>
{<z>
null) {<z>
IOException("Class not found");<z>
;<z>
= new ByteArrayOutputStream()) {<z>
= new byte[bufferSize];<z>
;<z>
0;<z>
) {<z>
bytesRead);<z>
;<z>
outputStream.flush();<z>
readCount == 1) {<z>
;<z>
{<z>
close) {<z>
();<z>
throws BeansException {<z>
new GenericBeanDefinition();<z>
clazz);<z>
(pvs);<z>
().registerBeanDefinition(name, bd);<z>
{<z>
.name = name;<z>
this.sqlType = sqlType;<z>
;<z>
> params) {<z>
charset = StandardCharsets.UTF_8;<z>
params.size());<z>
)) {<z>
{<z>
encodeQueryParam(value, charset));<z>
return result;<z>
getUser(String userName) {<z>
this.remoteRegistries.values()) {<z>
().get(userName);<z>
null) {<z>
return user;<z>
);<z>
other) {<z>
String name = combineNames(other);<z>
PathPatternsRequestCondition pathPatterns =<z>
null && other.pathPatternsCondition != null ?<z>
other.pathPatternsCondition) : null);<z>
PatternsRequestCondition patterns =<z>
&& other.patternsCondition != null ?<z>
null);<z>
methodsCondition);<z>
);<z>
;<z>
consumesCondition);<z>
combine(other.producesCondition);<z>
customConditionHolder.combine(other.customConditionHolder);<z>
new RequestMappingInfo(name, pathPatterns, patterns,<z>
this.options);<z>
String resolvePlaceholders(<z>
boolean ignoreUnresolvablePlaceholders) {<z>
) {<z>
return text;<z>
: strictHelper);<z>
text, servletContext));<z>
ResourceResolver resolver) {<z>
);<z>
;<z>
) {<z>
;<z>
if (resolver instanceof PathResourceResolver) {<z>
.hasPathResolver = true;<z>
WebJarsResourceResolver) {<z>
true;<z>
;<z>
protected Object invoke(<z>
invoker) {<z>
context.getOperation();<z>
context);<z>
Cache cache = resolveCache(context);<z>
resolveExceptionCache(context);<z>
(!operation.isAlwaysInvoked()) {<z>
doGet(cache, cacheKey);<z>
null) {<z>
);<z>
cacheKey);<z>
.invoke();<z>
, cacheKey, invocationResult);<z>
return invocationResult;<z>
ThrowableWrapper ex) {<z>
);<z>
.getExceptionTypeFilter(), cacheKey, original);<z>
throw ex;<z>
() {<z>
size = 0;<z>
fill(this.indexes, -1);<z>
; i++) {<z>
.assigned[i] == this) {<z>
i;<z>
this.size++;<z>
{<z>
;<z>
methodReplacerBeanName, "Method replacer bean name must not be null");<z>
;<z>
, String key, String value)<z>
MalformedObjectNameException {<z>
key, value);<z>
(BeanReference adviceReference, BeanReference pointcutReference) {<z>
"Advisor <advice(ref)='" +<z>
getBeanName() + "', pointcut(ref)='" +<z>
) + "'>";<z>
MediaType> supportedMediaTypes) {<z>
;<z>
supportedMediaTypes = new ArrayList<>(supportedMediaTypes);<z>
String canonicalName(String name) {<z>
String canonicalName = name;<z>
String resolvedName;<z>
;<z>
{<z>
= resolvedName;<z>
;<z>
return canonicalName;<z>
>> messageWriters,<z>
contentTypeResolver) {<z>
, ReactiveAdapterRegistry.getSharedInstance());<z>
) {<z>
return super.getInstalledExtensions(container);<z>
) {<z>
;<z>
{<z>
headers.get(JmsHeaders.CORRELATION_ID);<z>
(jmsCorrelationId instanceof Number) {<z>
toString();<z>
jmsCorrelationId instanceof String) {<z>
jmsMessage.setJMSCorrelationID((String) jmsCorrelationId);<z>
catch (Exception ex) {<z>
ex);<z>
JmsHeaders.REPLY_TO, Destination.class);<z>
null) {<z>
jmsMessage.setJMSReplyTo(jmsReplyTo);<z>
Exception ex) {<z>
.debug("Failed to set JMSReplyTo - skipping", ex);<z>
String.class);<z>
) {<z>
);<z>
ex) {<z>
, ex);<z>
)) {<z>
();<z>
.PREFIX)) {<z>
value = entry.getValue();<z>
.getClass())) {<z>
propertyName = this.fromHeaderName(headerName);<z>
(propertyName, value);<z>
) {<z>
(headerName.startsWith("JMSX")) {<z>
(logger.isTraceEnabled()) {<z>
trace("Skipping reserved header '" + headerName +<z>
);<z>
)) {<z>
("Failed to map message header '" + headerName + "' to JMS property", ex);<z>
(Exception ex) {<z>
isDebugEnabled()) {<z>
debug("Error occurred while mapping from MessageHeaders to JMS properties", ex);<z>
() {<z>
);<z>
) {<z>
.changeSessionId();<z>
session.getId();<z>
DeferredResultProcessingInterceptor... interceptors) {<z>
.notNull(interceptors, "A DeferredResultProcessingInterceptor is required");<z>
for (DeferredResultProcessingInterceptor interceptor : interceptors) {<z>
);<z>
, interceptor);<z>
serverCodecConfigurer) {<z>
();<z>
1);<z>
;<z>
());<z>
return mapping;<z>
{<z>
toFlux(typeReference));<z>
UnsupportedMediaTypeException.class, ERROR_MAPPER)<z>
(DecodingException.class, DECODING_MAPPER);<z>
<A> of(<z>
, @Nullable Object source,<z>
) {<z>
.notNull(annotationType, "Annotation type must not be null");<z>
AnnotationTypeMappings.forAnnotationType(annotationType);<z>
new TypeMappedAnnotation<>(<z>
);<z>
{<z>
destination;<z>
)) {<z>
(true);<z>
(@Nullable Set<String> modelKeys) {<z>
();<z>
if (modelKeys != null) {<z>
.addAll(modelKeys);<z>
props, Resource resource) throws IOException {<z>
getInputStream()) {<z>
String filename = resource.getFilename();<z>
)) {<z>
shouldIgnoreXml) {<z>
throw new UnsupportedOperationException("XML support disabled");<z>
;<z>
.load(is);<z>
ParserContext parserContext) {<z>
BASE_PACKAGE_ATTRIBUTE);<z>
).resolvePlaceholders(basePackage);<z>
[] basePackages = StringUtils.tokenizeToStringArray(basePackage,<z>
ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);<z>
);<z>
doScan(basePackages);<z>
;<z>
return null;<z>
) {<z>
) * (getPage() + 1);<z>
();<z>
? size : endIndex) - 1;<z>
protected HierarchicalUriComponents expandInternal(UriTemplateVariables uriVariables) {<z>
.encodeState.equals(EncodeState.FULLY_ENCODED),<z>
);<z>
uriVariables, this.variableEncoder);<z>
.userInfo, uriVariables, this.variableEncoder);<z>
);<z>
.variableEncoder);<z>
;<z>
String> queryParamsTo = expandQueryParams(uriVariables);<z>
(), uriVariables, this.variableEncoder);<z>
, fragmentTo, userInfoTo,<z>
.variableEncoder);<z>
ModelMBeanNotificationInfo[] extractNotificationMetadata(Object mapValue) {<z>
if (mapValue instanceof ManagedNotification mn) {<z>
(mn)};<z>
mapValue instanceof Collection) {<z>
mapValue;<z>
();<z>
{<z>
)) {<z>
IllegalArgumentException(<z>
;<z>
);<z>
ModelMBeanNotificationInfo[0]);<z>
IllegalArgumentException(<z>
"Property 'notificationInfoMappings' only accepts ManagedNotifications for Map values");<z>
Object bean, String beanName) {<z>
tasks;<z>
{<z>
(bean);<z>
tasks != null) {<z>
task : tasks) {<z>
();<z>
GroovyBeanDefinitionWrapper beanDefinition, String name, Object value) {<z>
this.beanDefinition = beanDefinition;<z>
= name;<z>
value = value;<z>
) {<z>
.node = node;<z>
(node instanceof Document) {<z>
Document) node;<z>
();<z>
() {<z>
;<z>
.characterEntityReferences.convertToCharacter(referenceName);<z>
CHAR_NULL) {<z>
;<z>
return true;<z>
return false;<z>
public ComposablePointcut intersection(Pointcut other) {<z>
));<z>
, other.getMethodMatcher());<z>
return this;<z>
final void visitInnerClass(<z>
int access) {<z>
) {<z>
innerClasses = new ByteVector();<z>
name);<z>
{<z>
++numberOfInnerClasses;<z>
index);<z>
).index);<z>
0 : symbolTable.addConstantUtf8(innerName));<z>
.putShort(access);<z>
= numberOfInnerClasses;<z>
throws IOException {<z>
asByteBuffer();<z>
{<z>
);<z>
(), StandardCharsets.UTF_8);<z>
(message.getPayload()));<z>
getType())) {<z>
setReadyToSend(false);<z>
()));<z>
message.getType())) {<z>
false);<z>
));<z>
))) {<z>
false);<z>
.getPayload()));<z>
;<z>
return true;<z>
) throws DataAccessException {<z>
"SQL must not be null");<z>
if (logger.isDebugEnabled()) {<z>
.debug("Executing SQL update [" + sql + "]");<z>
StatementCallback<Integer>, SqlProvider {<z>
stmt) throws SQLException {<z>
;<z>
)) {<z>
.trace("SQL update affected " + rows + " rows");<z>
return rows;<z>
String getSql() {<z>
return sql;<z>
));<z>
Method method) {<z>
{<z>
handlerMethod = getHandlerMethod(result);<z>
));<z>
Source source) {<z>
if (source instanceof StAXSource) {<z>
).getXMLStreamReader();<z>
(source instanceof StaxSource) {<z>
).getXMLStreamReader();<z>
+ "' is neither StaxSource nor StAXSource");<z>
?>> getWriters() {<z>
applyDefaultConfig(this.customCodecs);<z>
);<z>
().keySet());<z>
.getTypedWriters());<z>
().keySet());<z>
);<z>
(this.defaultCodecs.getCatchAllWriters());<z>
result;<z>
supportsReturnType(MethodParameter returnType) {<z>
type = returnType.getParameterType();<z>
.isAssignableFrom(type) ||<z>
(type) ||<z>
CompletionStage.class.isAssignableFrom(type));<z>
Class<?> requiredType) {<z>
null;<z>
) {<z>
propertyEditorRegistry.getDefaultEditor(requiredType);<z>
) {<z>
findEditorByConvention(requiredType);<z>
editor;<z>
protected void checkCompiled() {<z>
) {<z>
debug("SQL operation not compiled before execution - invoking compile");<z>
compile();<z>
(@Nullable Statement stmt) {<z>
null) {<z>
.close();<z>
ex) {<z>
, ex);<z>
(Throwable ex) {<z>
);<z>
JCacheOperationSource cacheOperationSource, CacheKeyGenerator target) {<z>
;<z>
, "CacheKeyGenerator must not be null");<z>
;<z>
target;<z>
Object leftOperand, @Nullable Object rightOperand)<z>
EvaluationException {<z>
false;<z>
> loggers, Predicate<Log> predicate) {<z>
(Log logger : loggers) {<z>
logger)) {<z>
;<z>
return NO_OP_LOG;<z>
Object o2) {<z>
o2 instanceof Object[]) {<z>
);<z>
&& o2 instanceof boolean[]) {<z>
;<z>
instanceof byte[]) {<z>
) o2);<z>
) {<z>
o1, (char[]) o2);<z>
o2 instanceof double[]) {<z>
, (double[]) o2);<z>
] && o2 instanceof float[]) {<z>
o1, (float[]) o2);<z>
[]) {<z>
[]) o2);<z>
{<z>
(long[]) o2);<z>
) {<z>
]) o2);<z>
;<z>
message, String name) {<z>
(name);<z>
getNativeHeaderValue(message, name);<z>
nativeHeaderValue != null) {<z>
) {<z>
("A value was found for '" + name + "', in both the top level header map " +<z>
;<z>
: nativeHeaderValue);<z>
) {<z>
.afterPropertiesSet();<z>
ex) {<z>
("Failed to set up a Bean Validation provider", ex);<z>
,<z>
HttpRequest request) {<z>
, charset,<z>
;<z>
ResultMatcher forwardedUrlPattern(String urlPattern) {<z>
{<z>
("'" + urlPattern + "' is not an Ant-style path pattern",<z>
(urlPattern));<z>
getForwardedUrl();<z>
+ url + "' does not match the expected URL pattern '" + urlPattern + "'",<z>
.match(urlPattern, url)));<z>
patterns) {<z>
<>(patterns.size());<z>
: patterns) {<z>
add(Pattern.compile(patternText));<z>
Supplier<String> messageSupplier) {<z>
(superType, "Super type to check against must not be null");<z>
subType)) {<z>
superType, subType, nullSafeGet(messageSupplier));<z>
headers) {<z>
headers == null) {<z>
);<z>
RecordComponentVisitor visitRecordComponent(<z>
signature) {<z>
.ASM8) {<z>
"Record requires ASM8");<z>
if (cv != null) {<z>
, descriptor, signature);<z>
null;<z>
putAttributes(<z>
final SymbolTable symbolTable,<z>
byte[] code,<z>
,<z>
maxStack,<z>
int maxLocals,<z>
) {<z>
classWriter = symbolTable.classWriter;<z>
this;<z>
(attribute != null) {<z>
attributeContent =<z>
);<z>
(attributeContent.length);<z>
attributeContent.length);<z>
attribute.nextAttribute;<z>
> returnValueHandlers) {<z>
== null) {<z>
;<z>
();<z>
(returnValueHandlers);<z>
,<z>
{<z>
0; i--) {<z>
);<z>
Throwable ex) {<z>
ex;<z>
return concurrentResult;<z>
createJacksonConverter() {<z>
= new DefaultContentTypeResolver();<z>
setDefaultMimeType(MimeTypeUtils.APPLICATION_JSON);<z>
;<z>
.setContentTypeResolver(resolver);<z>
;<z>
eatProductExpression() {<z>
eatPowerIncDecExpression();<z>
)) {<z>
= takeToken();<z>
);<z>
t, expr, rhExpr);<z>
(t.kind == TokenKind.STAR) {<z>
endPos, expr, rhExpr);<z>
== TokenKind.DIV) {<z>
.endPos, expr, rhExpr);<z>
, "Mod token expected");<z>
t.endPos, expr, rhExpr);<z>
return expr;<z>
, Duration expected) {<z>
(name).getMaxAge();<z>
{<z>
= getMessage(name) + " maxAge";<z>
(message, expected, maxAge);<z>
;<z>
;<z>
requestConsumer) {<z>
?<z>
andThen(requestConsumer) : requestConsumer);<z>
;<z>
{<z>
getSingletonMutex()) {<z>
.clearSingletonCache();<z>
);<z>
(TransactionAnnotationParser... annotationParsers) {<z>
this.publicMethodsOnly = true;<z>
;<z>
>(Arrays.asList(annotationParsers));<z>
(Runnable task) {<z>
;<z>
(future, TIMEOUT_INDEFINITE);<z>
future;<z>
T> completableFuture) {<z>
= completableFuture;<z>
.whenComplete((result, ex) -> {<z>
) {<z>
this.callbacks.failure(ex);<z>
(result);<z>
});<z>
protected SimpleUrlHandlerMapping buildHandlerMapping() {<z>
)) {<z>
;<z>
urlMap = new LinkedHashMap<>();<z>
: this.registrations) {<z>
), registration.getViewController());<z>
: this.redirectRegistrations) {<z>
), registration.getViewController());<z>
SimpleUrlHandlerMapping(urlMap, this.order);<z>
@Nullable ModelAndViewContainer mavContainer,<z>
throws Exception {<z>
, "ModelAndViewContainer is required for session status exposure");<z>
mavContainer.getSessionStatus();<z>
() {<z>
new ParameterContentTypeResolver(this.mediaTypes);<z>
{<z>
.parameterName);<z>
return resolver;<z>
Runnable task, long period) {<z>
, period, TimeUnit.MILLISECONDS);<z>
catch (RejectedExecutionException ex) {<z>
);<z>
Object criteria, int aggregateIndex,<z>
{<z>
;<z>
null;<z>
<SpringPersistenceUnitInfo> readPersistenceUnitInfos() {<z>
;<z>
.defaultPersistenceUnitName;<z>
null || this.mappingResources != null);<z>
false;<z>
this.resourcePatternResolver, this.dataSourceLookup);<z>
reader.readPersistenceUnitInfos(this.persistenceXmlLocations);<z>
{<z>
add(readInfo);<z>
))) {<z>
foundDefaultUnit = true;<z>
{<z>
) {<z>
isWarnEnabled()) {<z>
logger.warn("Found explicit default persistence unit with name '" + defaultName + "' in persistence.xml - " +<z>
;<z>
.add(buildDefaultPersistenceUnitInfo());<z>
;<z>
(Connection connection, ConnectionFactory targetConnectionFactory) {<z>
(TransactionAwareConnectionFactoryProxy.class.getClassLoader(),<z>
.class},<z>
targetConnectionFactory));<z>
resume() {<z>
if (this.holderActive) {<z>
.resourceHolder);<z>
) {<z>
facade) {<z>
facade;<z>
if (response instanceof HttpServletResponseWrapper wrapper) {<z>
;<z>
return getResponseFacade(wrappedResponse);<z>
() +<z>
;<z>
, EntityResolver schemaResolver) {<z>
;<z>
);<z>
this.dtdResolver = dtdResolver;<z>
schemaResolver;<z>
) {<z>
);<z>
null) {<z>
return unwrapped;<z>
);<z>
(SubscribableChannel clientInboundChannel,<z>
) {<z>
);<z>
(<z>
boolean classValuesAsString, boolean nestedAnnotationsAsMap) {<z>
annotation, classValuesAsString, nestedAnnotationsAsMap);<z>
name) {<z>
propertySourceList) {<z>
;<z>
index) : null);<z>
> environment) {<z>
{<z>
INITIAL_CONTEXT_FACTORY);<z>
if (icf != null) {<z>
Class<?> icfClass;<z>
instanceof Class) {<z>
(Class<?>) icf;<z>
) {<z>
).getClassLoader());<z>
IllegalArgumentException("Invalid value type for environment key [" +<z>
).getName());<z>
class.isAssignableFrom(icfClass)) {<z>
new IllegalArgumentException(<z>
) + "]: " + icf);<z>
(icfClass).newInstance();<z>
{<z>
icf, ex);<z>
String, Object>) env);<z>
parserContext) {<z>
;<z>
> processorDefinitions =<z>
parserContext.getRegistry(), source);<z>
), source);<z>
);<z>
for (BeanDefinitionHolder processorDefinition : processorDefinitions) {<z>
));<z>
.popAndRegisterContainingComponent();<z>
null;<z>
throws IOException {<z>
.connections) {<z>
.matches(request)) {<z>
).getResponse(request);<z>
this.defaultConnection.getResponse(request);<z>
List<String> codings) {<z>
notEmpty(codings, "At least one content coding expected");<z>
;<z>
;<z>
ClassLoader getNewTempClassLoader() {<z>
? this.loadTimeWeaver.getThrowawayClassLoader() :<z>
classLoader));<z>
= getPersistenceProviderPackageName();<z>
{<z>
tcl).excludePackage(packageToExclude);<z>
tcl;<z>
<? extends Annotation> annotationType) {<z>
,<z>
;<z>
);<z>
<?> testClass) {<z>
notNull(testClass, "Class must not be null");<z>
.class;<z>
contextHierarchyType = ContextHierarchy.class;<z>
<>();<z>
desc =<z>
testClass, contextConfigType, contextHierarchyType);<z>
(desc, () -> String.format(<z>
), testClass.getName()));<z>
!= null) {<z>
?> rootDeclaringClass = desc.getRootDeclaringClass();<z>
;<z>
(contextConfigType, declaringClass);<z>
declaringClass);<z>
&& contextHierarchyDeclaredLocally) {<z>
+<z>
);<z>
logger.error(msg);<z>
);<z>
;<z>
) {<z>
desc.getAnnotation();<z>
, rootDeclaringClass, configAttributesList);<z>
contextHierarchyDeclaredLocally) {<z>
getAnnotation(declaringClass, contextHierarchyType);<z>
{<z>
ContextConfiguration contextConfiguration : contextHierarchy.value()) {<z>
rootDeclaringClass, configAttributesList);<z>
String msg = String.format("Test class [%s] has been configured with neither @ContextConfiguration " +<z>
));<z>
.error(msg);<z>
msg);<z>
0, configAttributesList);<z>
.next();<z>
hierarchyAttributes;<z>
methodInvocation,<z>
Throwable throwable, long invocationTime) {<z>
PATTERN.matcher(message);<z>
.getThis();<z>
state(target != null, "Target must not be null");<z>
new StringBuffer();<z>
(matcher.find()) {<z>
;<z>
{<z>
;<z>
equals(match)) {<z>
getName();<z>
));<z>
) {<z>
target));<z>
, Matcher.quoteReplacement(shortName));<z>
if (PLACEHOLDER_ARGUMENTS.equals(match)) {<z>
output,<z>
getArguments())));<z>
.equals(match)) {<z>
, matcher, output);<z>
match)) {<z>
);<z>
.equals(match)) {<z>
()));<z>
if (PLACEHOLDER_INVOCATION_TIME.equals(match)) {<z>
toString(invocationTime));<z>
IllegalArgumentException("Unknown placeholder [" + match + "]");<z>
matcher.appendTail(output);<z>
();<z>
throws Exception {<z>
();<z>
) {<z>
throw new FactoryBeanNotInitializedException(<z>
getName() + " does not support circular references");<z>
.earlySingletonInstance == null) {<z>
= (T) Proxy.newProxyInstance(<z>
beanClassLoader, ifcs, new EarlySingletonInvocationHandler());<z>
this.earlySingletonInstance;<z>
{<z>
;<z>
, () -><z>
);<z>
-><z>
;<z>
0);<z>
<?> clazz, String methodName)<z>
throws IllegalArgumentException {<z>
(), methodName);<z>
{<z>
;<z>
;<z>
Void> writeWithMessageWriters(<z>
adapter) {<z>
Publisher<?> publisher;<z>
(body instanceof Publisher) {<z>
) body;<z>
if (adapter != null) {<z>
adapter.toPublisher(body);<z>
just(body);<z>
);<z>
stream()<z>
-> messageWriter.canWrite(bodyType, mediaType))<z>
()<z>
map(BodyInserters::cast)<z>
, mediaType, outputMessage, context, writer))<z>
);<z>
<T>> MultipartInserter fromMultipartAsyncData(<z>
P publisher, Class<T> elementClass) {<z>
publisher, elementClass);<z>
{<z>
classType.getName())) {<z>
.objectSourceClass;<z>
) {<z>
.validateAnnotation(ann);<z>
new SourceClass(classType);<z>
catch (Throwable ex) {<z>
(), filter);<z>
int hashCode() {<z>
));<z>
0);<z>
? 1 : 0);<z>
;<z>
{<z>
) {<z>
(this);<z>
.httpMethod, initUri())<z>
.addAll(initHeaders()))<z>
cookies.addAll(initCookies()))<z>
.attributes));<z>
null) {<z>
.httpRequest(this.httpRequestConsumer);<z>
;<z>
containerEle, Element listenerEle, ParserContext parserContext,<z>
specificContainerProperties) {<z>
= new RootBeanDefinition();<z>
(parserContext.extractSource(listenerEle));<z>
;<z>
.getAttribute(REF_ATTRIBUTE);<z>
!StringUtils.hasText(ref)) {<z>
getReaderContext().error(<z>
);<z>
(ref));<z>
(listenerEle.hasAttribute(METHOD_ATTRIBUTE)) {<z>
method = listenerEle.getAttribute(METHOD_ATTRIBUTE);<z>
{<z>
().error(<z>
, listenerEle);<z>
"defaultListenerMethod", method);<z>
getPropertyValue("messageConverter");<z>
null) {<z>
().addPropertyValue(messageConverterPv);<z>
createContainer(<z>
listenerEle, parserContext, commonContainerProperties, specificContainerProperties);<z>
listenerDef);<z>
RESPONSE_DESTINATION_ATTRIBUTE)) {<z>
(RESPONSE_DESTINATION_ATTRIBUTE);<z>
;<z>
) {<z>
pubSubDomain = false;<z>
(<z>
;<z>
.getPropertyValue("destinationResolver");<z>
{<z>
destinationResolver);<z>
ID_ATTRIBUTE);<z>
(containerBeanName)) {<z>
.getReaderContext().generateBeanName(containerDef);<z>
containerDef, containerBeanName));<z>
toStringAST() {<z>
;<z>
.toStringAST());<z>
i++) {<z>
()).append(' ');<z>
.toStringAST());<z>
')');<z>
);<z>
) {<z>
(handler) ||<z>
HandlerMethod handerMethod &&<z>
) != null);<z>
exchange) {<z>
;<z>
0) {<z>
return result;<z>
exchange);<z>
{<z>
;<z>
), exchange);<z>
0) {<z>
result;<z>
), exchange);<z>
!= 0) {<z>
;<z>
), exchange);<z>
0) {<z>
result;<z>
);<z>
result != 0) {<z>
return result;<z>
exchange);<z>
result != 0) {<z>
result;<z>
return 0;<z>
void visitLocalVariable(<z>
,<z>
,<z>
String signature,<z>
,<z>
end,<z>
index) {<z>
{<z>
) {<z>
();<z>
++localVariableTypeTableLength;<z>
putShort(start.bytecodeOffset)<z>
)<z>
)<z>
signature))<z>
.putShort(index);<z>
== null) {<z>
new ByteVector();<z>
localVariableTableLength;<z>
bytecodeOffset)<z>
putShort(end.bytecodeOffset - start.bytecodeOffset)<z>
))<z>
addConstantUtf8(descriptor))<z>
putShort(index);<z>
if (compute != COMPUTE_NOTHING) {<z>
charAt(0);<z>
);<z>
{<z>
maxLocals = currentMaxLocals;<z>
{<z>
)),<z>
.getName() + "' must be static");<z>
getParameterTypes();<z>
] == DynamicPropertyRegistry.class,<z>
() + "' must accept a single DynamicPropertyRegistry argument");<z>
request, HttpServletResponse response) {<z>
.SELECTED_CONTENT_TYPE);<z>
)) {<z>
());<z>
(getContentType());<z>
SAXException {<z>
StringBuilder("<!DOCTYPE ");<z>
(name);<z>
null) {<z>
.append(" PUBLIC \"");<z>
;<z>
;<z>
(" SYSTEM \"");<z>
systemId);<z>
.append("\">");<z>
;<z>
) {<z>
ex);<z>
, HandlerResult result) {<z>
);<z>
.getReturnTypeSource();<z>
exchange);<z>
, Class<T> type) {<z>
Object.class) {<z>
type;<z>
> attributeType = attribute.getReturnType();<z>
) {<z>
) MergedAnnotation.class;<z>
getComponentType().isAnnotation()) {<z>
.class;<z>
attributeType);<z>
Label label) {<z>
;<z>
baseOpcode =<z>
Constants.WIDE_JUMP_OPCODE_DELTA : opcode;<z>
boolean nextInsnIsJumpTarget = false;<z>
& Label.FLAG_RESOLVED) != 0<z>
{<z>
== Opcodes.GOTO) {<z>
GOTO_W);<z>
) {<z>
.putByte(Constants.JSR_W);<z>
{<z>
) - 1);<z>
putShort(8);<z>
.putByte(Constants.ASM_GOTO_W);<z>
hasAsmInstructions = true;<z>
= true;<z>
);<z>
else if (baseOpcode != opcode) {<z>
opcode);<z>
, true);<z>
{<z>
putByte(baseOpcode);<z>
);<z>
(currentBasicBlock != null) {<z>
nextBasicBlock = null;<z>
(compute == COMPUTE_ALL_FRAMES) {<z>
baseOpcode, 0, null, null);<z>
().flags |= Label.FLAG_JUMP_TARGET;<z>
Edge.JUMP, label);<z>
!= Opcodes.GOTO) {<z>
);<z>
{<z>
);<z>
{<z>
baseOpcode];<z>
{<z>
.JSR) {<z>
0) {<z>
FLAG_SUBROUTINE_START;<z>
true;<z>
Label.FLAG_SUBROUTINE_CALLER;<z>
, label);<z>
new Label();<z>
else {<z>
relativeStackSize += STACK_SIZE_DELTA[baseOpcode];<z>
);<z>
) {<z>
nextInsnIsJumpTarget) {<z>
FLAG_JUMP_TARGET;<z>
);<z>
{<z>
();<z>
void clear() {<z>
);<z>
null;<z>
null;<z>
, SQLException ex) {<z>
);<z>
) >= 2) {<z>
;<z>
logger.isDebugEnabled()) {<z>
+ sqlState + "'");<z>
(BAD_SQL_GRAMMAR_CODES.contains(classCode)) {<z>
null ? sql : ""), ex);<z>
(DATA_INTEGRITY_VIOLATION_CODES.contains(classCode)) {<z>
task, sql, ex), ex);<z>
classCode)) {<z>
sql, ex), ex);<z>
)) {<z>
task, sql, ex), ex);<z>
if (CONCURRENCY_FAILURE_CODES.contains(classCode)) {<z>
task, sql, ex), ex);<z>
().contains("Timeout")) {<z>
;<z>
return null;<z>
headerValue) {<z>
<>(1);<z>
headerValues.add(headerValue);<z>
headers.put(headerName, headerValues);<z>
String> getHeaders(String name) {<z>
name)) {<z>
Collections.emptyEnumeration();<z>
name);<z>
() {<z>
== 0) {<z>
throw new IllegalStateException("Label offset position has not been resolved yet");<z>
bytecodeOffset;<z>
RequestPredicate predicate) {<z>
.indent--;<z>
);<z>
this.builder.append("}\n");<z>
DataBuffer... buffers) {<z>
{<z>
(hasNettyDataBuffers(buffers)) {<z>
= new ByteBuf[buffers.length];<z>
{<z>
.getNativeBuffer();<z>
write(nativeBuffers);<z>
ByteBuffer[buffers.length];<z>
buffers.length; i++) {<z>
= buffers[i].asByteBuffer();<z>
write(byteBuffers);<z>
return this;<z>
{<z>
(SubscribeMapping.class) &&<z>
!returnType.hasMethodAnnotation(SendTo.class) &&<z>
.class));<z>
HttpServletResponse response)<z>
throws IOException {<z>
);<z>
sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);<z>
private SpelNodeImpl eatExpression() {<z>
= eatLogicalOrExpression();<z>
);<z>
t != null) {<z>
.ASSIGN) {<z>
null) {<z>
);<z>
;<z>
);<z>
expr, assignedValue);<z>
TokenKind.ELVIS) {<z>
== null) {<z>
2);<z>
;<z>
= eatExpression();<z>
null) {<z>
+ 1, t.endPos + 1);<z>
, valueIfNull);<z>
{<z>
== null) {<z>
t.endPos - 1);<z>
();<z>
eatExpression();<z>
);<z>
ifFalseExprValue = eatExpression();<z>
endPos, expr, ifTrueExprValue, ifFalseExprValue);<z>
expr;<z>
public static void registerBeanPostProcessors(<z>
beanFactory, AbstractApplicationContext applicationContext) {<z>
true, false);<z>
postProcessorNames.length;<z>
, beanProcessorTargetCount));<z>
>();<z>
= new ArrayList<>();<z>
();<z>
;<z>
for (String ppName : postProcessorNames) {<z>
class)) {<z>
ppName, BeanPostProcessor.class);<z>
add(pp);<z>
pp instanceof MergedBeanDefinitionPostProcessor) {<z>
);<z>
(ppName, Ordered.class)) {<z>
(ppName);<z>
add(ppName);<z>
(priorityOrderedPostProcessors, beanFactory);<z>
beanFactory, priorityOrderedPostProcessors);<z>
;<z>
for (String ppName : orderedPostProcessorNames) {<z>
;<z>
pp);<z>
MergedBeanDefinitionPostProcessor) {<z>
internalPostProcessors.add(pp);<z>
;<z>
;<z>
size());<z>
) {<z>
ppName, BeanPostProcessor.class);<z>
add(pp);<z>
instanceof MergedBeanDefinitionPostProcessor) {<z>
internalPostProcessors.add(pp);<z>
, nonOrderedPostProcessors);<z>
internalPostProcessors, beanFactory);<z>
beanFactory, internalPostProcessors);<z>
));<z>
String contextPath) {<z>
;<z>
{<z>
.startsWith("/"), "Context path must begin with '/'");<z>
.endsWith("/"), "Context path must not end with '/'");<z>
String, String> getParamsMultiValueMap(MockHttpServletRequest request) {<z>
();<z>
multiValueMap = new LinkedMultiValueMap<>();<z>
name, values) -> {<z>
{<z>
{<z>
.add(name, value);<z>
);<z>
multiValueMap;<z>
, ParserContext parserContext) {<z>
element);<z>
;<z>
(parserContext, source);<z>
class);<z>
);<z>
HttpStatus statusCode = null;<z>
(element.hasAttribute("status-code")) {<z>
"status-code"));<z>
);<z>
name = element.getLocalName();<z>
{<z>
case "view-controller":<z>
element.hasAttribute("view-name")) {<z>
element.getAttribute("view-name"));<z>
if (statusCode != null) {<z>
, statusCode);<z>
case "redirect-view-controller":<z>
;<z>
"status-controller":<z>
("statusCode", statusCode);<z>
add("statusOnly", true);<z>
new IllegalStateException("Unexpected tag name: " + name);<z>
.get("urlMap");<z>
== null) {<z>
= new ManagedMap<>();<z>
;<z>
.getAttribute("path"), controller);<z>
null;<z>
method, Object[] args) throws Throwable {<z>
(ReflectionUtils.isEqualsMethod(method)) {<z>
args[0]);<z>
{<z>
.identityHashCode(proxy);<z>
(ReflectionUtils.isToStringMethod(method)) {<z>
+ serviceLocatorInterface;<z>
invokeServiceLocatorMethod(method, args);<z>
action)<z>
JmsException {<z>
, "Callback object must not be null");<z>
-> {<z>
;<z>
session, browser);<z>
browser);<z>
, true);<z>
publishBrokerAvailableEvent() {<z>
brokerAvailable.compareAndSet(false, true);<z>
null && shouldPublish) {<z>
()) {<z>
info(this.availableEvent);<z>
);<z>
void doRegisterAfterCompletionWithJtaTransaction(<z>
txObject, List<TransactionSynchronization> synchronizations)<z>
throws RollbackException, SystemException {<z>
;<z>
(jtaStatus == Status.STATUS_NO_TRANSACTION) {<z>
;<z>
(jtaStatus == Status.STATUS_ROLLEDBACK) {<z>
new RollbackException("JTA transaction already rolled back (probably due to a timeout)");<z>
if (this.transactionSynchronizationRegistry != null) {<z>
.registerInterposedSynchronization(<z>
(synchronizations));<z>
if (getTransactionManager() != null) {<z>
getTransaction();<z>
if (transaction == null) {<z>
"No JTA Transaction available");<z>
new JtaAfterCompletionSynchronization(synchronizations));<z>
+<z>
;<z>
, TransactionSynchronization.STATUS_UNKNOWN);<z>
getTargetConnectionFactory() {<z>
= this.targetConnectionFactory;<z>
;<z>
return target;<z>
{<z>
;<z>
.getResource(name);<z>
) {<z>
.getURL();<z>
{<z>
)) {<z>
.warn("Could not load " + resource);<z>
return null;<z>
return getClassLoader().getResource(name);<z>
applicationContext) {<z>
.notNull(webHandler, "WebHandler must not be null");<z>
webHandler;<z>
applicationContext = applicationContext;<z>
{<z>
getThreadPoolExecutor();<z>
task);<z>
(RejectedExecutionException ex) {<z>
);<z>
configureAsyncSupport(AsyncSupportConfigurer configurer) {<z>
) {<z>
;<z>
() {<z>
(this.entity instanceof CompletionStage completionStage) {<z>
.headers, this.cookies,<z>
completionStage, this.entityType);<z>
else if (DefaultAsyncServerResponse.reactiveStreamsPresent) {<z>
));<z>
(adapter != null) {<z>
.entity);<z>
entityType);<z>
.entityType);<z>
Class<?> beanClass) {<z>
(new GenericBeanDefinition());<z>
.setBeanClass(beanClass);<z>
builder;<z>
> suspendedSynchronizations) {<z>
);<z>
TransactionSynchronization synchronization : suspendedSynchronizations) {<z>
resume();<z>
TransactionSynchronizationManager.registerSynchronization(synchronization);<z>
public static OutputStream getNoopOutputStream() {<z>
OutputStream() {<z>
{<z>
{<z>
(oldState, newState);<z>
) {<z>
;<z>
return result;<z>
C context, Method source,<z>
<C, R> processor) {<z>
(searchStrategy) {<z>
:<z>
INHERITED_ANNOTATIONS:<z>
, processor);<z>
SUPERCLASS:<z>
{0}, source.getDeclaringClass(),<z>
;<z>
:<z>
case TYPE_HIERARCHY_AND_ENCLOSING_CLASSES:<z>
(),<z>
true);<z>
IllegalStateException("Unsupported search strategy " + searchStrategy);<z>
[] getAnnotations() {<z>
) {<z>
);<z>
return this.annotations;<z>
is) throws IOException {<z>
shouldIgnoreXml) {<z>
new UnsupportedOperationException("XML support disabled");<z>
.loadFromXml(props, is);<z>
scope) {<z>
;<z>
(scope) {<z>
case PAGE_SCOPE:<z>
, value);<z>
:<z>
setAttribute(name, value);<z>
SESSION_SCOPE:<z>
;<z>
case APPLICATION_SCOPE:<z>
, value);<z>
"Invalid scope: " + scope);<z>
) throws JMSException {<z>
= obtainTargetConnectionFactory();<z>
{<z>
QueueConnectionFactory) target).createQueueConnection();<z>
Connection con = target.createConnection();<z>
(!(con instanceof QueueConnection)) {<z>
jms.IllegalStateException("'targetConnectionFactory' is not a QueueConnectionFactory");<z>
(QueueConnection) con;<z>
(Class<?> beanClass) throws IntrospectionException {<z>
{<z>
);<z>
) {<z>
return beanInfo;<z>
shouldIntrospectorIgnoreBeaninfoClasses ?<z>
.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :<z>
;<z>
> namespaces, Object... args)<z>
{<z>
(expression, namespaces, args);<z>
,<z>
) {<z>
handler);<z>
httpHandler, pathPattern);<z>
createRelative(String relativePath) {<z>
;<z>
clazz) :<z>
);<z>
) {<z>
) == null) {<z>
beanFactory != null, "BeanFactory required for default CacheManager resolution");<z>
);<z>
catch (NoUniqueBeanDefinitionException ex) {<z>
throw new IllegalStateException("No unique bean of type CacheManager found. "+<z>
"Mark one as primary or declare a specific CacheManager to use.");<z>
{<z>
new IllegalStateException("No bean of type CacheManager found. Register a CacheManager "+<z>
);<z>
getCacheManager();<z>
handleMissingValue(String name, MethodParameter parameter) {<z>
getSimpleName();<z>
"' of type " + type;<z>
new ServerWebInputException(reason, parameter);<z>
) {<z>
) {<z>
.class) {<z>
("SimpleEvaluationContext is not designed for use with a plain " +<z>
;<z>
resolvers);<z>
;<z>
{<z>
.scriptEngineManager;<z>
if (scriptEngineManager == null) {<z>
new ScriptEngineManager();<z>
.scriptEngineManager = scriptEngineManager;<z>
.hasText(this.engineName)) {<z>
this.engineName);<z>
else if (script instanceof ResourceScriptSource) {<z>
script).getResource();<z>
;<z>
extension == null) {<z>
throw new IllegalStateException(<z>
resource);<z>
ScriptEngine engine = scriptEngineManager.getEngineByExtension(extension);<z>
engine == null) {<z>
"'");<z>
;<z>
new IllegalStateException(<z>
script);<z>
tb, String name, int num) {<z>
;<z>
;<z>
= num;<z>
void setBeanFactory(BeanFactory beanFactory) {<z>
beanFactory;<z>
beanFactory instanceof ConfigurableBeanFactory) {<z>
ConfigurableBeanFactory) beanFactory);<z>
;<z>
method) {<z>
);<z>
(method, "Method is required");<z>
this.bean = bean;<z>
;<z>
bean);<z>
;<z>
.bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);<z>
.bridgedMethod);<z>
this.parameters = initMethodParameters();<z>
> mpFiles,<z>
, Map<String, String> mpParamContentTypes) {<z>
(request);<z>
mpFiles);<z>
setMultipartParameters(mpParams);<z>
setMultipartParameterContentTypes(mpParamContentTypes);<z>
public void applyDefaults(BeanDefinitionDefaults defaults) {<z>
();<z>
null) {<z>
;<z>
setAutowireMode(defaults.getAutowireMode());<z>
getDependencyCheck());<z>
defaults.getInitMethodName());<z>
false);<z>
setDestroyMethodName(defaults.getDestroyMethodName());<z>
);<z>
ContainedBean<B> getBean(<z>
beanType, LifecycleOptions lifecycleOptions, BeanInstanceProducer fallbackProducer) {<z>
;<z>
(lifecycleOptions.canUseCachedReferences()) {<z>
= this.beanCache.get(name);<z>
== null) {<z>
fallbackProducer);<z>
, bean);<z>
name, beanType, lifecycleOptions, fallbackProducer);<z>
(SpringContainedBean<B>) bean;<z>
private void checkBufferLimits() {<z>
contentLength = this.expectedContentLength;<z>
&& contentLength > this.bufferSizeLimit) {<z>
StompConversionException(<z>
+ this.expectedContentLength +<z>
);<z>
) > this.bufferSizeLimit) {<z>
+<z>
this.bufferSizeLimit + " bytes has been exceeded");<z>
, Class[] primaryConstructorArgTypes, boolean classOnly) {<z>
generatedClass = generatedClass;<z>
generatedClass, SET_THREAD_CALLBACKS_NAME);<z>
if (classOnly) {<z>
primaryConstructorArgTypes = null;<z>
;<z>
primaryConstructorArgTypes = primaryConstructorArgTypes;<z>
;<z>
{<z>
e);<z>
, String scriptSourceLocator,<z>
) {<z>
(scriptSourceLocator.startsWith(INLINE_SCRIPT_PREFIX)) {<z>
)), beanName);<z>
));<z>
MockHttpServletRequest buildRequest(ServletContext servletContext) {<z>
;<z>
(true);<z>
.method);<z>
;<z>
);<z>
.url.getScheme() != null) {<z>
;<z>
.url.getHost() != null) {<z>
getHost());<z>
{<z>
.getPort());<z>
updatePathRequestProperties(request, requestUri);<z>
(this.secure != null) {<z>
(this.secure);<z>
principal != null) {<z>
.setUserPrincipal(this.principal);<z>
null) {<z>
session);<z>
;<z>
this.content);<z>
this.contentType);<z>
name, values) -> {<z>
{<z>
;<z>
;<z>
) &&<z>
.headers.containsKey(HttpHeaders.CONTENT_LENGTH) &&<z>
.TRANSFER_ENCODING)) {<z>
length);<z>
.url.getRawQuery();<z>
.isEmpty()) {<z>
);<z>
+ str) : str;<z>
if (query != null) {<z>
query);<z>
.build().getQueryParams());<z>
values) -> {<z>
String value : values) {<z>
request.addParameter(name, value);<z>
;<z>
length > 0) {<z>
;<z>
requestContentType != null) {<z>
MediaType.parseMediaType(requestContentType);<z>
includes(mediaType)) {<z>
mediaType));<z>
(Exception ex) {<z>
isEmpty(this.cookies)) {<z>
));<z>
isEmpty(this.locales)) {<z>
;<z>
;<z>
(name, attribute) -> {<z>
getSession();<z>
session != null, "No HttpSession");<z>
);<z>
});<z>
flashMap = new FlashMap();<z>
.putAll(this.flashAttributes);<z>
= getFlashMapManager(request);<z>
);<z>
return request;<z>
{<z>
getCachedPath(request);<z>
instanceof PathContainer) {<z>
PathContainer) path).value();<z>
.defaultInstance.removeSemicolonContent(value);<z>
return (String) path;<z>
(Locale locale) throws Exception {<z>
String url = getUrl();<z>
null, "'url' not set");<z>
) != null);<z>
(HttpMethod httpMethod, URI url) {<z>
httpMethod = httpMethod;<z>
url;<z>
.writeHandler = body -> {<z>
this.body = body.cache();<z>
);<z>
MethodParameter parameter, NamedValueInfo info) {<z>
;<z>
name.isEmpty()) {<z>
parameter.getParameterName();<z>
null) {<z>
new IllegalArgumentException(<z>
getName() +<z>
"] not specified, and parameter name information not found in class file either.");<z>
defaultValue);<z>
, defaultValue);<z>
if (isPresent(LOG4J_SPI)) {<z>
&& isPresent(SLF4J_SPI)) {<z>
SLF4J_LAL;<z>
logApi = LogApi.LOG4J;<z>
) {<z>
if (this.beans == null) {<z>
= new HashMap<>();<z>
== null) {<z>
this.autodetectMode = AUTODETECT_ALL;<z>
AUTODETECT_NONE);<z>
AUTODETECT_NONE) {<z>
{<z>
new MBeanExportException("Cannot autodetect MBeans if not running in a BeanFactory");<z>
== AUTODETECT_ALL) {<z>
"Autodetecting user-defined JMX MBeans");<z>
));<z>
mode == AUTODETECT_ASSEMBLER || mode == AUTODETECT_ALL) &&<z>
assembler instanceof AutodetectCapableMBeanInfoAssembler) {<z>
assembler)::includeBean);<z>
{<z>
-> registerBeanNameOrInstance(instance, beanName));<z>
response)<z>
, IOException {<z>
valueOf(request.getMethod());<z>
httpMethod)) {<z>
request, response);<z>
service(request, response);<z>
String headerName) {<z>
<String> values = get(headerName);<z>
values != null) {<z>
);<z>
value : values) {<z>
!= null) {<z>
","));<z>
;<z>
.emptyList();<z>
other) {<z>
request;<z>
.response = other.response;<z>
this.requestBody = other.requestBody;<z>
;<z>
timeout;<z>
.uriTemplate;<z>
other.mockServerResult;<z>
.diagnosticsLogged;<z>
XMLStreamException {<z>
);<z>
.START_ELEMENT) {<z>
= streamReader.next();<z>
.next();<z>
) {<z>
streamReader.next();<z>
event;<z>
[] beanNamesForTypeIncludingAncestors(<z>
boolean allowEagerInit) {<z>
;<z>
.getBeanNamesForType(type, includeNonSingletons, allowEagerInit);<z>
) {<z>
{<z>
= beanNamesForTypeIncludingAncestors(<z>
(), type, includeNonSingletons, allowEagerInit);<z>
);<z>
;<z>
<T, ReactiveHttpOutputMessage> inserter) {<z>
, inserter)<z>
this.statusCode)<z>
headers)<z>
-> cookies.addAll(this.cookies))<z>
hints))<z>
.build()<z>
));<z>
{<z>
null) {<z>
;<z>
{<z>
destination;<z>
destinationPrefixes) {<z>
{<z>
));<z>
;<z>
, @Nullable RequestCallback requestCallback,<z>
> uriVariables)<z>
throws RestClientException {<z>
expand(url, uriVariables);<z>
, responseExtractor);<z>
, final String version) {<z>
{<z>
visitRequire(module, access, version);<z>
count) {<z>
return doCommit(() -><z>
Mono.create(sink -> {<z>
READ);<z>
position,<z>
sink);<z>
(listener::closeSource);<z>
;<z>
().set(listener::transfer);<z>
;<z>
IOException ex) {<z>
.error(ex);<z>
;<z>
classLoader)<z>
{<z>
);<z>
Class) {<z>
<?>) result;<z>
).newInstance();<z>
ex) {<z>
), ex);<z>
return result;<z>
{<z>
collection.size()) {<z>
.growCollection) {<z>
SpelEvaluationException(getStartPosition(), SpelMessage.COLLECTION_INDEX_OUT_OF_BOUNDS,<z>
this.index);<z>
this.index >= this.maximumSize) {<z>
;<z>
null) {<z>
(<z>
SpelMessage.UNABLE_TO_GROW_COLLECTION_UNKNOWN_ELEMENT_TYPE);<z>
collectionEntryDescriptor.getElementTypeDescriptor();<z>
.getType());<z>
();<z>
(newElements >= 0) {<z>
);<z>
newElements--;<z>
ex) {<z>
.UNABLE_TO_GROW_COLLECTION);<z>
, HttpServletResponse response) throws IOException {<z>
wrapper =<z>
, ConditionalContentCachingResponseWrapper.class);<z>
, "ContentCachingResponseWrapper not found");<z>
();<z>
())) {<z>
);<z>
!StringUtils.hasText(eTag)) {<z>
writeWeakETag);<z>
setHeader(HttpHeaders.ETAG, eTag);<z>
rawResponse).checkNotModified(eTag)) {<z>
.copyBodyToResponse();<z>
HttpMessageConverter<?>> messageConverters) {<z>
ByteArrayHttpMessageConverter());<z>
add(new StringHttpMessageConverter());<z>
());<z>
.add(new ResourceRegionHttpMessageConverter());<z>
!shouldIgnoreXml) {<z>
new SourceHttpMessageConverter<>());<z>
(Throwable ex) {<z>
));<z>
(romePresent) {<z>
());<z>
));<z>
if (!shouldIgnoreXml) {<z>
(jackson2XmlPresent) {<z>
Jackson2ObjectMapperBuilder builder = Jackson2ObjectMapperBuilder.xml();<z>
(this.applicationContext != null) {<z>
this.applicationContext);<z>
build()));<z>
jaxb2Present) {<z>
Jaxb2RootElementHttpMessageConverter());<z>
{<z>
.add(new KotlinSerializationJsonHttpMessageConverter());<z>
(jackson2Present) {<z>
.json();<z>
this.applicationContext != null) {<z>
builder.applicationContext(this.applicationContext);<z>
);<z>
else if (gsonPresent) {<z>
);<z>
if (jsonbPresent) {<z>
);<z>
if (jackson2SmilePresent) {<z>
);<z>
.applicationContext != null) {<z>
(this.applicationContext);<z>
)));<z>
jackson2CborPresent) {<z>
;<z>
.applicationContext != null) {<z>
this.applicationContext);<z>
build()));<z>
public XmlContentAssert isSimilarTo(String control,<z>
{<z>
withDifferenceEvaluator(<z>
).areSimilar();<z>
;<z>
int compareTo(MimeType other) {<z>
);<z>
0) {<z>
return comp;<z>
getSubtype());<z>
) {<z>
;<z>
).size();<z>
!= 0) {<z>
;<z>
String.CASE_INSENSITIVE_ORDER);<z>
));<z>
CASE_INSENSITIVE_ORDER);<z>
().keySet());<z>
();<z>
();<z>
{<z>
();<z>
.next();<z>
);<z>
comp != 0) {<z>
comp;<z>
)) {<z>
Charset thisCharset = getCharset();<z>
;<z>
if (thisCharset != otherCharset) {<z>
thisCharset == null) {<z>
;<z>
== null) {<z>
1;<z>
= thisCharset.compareTo(otherCharset);<z>
!= 0) {<z>
;<z>
get(thisAttribute);<z>
).get(otherAttribute);<z>
null) {<z>
;<z>
;<z>
!= 0) {<z>
comp;<z>
;<z>
public static boolean isNumeric(int sqlType) {<z>
sqlType || Types.DECIMAL == sqlType ||<z>
Types.INTEGER == sqlType ||<z>
sqlType ||<z>
;<z>
WebSocketHandler handler, URI receiveUrl,<z>
XhrClientSockJsSession session,<z>
<WebSocketSession> connectFuture) {<z>
;<z>
) throws Exception {<z>
);<z>
jndiTemplate) {<z>
(jndiTemplate);<z>
if (jndiEnvironment instanceof Properties properties) {<z>
(properties);<z>
else if (jndiEnvironment != null) {<z>
.getClass());<z>
(resourceRef);<z>
);<z>
(String name, int value) {<z>
CONTENT_LENGTH.equals(name)) {<z>
, value);<z>
() {<z>
if (this.holderActive) {<z>
dataSource, this.connectionHolder);<z>
) {<z>
Arrays.asList(modules);<z>
this.findWellKnownModules = true;<z>
return this;<z>
() {<z>
== 0) {<z>
);<z>
() {<z>
this.directFieldAccessor == null) {<z>
createDirectFieldAccessor();<z>
);<z>
;<z>
return this.directFieldAccessor;<z>
) {<z>
(<z>
extension != null) ?<z>
extension :<z>
);<z>
Map<String, ?> jpaProperties) {<z>
) {<z>
this.jpaPropertyMap.putAll(jpaProperties);<z>
(String attributeName) {<z>
{<z>
attributeName);<z>
false;<z>
String path1, String path2) {<z>
;<z>
startsWith(this.pathSeparator);<z>
) {<z>
path2.substring(1);<z>
path1EndsWithSeparator || path2StartsWithSeparator) {<z>
return path1 + path2;<z>
path2;<z>
(T body) {<z>
notNull(body, "'body' must not be null");<z>
body.getClass()), "'body' should be an object, for reactive types use a variant specifying a publisher/producer and its related element type");<z>
return (message, context) -><z>
), null);<z>
) {<z>
notNull(viewResolver, "ViewResolver must not be null");<z>
add(viewResolver);<z>
return this;<z>
protected void flush() throws IOException {<z>
if (rsWriteFlushLogger.isTraceEnabled()) {<z>
);<z>
flush();<z>
) {<z>
)) {<z>
page++;<z>
int rowNum) throws SQLException {<z>
.context);<z>
.updateRow();<z>
return result;<z>
() {<z>
BeanFactory beanFactory = getBeanFactory();<z>
beanFactory instanceof ConfigurableBeanFactory) {<z>
.getTypeConverter();<z>
();<z>
BeanDefinitionDefaults getBeanDefinitionDefaults() {<z>
BeanDefinitionDefaults bdd = new BeanDefinitionDefaults();<z>
defaults.getLazyInit()));<z>
getAutowireMode(DEFAULT_VALUE));<z>
getInitMethod());<z>
.defaults.getDestroyMethod());<z>
;<z>
protected ParsedSql getParsedSql() {<z>
synchronized (this.parsedSqlMonitor) {<z>
(this.cachedSql == null) {<z>
NamedParameterUtils.parseSqlStatement(resolveSql());<z>
.cachedSql;<z>
{<z>
metadata = new CandidateComponentsMetadata();<z>
: this.metadataItems) {<z>
;<z>
null) {<z>
.previousMetadata.getItems();<z>
for (ItemMetadata item : items) {<z>
item)) {<z>
.add(item);<z>
metadata;<z>
(HttpServletRequest request, HttpServletResponse response)<z>
{<z>
(this.servletInstance != null, "No Servlet instance");<z>
, response);<z>
null;<z>
<?> list) {<z>
> 1) {<z>
INSTANCE);<z>
PropertyValues changesSince(PropertyValues old) {<z>
new MutablePropertyValues();<z>
old == this) {<z>
;<z>
) {<z>
.getPropertyValue(newPv.getName());<z>
)) {<z>
addPropertyValue(newPv);<z>
changes;<z>
() {<z>
{<z>
;<z>
, List<String> subProtocols) {<z>
.Builder.create()<z>
.configurator(configurator)<z>
preferredSubprotocols(subProtocols)<z>
build();<z>
Nullable String fragment) throws MalformedURLException {<z>
new URI(protocol, location, fragment);<z>
this.uri.toURL();<z>
catch (URISyntaxException ex) {<z>
;<z>
);<z>
throw exToThrow;<z>
void recordModificationIfSetterArgumentDiffersFromOldValue(<z>
, MutableModifiable mixin, Object newValue) {<z>
)) {<z>
);<z>
= true;<z>
!= null) {<z>
());<z>
!ObjectUtils.nullSafeEquals(oldValue, newValue);<z>
(Exception ex) {<z>
.printStackTrace();<z>
modified) {<z>
mixin.markDirty();<z>
getContentDisposition() {<z>
getFirst(CONTENT_DISPOSITION);<z>
contentDisposition)) {<z>
.parse(contentDisposition);<z>
return ContentDisposition.empty();<z>
boolean equals(@Nullable Object other) {<z>
{<z>
true;<z>
rhs)) {<z>
;<z>
.exceptionName.equals(rhs.exceptionName);<z>
uriTemplate, Object... uriVars) {<z>
uriTemplate, uriVars);<z>
Assert.notNull(endpointClass, "endpointClass must not be null");<z>
;<z>
<>(endpointClass);<z>
, Object hintValue) {<z>
hints.isEmpty()) {<z>
hintName, hintValue);<z>
(hints.size() + 1);<z>
result.putAll(hints);<z>
result.put(hintName, hintValue);<z>
return result;<z>
equals(@Nullable Object other) {<z>
other) {<z>
true;<z>
instanceof SockJsFrame otherFrame)) {<z>
;<z>
content));<z>
>> interfaces) {<z>
= pd.getWriteMethod();<z>
null) {<z>
();<z>
?> ifc : interfaces) {<z>
.hasMethod(ifc, setter)) {<z>
true;<z>
return false;<z>
void onWebSocketFrame(Frame frame) {<z>
.PONG == frame.getOpCode()) {<z>
null ? frame.getPayload() : EMPTY_PAYLOAD;<z>
payload);<z>
this.wsSession, message);<z>
Exception ex) {<z>
(this.wsSession, ex, logger);<z>
void destroy() {<z>
("Destroying Spring FrameworkServlet '" + getServletName() + "'");<z>
instanceof ConfigurableApplicationContext cac) {<z>
cac.close();<z>
afterPropertiesSet() {<z>
this.handlerMappings == null) {<z>
(this.applicationContext, "No ApplicationContext");<z>
initHandlerMappings(this.applicationContext);<z>
handlerMappings);<z>
) {<z>
;<z>
attr)) {<z>
.getAutowire();<z>
AbstractBeanDefinition.AUTOWIRE_NO;<z>
if (AUTOWIRE_BY_NAME_VALUE.equals(attr)) {<z>
AUTOWIRE_BY_NAME;<z>
)) {<z>
AUTOWIRE_BY_TYPE;<z>
.equals(attr)) {<z>
AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR;<z>
(attr)) {<z>
AbstractBeanDefinition.AUTOWIRE_AUTODETECT;<z>
autowire;<z>
void write(int c) {<z>
;<z>
flush();<z>
;<z>
mi) throws Throwable {<z>
mi)) {<z>
), mi.getArguments());<z>
instanceof ProxyMethodInvocation) {<z>
) mi).getProxy();<z>
{<z>
= proxy;<z>
return retVal;<z>
doProceed(mi);<z>
key, List<String> value) {<z>
> previousValues = get(key);<z>
key);<z>
key).setString(v));<z>
previousValues;<z>
) {<z>
this.server != null) {<z>
) -> {<z>
: mappedObjectNames) {<z>
bean.getNotificationListener(),<z>
getHandback());<z>
{<z>
)) {<z>
, ex);<z>
});<z>
.clear();<z>
{<z>
;<z>
{<z>
(1);<z>
.endsWith("/")) {<z>
length() - 1);<z>
stripFilenameExtension(path);<z>
charset(HttpHeaders headers) {<z>
contentType = headers.getContentType();<z>
if (contentType != null) {<z>
;<z>
(charset != null) {<z>
;<z>
return StandardCharsets.UTF_8;<z>
, final Label start, final Label end) {<z>
== null) {<z>
return null;<z>
} else {<z>
, end);<z>
startPc.bytecodeOffset;<z>
= firstHandler.endPc.bytecodeOffset;<z>
bytecodeOffset;<z>
bytecodeOffset;<z>
(rangeStart >= handlerEnd || rangeEnd <= handlerStart) {<z>
return firstHandler;<z>
rangeStart <= handlerStart) {<z>
rangeEnd >= handlerEnd) {<z>
return firstHandler.nextHandler;<z>
{<z>
firstHandler, end, firstHandler.endPc);<z>
handlerEnd) {<z>
;<z>
else {<z>
, firstHandler.endPc);<z>
firstHandler, firstHandler.startPc, start);<z>
classBeingRedefined,<z>
) throws IllegalClassFormatException {<z>
{<z>
;<z>
classfileBuffer);<z>
JAXBException ex) {<z>
(ex instanceof ValidationException) {<z>
ValidationFailureException("JAXB validation exception", ex);<z>
else if (ex instanceof MarshalException) {<z>
("JAXB marshalling exception", ex);<z>
instanceof UnmarshalException) {<z>
ex);<z>
, ex);<z>
<MediaType> mediaTypes) {<z>
;<z>
) > 1) {<z>
SPECIFICITY_COMPARATOR);<z>
propertySources) {<z>
propertySources = propertySources;<z>
this.propertyResolver = createPropertyResolver(propertySources);<z>
;<z>
headers) {<z>
, "'headers' must not be null");<z>
(headers);<z>
return this;<z>
Class<?>> predicate) {<z>
{<z>
.pathPrefixes = new LinkedHashMap<>();<z>
predicate);<z>
return this;<z>
throws XMLStreamException {<z>
();<z>
);<z>
.emptyElement = true;<z>
void accept(Visitor visitor) {<z>
);<z>
this.routerFunction.accept(visitor);<z>
endNested(this.predicate);<z>
{<z>
BeanFactoryUtils.beanOfTypeIncludingAncestors(<z>
, false);<z>
ex) {<z>
throw new ApplicationContextException(<z>
;<z>
TypedValue getValueInternal(ExpressionState state) throws EvaluationException {<z>
();<z>
.children.length < 2) {<z>
(state).getValue();<z>
{<z>
operandOne instanceof Double) {<z>
this.exitTypeDescriptor = "D";<z>
(operandOne instanceof Float) {<z>
"F";<z>
Long) {<z>
this.exitTypeDescriptor = "J";<z>
) {<z>
"I";<z>
(operandOne);<z>
, null);<z>
= leftOp.getValueInternal(state);<z>
getValue();<z>
= getRightOperand().getValueInternal(state);<z>
);<z>
rightOperand instanceof Number rightNumber) {<z>
(leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {<z>
class);<z>
class);<z>
add(rightBigDecimal));<z>
leftNumber instanceof Double || rightNumber instanceof Double) {<z>
exitTypeDescriptor = "D";<z>
rightNumber.doubleValue());<z>
) {<z>
exitTypeDescriptor = "F";<z>
rightNumber.floatValue());<z>
leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {<z>
, BigInteger.class);<z>
);<z>
.add(rightBigInteger));<z>
leftNumber instanceof Long || rightNumber instanceof Long) {<z>
"J";<z>
) + rightNumber.longValue());<z>
.isIntegerForNumericOp(rightNumber)) {<z>
this.exitTypeDescriptor = "I";<z>
.intValue());<z>
);<z>
instanceof String rightString) {<z>
= "Ljava/lang/String";<z>
return new TypedValue(leftString + rightString);<z>
leftOperand instanceof String) {<z>
TypedValue(<z>
));<z>
instanceof String) {<z>
TypedValue(<z>
operandOneValue, state)) + rightOperand);<z>
rightOperand);<z>
{<z>
);<z>
());<z>
registerBeanDefinitionParser("list", new ListBeanDefinitionParser());<z>
);<z>
);<z>
PropertiesBeanDefinitionParser());<z>
int sqlType, @Nullable String typeName) {<z>
.name = name;<z>
this.sqlType = sqlType;<z>
.typeName = typeName;<z>
brokerElem,<z>
inChannel,<z>
ParserContext context, @Nullable Object source) {<z>
source);<z>
UserDestinationMessageHandler.class);<z>
.addIndexedArgumentValue(0, inChannel);<z>
, brokerChannel);<z>
.addIndexedArgumentValue(2, userDestResolver);<z>
DomUtils.getChildElementByTagName(brokerElem, "stomp-broker-relay");<z>
null && relayElement.hasAttribute("user-destination-broadcast")) {<z>
;<z>
"broadcastDestination", destination);<z>
, context, source);<z>
RuntimeBeanReference(beanName);<z>
throws ObjectStreamException {<z>
)) {<z>
+ "]");<z>
= getTarget();<z>
? new SingletonTargetSource(target) :<z>
));<z>
(Exception ex) {<z>
= "Cannot get target for disconnecting TargetSource [" + this + "]";<z>
ex);<z>
NotSerializableException(msg + ": " + ex);<z>
, Object> model) {<z>
, (HttpServletResponse) pageContext.getResponse(),<z>
), model);<z>
pageContext;<z>
Nullable Object value) {<z>
return result -> {<z>
getModelAndView(result);<z>
name));<z>
protected AssertionError createUnexpectedRequestError(ClientHttpRequest request) {<z>
();<z>
;<z>
"No further requests expected: HTTP " + method + " " + uri + "\n";<z>
AssertionError(message + getRequestDetails());<z>
converterRegistry) {<z>
;<z>
.addConverter(new DateToCalendarConverter());<z>
.addConverter(new CalendarToDateConverter());<z>
.addConverter(new CalendarToLongConverter());<z>
());<z>
new LongToCalendarConverter());<z>
(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {<z>
;<z>
) {<z>
;<z>
GenericConverter converter = getConverter(sourceType, targetType);<z>
;<z>
String toString() {<z>
)<z>
"testClass", getTestClass())<z>
, ObjectUtils.nullSafeToString(getLocations()))<z>
ObjectUtils.nullSafeToString(getClasses()))<z>
, ObjectUtils.nullSafeToString(getContextInitializerClasses()))<z>
()))<z>
))<z>
)))<z>
append("contextCustomizers", getContextCustomizers())<z>
getResourceBasePath())<z>
)))<z>
())<z>
;<z>
public void saveModel() {<z>
null) {<z>
.run();<z>
public void accept(Visitor visitor) {<z>
.header(HttpHeaders.CONTENT_TYPE,<z>
?<z>
toString() :<z>
());<z>
Exception {<z>
if (this.messageSource != null) {<z>
(request, this.messageSource);<z>
)));<z>
executeListener(Session session, Message message) {<z>
message);<z>
Throwable ex) {<z>
(ex);<z>
{<z>
ObjectUtils.isEmpty(patterns)) {<z>
pattern : patterns) {<z>
) {<z>
return true;<z>
return false;<z>
value) {<z>
(value == null) {<z>
;<z>
)) {<z>
name, value, replaceHeader);<z>
void rethrowAnnotationConfigurationException(Throwable ex) {<z>
{<z>
ex;<z>
Object destination) {<z>
Assert.notNull(response, "Result must not be null");<z>
.response = response;<z>
this.destination = destination;<z>
DataBuffer> buffers, int maxByteCount) {<z>
Assert.notNull(buffers, "'dataBuffers' must not be null");<z>
) {<z>
Mono<DataBuffer>) buffers;<z>
return Flux.from(buffers)<z>
new LimitedDataBufferList(maxByteCount), LimitedDataBufferList::add)<z>
)<z>
().join(list))<z>
.class, DataBufferUtils::release);<z>
Object other) {<z>
) {<z>
return false;<z>
) {<z>
;<z>
.count;<z>
closeConnection(Connection con) {<z>
(logger.isDebugEnabled()) {<z>
"Closing shared JMS Connection: " + con);<z>
this.startedCount > 0) {<z>
stop();<z>
.close();<z>
catch (jakarta.jms.IllegalStateException ex) {<z>
debug("Ignoring Connection state exception - assuming already closed: " + ex);<z>
catch (Throwable ex) {<z>
warn("Could not close shared JMS Connection", ex);<z>
) {<z>
key, "Key must not be null");<z>
context, "ApplicationContext must not be null");<z>
put(key, context);<z>
key;<z>
MergedContextConfiguration parent = child.getParent();<z>
null) {<z>
new HashSet<>());<z>
;<z>
= parent;<z>
();<z>
) {<z>
.state(this.asyncSupported, "Async not supported");<z>
;<z>
, response);<z>
asyncContext;<z>
() {<z>
!= null) {<z>
.visitEnd();<z>
() {<z>
);<z>
) {<z>
i).toStringAST());<z>
+ sj.toString();<z>
throws IOException {<z>
ByteBuffer buffer = this.byteBuffer;<z>
{<z>
;<z>
this.writePossible = false;<z>
.remaining();<z>
(buffer);<z>
(rsWriteLogger.isTraceEnabled()) {<z>
" of " + total + " bytes");<z>
written != total) {<z>
return false;<z>
true;<z>
release(dataBuffer);<z>
byteBuffer = null;<z>
return true;<z>
{<z>
) {<z>
.start();<z>
(Exception ex) {<z>
);<z>
String str,<z>
> uriTemplateVariables) {<z>
pattern).matchStrings(str, uriTemplateVariables);<z>
(Object[] args) {<z>
this.rawArguments = args;<z>
;<z>
args;<z>
String namespaceURI, String localName, String value)<z>
XMLStreamException {<z>
value));<z>
) {<z>
cacheDir, "'cacheDir' must not be null");<z>
cacheDir.isDirectory(), "'cacheDir' is not a directory");<z>
;<z>
resolveEntityManagerFactory(@Nullable String requestingBeanName) {<z>
.unitName);<z>
) {<z>
requestingBeanName);<z>
return emf;<z>
) {<z>
()) {<z>
name + "] = [" + obj + "]");<z>
.boundObjects.put(name, obj);<z>
(boolean mayInterruptIfRunning) {<z>
this.delegate.cancel(mayInterruptIfRunning);<z>
mayInterruptIfRunning);<z>
;<z>
attributeName, Class<T> type)<z>
throws NoSuchElementException {<z>
;<z>
attributeIndex);<z>
(type, "Type must not be null");<z>
),<z>
+ attributeName + " type mismatch:");<z>
attributeName);<z>
void start() {<z>
listenerContainer : getListenerContainers()) {<z>
(listenerContainer);<z>
(<z>
com.google.protobuf.CodedInputStream input,<z>
.ExtensionRegistryLite extensionRegistry)<z>
throws java.io.IOException {<z>
.parseFrom(input, extensionRegistry);<z>
String sourceDestination, Set<String> targetDestinations,<z>
user) {<z>
notNull(sourceDestination, "'sourceDestination' must not be null");<z>
"'targetDestinations' must not be null");<z>
;<z>
.sourceDestination = sourceDestination;<z>
;<z>
this.subscribeDestination = subscribeDestination;<z>
= user;<z>
oldValue, @Nullable Object newValue,<z>
@Nullable PropertyEditor editor) {<z>
newValue;<z>
) {<z>
editor.setValue(convertedValue);<z>
= editor.getValue();<z>
convertedValue) {<z>
;<z>
null;<z>
) {<z>
.isDebugEnabled()) {<z>
getName() + "] does not support setValue call", ex);<z>
convertedValue;<z>
convertedValue instanceof String[]) {<z>
)) {<z>
;<z>
);<z>
(convertedValue instanceof String) {<z>
editor != null) {<z>
logger.isTraceEnabled()) {<z>
"] using property editor [" + editor + "]");<z>
newTextValue = (String) convertedValue;<z>
newTextValue, editor);<z>
(String.class == requiredType) {<z>
;<z>
returnValue;<z>
MessageCreator messageCreator)<z>
JMSException {<z>
;<z>
;<z>
null;<z>
consumer = null;<z>
);<z>
.createTemporaryQueue();<z>
(destination);<z>
(responseQueue);<z>
responseQueue);<z>
{<z>
debug("Sending created message: " + requestMessage);<z>
(producer, requestMessage);<z>
(consumer, getReceiveTimeout());<z>
);<z>
);<z>
(responseQueue != null) {<z>
delete();<z>
{<z>
);<z>
newNamespaceMapping();<z>
) {<z>
), ex);<z>
, Object newValue) {<z>
, newValue)) {<z>
, newValue);<z>
Cache cache, Object key, boolean immediate) {<z>
(immediate) {<z>
evictIfPresent(key);<z>
;<z>
RuntimeException ex) {<z>
(ex, cache, key);<z>
int autowireMode, boolean dependencyCheck) throws BeansException {<z>
RootBeanDefinition(beanClass, autowireMode, dependencyCheck);<z>
.setScope(SCOPE_PROTOTYPE);<z>
(), bd, null);<z>
getRowsAffected() {<z>
size()];<z>
i++) {<z>
;<z>
;<z>
> annotationParsers) {<z>
publicMethodsOnly = true;<z>
Assert.notEmpty(annotationParsers, "At least one CacheAnnotationParser needs to be specified");<z>
;<z>
processRollback(DefaultTransactionStatus status, boolean unexpected) {<z>
boolean unexpectedRollback = unexpected;<z>
(status);<z>
status.hasSavepoint()) {<z>
) {<z>
.debug("Rolling back transaction to savepoint");<z>
;<z>
)) {<z>
status.isDebug()) {<z>
.debug("Initiating transaction rollback");<z>
doRollback(status);<z>
.hasTransaction()) {<z>
) || isGlobalRollbackOnParticipationFailure()) {<z>
(status.isDebug()) {<z>
.debug("Participating transaction failed - marking existing transaction as rollback-only");<z>
doSetRollbackOnly(status);<z>
isDebug()) {<z>
("Participating transaction failed - letting transaction originator decide on rollback");<z>
("Should roll back transaction but cannot - no transaction available");<z>
) {<z>
= false;<z>
catch (RuntimeException | Error ex) {<z>
.STATUS_UNKNOWN);<z>
ex;<z>
);<z>
{<z>
UnexpectedRollbackException(<z>
;<z>
);<z>
generateCode(MethodVisitor mv, CodeFlow cf) {<z>
();<z>
cf.enterCompilationScope();<z>
mv, cf);<z>
.lastDescriptor();<z>
state(lastDesc != null, "No last descriptor");<z>
)) {<z>
;<z>
exitCompilationScope();<z>
Label();<z>
);<z>
);<z>
.enterCompilationScope();<z>
, cf);<z>
exitTypeDescriptor)) {<z>
lastDescriptor();<z>
;<z>
, lastDesc.charAt(0));<z>
.exitCompilationScope();<z>
GOTO, endOfIf);<z>
(elseTarget);<z>
;<z>
mv, cf);<z>
isPrimitive(this.exitTypeDescriptor)) {<z>
.lastDescriptor();<z>
!= null, "No last descriptor");<z>
lastDesc.charAt(0));<z>
;<z>
(endOfIf);<z>
cf.pushDescriptor(this.exitTypeDescriptor);<z>
Nullable Object oldValue,<z>
<?> requiredType, @Nullable TypeDescriptor td)<z>
{<z>
null, "No TypeConverterDelegate");<z>
newValue, requiredType, td);<z>
) {<z>
PropertyChangeEvent pce =<z>
, oldValue, newValue);<z>
ConversionNotSupportedException(pce, requiredType, ex);<z>
) {<z>
pce =<z>
;<z>
ex);<z>
() throws JspException {<z>
!= null, "No value set");<z>
this.pageContext.getRequest();<z>
.pageContext.getResponse();<z>
= new StringBuilder();<z>
.type == UrlType.CONTEXT_RELATIVE) {<z>
{<z>
.append(request.getContextPath());<z>
"/")) {<z>
;<z>
);<z>
("/")) {<z>
.append('/');<z>
);<z>
("?") == -1)));<z>
.toString();<z>
!= UrlType.ABSOLUTE) {<z>
encodeURL(urlStr);<z>
;<z>
urlStr);<z>
return urlStr;<z>
{<z>
, "ServerRequest must not be null");<z>
);<z>
;<z>
= other.method();<z>
;<z>
asHttpHeaders());<z>
));<z>
;<z>
other) {<z>
(this == other) {<z>
;<z>
{<z>
return false;<z>
otherNlh.notificationListener) &&<z>
notificationFilter, otherNlh.notificationFilter) &&<z>
&&<z>
, otherNlh.mappedObjectNames));<z>
{<z>
(response -><z>
(response,<z>
bodyClass))));<z>
{<z>
getAttribute(INDEX_ATTRIBUTE);<z>
;<z>
;<z>
hasLength(indexAttr)) {<z>
index = Integer.parseInt(indexAttr);<z>
< 0) {<z>
"'index' cannot be lower than 0", ele);<z>
));<z>
, null);<z>
);<z>
.hasLength(typeAttr)) {<z>
;<z>
StringUtils.hasLength(nameAttr)) {<z>
setName(nameAttr);<z>
));<z>
index)) {<z>
index, ele);<z>
, valueHolder);<z>
);<z>
ex) {<z>
"Attribute 'index' of tag 'constructor-arg' must be an integer", ele);<z>
;<z>
, null);<z>
;<z>
typeAttr)) {<z>
);<z>
{<z>
;<z>
extractSource(ele));<z>
.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);<z>
;<z>
public List<Object> getInterceptorsAndDynamicInterceptionAdvice(<z>
Class<?> targetClass) {<z>
registry = GlobalAdvisorAdapterRegistry.getInstance();<z>
getAdvisors();<z>
;<z>
getDeclaringClass());<z>
hasIntroductions = null;<z>
) {<z>
) {<z>
).matches(actualClass)) {<z>
);<z>
match;<z>
) {<z>
hasIntroductions == null) {<z>
;<z>
.matches(method, actualClass, hasIntroductions);<z>
, actualClass);<z>
if (match) {<z>
);<z>
mm.isRuntime()) {<z>
: interceptors) {<z>
(new InterceptorAndDynamicMethodMatcher(interceptor, mm));<z>
asList(interceptors));<z>
{<z>
)) {<z>
= registry.getInterceptors(advisor);<z>
Arrays.asList(interceptors));<z>
= registry.getInterceptors(advisor);<z>
));<z>
interceptorList;<z>
predicate,<z>
@Nullable MergedAnnotationSelector<A> selector) {<z>
this.requiredType = requiredType;<z>
.predicate = predicate;<z>
MergedAnnotationSelectors.nearest());<z>
> messageFactory) {<z>
logger.isDebugEnabled()) {<z>
);<z>
String logMessage = messageFactory.apply(traceEnabled);<z>
if (traceEnabled) {<z>
trace(logMessage);<z>
debug(logMessage);<z>
void doPost(HttpServletRequest request, HttpServletResponse response)<z>
ServletException, IOException {<z>
processRequest(request, response);<z>
close(CloseStatus status) throws IOException {<z>
if (isOpen()) {<z>
if (logger.isDebugEnabled()) {<z>
" with " + status);<z>
this.state = State.CLOSED;<z>
)) {<z>
), status.getReason()));<z>
(Throwable ex) {<z>
"Failure while sending SockJS close frame", ex);<z>
;<z>
();<z>
;<z>
, status);<z>
) {<z>
ex);<z>
classLoader) &&<z>
isPresent(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, classLoader);<z>
void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) {<z>
registerAnnotationConfigProcessors(registry, null);<z>
(Object bean, String beanName) throws BeansException {<z>
{<z>
;<z>
return bean;<z>
private static Random initRandom() {<z>
randomToUse = random;<z>
(randomToUse == null) {<z>
synchronized (MimeTypeUtils.class) {<z>
random;<z>
(randomToUse == null) {<z>
);<z>
randomToUse;<z>
randomToUse;<z>
{<z>
source.size());<z>
source) {<z>
valueOf(element));<z>
bh.consume(target);<z>
() {<z>
this.model == null) {<z>
new ExtendedModelMap();<z>
this.model;<z>
{<z>
logger.isDebugEnabled()) {<z>
.logPrefix + "AsyncEvent onTimeout");<z>
delegateTimeout(this.requestAsyncListener, event);<z>
this.responseAsyncListener, event);<z>
);<z>
public void setup() {<z>
.beanFactory = new DefaultListableBeanFactory();<z>
TestBean.class));<z>
;<z>
extends ResourceRegion> input,<z>
mimeType,<z>
Map<String, Object> hints) {<z>
;<z>
Assert.notNull(bufferFactory, "'bufferFactory' must not be null");<z>
notNull(elementType, "'elementType' must not be null");<z>
instanceof Mono) {<z>
input)<z>
.flatMapMany(region -> {<z>
.isReadable()) {<z>
EncodingException(<z>
);<z>
;<z>
;<z>
(hints, BOUNDARY_STRING_HINT);<z>
;<z>
new byte[0];<z>
)<z>
{<z>
()) {<z>
.error(new EncodingException(<z>
));<z>
prefix = Flux.just(<z>
(startBoundary),<z>
wrap(contentType),<z>
(region)));<z>
region, bufferFactory, hints));<z>
);<z>
ApplicationEvent event) {<z>
ErrorHandler errorHandler = getErrorHandler();<z>
errorHandler != null) {<z>
);<z>
) {<z>
handleError(err);<z>
event);<z>
element, BeanDefinitionBuilder builder) {<z>
DB_NAME_ATTRIBUTE);<z>
)) {<z>
;<z>
StringUtils.hasText(name)) {<z>
, name);<z>
ValueRef getValueRef(ExpressionState state) throws EvaluationException {<z>
arguments = getArguments(state);<z>
{<z>
throwIfNotNullSafe(getArgumentTypes(arguments));<z>
.NullValueRef.INSTANCE;<z>
arguments);<z>
extends Annotation> annotationType) {<z>
()) {<z>
return false;<z>
(this.annotatedElement, annotationType);<z>
{<z>
;<z>
setTransactionAttributeSource(transactionAttributeSource);<z>
if (this.txManager != null) {<z>
setTransactionManager(this.txManager);<z>
interceptor;<z>
synchronizationManager, GenericReactiveTransaction status) throws TransactionException {<z>
++commits;<z>
--inflight;<z>
empty();<z>
String, T> matchingBeans) {<z>
count = matchingBeans.size();<z>
(count == 1) {<z>
.iterator().next();<z>
if (count > 1) {<z>
.keySet());<z>
new NoSuchBeanDefinitionException(type);<z>
{<z>
value) -> {<z>
key);<z>
Map) {<z>
>) existing);<z>
(result, (Map) value);<z>
.put(key, result);<z>
, value);<z>
});<z>
BeanFactory beanFactory, String beanName) {<z>
"BeanFactory is required");<z>
, "Bean name is required");<z>
beanFactory;<z>
.beanName = beanName;<z>
public String toString() {<z>
)) {<z>
();<z>
super.toString());<z>
(") are:");<z>
length; i++) {<z>
= this.messageExceptions[i];<z>
(": ");<z>
sb.append(subEx);<z>
return sb.toString();<z>
) {<z>
WildcardType wt) {<z>
).length == 0) {<z>
getUpperBounds();<z>
) {<z>
true;<z>
return false;<z>
GenericMessage(T payload, MessageHeaders headers) {<z>
(payload, "Payload must not be null");<z>
, "MessageHeaders must not be null");<z>
payload;<z>
= headers;<z>
arg, String name, MethodParameter parameter,<z>
Nullable ModelAndViewContainer mavContainer, NativeWebRequest request) {<z>
String key = View.PATH_VARIABLES;<z>
;<z>
request.getAttribute(key, scope);<z>
if (pathVars == null) {<z>
= new HashMap<>();<z>
key, pathVars, scope);<z>
;<z>
) {<z>
if (this.proxy == null) {<z>
);<z>
proxy;<z>
(ServerHttpRequest request, ServerHttpResponse response,<z>
String transport) throws SockJsException {<z>
);<z>
{<z>
()) {<z>
));<z>
);<z>
get(transportType);<z>
== null) {<z>
{<z>
, true));<z>
(HttpStatus.NOT_FOUND);<z>
= null;<z>
.interceptors, handler);<z>
();<z>
{<z>
()) {<z>
, supportedMethod)) {<z>
;<z>
);<z>
) {<z>
);<z>
supportedMethod);<z>
);<z>
= false;<z>
(session == null) {<z>
{<z>
>();<z>
)) {<z>
SockJsSessionFactory) transportHandler;<z>
handler, attributes);<z>
= true;<z>
;<z>
logger.isDebugEnabled()) {<z>
.debug("Session not found, sessionId=" + sessionId +<z>
);<z>
);<z>
)) {<z>
"The user for the session does not match the user for the request.");<z>
.setStatusCode(HttpStatus.NOT_FOUND);<z>
) {<z>
("Session type does not match the transport type for the request.");<z>
HttpStatus.NOT_FOUND);<z>
()) {<z>
);<z>
!checkOrigin(request, response)) {<z>
request, response, handler, session);<z>
(response instanceof ServletServerHttpResponse)) {<z>
();<z>
)) {<z>
);<z>
(request, response, null);<z>
(SockJsException ex) {<z>
ex;<z>
(Exception ex) {<z>
.getURI(), sessionId, ex);<z>
!= null) {<z>
;<z>
;<z>
) {<z>
handleMatch(info, lookupPath, request);<z>
condition = info.getActivePatternsCondition();<z>
instanceof PathPatternsRequestCondition) {<z>
request);<z>
, request);<z>
)) {<z>
.getProducesCondition().getProducibleMediaTypes();<z>
, mediaTypes);<z>
public final ConfigurableListableBeanFactory getBeanFactory() {<z>
DefaultListableBeanFactory beanFactory = this.beanFactory;<z>
if (beanFactory == null) {<z>
new IllegalStateException("BeanFactory not initialized or already closed - " +<z>
"call 'refresh' before accessing beans via the ApplicationContext");<z>
beanFactory;<z>
URI getURI() {<z>
this.uri == null) {<z>
null;<z>
;<z>
.servletRequest.getRequestURL();<z>
);<z>
(query);<z>
{<z>
query);<z>
toString();<z>
.uri = new URI(urlString);<z>
(URISyntaxException ex) {<z>
) {<z>
(<z>
+ urlString, ex);<z>
.getRequestURL().toString();<z>
= new URI(urlString);<z>
catch (URISyntaxException ex2) {<z>
(<z>
urlString, ex2);<z>
;<z>
, Object targetObject, String name,<z>
{<z>
Class) {<z>
"DataBindingMethodResolver does not support Class targets");<z>
name, argumentTypes);<z>
@Nullable Object[] args)<z>
throws BeanCreationException {<z>
.isTraceEnabled()) {<z>
;<z>
mbd;<z>
= resolveBeanClass(mbd, beanName);<z>
) != null) {<z>
= new RootBeanDefinition(mbd);<z>
(resolvedClass);<z>
prepareMethodOverrides();<z>
) {<z>
(),<z>
;<z>
;<z>
!= null) {<z>
return bean;<z>
) {<z>
.getResourceDescription(), beanName,<z>
, ex);<z>
(beanName, mbdToUse, args);<z>
()) {<z>
+ "'");<z>
;<z>
| ImplicitlyAppearedSingletonException ex) {<z>
ex;<z>
(Throwable ex) {<z>
BeanCreationException(<z>
, "Unexpected exception during bean creation", ex);<z>
public static WebApplicationContext getCurrentWebApplicationContext() {<z>
).getContextClassLoader();<z>
null) {<z>
get(ccl);<z>
ccpt != null) {<z>
ccpt;<z>
;<z>
) {<z>
long i = this.currentInterval;<z>
();<z>
.min(i, maxInterval);<z>
public MarshallingMessageConverter(Marshaller marshaller) {<z>
this();<z>
;<z>
= marshaller;<z>
if (marshaller instanceof Unmarshaller) {<z>
.unmarshaller = (Unmarshaller) marshaller;<z>
public boolean add(Object value) {<z>
(this.propertyValue, "add", value);<z>
updateDeferredProperties(value);<z>
return retVal;<z>
public void setupListenerContainer(MessageListenerContainer listenerContainer) {<z>
AbstractMessageListenerContainer) {<z>
(AbstractMessageListenerContainer) listenerContainer);<z>
(listenerContainer);<z>
void resume() {<z>
) {<z>
this.sessionHolder);<z>
String>> headers) {<z>
forEach(headers::put);<z>
if (this.delegate != null) {<z>
;<z>
> readMethodNames)<z>
throws IntrospectionException {<z>
)) {<z>
isJavaLanguageInterface(ifc)) {<z>
ifc).getPropertyDescriptors()) {<z>
());<z>
(existingPd == null ||<z>
) != null)) {<z>
beanClass, pd);<z>
(), pd);<z>
pd.getReadMethod();<z>
if (readMethod != null) {<z>
getName());<z>
, readMethodNames);<z>
PathPatternMatchableHandlerMapping> initPathPatternMatchableHandlerMappings(<z>
{<z>
return mappings.stream()<z>
mapping -> mapping instanceof MatchableHandlerMapping)<z>
-> (MatchableHandlerMapping) mapping)<z>
mapping.getPatternParser() != null)<z>
));<z>
) {<z>
.condition == null) {<z>
return 0;<z>
else if (this.condition == null) {<z>
return 1;<z>
{<z>
;<z>
this.condition, other.condition);<z>
;<z>
request) {<z>
getMatchingCondition(request);<z>
methods == null) {<z>
;<z>
);<z>
) {<z>
return null;<z>
);<z>
== null) {<z>
;<z>
(request);<z>
== null) {<z>
;<z>
this.producesCondition.getMatchingCondition(request);<z>
== null) {<z>
null;<z>
PathPatternsRequestCondition pathPatterns = null;<z>
(this.pathPatternsCondition != null) {<z>
;<z>
{<z>
return null;<z>
patterns = null;<z>
this.patternsCondition != null) {<z>
.getMatchingCondition(request);<z>
(patterns == null) {<z>
null;<z>
this.customConditionHolder.getMatchingCondition(request);<z>
(custom == null) {<z>
null;<z>
, pathPatterns, patterns,<z>
produces, custom, this.options);<z>
{<z>
ToStringVisitor visitor = new ToStringVisitor();<z>
accept(visitor);<z>
visitor.toString();<z>
protected Object invokeJoinpoint() throws Throwable {<z>
{<z>
arguments);<z>
catch (CodeGenerationException ex) {<z>
.method);<z>
);<z>
> annotations) {<z>
(annotations, "Annotations must not be null");<z>
]);<z>
length];<z>
; i++) {<z>
i];<z>
(annotation, "Annotation must not be null");<z>
);<z>
() == 0, "Annotation must have aggregate index of zero");<z>
.forAnnotationType(annotation.getType());<z>
{<z>
;<z>
<>();<z>
: allParameters) {<z>
) {<z>
all.add(allParameter);<z>
()) {<z>
add(allParameter);<z>
) ? all : annotated);<z>
String name, Object value) {<z>
);<z>
"'value' must not be null");<z>
.with(name, value);<z>
getScalarOutParameterName() {<z>
()) {<z>
getFunctionReturnName();<z>
{<z>
logger.info("Accessing single output value when procedure has more than one output parameter");<z>
.get(0) : null);<z>
HttpMethod getAccessControlRequestMethod() {<z>
= getFirst(ACCESS_CONTROL_REQUEST_METHOD);<z>
if (requestMethod != null) {<z>
return HttpMethod.valueOf(requestMethod);<z>
;<z>
<String, ?> attributes) {<z>
null) {<z>
) {<z>
.remove(key);<z>
this;<z>
) {<z>
+ this.variableName + "' for method parameter type " +<z>
+<z>
;<z>
(String token) {<z>
length(); i++) {<z>
;<z>
TOKEN.get(ch)) {<z>
+ token + "\"");<z>
{<z>
.fieldType = fieldType;<z>
resolvePrinterObjectType(printer));<z>
.printer = printer;<z>
= conversionService;<z>
, ?> model) {<z>
new DefaultRenderingResponseBuilder(name)<z>
this.statusCode)<z>
-> headers.putAll(this.headers))<z>
(this.cookies))<z>
.modelAttributes(model)<z>
.build();<z>
ManagedList<?> getInterceptors(<z>
interceptorElementName) {<z>
);<z>
.getChildElementByTagName(element, "async-support");<z>
{<z>
DomUtils.getChildElementByTagName(asyncElement, interceptorElementName);<z>
(interceptorsElement != null) {<z>
;<z>
{<z>
;<z>
beanDef != null) {<z>
beanDef);<z>
;<z>
return interceptors;<z>
getWriter() throws IOException {<z>
== null) {<z>
= getCharacterEncoding();<z>
) :<z>
new ResponsePrintWriter(WebUtils.DEFAULT_CHARACTER_ENCODING));<z>
return this.writer;<z>
) {<z>
= getTypeConverter();<z>
if (converter != null) {<z>
targetMethod = getTargetMethod();<z>
;<z>
;<z>
<?> targetClass = getTargetClass();<z>
, "No target class set");<z>
= ReflectionUtils.getAllDeclaredMethods(targetClass);<z>
;<z>
] argumentsToUse = null;<z>
{<z>
).equals(targetMethod)) {<z>
;<z>
{<z>
.getParameterTypes();<z>
argCount];<z>
= true;<z>
j++) {<z>
[j]);<z>
catch (TypeMismatchException ex) {<z>
= false;<z>
if (match) {<z>
int typeDiffWeight = getTypeDifferenceWeight(paramTypes, convertedArguments);<z>
{<z>
;<z>
;<z>
= convertedArguments;<z>
if (matchingMethod != null) {<z>
);<z>
matchingMethod;<z>
null;<z>
protected void useCachingConfigurer(CachingConfigurerSupplier cachingConfigurerSupplier) {<z>
(CachingConfigurer::cacheManager);<z>
(CachingConfigurer::cacheResolver);<z>
;<z>
errorHandler);<z>
baseUrl,<z>
, Method method, Object... args) {<z>
fromMethodInternal(baseUrl,<z>
args);<z>
{<z>
userTransaction == null) {<z>
.userTransactionName)) {<z>
lookupUserTransaction(this.userTransactionName);<z>
true;<z>
);<z>
== null && this.autodetectUserTransaction) {<z>
;<z>
this.transactionManager == null) {<z>
(this.transactionManagerName)) {<z>
(this.transactionManagerName);<z>
this.transactionManager = retrieveTransactionManager();<z>
.autodetectTransactionManager) {<z>
= findTransactionManager(this.userTransaction);<z>
{<z>
userTransaction = buildUserTransaction(this.transactionManager);<z>
T mapping) {<z>
(logger.isTraceEnabled()) {<z>
+ mapping);<z>
);<z>
{<z>
this.segments) {<z>
segment.clear();<z>
throws TransactionException {<z>
;<z>
== null) {<z>
TransactionUsageException(<z>
;<z>
savepoint);<z>
null);<z>
) {<z>
.getBean(FLASH_MAP_MANAGER_BEAN_NAME, FlashMapManager.class);<z>
()) {<z>
getClass().getSimpleName());<z>
.isDebugEnabled()) {<z>
debug("Detected " + this.flashMapManager);<z>
{<z>
);<z>
.isTraceEnabled()) {<z>
"No FlashMapManager '" + FLASH_MAP_MANAGER_BEAN_NAME +<z>
);<z>
connectedHeaders) {<z>
) {<z>
.info("\"System\" session connected.");<z>
.afterStompConnected(connectedHeaders);<z>
();<z>
sendSystemSubscriptions();<z>
) {<z>
reason, cause);<z>
;<z>
null;<z>
) {<z>
Assert.notNull(resource, "'resource' must not be null");<z>
) -> {<z>
;<z>
);<z>
getContentType();<z>
, outputMessage, context, writer);<z>
task, Throwable throwable) {<z>
();<z>
this.interceptors) {<z>
(request, task, throwable);<z>
CallableProcessingInterceptor.RESPONSE_HANDLED) {<z>
{<z>
return result;<z>
(Throwable ex) {<z>
return ex;<z>
return CallableProcessingInterceptor.RESULT_NONE;<z>
] headers) {<z>
expressions = parseExpressions(consumes, headers);<z>
> 1) {<z>
(this.expressions);<z>
Method method)<z>
throws SpelEvaluationException {<z>
;<z>
, method, varargsPosition);<z>
List<String> headerValues) {<z>
", ");<z>
(String val : headerValues) {<z>
if (val != null) {<z>
val);<z>
();<z>
{<z>
return new ResolvableType(clazz) {<z>
getGenerics() {<z>
EMPTY_TYPES_ARRAY;<z>
other) {<z>
other));<z>
isAssignableFrom(ResolvableType other) {<z>
);<z>
(clazz, otherClass)));<z>
@Nullable Object source, ParserContext parserContext) {<z>
BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(<z>
);<z>
.getRawBeanDefinition().setSource(source);<z>
JMS_LISTENER_ENDPOINT_REGISTRY_BEAN_NAME);<z>
{<z>
);<z>
this.groupings.computeIfAbsent(<z>
!= null ? group : deferredImport),<z>
DeferredImportSelectorGrouping(createGroup(group)));<z>
.add(deferredImport);<z>
),<z>
deferredImport.getConfigurationClass());<z>
{<z>
);<z>
.length();<z>
< this.paddingLength) {<z>
(this.paddingLength);<z>
paddingLength - len; i++) {<z>
('0');<z>
append(s);<z>
.toString();<z>
;<z>
HttpInputMessage inputMessage)<z>
throws IOException, HttpMessageNotReadableException {<z>
);<z>
{<z>
);<z>
== clazz) {<z>
T) readSAXSource(body, inputMessage);<z>
clazz) {<z>
) readStAXSource(body, inputMessage);<z>
) {<z>
return (T) readStreamSource(body);<z>
+<z>
"]. Only DOMSource, SAXSource, StAXSource, and StreamSource are supported.", inputMessage);<z>
simpAnnotationMethodMessageHandler(<z>
AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,<z>
SimpMessagingTemplate brokerMessagingTemplate, CompositeMessageConverter brokerMessageConverter) {<z>
(<z>
clientOutboundChannel, brokerMessagingTemplate);<z>
;<z>
.getApplicationDestinationPrefixes());<z>
setMessageConverter(brokerMessageConverter);<z>
.setValidator(simpValidator());<z>
new ArrayList<>();<z>
;<z>
handler.setCustomArgumentResolvers(argumentResolvers);<z>
<>();<z>
);<z>
);<z>
pathMatcher = brokerRegistry.getPathMatcher();<z>
{<z>
(pathMatcher);<z>
return handler;<z>
, XMLStreamException {<z>
boolean documentStarted = false;<z>
false;<z>
int elementDepth = 0;<z>
.reader.getEventType();<z>
while (true) {<z>
XMLStreamConstants.END_DOCUMENT &&<z>
documentStarted) {<z>
);<z>
true;<z>
switch (eventType) {<z>
START_ELEMENT:<z>
;<z>
);<z>
case XMLStreamConstants.END_ELEMENT:<z>
elementDepth--;<z>
(elementDepth >= 0) {<z>
handleEndElement();<z>
case XMLStreamConstants.PROCESSING_INSTRUCTION:<z>
);<z>
XMLStreamConstants.CHARACTERS:<z>
:<z>
:<z>
handleCharacters();<z>
XMLStreamConstants.START_DOCUMENT:<z>
);<z>
documentStarted = true;<z>
case XMLStreamConstants.END_DOCUMENT:<z>
();<z>
= true;<z>
:<z>
handleComment();<z>
DTD:<z>
);<z>
:<z>
);<z>
) {<z>
);<z>
(!documentEnded) {<z>
;<z>
(RSocketStrategies rsocketStrategies) {<z>
;<z>
clear();<z>
this.strategies.encoders());<z>
());<z>
;<z>
.reactiveAdapterRegistry());<z>
getObject() throws BeansException {<z>
if (isSingleton()) {<z>
testBean;<z>
;<z>
!= null) {<z>
;<z>
= true;<z>
return prototype;<z>
public ResponseEntityResultHandler responseEntityResultHandler(<z>
@Qualifier("webFluxAdapterRegistry") ReactiveAdapterRegistry reactiveAdapterRegistry,<z>
ServerCodecConfigurer serverCodecConfigurer,<z>
RequestedContentTypeResolver contentTypeResolver) {<z>
,<z>
contentTypeResolver, reactiveAdapterRegistry);<z>
visitTypeAnnotation(<z>
) {<z>
(visible) {<z>
lastRuntimeVisibleTypeAnnotation =<z>
.create(<z>
typePath, descriptor, lastRuntimeVisibleTypeAnnotation);<z>
else {<z>
lastRuntimeInvisibleTypeAnnotation =<z>
AnnotationWriter.create(<z>
, typePath, descriptor, lastRuntimeInvisibleTypeAnnotation);<z>
(<z>
descriptorEnd) {<z>
switch (descriptorBuffer.charAt(descriptorBegin)) {<z>
:<z>
;<z>
'Z':<z>
BOOLEAN_TYPE;<z>
:<z>
CHAR_TYPE;<z>
'B':<z>
;<z>
'S':<z>
;<z>
'I':<z>
INT_TYPE;<z>
'F':<z>
return FLOAT_TYPE;<z>
:<z>
;<z>
'D':<z>
DOUBLE_TYPE;<z>
:<z>
descriptorEnd);<z>
case 'L':<z>
);<z>
case '(':<z>
, descriptorBegin, descriptorEnd);<z>
new IllegalArgumentException();<z>
{<z>
= ServerSocketFactory.getDefault().createServerSocket(<z>
InetAddress.getByName("localhost"));<z>
.close();<z>
true;<z>
{<z>
;<z>
method) {<z>
method != null) {<z>
.equals(this.method);<z>
!isOverloaded() ||<z>
getParameterCount() == 0));<z>
,<z>
Nullable Charset responseCharset) {<z>
, responseCharset);<z>
boolean pubSubDomain) {<z>
class;<z>
if (pubSubDomain) {<z>
= Topic.class;<z>
) {<z>
(<z>
);<z>
createRelative(String relativePath) throws IOException {<z>
)) {<z>
);<z>
{<z>
, relativePath)));<z>
headers) {<z>
()) {<z>
toMessage(payload, headers);<z>
(result != null) {<z>
;<z>
return null;<z>
{<z>
.notNull(servletResponse, "HttpServletResponse must not be null");<z>
servletResponse;<z>
);<z>
> annotationType,<z>
> predicate,<z>
{<z>
, predicate, selector);<z>
.missing());<z>
adaptForwardedHost(String rawValue) {<z>
int portSeparatorIdx = rawValue.lastIndexOf(':');<z>
int squareBracketIdx = rawValue.lastIndexOf(']');<z>
squareBracketIdx) {<z>
(':') != portSeparatorIdx) {<z>
+ rawValue);<z>
.substring(0, portSeparatorIdx));<z>
);<z>
(rawValue);<z>
port(null);<z>
) {<z>
) {<z>
= true;<z>
.values()) {<z>
{<z>
);<z>
) throws IOException {<z>
URL url = getURL();<z>
{<z>
();<z>
.length();<z>
()) {<z>
new FileNotFoundException(getDescription() +<z>
;<z>
length;<z>
con = url.openConnection();<z>
customizeConnection(con);<z>
;<z>
Reader getReader() throws IOException {<z>
.charset != null) {<z>
);<z>
if (this.encoding != null) {<z>
getInputStream(), this.encoding);<z>
resource.getInputStream());<z>
addFixedDelayTask(IntervalTask task) {<z>
(this.fixedDelayTasks == null) {<z>
.fixedDelayTasks = new ArrayList<>();<z>
this.fixedDelayTasks.add(task);<z>
destinations) {<z>
resolveEmbeddedValuesInDestinations(destinations);<z>
return new SimpMessageMappingInfo(SimpMessageTypeMessageCondition.MESSAGE,<z>
this.pathMatcher));<z>
{<z>
;<z>
null && isSingletonCurrentlyInCreation(beanName)) {<z>
.earlySingletonObjects.get(beanName);<z>
== null && allowEarlyReference) {<z>
.singletonObjects) {<z>
= this.singletonObjects.get(beanName);<z>
if (singletonObject == null) {<z>
.earlySingletonObjects.get(beanName);<z>
singletonObject == null) {<z>
beanName);<z>
(singletonFactory != null) {<z>
singletonObject = singletonFactory.getObject();<z>
;<z>
singletonFactories.remove(beanName);<z>
;<z>
src, File dest) throws IOException {<z>
notNull(src, "Source File must not be null");<z>
, "Destination File must not be null");<z>
;<z>
public String getShortDescription() {<z>
= new StringBuilder();<z>
);<z>
).append("]; ");<z>
));<z>
();<z>
() throws Exception {<z>
resolveResourceLocations();<z>
.resourceResolvers.isEmpty()) {<z>
(new PathResourceResolver());<z>
);<z>
DefaultResourceResolverChain(this.resourceResolvers);<z>
this.resourceTransformers);<z>
if (this.resourceHttpMessageConverter == null) {<z>
;<z>
{<z>
new ResourceRegionHttpMessageConverter();<z>
();<z>
null) {<z>
.getMediaTypeMappings());<z>
"deprecation")<z>
=<z>
;<z>
!= null) {<z>
strategy.getMediaTypes());<z>
SqlParameter... parameters) {<z>
(isCompiled()) {<z>
;<z>
< parameters.length; i++) {<z>
(parameters[i] != null) {<z>
i]);<z>
InvalidDataAccessApiUsageException("Cannot add parameter at index " + i + " from " +<z>
" since it is 'null'");<z>
Object generateKey(CacheOperationInvocationContext<O> context) {<z>
getOperation().getKeyGenerator();<z>
context.getArgs());<z>
()) {<z>
getOperation());<z>
return key;<z>
>... annotationTypes) {<z>
(annotationTypes);<z>
{<z>
!= 0) {<z>
(annotType -><z>
(method, annotType) != null);<z>
().length == 0;<z>
;<z>
return this;<z>
(@Nullable List<HandlerMethodArgumentResolver> customArgumentResolvers) {<z>
.customArgumentResolvers.clear();<z>
if (customArgumentResolvers != null) {<z>
.customArgumentResolvers.addAll(customArgumentResolvers);<z>
(MethodParameter parameter) {<z>
.hasParameterAnnotation(RequestPart.class)) {<z>
true;<z>
RequestParam.class)) {<z>
return false;<z>
nestedIfOptional());<z>
, MethodParameter parameter,<z>
> converterType) {<z>
, RequestBodyAdvice.class)) {<z>
supports(parameter, targetType, converterType)) {<z>
converterType);<z>
return body;<z>
,<z>
, Object> hints) {<z>
inputStream, elementType, mimeType, hints));<z>
public static Object unwrapIfNecessary(Object resource) {<z>
instanceof ScopedObject) {<z>
.getTargetObject();<z>
resource;<z>
getDefaultExecutor(@Nullable BeanFactory beanFactory) {<z>
!= null) {<z>
.class);<z>
NoUniqueBeanDefinitionException ex) {<z>
ex);<z>
(DEFAULT_TASK_EXECUTOR_BEAN_NAME, Executor.class);<z>
ex2) {<z>
isInfoEnabled()) {<z>
logger.info("More than one TaskExecutor bean found within the context, and none is named " +<z>
.getBeanNamesFound());<z>
catch (NoSuchBeanDefinitionException ex) {<z>
"Could not find default TaskExecutor bean", ex);<z>
Executor.class);<z>
(NoSuchBeanDefinitionException ex2) {<z>
("No task executor bean found for async processing: " +<z>
;<z>
return null;<z>
TypeDescriptor targetTypeDescriptor) throws EvaluationException {<z>
().convertValue(<z>
targetTypeDescriptor);<z>
) {<z>
;<z>
;<z>
ResultMatcher nodeCount(int expectedCount) {<z>
-> {<z>
response = result.getResponse();<z>
(response), expectedCount);<z>
<String, ?> map) throws ClassNotFoundException {<z>
.size());<z>
{<z>
);<z>
value = entry.getValue();<z>
Class<?> type;<z>
clazz) {<z>
= clazz;<z>
instanceof String className) {<z>
beanClassLoader);<z>
+ value + "] - expected String or Class");<z>
type);<z>
result;<z>
initMethod) {<z>
) {<z>
if (this.externallyManagedInitMethods == null) {<z>
= new LinkedHashSet<>(1);<z>
);<z>
doCleanupAfterCompletion(Object transaction) {<z>
) transaction;<z>
{<z>
));<z>
).getConnection();<z>
isMustRestoreAutoCommit()) {<z>
(true);<z>
(<z>
isReadOnly());<z>
ex) {<z>
ex);<z>
) {<z>
isDebugEnabled()) {<z>
);<z>
releaseConnection(con, this.dataSource);<z>
clear();<z>
) {<z>
if (api != Opcodes.ASM9<z>
Opcodes.ASM8<z>
ASM7<z>
api != Opcodes.ASM6<z>
.ASM5<z>
&& api != Opcodes.ASM4<z>
{<z>
("Unsupported api " + api);<z>
api;<z>
.av = annotationVisitor;<z>
(MutablePropertyValues mpvs) {<z>
mpvs.getPropertyValues()) {<z>
= pv.getName();<z>
"[]")) {<z>
- 2);<z>
)) {<z>
);<z>
removePropertyValue(pv);<z>
Object annotatedElement,<z>
@Nullable AnnotationAttributes attributes, boolean classValuesAsString) {<z>
) {<z>
{<z>
();<z>
null) {<z>
0);<z>
; i++) {<z>
getMirrorSets().get(i);<z>
resolve(attributes.displayName, attributes,<z>
::getAttributeValueForMirrorResolution);<z>
-1) {<z>
resolved);<z>
);<z>
j++) {<z>
j);<z>
) {<z>
getName(),<z>
, classValuesAsString));<z>
) {<z>
;<z>
= attributeEntry.getValue();<z>
{<z>
= ((DefaultValueHolder) value).defaultValue;<z>
attributes.put(attributeName,<z>
, value, classValuesAsString));<z>
String, Object> createResultsMap() {<z>
()) {<z>
();<z>
new LinkedHashMap<>();<z>
Class<?> targetClass, boolean hasIntroductions) {<z>
pc, "Pointcut must not be null");<z>
targetClass)) {<z>
false;<z>
= pc.getMethodMatcher();<z>
.TRUE) {<z>
true;<z>
IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;<z>
{<z>
= (IntroductionAwareMethodMatcher) methodMatcher;<z>
classes = new LinkedHashSet<>();<z>
(targetClass)) {<z>
(targetClass));<z>
getAllInterfacesForClassAsSet(targetClass));<z>
{<z>
);<z>
methods) {<z>
!= null ?<z>
, hasIntroductions) :<z>
) {<z>
true;<z>
;<z>
{<z>
.isSessionLocallyTransacted(session)) {<z>
;<z>
JmsResourceHolder resourceHolder =<z>
obtainConnectionFactory());<z>
null || resourceHolder instanceof LocallyExposedJmsResourceHolder ||<z>
resourceHolder.containsSession(session));<z>
.protobuf.SecondMsg parseFrom(<z>
google.protobuf.ByteString data)<z>
.protobuf.InvalidProtocolBufferException {<z>
PARSER.parseFrom(data);<z>
{<z>
for (RequestPostProcessor postProcessor : this.postProcessors) {<z>
.postProcessRequest(request);<z>
return request;<z>
{<z>
1) {<z>
Arrays.sort(array, INSTANCE);<z>
entity) throws DataAccessException {<z>
executeWithNativeSession(session -> {<z>
(session);<z>
(entityName, entity);<z>
));<z>
(ServerHttpRequest request) {<z>
(request);<z>
= String.format(PARTIAL_HTML_CONTENT, callback);<z>
StandardCharsets.UTF_8);<z>
> findAutowireCandidates(<z>
) {<z>
= BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<z>
);<z>
(candidateNames.length);<z>
entrySet()) {<z>
.getKey();<z>
.isAssignableFrom(requiredType)) {<z>
= classObjectEntry.getValue();<z>
);<z>
{<z>
, autowiringValue);<z>
(String candidate : candidateNames) {<z>
) && isAutowireCandidate(candidate, descriptor)) {<z>
requiredType);<z>
(result.isEmpty()) {<z>
;<z>
();<z>
String candidate : candidateNames) {<z>
) &&<z>
))) {<z>
(result, candidate, descriptor, requiredType);<z>
) && !multiple) {<z>
candidate : candidateNames) {<z>
beanName, candidate) &&<z>
candidate)) &&<z>
, fallbackDescriptor)) {<z>
candidate, descriptor, requiredType);<z>
;<z>
n) throws IOException {<z>
> Integer.MAX_VALUE) {<z>
+ "): " + n);<z>
== 0) {<z>
0;<z>
0) {<z>
+ n);<z>
) n;<z>
{<z>
return 0;<z>
currentBufferLength) {<z>
this.nextIndexInCurrentBuffer);<z>
totalBytesRead += bytesToSkip;<z>
.nextIndexInCurrentBuffer += bytesToSkip;<z>
bytesToSkip));<z>
buffersIterator.hasNext()) {<z>
;<z>
updateCurrentBufferLength();<z>
.nextIndexInCurrentBuffer = 0;<z>
;<z>
return skip(len);<z>
, @Nullable Class<?> targetClass) {<z>
.getDeclaringClass() == Object.class) {<z>
null;<z>
getCacheKey(method, targetClass);<z>
;<z>
) {<z>
if (cached == NULL_TRANSACTION_ATTRIBUTE) {<z>
;<z>
cached;<z>
);<z>
txAttr == null) {<z>
.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);<z>
, targetClass);<z>
) {<z>
;<z>
.resolveAttributeStrings(this.embeddedValueResolver);<z>
isTraceEnabled()) {<z>
+ methodIdentification + "' with attribute: " + txAttr);<z>
.attributeCache.put(cacheKey, txAttr);<z>
;<z>
{<z>
()) {<z>
.page--;<z>
Log> loggers) {<z>
isFatalEnabled);<z>
, Log::isErrorEnabled);<z>
, Log::isWarnEnabled);<z>
Log::isInfoEnabled);<z>
= initLogger(loggers, Log::isDebugEnabled);<z>
::isTraceEnabled);<z>
public void setUrlDecode(boolean urlDecode) {<z>
.urlPathHelper.setUrlDecode(urlDecode);<z>
instanceof UrlBasedCorsConfigurationSource urlConfigSource) {<z>
(urlDecode);<z>
public void removeHeaders(String... headerPatterns) {<z>
ArrayList<>();<z>
) {<z>
pattern)){<z>
("*")){<z>
));<z>
(pattern);<z>
) {<z>
headerToRemove);<z>
) {<z>
boolean candidateFound = false;<z>
();<z>
) {<z>
AnnotationConfigUtils.attributesFor(importingClassMetadata, annType);<z>
) {<z>
("mode");<z>
("proxyTargetClass");<z>
AdviceMode.class == mode.getClass() &&<z>
)) {<z>
= true;<z>
== AdviceMode.PROXY) {<z>
AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);<z>
((Boolean) proxyTargetClass) {<z>
;<z>
)) {<z>
.getSimpleName();<z>
.format("%s was imported but no annotations were found " +<z>
, name, name));<z>
,<z>
{<z>
asyncContext, bufferFactory, bufferSize, request);<z>
) throws Throwable {<z>
;<z>
throw e;<z>
(Object originalName, Object newName) {<z>
)) {<z>
mappedObjectNames.remove(originalName);<z>
newName);<z>
exchange) {<z>
(name);<z>
.getParameterType());<z>
if (toAdapter != null) {<z>
== null) {<z>
toAdapter.supportsEmpty(),<z>
-> "No request attribute '" + name + "' and target type " +<z>
) + " doesn't support empty values.");<z>
.fromPublisher(Mono.empty());<z>
))) {<z>
;<z>
.getAdapter(value.getClass());<z>
!= null,<z>
.getSimpleName() + " doesn't support " +<z>
getGenericParameterType());<z>
toPublisher(value));<z>
;<z>
(<z>
HttpStatus status, WebRequest request) {<z>
status)) {<z>
);<z>
>(body, headers, status);<z>
private Mono<Void> processCommit(TransactionSynchronizationManager synchronizationManager,<z>
) throws TransactionException {<z>
AtomicBoolean();<z>
prepareForCommit(synchronizationManager, status)<z>
))<z>
.then(triggerBeforeCompletion(synchronizationManager, status))<z>
{<z>
(true);<z>
)) {<z>
isDebug()) {<z>
"Initiating transaction commit");<z>
(synchronizationManager, status);<z>
;<z>
.onErrorResume(ex -> {<z>
;<z>
Mono<Object> result = propagateException;<z>
(ex)) {<z>
status, TransactionSynchronization.STATUS_ROLLED_BACK)<z>
);<z>
{<z>
, TransactionSynchronization.STATUS_UNKNOWN)<z>
);<z>
test(ex)) {<z>
> mono;<z>
()) {<z>
, status);<z>
);<z>
, status, ex))<z>
propagateException);<z>
result;<z>
, status).onErrorResume(ex -><z>
(ex)))<z>
, TransactionSynchronization.STATUS_COMMITTED))));<z>
onErrorResume(ex -> cleanupAfterCompletion(synchronizationManager, status)<z>
));<z>
HttpServletRequest request) {<z>
) request.getAttribute(RequestDispatcher.INCLUDE_MAPPING);<z>
mapping == null) {<z>
= request.getHttpServletMapping();<z>
;<z>
equals("/*")));<z>
Throwable ex) {<z>
(logger.isDebugEnabled()) {<z>
sessionId, ex);<z>
);<z>
handleTransportError(this, ex);<z>
createAopProxy(AdvisedSupport config) throws AopConfigException {<z>
(!NativeDetector.inNativeImage() &&<z>
() || hasNoUserSuppliedProxyInterfaces(config))) {<z>
.getTargetClass();<z>
== null) {<z>
"TargetSource cannot determine target class: " +<z>
;<z>
|| Proxy.isProxyClass(targetClass)) {<z>
return new JdkDynamicAopProxy(config);<z>
new ObjenesisCglibAopProxy(config);<z>
new JdkDynamicAopProxy(config);<z>
{<z>
fqClassName, "Class name must not be null");<z>
= fqClassName.lastIndexOf(PACKAGE_SEPARATOR);<z>
"");<z>
) {<z>
?> beanType = null;<z>
(beanName);<z>
catch (Throwable ex) {<z>
isTraceEnabled()) {<z>
ex);<z>
null && isHandler(beanType)) {<z>
);<z>
throws JspException {<z>
.optionSource;<z>
entry : optionMap.entrySet()) {<z>
;<z>
getValue();<z>
.valueProperty != null ?<z>
.valueProperty) :<z>
);<z>
this.labelProperty != null ?<z>
(this.labelProperty) :<z>
;<z>
);<z>
RSocketRequester wrap(<z>
, MimeType metadataMimeType,<z>
{<z>
;<z>
attribute, String header) {<z>
nameAndValue = attribute.split("=");<z>
(nameAndValue.length == 2,<z>
0] + "' for Set-Cookie header '" + header + "'");<z>
1];<z>
contentType,<z>
outputMessage)<z>
IOException, HttpMessageNotWritableException {<z>
= getContentType(contentType);<z>
getHeaders().setContentType(selectedContentType);<z>
StreamingHttpOutputMessage streamingOutputMessage) {<z>
writeInternal(image, selectedContentType, outputStream));<z>
outputMessage.getBody());<z>
void postProcessBeanDefinition(AbstractBeanDefinition beanDefinition, String beanName) {<z>
(this.beanDefinitionDefaults);<z>
) {<z>
simpleMatch(this.autowireCandidatePatterns, beanName));<z>
request, Object... uriVariables)<z>
{<z>
);<z>
), uriVariables);<z>
getLocation() : null);<z>
@Nullable Object source) {<z>
getRegistry().containsBeanDefinition(HTTP_REQUEST_HANDLER_ADAPTER_BEAN_NAME)) {<z>
.class);<z>
adapterDef.setSource(source);<z>
);<z>
;<z>
;<z>
String description) {<z>
(byteArray, "Byte array must not be null");<z>
.byteArray = byteArray;<z>
? description : "");<z>
{<z>
super.hashCode();<z>
hashCode + this.container.hashCode();<z>
repeatable.hashCode();<z>
hashCode;<z>
String> messageSupplier) {<z>
!= null) {<z>
(Object element : collection) {<z>
) {<z>
IllegalArgumentException(nullSafeGet(messageSupplier));<z>
) {<z>
);<z>
CacheManager manager : this.cacheManagers) {<z>
(manager.getCacheNames());<z>
(names);<z>
() {<z>
.isEmpty()) {<z>
return new int[0];<z>
.batchUpdate(<z>
resolveSql(),<z>
() {<z>
getBatchSize() {<z>
;<z>
int index) throws SQLException {<z>
[] params = parameterQueue.removeFirst();<z>
ps);<z>
;<z>
int rowCount : rowsAffected) {<z>
checkRowsAffected(rowCount);<z>
) {<z>
rowCount);<z>
return rowsAffected;<z>
void clear() {<z>
.view = null;<z>
model = null;<z>
cleared = true;<z>
) {<z>
(logger.isInfoEnabled()) {<z>
, ex);<z>
(error);<z>
;<z>
{<z>
logger.isDebugEnabled()) {<z>
);<z>
Map<String, MediaType> mediaTypes) {<z>
mediaTypes != null) {<z>
mediaTypes.forEach(this::addMediaType);<z>
data, int offset, int length) {<z>
;<z>
this.data = data;<z>
;<z>
length;<z>
<Object> handleNoHandlerFoundException(<z>
status, WebRequest request) {<z>
status, request);<z>
) {<z>
-> {<z>
);<z>
getDefinedEncoding(response), matcher);<z>
registry) {<z>
, "BeanDefinitionRegistry must not be null");<z>
this.registry = registry;<z>
instanceof ResourceLoader) {<z>
) this.registry;<z>
.resourceLoader = new PathMatchingResourcePatternResolver();<z>
if (this.registry instanceof EnvironmentCapable) {<z>
) this.registry).getEnvironment();<z>
new StandardEnvironment();<z>
BeanFactory beanFactory) {<z>
instanceof ConfigurableListableBeanFactory)) {<z>
IllegalArgumentException(<z>
beanFactory);<z>
= (ConfigurableListableBeanFactory) beanFactory;<z>
null) {<z>
createDefaultBeanWiringInfoResolver();<z>
targetType,<z>
{<z>
mimeType, hints).toFuture();<z>
;<z>
failure;<z>
);<z>
ExecutionException ex) {<z>
.getCause();<z>
ex) {<z>
failure = ex;<z>
failure instanceof CodecException ? (CodecException) failure :<z>
failure));<z>
handleResolvedValue(<z>
MethodParameter parameter, Model model, ServerWebExchange exchange) {<z>
, ?> mm) {<z>
size());<z>
((key, value) -> {<z>
resolvedKey = resolveValueIfNecessary(argName, key);<z>
(argName, key), value);<z>
);<z>
);<z>
resolved;<z>
) {<z>
null) {<z>
);<z>
null;<z>
{<z>
{<z>
= new MutablePropertySources();<z>
(this.environment != null) {<z>
propertySources.addLast(<z>
>(ENVIRONMENT_PROPERTIES_PROPERTY_SOURCE_NAME, this.environment) {<z>
key) {<z>
.getProperty(key);<z>
localPropertySource =<z>
(LOCAL_PROPERTIES_PROPERTY_SOURCE_NAME, mergeProperties());<z>
(this.localOverride) {<z>
this.propertySources.addFirst(localPropertySource);<z>
.addLast(localPropertySource);<z>
{<z>
BeanInitializationException("Could not load properties", ex);<z>
this.propertySources));<z>
;<z>
descriptor) {<z>
length() == 1) {<z>
charAt(0));<z>
Class<?> declaringClass, AnnotationAttributes annAttrs) {<z>
"classes"),<z>
getBoolean("inheritLocations"),<z>
),<z>
));<z>
, DataBufferFactory bufferFactory,<z>
Nullable Map<String, Object> hints) {<z>
return Flux.from(inputStream)<z>
take(1)<z>
mimeType, hints))<z>
);<z>
@Nullable Token node) {<z>
node.kind == TokenKind.LITERAL_STRING) {<z>
return false;<z>
|| node.kind == TokenKind.IDENTIFIER) {<z>
;<z>
.stringValue();<z>
(value).matches());<z>
org.springframework.protobuf.Msg other) {<z>
return this;<z>
)) {<z>
bitField0_ |= 0x00000001;<z>
other.foo_;<z>
onChanged();<z>
(other.hasBlah()) {<z>
;<z>
mergeUnknownFields(other.getUnknownFields());<z>
return this;<z>
<Resource> result) {<z>
{<z>
url : urlClassLoader.getURLs()) {<z>
?<z>
(url) :<z>
.JAR_URL_SEPARATOR));<z>
exists()) {<z>
);<z>
catch (MalformedURLException ex) {<z>
.isDebugEnabled()) {<z>
.debug("Cannot search for matching files underneath [" + url +<z>
ex.getMessage());<z>
) {<z>
)) {<z>
("Cannot introspect jar files since ClassLoader [" + classLoader +<z>
ex);<z>
{<z>
(result);<z>
(classLoader != null) {<z>
(classLoader.getParent(), result);<z>
Exception ex) {<z>
.isDebugEnabled()) {<z>
+ classLoader +<z>
ex);<z>
setRollbackOnly() {<z>
.getTransaction();<z>
(tx.isActive()) {<z>
);<z>
) {<z>
.setRollbackOnly();<z>
) {<z>
length < 2) {<z>
.toStringAST();<z>
.toStringAST();<z>
) {<z>
isDebugEnabled()) {<z>
() +<z>
.getClass().getSimpleName());<z>
SpringSessionContext(SessionFactoryImplementor sessionFactory) {<z>
sessionFactory = sessionFactory;<z>
;<z>
);<z>
.transactionManager != null) {<z>
;<z>
ex) {<z>
warn(<z>
;<z>
List<T> existing, T element) {<z>
== null) {<z>
element);<z>
() + 1);<z>
.addAll(existing);<z>
;<z>
(merged);<z>
private NotAcceptable(String message, String statusText,<z>
charset) {<z>
charset);<z>
, Locale locale) throws NoSuchMessageException {<z>
null) {<z>
, args, locale);<z>
NoSuchMessageException(code, locale);<z>
) {<z>
.fromMessage(jmsMessage);<z>
catch (JMSException ex) {<z>
throw new MessageConversionException("Could not convert JMS message", ex);<z>
delegate, String id, HandshakeInfo info,<z>
Nullable Sinks.Empty<Void> handlerCompletionSink) {<z>
id, info, bufferFactory);<z>
= new WebSocketReceivePublisher();<z>
handlerCompletionSink;<z>
handlerCompletionMono = null;<z>
void onWebSocketFrame(Frame frame) {<z>
) {<z>
getOpCode()) {<z>
);<z>
(Type.PONG, buffer);<z>
), webSocketMessage);<z>
, String... values) {<z>
.notNull(name, "Parameter name must not be null");<z>
name);<z>
if (oldArr != null) {<z>
+ values.length];<z>
length);<z>
length);<z>
.parameters.put(name, newArr);<z>
, values);<z>
{<z>
;<z>
!= null) {<z>
.append(this.statusCode);<z>
{<z>
;<z>
();<z>
+ viewName + "\"" : this.view);<z>
.toString();<z>
,<z>
Nullable ErrorHandler errorHandler)<z>
{<z>
= factory.newDocumentBuilder();<z>
null) {<z>
(entityResolver);<z>
errorHandler != null) {<z>
docBuilder.setErrorHandler(errorHandler);<z>
docBuilder;<z>
beginTransaction(EntityManager entityManager, TransactionDefinition definition)<z>
{<z>
.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {<z>
class);<z>
;<z>
.begin();<z>
() && !this.lazyDatabaseTransaction) {<z>
class).beginEarlyTransaction();<z>
return null;<z>
asPlatformTransactionManager(@Nullable Object transactionManager) {<z>
instanceof PlatformTransactionManager) {<z>
;<z>
new IllegalStateException(<z>
);<z>
name() {<z>
getContentDisposition().getName();<z>
.state(name != null, "No name available");<z>
;<z>
{<z>
;<z>
SCOPE_PROTOTYPE);<z>
());<z>
BeanWrapperImpl(existingBean);<z>
initBeanWrapper(bw);<z>
, bw);<z>
() {<z>
this.connection == null) {<z>
(Connection.class);<z>
.connection;<z>
void setRollbackOnly() {<z>
).setRollbackOnly();<z>
(hasConnectionHolder()) {<z>
;<z>
() {<z>
{<z>
();<z>
Map<?, ?> properties)<z>
DataAccessResourceFailureException {<z>
, properties, true);<z>
PersistenceException ex) {<z>
throw new DataAccessResourceFailureException("Could not obtain JPA EntityManager", ex);<z>
() {<z>
"new ");<z>
= 0;<z>
(index++).toStringAST());<z>
('(');<z>
++) {<z>
if (i > index) {<z>
(',');<z>
());<z>
')');<z>
();<z>
InternetAddress[] bcc) throws MessagingException {<z>
(bcc, "Bcc address array must not be null");<z>
bcc);<z>
.BCC, bcc);<z>
(<z>
) {<z>
= new HashSet<>(incorrectSet);<z>
;<z>
(!tempSet.isEmpty()) {<z>
("Set has too many elements:\n");<z>
(Object element : tempSet) {<z>
'-');<z>
;<z>
append('\n');<z>
(assertionSet);<z>
(incorrectSet);<z>
()) {<z>
.append("Set is missing elements:\n");<z>
tempSet) {<z>
'-');<z>
;<z>
sb.append('\n');<z>
public void afterConcurrentHandlingStarted(WebRequest request) {<z>
(request)) {<z>
obtainSessionFactory());<z>
writeComplete(AbstractListenerWriteFlushProcessor<T> processor) {<z>
flush();<z>
(Throwable ex) {<z>
ex);<z>
changeState(this, REQUESTED)) {<z>
processor.sourceCompleted) {<z>
processor);<z>
!= null, "No subscription");<z>
processor.subscription.request(1);<z>
public ClientHttpRequestFactory getRequestFactory() {<z>
interceptors = getInterceptors();<z>
) {<z>
ClientHttpRequestFactory factory = this.interceptingRequestFactory;<z>
(factory == null) {<z>
getRequestFactory(), interceptors);<z>
= factory;<z>
return factory;<z>
getRequestFactory();<z>
protected void writeFrame(SockJsFrame frame) throws SockJsTransportFailureException {<z>
logger.isTraceEnabled()) {<z>
.trace("Preparing to write " + frame);<z>
frame);<z>
{<z>
;<z>
);<z>
(Throwable disconnectFailure) {<z>
);<z>
catch (Throwable closeFailure) {<z>
getId(), ex);<z>
(String beanName) {<z>
;<z>
startsWith("/")) {<z>
urls.add(beanName);<z>
;<z>
alias : aliases) {<z>
)) {<z>
alias);<z>
toStringArray(urls);<z>
public void setAutodetectMode(int autodetectMode) {<z>
).contains(autodetectMode)) {<z>
;<z>
autodetectMode = autodetectMode;<z>
boolean htmlEscape) {<z>
getLocale());<z>
== null) {<z>
;<z>
);<z>
Method bridgeMethod) {<z>
?> ifc : interfaces) {<z>
(ifc, bridgeMethod);<z>
null && !method.isBridge()) {<z>
method;<z>
ifc.getInterfaces(), bridgeMethod);<z>
if (method != null) {<z>
return method;<z>
;<z>
{<z>
)));<z>
PAGE_SCOPE);<z>
;<z>
.errorMessagesWereExposed = true;<z>
writeMetaData() {<z>
metadataCollector.getMetadata();<z>
{<z>
metadataStore.writeMetadata(metadata);<z>
catch (IOException ex) {<z>
);<z>
boolean fullMatch,<z>
) {<z>
.pathSeparator)) {<z>
;<z>
= tokenizePattern(pattern);<z>
!isPotentialMatch(path, pattDirs)) {<z>
return false;<z>
(path);<z>
;<z>
- 1;<z>
0;<z>
length - 1;<z>
<= pathIdxEnd) {<z>
[pattIdxStart];<z>
)) {<z>
], uriTemplateVariables)) {<z>
return false;<z>
;<z>
;<z>
> pathIdxEnd) {<z>
if (pattIdxStart > pattIdxEnd) {<z>
endsWith(this.pathSeparator));<z>
) {<z>
true;<z>
) {<z>
;<z>
{<z>
.equals("**")) {<z>
;<z>
true;<z>
) {<z>
false;<z>
equals(pattDirs[pattIdxStart])) {<z>
true;<z>
pathIdxStart <= pathIdxEnd) {<z>
;<z>
) {<z>
pathDirs[pathIdxEnd], uriTemplateVariables)) {<z>
return false;<z>
--;<z>
;<z>
pathIdxEnd) {<z>
<= pattIdxEnd; i++) {<z>
"**")) {<z>
false;<z>
;<z>
<= pathIdxEnd) {<z>
-1;<z>
; i <= pattIdxEnd; i++) {<z>
) {<z>
i;<z>
+ 1) {<z>
++;<z>
- 1);<z>
= (pathIdxEnd - pathIdxStart + 1);<z>
;<z>
++) {<z>
0; j < patLength; j++) {<z>
;<z>
pathIdxStart + i + j];<z>
subStr, uriTemplateVariables)) {<z>
;<z>
pathIdxStart + i;<z>
{<z>
false;<z>
;<z>
+ patLength;<z>
pattIdxEnd; i++) {<z>
.equals("**")) {<z>
;<z>
;<z>
throws InvalidDataAccessApiUsageException, DataRetrievalFailureException {<z>
keyList.isEmpty()) {<z>
return null;<z>
) {<z>
InvalidDataAccessApiUsageException(<z>
.keyList);<z>
iterator();<z>
) {<z>
keyIter.next();<z>
))) {<z>
(<z>
getName() : null) +<z>
) + "].");<z>
);<z>
DataRetrievalFailureException("Unable to retrieve the generated key. " +<z>
);<z>
) throws IOException {<z>
(this.cacheDir != null) {<z>
is, this.cacheDir);<z>
is);<z>
cloneIfNecessary() {<z>
AutowireCandidateResolver) clone();<z>
{<z>
);<z>
Nullable String beanName) {<z>
;<z>
DefaultListableBeanFactory,<z>
;<z>
final DefaultListableBeanFactory dlbf = (DefaultListableBeanFactory) beanFactory;<z>
) {<z>
<?> getTargetClass() {<z>
();<z>
{<z>
false;<z>
Object getTarget() {<z>
LinkedHashSet<>(1) : null);<z>
autowiredBeanNames, null);<z>
if (target == null) {<z>
);<z>
if (Map.class == type) {<z>
;<z>
else if (List.class == type) {<z>
emptyList();<z>
Collection.class == type) {<z>
();<z>
getResolvableType(),<z>
;<z>
null) {<z>
String autowiredBeanName : autowiredBeanNames) {<z>
autowiredBeanName)) {<z>
beanName);<z>
return target;<z>
releaseTarget(Object target) {<z>
ProxyFactory();<z>
.setTargetSource(ts);<z>
();<z>
(dependencyType.isInterface()) {<z>
pf.addInterface(dependencyType);<z>
));<z>
<HandlerExceptionResolver> exceptionResolvers) {<z>
(WebMvcConfigurer delegate : this.delegates) {<z>
delegate.extendHandlerExceptionResolvers(exceptionResolvers);<z>
public PollingSockJsSession(String sessionId, SockJsServiceConfig config,<z>
String, Object> attributes) {<z>
sessionId, config, wsHandler, attributes);<z>
void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {<z>
;<z>
();<z>
String methodName = metadata.getMethodName();<z>
{<z>
(methodName);<z>
.skippedBeanMethods.contains(methodName)) {<z>
metadata, Bean.class);<z>
, "No @Bean annotation attributes");<z>
getStringArray("name")));<z>
0) : methodName);<z>
alias : names) {<z>
registry.registerAlias(beanName, alias);<z>
(beanMethod, beanName)) {<z>
)) {<z>
getResource().getDescription(),<z>
.getMethodName() +<z>
);<z>
configClass, metadata, beanName);<z>
, configClass.getResource()));<z>
isStatic()) {<z>
() instanceof StandardAnnotationMetadata) {<z>
()).getIntrospectedClass());<z>
;<z>
setUniqueFactoryMethodName(methodName);<z>
);<z>
;<z>
) {<z>
).getIntrospectedMethod());<z>
AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);<z>
);<z>
autowireCandidate = bean.getBoolean("autowireCandidate");<z>
!autowireCandidate) {<z>
setAutowireCandidate(false);<z>
= bean.getString("initMethod");<z>
{<z>
setInitMethodName(initMethodName);<z>
);<z>
);<z>
ScopedProxyMode.NO;<z>
Scope.class);<z>
) {<z>
"value"));<z>
attributes.getEnum("proxyMode");<z>
ScopedProxyMode.DEFAULT) {<z>
ScopedProxyMode.NO;<z>
beanDef;<z>
NO) {<z>
ScopedProxyCreator.createScopedProxy(<z>
, beanName), this.registry,<z>
);<z>
new ConfigurationClassBeanDefinition(<z>
metadata, beanName);<z>
logger.isTraceEnabled()) {<z>
"Registering bean definition for @Bean method %s.%s()",<z>
, beanName));<z>
beanName, beanDefToRegister);<z>
throws IOException {<z>
(shouldNotSend()) {<z>
add(message);<z>
));<z>
preSendCallback != null) {<z>
preSendCallback.accept(message);<z>
if (!tryFlushMessageBuffer()) {<z>
) {<z>
+<z>
getTimeSinceSendStarted(), getBufferSize()));<z>
;<z>
shouldNotSend());<z>
{<z>
(this.map) {<z>
);<z>
) {<z>
();<z>
.put(name, scopedObject);<z>
scopedObject;<z>
TransactionDefinition definition) {<z>
= (JtaTransactionObject) transaction;<z>
txObject, definition);<z>
) {<z>
NestedTransactionNotSupportedException(<z>
, ex);<z>
ex) {<z>
;<z>
?> findAutowiredAnnotation(AccessibleObject ao) {<z>
= MergedAnnotations.from(ao);<z>
type : this.autowiredAnnotationTypes) {<z>
get(type);<z>
()) {<z>
;<z>
return null;<z>
protected PropertyEditor getCustomEditor(String fixedField) {<z>
fixedField);<z>
);<z>
editor == null) {<z>
= BeanUtils.findEditorByConvention(targetType);<z>
;<z>
public OutputStream getOutputStream() throws IOException {<z>
isDirectory(this.path)) {<z>
(getPath() + " (is a directory)");<z>
path);<z>
) {<z>
== null) {<z>
;<z>
(this.viewResolverRegistry);<z>
viewResolverRegistry;<z>
> message) {<z>
();<z>
.class.isAssignableFrom(paramType)) {<z>
return message.getHeaders();<z>
else if (MessageHeaderAccessor.class == paramType) {<z>
(message, MessageHeaderAccessor.class);<z>
;<z>
) {<z>
getAccessor(message, MessageHeaderAccessor.class);<z>
{<z>
;<z>
class);<z>
method == null) {<z>
throw new IllegalStateException(<z>
message);<z>
invokeMethod(method, null, message);<z>
paramType +<z>
+ ". ");<z>
{<z>
.notNull(headers, "Headers must not be null");<z>
;<z>
;<z>
new FileContent(file, scheduler));<z>
{<z>
key);<z>
.notNull(value, "Value must not be null");<z>
.get();<z>
{<z>
new HashMap<>();<z>
resources.set(map);<z>
;<z>
) {<z>
;<z>
oldValue != null) {<z>
throw new IllegalStateException(<z>
+ actualKey + "] bound to thread");<z>
<Object> handleHttpRequestMethodNotSupported(<z>
HttpStatus status, WebRequest request) {<z>
());<z>
ex.getSupportedHttpMethods();<z>
supportedMethods)) {<z>
supportedMethods);<z>
, request);<z>
{<z>
super.write(b);<z>
;<z>
;<z>
(String url, @Nullable Object request,<z>
Object... uriVariables) throws RestClientException {<z>
= httpEntityCallback(request, responseType);<z>
T>> responseExtractor = responseEntityExtractor(responseType);<z>
;<z>
{<z>
if (exceptionToMatch.equals(declaredException)) {<z>
return depth;<z>
) {<z>
;<z>
+ 1);<z>
convertFromBytesMessage(BytesMessage message, JavaType targetJavaType)<z>
throws JMSException, IOException {<z>
String encoding = this.encoding;<z>
{<z>
(this.encodingPropertyName);<z>
];<z>
(bytes);<z>
) {<z>
= new String(bytes, encoding);<z>
, targetJavaType);<z>
UnsupportedEncodingException ex) {<z>
, ex);<z>
targetJavaType);<z>
>... fieldTypes) {<z>
adapter = new FormatterPropertyEditorAdapter(formatter);<z>
.isEmpty(fieldTypes)) {<z>
), adapter);<z>
: fieldTypes) {<z>
adapter);<z>
public ServerResponseResultHandler serverResponseResultHandler(ServerCodecConfigurer serverCodecConfigurer) {<z>
.getViewResolvers();<z>
);<z>
());<z>
handler.setViewResolvers(resolvers);<z>
return handler;<z>
Exception {<z>
interceptor : this.interceptors) {<z>
request, deferredResult);<z>
preProcessingIndex++;<z>
annotationIntrospector(<z>
AnnotationIntrospector> pairingFunction) {<z>
.apply(this.annotationIntrospector);<z>
;<z>
(BitSet bits, String value) {<z>
max = 12;<z>
= replaceOrdinals(value, "FOO,JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC");<z>
13);<z>
;<z>
; i <= max; i++) {<z>
(months.get(i)) {<z>
);<z>
<String, ?> uriVariables) throws RestClientException {<z>
requestCallback = acceptHeaderRequestCallback(responseType);<z>
=<z>
(), logger);<z>
, uriVariables);<z>
public void setExcludedPatterns(String... excludedPatterns) {<z>
Assert.notEmpty(excludedPatterns, "'excludedPatterns' must not be empty");<z>
length];<z>
i++) {<z>
excludedPatterns[i].strip();<z>
;<z>
fragment(@Nullable String fragment) {<z>
{<z>
);<z>
;<z>
this.fragment = null;<z>
return this;<z>
{<z>
) {<z>
;<z>
isStoresUpperCaseIdentifiers()) {<z>
catalogName.toUpperCase();<z>
(isStoresLowerCaseIdentifiers()) {<z>
();<z>
return catalogName;<z>
setRequiredFields(@Nullable String... requiredFields) {<z>
);<z>
if (logger.isDebugEnabled()) {<z>
debug("DataBinder requires binding of required fields [" +<z>
requiredFields) + "]");<z>
() {<z>
this.request);<z>
.request))) {<z>
.getOriginatingServletPath(this.request);<z>
;<z>
(@Nullable Class<?> exClass) {<z>
(super.contains(exClass)) {<z>
return true;<z>
this.relatedCauses != null) {<z>
relatedCause : this.relatedCauses) {<z>
instanceof NestedRuntimeException &&<z>
) {<z>
return true;<z>
return false;<z>
DataBuffer dataBuffer) {<z>
pos++) {<z>
;<z>
match(b)) {<z>
reset();<z>
pos;<z>
;<z>
{<z>
.beanFactory instanceof ListableBeanFactory lbf) {<z>
.class);<z>
{<z>
) lbf.getBean(beanName);<z>
())) {<z>
return schedulerBean;<z>
);<z>
(schedulerInRepo == null) {<z>
schedulerName + "' found");<z>
return schedulerInRepo;<z>
inputStreamSource)<z>
{<z>
).getContentType(attachmentFilename);<z>
(attachmentFilename, inputStreamSource, contentType);<z>
String name) {<z>
;<z>
{<z>
target).getHeaders() : null;<z>
instanceof MessageHeaders headers) {<z>
SimpMessageHeaderAccessor accessor =<z>
;<z>
);<z>
if ("destination".equalsIgnoreCase(name)) {<z>
= accessor.getDestination();<z>
);<z>
null) {<z>
);<z>
);<z>
new TypedValue(value);<z>
String> getBodyAsString() {<z>
())<z>
{<z>
.toString(getCharset());<z>
release(buffer);<z>
return s;<z>
.defaultIfEmpty("");<z>
String name) throws AccessException {<z>
!= null, "Target must not be null");<z>
());<z>
("length")) {<z>
(target instanceof Class) {<z>
AccessException("Cannot access length on array class itself");<z>
getLength(target));<z>
target instanceof Class);<z>
.readerCache.get(cacheKey);<z>
this.lastReadInvokerPair = invoker;<z>
{<z>
invoker.member : null);<z>
{<z>
;<z>
null) {<z>
, method, null);<z>
;<z>
method);<z>
);<z>
lastReadInvokerPair = invoker;<z>
put(cacheKey, invoker);<z>
null) {<z>
(method);<z>
);<z>
value));<z>
) {<z>
"' through getter method", ex);<z>
{<z>
;<z>
field == null) {<z>
type, target);<z>
) {<z>
(field));<z>
;<z>
;<z>
) {<z>
ReflectionUtils.makeAccessible(field);<z>
Object value = field.get(target);<z>
);<z>
{<z>
, ex);<z>
name + "'");<z>
getURL() throws IOException {<z>
= resolveURL();<z>
null) {<z>
);<z>
url;<z>
String conditionExpression, ApplicationEvent event, Method targetMethod,<z>
BeanFactory beanFactory) {<z>
root = new EventExpressionRootObject(event, args);<z>
MethodBasedEvaluationContext evaluationContext = new MethodBasedEvaluationContext(<z>
getParameterNameDiscoverer());<z>
{<z>
));<z>
(<z>
;<z>
, boolean nullAsEmptyMap) {<z>
notNull(mapType, "Map type is required");<z>
(mapType)) {<z>
(<z>
+ mapType.getName() + "] does not implement [java.util.Map]");<z>
= mapType;<z>
this.nullAsEmptyMap = nullAsEmptyMap;<z>
MvcResult result) {<z>
);<z>
instanceof HandlerMethod);<z>
(HandlerMethod) handler;<z>
HttpServletRequest request) {<z>
.patterns.iterator();<z>
other.getPatterns().iterator();<z>
.hasNext()) {<z>
());<z>
{<z>
return result;<z>
iterator.hasNext()) {<z>
;<z>
) {<z>
1;<z>
;<z>
Annotation[] getParameterAnnotations() {<z>
.combinedAnnotations;<z>
{<z>
);<z>
).getDeclaredField(this.parameterName);<z>
();<z>
> 0) {<z>
);<z>
addAll(Arrays.asList(anns));<z>
fieldAnn : fieldAnns) {<z>
existingType = false;<z>
{<z>
) == fieldAnn.annotationType()) {<z>
existingType = true;<z>
if (!existingType) {<z>
fieldAnn);<z>
]);<z>
| SecurityException ex) {<z>
;<z>
return anns;<z>
{<z>
checkIfConfigurationModificationIsAllowed();<z>
clear();<z>
.declaredColumns.addAll(columnNames);<z>
Nullable ProtectionDomain pd) {<z>
byte[] result = bytes;<z>
this.transformers) {<z>
pd, result);<z>
if (transformed != null) {<z>
= transformed;<z>
(IllegalClassFormatException ex) {<z>
ex);<z>
return result;<z>
List methods, List interfaceMethods, Set forcePublic) {<z>
(superclass, methods);<z>
(interfaceMethods != null) ? interfaceMethods : methods;<z>
{<z>
interfaces.length; i++) {<z>
.class) {<z>
[i], target);<z>
interfaceMethods != null) {<z>
{<z>
;<z>
(interfaceMethods);<z>
);<z>
);<z>
methods, new DuplicatesPredicate());<z>
new RejectModifierPredicate(Constants.ACC_FINAL));<z>
(Member member, @Nullable PropertyDescriptor pd) {<z>
member;<z>
member instanceof Field);<z>
pd = pd;<z>
(String[] array) {<z>
.isEmpty(array)) {<z>
;<z>
;<z>
.length; i++) {<z>
element = array[i];<z>
;<z>
;<z>
DefaultMessageSourceResolvable(<z>
, @Nullable String defaultMessage) {<z>
codes;<z>
this.arguments = arguments;<z>
= defaultMessage;<z>
supportsEvent(<z>
, String listenerBeanName, ResolvableType eventType) {<z>
);<z>
listenerType) ||<z>
.isAssignableFrom(listenerType)) {<z>
;<z>
listenerType, eventType)) {<z>
;<z>
(listenerBeanName);<z>
;<z>
isAssignableFrom(eventType));<z>
catch (NoSuchBeanDefinitionException ex) {<z>
;<z>
protected String resolveCssClass() throws JspException {<z>
(getCssErrorClass())) {<z>
;<z>
evaluate("cssClass", getCssClass()));<z>
StandardTypeLocator(@Nullable ClassLoader classLoader) {<z>
= classLoader;<z>
"java.lang");<z>
contextPath(String contextPath) {<z>
"'contextPath' must not be null");<z>
contextPath;<z>
this;<z>
{<z>
headers instanceof HttpFields.Mutable mutableHttpFields)) {<z>
throw new IllegalStateException("Immutable headers");<z>
mutableHttpFields.clear();<z>
() {<z>
) {<z>
.maxConcurrentConsumers;<z>
) {<z>
) {<z>
IllegalStateException("Specify either 'activationSpecFactory' or " +<z>
;<z>
();<z>
(this.resourceAdapter != null) {<z>
resourceAdapter);<z>
null) {<z>
.setActivationSpecFactory(this.activationSpecFactory);<z>
this.destinationResolver != null) {<z>
(this.destinationResolver);<z>
.transactionManager != null) {<z>
.transactionManager);<z>
) {<z>
(this.phase);<z>
setActivationSpecConfig(this);<z>
instance);<z>
return instance;<z>
delay, long period, boolean fixedRate) {<z>
executorTask;<z>
delay;<z>
period;<z>
.fixedRate = fixedRate;<z>
SuffixByteRange(long suffixLength) {<z>
0) {<z>
IllegalArgumentException("Invalid suffix length: " + suffixLength);<z>
suffixLength;<z>
private static <T> T[] copyPropertiesToBeanArray(<z>
{<z>
);<z>
i = 0;<z>
: anns) {<z>
, beanClass);<z>
beans;<z>
(ProcessingInstruction pi) throws SAXException {<z>
!= null) {<z>
));<z>
AnnotatedTypeMetadata metadata) {<z>
), true);<z>
);<z>
: Collections.emptyList());<z>
EvaluationException {<z>
overloader = this.relatedContext.getOperatorOverloader();<z>
{<z>
right);<z>
(returnValue);<z>
getClass().getName());<z>
getName());<z>
, rightType);<z>
(<z>
?> message) {<z>
) {<z>
message);<z>
bufferFactory = (DataBufferFactory) message.getHeaders()<z>
HandlerMethodReturnValueHandler.DATA_BUFFER_FACTORY_HEADER,<z>
DefaultDataBufferFactory.sharedInstance);<z>
.get(MessageHeaders.CONTENT_TYPE);<z>
= encodeContent(<z>
, mimeType, Collections.emptyMap());<z>
publisher -><z>
publisher), returnType, message));<z>
<? extends Annotation> annotationType)<z>
BeansException {<z>
getBeansWithAnnotation(annotationType);<z>
Object actual) {<z>
(expected, actual)) {<z>
+ " was not expected to be:" +<z>
.nullSafeToString(actual) + ">");<z>
) throws BeansException, IOException {<z>
(beanFactory);<z>
());<z>
);<z>
beanDefinitionReader);<z>
beanDefinitionReader);<z>
String beanClassName, @Nullable String factoryMethodName) {<z>
());<z>
);<z>
.beanDefinition.setFactoryMethodName(factoryMethodName);<z>
builder;<z>
> messageReaders) {<z>
() {<z>
) {<z>
return messageReaders;<z>
() {<z>
return Collections.emptyList();<z>
;<z>
> getPropertyType(String propertyName) throws BeansException {<z>
ph = getPropertyHandler(propertyName);<z>
null) {<z>
;<z>
Object value = getPropertyValue(propertyName);<z>
value != null) {<z>
.getClass();<z>
= guessPropertyTypeFromEditors(propertyName);<z>
!= null) {<z>
;<z>
ex) {<z>
return null;<z>
ResolvableType elementType,<z>
> hints) {<z>
Object> allHints = Hints.merge(hints,<z>
));<z>
;<z>
(<z>
, Class<?> targetClass) {<z>
new CacheOperationCacheKey(operation, method, targetClass);<z>
this.metadataCache.get(cacheKey);<z>
(metadata == null) {<z>
operationKeyGenerator;<z>
(operation.getKeyGenerator())) {<z>
);<z>
= getKeyGenerator();<z>
operationCacheResolver;<z>
)) {<z>
), CacheResolver.class);<z>
))) {<z>
CacheManager.class);<z>
operationCacheResolver = new SimpleCacheResolver(cacheManager);<z>
);<z>
.state(operationCacheResolver != null, "No CacheResolver/CacheManager set");<z>
= new CacheOperationMetadata(operation, method, targetClass,<z>
;<z>
;<z>
;<z>
, PathMatcher pathMatcher) {<z>
isPathContainer) {<z>
PathContainer pathContainer = (PathContainer) path;<z>
{<z>
pathPattern.matches(pathContainer);<z>
();<z>
.removeSemicolonContent(lookupPath);<z>
this.patternString, (String) path);<z>
contributeMethodArgument(MethodParameter parameter, Object value,<z>
, Object> uriVariables, ConversionService conversionService) {<z>
).getNestedParameterType())) {<z>
.class);<z>
() : parameter.getParameterName());<z>
, value);<z>
uriVariables.put(name, formatted);<z>
entity) throws DataAccessException {<z>
(session -> {<z>
;<z>
session.persist(entity);<z>
;<z>
);<z>
WebClient build() {<z>
=<z>
connector : initConnector());<z>
?<z>
initExchangeStrategies()) :<z>
);<z>
stream()<z>
reduce(ExchangeFilterFunction::andThen)<z>
(exchange))<z>
exchange);<z>
HttpHeaders defaultHeaders = copyDefaultHeaders();<z>
();<z>
DefaultWebClient(filteredExchange, initUriBuilderFactory(),<z>
(this));<z>
