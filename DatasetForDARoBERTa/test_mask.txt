public MethodVisitor visitMethod(<z>
signature, String[] exceptions) {<z>
) || name.equals("<init>")) {<z>
;<z>
this.classLoader, this.className,<z>
declaredMethods::add);<z>
rejectInvalid) {<z>
(headerName);<z>
null) {<z>
return null;<z>
.length() >= 3) {<z>
;<z>
(parametersIndex != -1) {<z>
.substring(0, parametersIndex);<z>
(DateTimeFormatter dateFormatter : DATE_PARSERS) {<z>
return ZonedDateTime.parse(headerValue, dateFormatter);<z>
catch (DateTimeParseException ex) {<z>
{<z>
+ headerValue +<z>
+ headerName + "\" header");<z>
null;<z>
final ByteVector output) {<z>
output.putShort(getExceptionTableLength(firstHandler));<z>
= firstHandler;<z>
(handler != null) {<z>
(handler.startPc.bytecodeOffset)<z>
handler.endPc.bytecodeOffset)<z>
(handler.handlerPc.bytecodeOffset)<z>
);<z>
;<z>
void setupMessageListener(Object messageListener) {<z>
if (messageListener instanceof MessageListener) {<z>
;<z>
+<z>
getName() +<z>
);<z>
field) {<z>
)) {<z>
(field);<z>
getNestedPath();<z>
path.endsWith(Errors.NESTED_PATH_SEPARATOR) ?<z>
NESTED_PATH_SEPARATOR.length()) : path);<z>
<?>[] parameterTypes,<z>
, ResourceLoader resourceLoader,<z>
classLoader) {<z>
parameterTypes.length];<z>
i++) {<z>
[i], environment,<z>
registry, classLoader);<z>
;<z>
(String viewName) throws Exception {<z>
;<z>
if (this.alwaysInclude != null) {<z>
setAlwaysInclude(this.alwaysInclude);<z>
;<z>
return view;<z>
, BeanDefinitionBuilder builder) {<z>
false);<z>
new ManagedList<>();<z>
> fixedDelayTaskList = new ManagedList<>();<z>
>();<z>
triggerTaskList = new ManagedList<>();<z>
();<z>
.getLength(); i++) {<z>
i);<z>
isScheduledElement(child, parserContext)) {<z>
;<z>
;<z>
taskElement.getAttribute("method");<z>
!StringUtils.hasText(method)) {<z>
().error("Both 'ref' and 'method' are required", taskElement);<z>
cronAttribute = taskElement.getAttribute("cron");<z>
fixedDelayAttribute = taskElement.getAttribute("fixed-delay");<z>
.getAttribute("fixed-rate");<z>
triggerAttribute = taskElement.getAttribute("trigger");<z>
;<z>
.hasText(cronAttribute);<z>
= StringUtils.hasText(fixedDelayAttribute);<z>
fixedRateAttribute);<z>
);<z>
(initialDelayAttribute);<z>
{<z>
error(<z>
taskElement);<z>
hasTriggerAttribute)) {<z>
parserContext.getReaderContext().error(<z>
, taskElement);<z>
String runnableName =<z>
);<z>
if (hasFixedDelayAttribute) {<z>
intervalTaskReference(runnableName,<z>
fixedDelayAttribute, taskElement, parserContext));<z>
if (hasFixedRateAttribute) {<z>
(runnableName,<z>
;<z>
if (hasCronAttribute) {<z>
(runnableName, cronAttribute,<z>
, parserContext));<z>
(hasTriggerAttribute) {<z>
();<z>
(runnableName, triggerName,<z>
));<z>
"scheduler");<z>
schedulerRef)) {<z>
addPropertyReference("taskScheduler", schedulerRef);<z>
.addPropertyValue("cronTasksList", cronTaskList);<z>
("fixedDelayTasksList", fixedDelayTaskList);<z>
, fixedRateTaskList);<z>
triggerTaskList);<z>
{<z>
(this == other) {<z>
true;<z>
other instanceof NullSafeComparator)) {<z>
;<z>
<T>) other;<z>
nullsLow == otherComp.nullsLow);<z>
constructorArgs) {<z>
beanName = beanName;<z>
= clazz;<z>
this.constructorArgs = constructorArgs;<z>
propertyPath) {<z>
.indexOf(PropertyAccessor.PROPERTY_KEY_PREFIX_CHAR);<z>
1) {<z>
;<z>
(endIndex != -1) {<z>
(0, startIndex);<z>
startIndex, endIndex + 1);<z>
1);<z>
prefix + suffix);<z>
, nestedPath + prefix, suffix);<z>
suffix);<z>
throws InvalidResultSetAccessException {<z>
.isLast();<z>
SQLException se) {<z>
InvalidResultSetAccessException(se);<z>
Element element,<z>
source) {<z>
);<z>
!StringUtils.hasText(locationAttr)) {<z>
element));<z>
null;<z>
new RootBeanDefinition(ResourceHttpRequestHandler.class);<z>
.setSource(source);<z>
(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
getPropertyValues();<z>
add("urlPathHelper", pathHelperRef);<z>
));<z>
element.getAttribute("cache-period");<z>
)) {<z>
cacheSeconds);<z>
.getChildElementByTagName(element, "cache-control");<z>
(cacheControlElement != null) {<z>
;<z>
, cacheControl);<z>
(element, "resource-chain");<z>
!= null) {<z>
resourceHandlerDef, context, resourceChainElement, source);<z>
context);<z>
!= null) {<z>
;<z>
getReaderContext().generateBeanName(resourceHandlerDef);<z>
);<z>
beanName));<z>
;<z>
(@Nullable Object other) {<z>
) {<z>
;<z>
.getClass()) {<z>
false;<z>
other;<z>
this.isNegated == otherExpr.isNegated);<z>
, ValueHolder newValue) {<z>
"Index must not be negative");<z>
);<z>
index, newValue);<z>
(ResolvableType elementType, @Nullable MediaType mediaType) {<z>
(MULTIPART_VALUE_TYPE.isAssignableFrom(elementType)) {<z>
if (mediaType == null) {<z>
true;<z>
MediaType supportedMediaType : MIME_TYPES) {<z>
mediaType)) {<z>
true;<z>
return false;<z>
{<z>
) == null) {<z>
);<z>
Element element) {<z>
element)) {<z>
;<z>
!= null) {<z>
, stereotypes, next);<z>
(MockHttpServletRequest request) throws Exception {<z>
.getCharacterEncoding() != null ?<z>
) : MISSING_CHARACTER_ENCODING);<z>
"HTTP Method", request.getMethod());<z>
, request.getRequestURI());<z>
(request));<z>
printValue("Headers", getRequestHeaders(request));<z>
body);<z>
getSessionAttributes(request));<z>
>>, ServerHttpRequest> toMultipartData() {<z>
) -> {<z>
elementType = MULTIPART_DATA_TYPE;<z>
MediaType.MULTIPART_FORM_DATA;<z>
, mediaType, context);<z>
context, elementType, reader);<z>
) {<z>
return result -> {<z>
(result).getModelMap());<z>
;<z>
StaxResult(XMLEventWriter eventWriter) {<z>
StaxEventHandler(eventWriter);<z>
;<z>
.setLexicalHandler(handler);<z>
eventWriter;<z>
void registerAlias(String name, String alias) {<z>
.hasText(name, "'name' must not be empty");<z>
hasText(alias, "'alias' must not be empty");<z>
(this.aliasMap) {<z>
(name)) {<z>
(alias);<z>
logger.isDebugEnabled()) {<z>
+ "' ignored since it points to same name");<z>
(alias);<z>
!= null) {<z>
if (registeredName.equals(name)) {<z>
if (!allowAliasOverriding()) {<z>
alias + "' for name '" +<z>
+ "'.");<z>
.isDebugEnabled()) {<z>
debug("Overriding alias '" + alias + "' definition for registered name '" +<z>
+ "' with new target name '" + name + "'");<z>
);<z>
, name);<z>
{<z>
name + "'");<z>
() {<z>
= peekToken();<z>
) {<z>
false;<z>
TokenKind.SELECT_LAST);<z>
() throws JMSException {<z>
ConnectionFactory cf = getTargetConnectionFactory();<z>
.pubSubMode) && cf instanceof QueueConnectionFactory) {<z>
QueueConnectionFactory) cf).createQueueConnection();<z>
cf instanceof TopicConnectionFactory) {<z>
(TopicConnectionFactory) cf).createTopicConnection();<z>
;<z>
, Type resolvedType, Writer writer) {<z>
ParameterizedType) {<z>
;<z>
payload, writer);<z>
String personal) throws MessagingException, UnsupportedEncodingException {<z>
.notNull(bcc, "Bcc address must not be null");<z>
(getEncoding() != null ?<z>
getEncoding()) :<z>
;<z>
@Nullable Object obj) {<z>
this == obj) {<z>
true;<z>
) {<z>
false;<z>
.className);<z>
public void onComplete() {<z>
handlerCompletionSink != null) {<z>
.handlerCompletionSink.tryEmitEmpty();<z>
!= null) {<z>
handlerCompletionMono.onComplete();<z>
close();<z>
addConstantMemberReference(<z>
name, final String descriptor) {<z>
);<z>
Entry entry = get(hashCode);<z>
(entry != null) {<z>
== tag<z>
&& entry.hashCode == hashCode<z>
.equals(owner)<z>
name)<z>
)) {<z>
entry;<z>
next;<z>
(<z>
);<z>
);<z>
registerTransactionalEventListenerFactory(ParserContext parserContext) {<z>
def = new RootBeanDefinition();<z>
setBeanClass(TransactionalEventListenerFactory.class);<z>
registerBeanComponent(new BeanComponentDefinition(def,<z>
));<z>
, Class<?>... paramTypes) {<z>
, "Class must not be null");<z>
.getConstructor(paramTypes);<z>
(NoSuchMethodException ex) {<z>
return null;<z>
() {<z>
nullSafeHashCode(this.type);<z>
name);<z>
ObjectUtils.nullSafeHashCode(this.filename);<z>
(this.charset);<z>
;<z>
.creationDate.hashCode() : 0);<z>
.hashCode() : 0);<z>
hashCode() : 0);<z>
;<z>
) : SpelCompilerMode.OFF);<z>
;<z>
final ClassLoader compilerClassLoader;<z>
private final boolean autoGrowNullReferences;<z>
final boolean autoGrowCollections;<z>
maximumAutoGrowSize;<z>
) {<z>
false, Integer.MAX_VALUE);<z>
) throws BeansException {<z>
(beanClass);<z>
SCOPE_PROTOTYPE);<z>
beanClass, getBeanClassLoader());<z>
;<z>
) {<z>
) {<z>
getObject() throws BeansException {<z>
, false);<z>
if (resolved == null) {<z>
new NoSuchBeanDefinitionException(requiredType);<z>
resolved;<z>
{<z>
= resolveBean(requiredType, args, false);<z>
{<z>
throw new NoSuchBeanDefinitionException(requiredType);<z>
return resolved;<z>
) throws BeansException {<z>
return resolveBean(requiredType, null, false);<z>
{<z>
return null;<z>
<T> dependencyConsumer) throws BeansException {<z>
getIfAvailable();<z>
!= null) {<z>
;<z>
catch (ScopeNotActiveException ex) {<z>
() throws BeansException {<z>
null, true);<z>
ScopeNotActiveException ex) {<z>
null;<z>
) throws BeansException {<z>
dependency = getIfUnique();<z>
{<z>
);<z>
ScopeNotActiveException ex) {<z>
@SuppressWarnings("unchecked")<z>
<T> stream() {<z>
allowEagerInit))<z>
(name))<z>
(bean instanceof NullBean));<z>
"unchecked")<z>
{<z>
= getBeanNamesForTypedStream(requiredType, allowEagerInit);<z>
(beanNames.length == 0) {<z>
.empty();<z>
(beanNames.length);<z>
(String beanName : beanNames) {<z>
Object beanInstance = getBean(beanName);<z>
) {<z>
beanName, (T) beanInstance);<z>
);<z>
(adaptOrderComparator(matchingBeans));<z>
... generatedKeyNames) {<z>
LinkedHashSet<>(generatedKeyNames.length);<z>
(String key : generatedKeyNames) {<z>
(key.toUpperCase());<z>
();<z>
;<z>
getSchemaName() != null) {<z>
;<z>
('.');<z>
(getTableName());<z>
insertStatement.append(" (");<z>
int columnCount = 0;<z>
(String columnName : getTableColumns()) {<z>
.toUpperCase())) {<z>
++;<z>
if (columnCount > 1) {<z>
insertStatement.append(", ");<z>
(columnName);<z>
append(") VALUES(");<z>
columnCount < 1) {<z>
.generatedKeyColumnsUsed) {<z>
isDebugEnabled()) {<z>
logger.debug("Unable to locate non-key columns for table '" +<z>
;<z>
"Unable to locate columns for table '" + getTableName()<z>
"' so an insert statement can't be generated.";<z>
)) {<z>
" Consider specifying explicit column names -- for example, via SimpleJdbcInsert#usingColumns().";<z>
throw new InvalidDataAccessApiUsageException(message);<z>
(columnCount, "?"));<z>
(params);<z>
.append(')');<z>
;<z>
public Theme getTheme(String themeName) {<z>
ORIGINAL_DEFAULT_THEME_NAME.equals(themeName)) {<z>
);<z>
return null;<z>
, Function<String, T> computeFunction) {<z>
(name, "Name must not be null");<z>
);<z>
computeIfAbsent(name, computeFunction);<z>
!= null,<z>
);<z>
) value;<z>
) {<z>
.getName().equals("groovy.lang.GroovyObject") ||<z>
).endsWith(".cglib.proxy.Factory") ||<z>
);<z>
messages, int i) {<z>
switch (messages.length - i) {<z>
0:<z>
return Collections.emptyList();<z>
:<z>
) ?<z>
));<z>
))<z>
))<z>
Collectors.toList());<z>
private TypedValue getValueInternal(TypedValue contextObject, EvaluationContext evalContext,<z>
{<z>
.name);<z>
&&<z>
) {<z>
TypeDescriptor resultDescriptor = result.getTypeDescriptor();<z>
null, "No result type");<z>
.class == resultDescriptor.getType()) {<z>
{<z>
;<z>
name, newList);<z>
, this.name);<z>
class == resultDescriptor.getType()) {<z>
this.name,contextObject, evalContext)) {<z>
= new HashMap<>();<z>
.name, newMap);<z>
);<z>
evalContext)) {<z>
().getType();<z>
accessibleConstructor(clazz).newInstance();<z>
, this.name, newObject);<z>
name);<z>
{<z>
,<z>
());<z>
Throwable ex) {<z>
), ex,<z>
().getType());<z>
;<z>
() {<z>
;<z>
, "(", ")");<z>
> paramType : method.getParameterTypes()) {<z>
getName());<z>
);<z>
) {<z>
) {<z>
);<z>
) {<z>
(ScheduledTask task : tasks) {<z>
;<z>
.clear();<z>
destroy();<z>
void reset() {<z>
0;<z>
0;<z>
;<z>
;<z>
0;<z>
) {<z>
));<z>
Type type = parameterizedTypeReferenceSubclass.getGenericSuperclass();<z>
, "Type must be a parameterized type");<z>
= (ParameterizedType) type;<z>
;<z>
== 1, "Number of type arguments must be 1");<z>
type = actualTypeArguments[0];<z>
> monoToDeferred(Mono<T> source) {<z>
, Dispatchers.getUnconfined(),<z>
.DEFAULT,<z>
, continuation));<z>
private ByteBuffer assembleChunksAndReset() {<z>
ByteBuffer result;<z>
chunks.size() == 1) {<z>
);<z>
);<z>
ByteBuffer partial : this.chunks) {<z>
partial);<z>
result.flip();<z>
chunks.clear();<z>
.expectedContentLength = null;<z>
;<z>
Nullable ReactiveTransactionManager tm,<z>
String joinpointIdentification,<z>
@Nullable ReactiveTransaction transaction) {<z>
);<z>
null) {<z>
)) {<z>
.getJoinpointIdentification() + "]");<z>
(transaction);<z>
)) {<z>
.trace("Don't need to create transaction for [" + joinpointIdentification +<z>
"]: This method isn't transactional.");<z>
;<z>
static RequestPath parseAndCache(HttpServletRequest request) {<z>
;<z>
setAttribute(PATH_ATTRIBUTE, requestPath);<z>
return requestPath;<z>
() {<z>
) {<z>
new Properties();<z>
this.hibernateProperties;<z>
request) throws Exception {<z>
.getNativeRequest(HttpServletRequest.class);<z>
{<z>
resolveMultipartArgument(name, parameter, servletRequest);<z>
mpArg != MultipartResolutionDelegate.UNRESOLVABLE) {<z>
;<z>
= null;<z>
.class);<z>
) {<z>
name);<z>
isEmpty()) {<z>
.get(0) : files);<z>
{<z>
);<z>
(paramValues != null) {<z>
] : paramValues);<z>
arg;<z>
Symbol addConstantMethodref(<z>
, final boolean isInterface) {<z>
isInterface ? Symbol.CONSTANT_INTERFACE_METHODREF_TAG : Symbol.CONSTANT_METHODREF_TAG;<z>
descriptor);<z>
(<z>
String> uriVariables) {<z>
LinkedHashMap<>();<z>
uriVarValue) -> {<z>
'=');<z>
equalsIndex == -1) {<z>
);<z>
-1 && semicolonIndex != 0) {<z>
));<z>
;<z>
semicolonIndex == 0 || equalsIndex < semicolonIndex) {<z>
matrixVariables = uriVarValue;<z>
(semicolonIndex + 1);<z>
parseMatrixVariables(matrixVariables);<z>
);<z>
;<z>
;<z>
() {<z>
1));<z>
.get().await();<z>
) {<z>
printStackTrace();<z>
ApplicationEvent event) {<z>
== this.source) {<z>
);<z>
response,<z>
throws SockJsException {<z>
;<z>
);<z>
catch (IOException ex) {<z>
"Failed to read message", ex);<z>
)) {<z>
"Payload expected.", sockJsSession.getId());<z>
, sockJsSession.getId());<z>
(Exception ex) {<z>
ex);<z>
"Failed to read message(s)", sockJsSession.getId());<z>
{<z>
());<z>
isTraceEnabled()) {<z>
;<z>
));<z>
, "plain", StandardCharsets.UTF_8));<z>
(messages);<z>
<T> requiredType, @Nullable Field field)<z>
TypeMismatchException {<z>
.convertIfNecessary(value, requiredType, field);<z>
(final String name) {<z>
++numElementValuePairs;<z>
useNamedValues) {<z>
(name));<z>
0);<z>
, null);<z>
byte[] source) {<z>
"Byte array must not be null");<z>
length);<z>
;<z>
target, @Nullable Object value) {<z>
field.set(target, value);<z>
(IllegalAccessException ex) {<z>
handleReflectionException(ex);<z>
(String name) {<z>
logger = LoggerFactory.getLogger(name);<z>
(logger instanceof LocationAwareLogger ?<z>
;<z>
(String... names) {<z>
mvcResult -> {<z>
);<z>
{<z>
);<z>
getAllErrors(),<z>
result.hasErrors());<z>
String, ?> environment) {<z>
{<z>
(environment);<z>
(ExtensionContext context) throws Exception {<z>
testInstance = context.getRequiredTestInstance();<z>
;<z>
);<z>
testException);<z>
String, Object> hints) {<z>
+ "Writing " +<z>
isEnableLoggingRequestDetails() ?<z>
(form, !traceOn) :<z>
.keySet() + " (content masked)"));<z>
final int numLocal, final int numStack) {<z>
frameLength = 3 + numLocal + numStack;<z>
{<z>
currentFrame = new int[frameLength];<z>
;<z>
[1] = numLocal;<z>
;<z>
3;<z>
ConstantDynamic readConstantDynamic(<z>
[] charBuffer) {<z>
ConstantDynamic constantDynamic = constantDynamicValues[constantPoolEntryIndex];<z>
{<z>
constantDynamic;<z>
];<z>
(cpInfoOffset + 2)];<z>
);<z>
);<z>
bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];<z>
;<z>
];<z>
;<z>
; i++) {<z>
), charBuffer);<z>
+= 2;<z>
=<z>
descriptor, handle, bootstrapMethodArguments);<z>
parent) {<z>
if (!this.mergeEnabled) {<z>
;<z>
null) {<z>
;<z>
)) {<z>
;<z>
ManagedSet<>();<z>
parent);<z>
(this);<z>
merged;<z>
) {<z>
headers, "'headers' must not be null");<z>
) {<z>
size());<z>
Collections.unmodifiableList(value)));<z>
unmodifiableMap(map);<z>
headers = headers;<z>
(Exception ex) {<z>
Throwable t = ex;<z>
) {<z>
ex;<z>
.getCause();<z>
);<z>
Exception ex) {<z>
{<z>
i);<z>
;<z>
catch (Throwable ex2) {<z>
;<z>
{<z>
;<z>
validateAddresses(cc);<z>
);<z>
) {<z>
)) {<z>
addResolvers(initArgumentResolvers());<z>
()) {<z>
());<z>
);<z>
(returnValueLogger != null) {<z>
setLogger(returnValueLogger);<z>
();<z>
ApplicationContext context = getApplicationContext();<z>
null) {<z>
Object.class)) {<z>
startsWith(SCOPED_TARGET_NAME_PREFIX)) {<z>
;<z>
beanType = context.getType(beanName);<z>
(Throwable ex) {<z>
()) {<z>
beanName + "'", ex);<z>
)) {<z>
detectHandlerMethods(beanName);<z>
> candidates, Class<?> requiredType) {<z>
highestPriorityBeanName = null;<z>
highestPriority = null;<z>
.entrySet()) {<z>
;<z>
Object beanInstance = entry.getValue();<z>
{<z>
candidatePriority = getPriority(beanInstance);<z>
candidatePriority != null) {<z>
(highestPriorityBeanName != null) {<z>
highestPriority)) {<z>
size(),<z>
+<z>
);<z>
else if (candidatePriority < highestPriority) {<z>
highestPriorityBeanName = candidateBeanName;<z>
= candidatePriority;<z>
highestPriorityBeanName = candidateBeanName;<z>
candidatePriority;<z>
return highestPriorityBeanName;<z>
ServletRequest request, String name)<z>
{<z>
);<z>
public MessagingMessageConverter(MessageConverter payloadConverter, JmsHeaderMapper headerMapper) {<z>
;<z>
);<z>
= payloadConverter;<z>
this.headerMapper = headerMapper;<z>
{<z>
synchronized (this.lifecycleMonitor) {<z>
.size();<z>
{<z>
) {<z>
debug("JdbcCall call not compiled before execution - invoking compile");<z>
);<z>
void endTransaction() throws Exception {<z>
(this.transaction != null) {<z>
if (this.rollbackOnly) {<z>
this.transaction.rollback();<z>
();<z>
this.transaction = null;<z>
this.rollbackOnly = false;<z>
<?> controllerType,<z>
String methodName, Object... args) {<z>
);<z>
, controllerType, method, args);<z>
exchange(String url, HttpMethod method,<z>
responseType, Map<String, ?> uriVariables)<z>
throws RestClientException {<z>
RequestCallback requestCallback = httpEntityCallback(requestEntity, responseType);<z>
>> responseExtractor = responseEntityExtractor(responseType);<z>
, responseExtractor, uriVariables));<z>
protected void checkDependencies(<z>
PropertyDescriptor[] pds, @Nullable PropertyValues pvs)<z>
throws UnsatisfiedDependencyException {<z>
int dependencyCheck = mbd.getDependencyCheck();<z>
: pds) {<z>
)) {<z>
.getPropertyType());<z>
dependencyCheck == AbstractBeanDefinition.DEPENDENCY_CHECK_ALL) ||<z>
== AbstractBeanDefinition.DEPENDENCY_CHECK_SIMPLE) ||<z>
AbstractBeanDefinition.DEPENDENCY_CHECK_OBJECTS);<z>
unsatisfied) {<z>
, pd.getName(),<z>
;<z>
> getPropertyType() {<z>
if (this.propertyType == null) {<z>
(this.readMethod, this.writeMethod);<z>
ex) {<z>
propertyType;<z>
] extractedValue) {<z>
!= extractedValue.length) {<z>
;<z>
i < value.length; i++) {<z>
{<z>
false;<z>
return true;<z>
) {<z>
(destination);<z>
!this.selectorHeaderInUse) {<z>
;<z>
.size());<z>
((sessionId, subscriptionIds) -> {<z>
(sessionId);<z>
info != null) {<z>
(String subscriptionId : subscriptionIds) {<z>
= info.getSubscription(subscriptionId);<z>
subscription.getSelector(), message)) {<z>
;<z>
;<z>
return result;<z>
(UriComponents uriComponents, MockHttpServletRequest request) {<z>
serverPort = uriComponents.getPort();<z>
.setServerPort(serverPort);<z>
serverPort == -1) {<z>
webRequest.getUrl().getDefaultPort();<z>
serverPort);<z>
request.setRemotePort(portConnection);<z>
request.setRemotePort(serverPort);<z>
private int indexOfEqualMediaType(MediaType mediaType) {<z>
) {<z>
();<z>
) &&<z>
) {<z>
;<z>
1;<z>
Advisor o2) {<z>
;<z>
(o1, o2)) {<z>
(o1, o2);<z>
return advisorPrecedence;<z>
WebsocketInbound inbound, WebsocketOutbound outbound,<z>
, NettyDataBufferFactory bufferFactory,<z>
int maxFramePayloadLength) {<z>
, outbound), info, bufferFactory);<z>
maxFramePayloadLength;<z>
.channel().id();<z>
HttpInputMessage inputMessage)<z>
, HttpMessageNotReadableException {<z>
clazz, null);<z>
javaType, inputMessage);<z>
{<z>
(!hasLength(str)) {<z>
str;<z>
int beginIdx = 0;<z>
.charAt(beginIdx)) {<z>
;<z>
substring(beginIdx);<z>
List<WebSocketExtension> parseExtensions(String extensions) {<z>
)) {<z>
StringUtils.tokenizeToStringArray(extensions, ",");<z>
(tokens.length);<z>
(String token : tokens) {<z>
;<z>
result;<z>
.emptyList();<z>
value) {<z>
.RESTRUCTURE_AFTER, TaskOption.SKIP_IF_EMPTY) {<z>
Entry<K, V> entry) {<z>
, value)) {<z>
) {<z>
;<z>
return true;<z>
return false;<z>
);<z>
);<z>
{<z>
foo_;<z>
instanceof String) {<z>
=<z>
(<z>
) ref);<z>
= b;<z>
;<z>
} else {<z>
ByteString) ref;<z>
boolean isRequired() {<z>
if (!this.required) {<z>
;<z>
{<z>
Optional.class || hasNullableAnnotation() ||<z>
&&<z>
()) &&<z>
(this.field)));<z>
);<z>
{<z>
setupMetadata);<z>
mimeType);<z>
return this;<z>
, @Nullable Locale locale) {<z>
(name, "Name must not be null");<z>
, "Extension must not be null");<z>
null;<z>
null) {<z>
);<z>
();<z>
= locale.getVariant();<z>
() > 0) {<z>
String location =<z>
this.separator + variant + extension;<z>
(location);<z>
.length() > 0) {<z>
+ extension;<z>
;<z>
{<z>
lang + extension;<z>
resourceLoader.getResource(location);<z>
exists()) {<z>
extension;<z>
.getResource(location);<z>
;<z>
getCacheResolver(<z>
, CacheMethodDetails<?> details) {<z>
factory != null) {<z>
factory.getCacheResolver(details);<z>
);<z>
();<z>
public Date getDate(int columnIndex) throws InvalidResultSetAccessException {<z>
columnIndex);<z>
se) {<z>
InvalidResultSetAccessException(se);<z>
void flushCache() throws SockJsTransportFailureException {<z>
)];<z>
i++) {<z>
getMessageCache().poll();<z>
getSockJsServiceConfig().getMessageCodec();<z>
SockJsFrame.messageFrame(messageCodec, messages);<z>
frame);<z>
ParserContext parserContext, BeanDefinitionBuilder builder) {<z>
.getAttribute("location");<z>
if (StringUtils.hasLength(location)) {<z>
resolvePlaceholders(location);<z>
location);<z>
"locations", locations);<z>
("properties-ref");<z>
{<z>
("properties", propertiesRef);<z>
);<z>
.hasLength(fileEncoding)) {<z>
addPropertyValue("fileEncoding", fileEncoding);<z>
("order");<z>
(StringUtils.hasLength(order)) {<z>
);<z>
"ignoreResourceNotFound",<z>
("ignore-resource-not-found")));<z>
("localOverride",<z>
("local-override")));<z>
ROLE_INFRASTRUCTURE);<z>
computeAttributesSize(final SymbolTable symbolTable) {<z>
;<z>
= 0;<z>
maxStack = -1;<z>
int maxLocals = -1;<z>
codeLength, maxStack, maxLocals);<z>
(Object key) {<z>
if (containsKey(key)) {<z>
String) key);<z>
;<z>
formWriter) {<z>
>(MultipartHttpMessageReader.MIME_TYPES);<z>
(formWriter != null) {<z>
.getWritableMediaTypes());<z>
);<z>
ex) {<z>
if (ex instanceof HibernateException) {<z>
(HibernateException) ex);<z>
{<z>
HibernateException) {<z>
());<z>
EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(ex);<z>
return null;<z>
other, ServerWebExchange exchange) {<z>
- this.expressions.size();<z>
{<z>
result;<z>
;<z>
initConnection() throws JMSException {<z>
if (getTargetConnectionFactory() == null) {<z>
throw new IllegalStateException(<z>
);<z>
(this.connectionMonitor) {<z>
.connection != null) {<z>
closeConnection(this.connection);<z>
this.connection = doCreateConnection();<z>
connection);<z>
{<z>
this.connection.start();<z>
)) {<z>
;<z>
throws NotSupportedException, SystemException {<z>
>= 0) {<z>
transactionManager.setTransactionTimeout(timeout);<z>
);<z>
new ManagedTransactionAdapter(this.transactionManager);<z>
?> targetClass) {<z>
source : this.transactionAttributeSources) {<z>
(source.isCandidateClass(targetClass)) {<z>
true;<z>
return false;<z>
String annotationName) {<z>
(getIntrospectedClass(), annotationName)) {<z>
ReflectionUtils.getDeclaredMethods(getIntrospectedClass());<z>
method : methods) {<z>
) {<z>
return true;<z>
ex) {<z>
;<z>
return false;<z>
{<z>
;<z>
{<z>
;<z>
routerFunctionMapping(<z>
"mvcConversionService") FormattingConversionService conversionService,<z>
ResourceUrlProvider resourceUrlProvider) {<z>
;<z>
;<z>
setInterceptors(getInterceptors(conversionService, resourceUrlProvider));<z>
.setCorsConfigurations(getCorsConfigurations());<z>
());<z>
();<z>
(patternParser != null) {<z>
(patternParser);<z>
mapping;<z>
elementType, @Nullable MimeType mimeType) {<z>
== null) {<z>
;<z>
{<z>
mimeType)) {<z>
;<z>
false;<z>
uriVariables)<z>
throws RestClientException {<z>
responseType);<z>
;<z>
, responseExtractor, uriVariables));<z>
() {<z>
);<z>
);<z>
currentTimeMillis() + getReceiptTimeLimit());<z>
this::handleReceiptNotReceived, startTime);<z>
throws Throwable {<z>
;<z>
catch (RuntimeException ex) {<z>
) {<z>
throw ex;<z>
persistenceExceptionTranslator;<z>
if (translator == null) {<z>
null,<z>
;<z>
(this.beanFactory);<z>
= translator;<z>
;<z>
TagWriter tagWriter) throws JspException {<z>
getBoundValue(), getPropertyEditor());<z>
= null;<z>
getDynamicAttributes();<z>
(attributes != null) {<z>
;<z>
if (type == null) {<z>
getType();<z>
;<z>
extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {<z>
className = "spel/Ex" + getNextSuffix();<z>
;<z>
cw = new ExpressionClassWriter();<z>
className, null, "org/springframework/expression/spel/CompiledExpression", null);<z>
);<z>
();<z>
(ALOAD, 0);<z>
.visitMethodInsn(INVOKESPECIAL, "org/springframework/expression/spel/CompiledExpression",<z>
, "()V", false);<z>
mv.visitInsn(RETURN);<z>
visitMaxs(1, 1);<z>
mv.visitEnd();<z>
.visitMethod(ACC_PUBLIC, "getValue",<z>
";)Ljava/lang/Object;", null,<z>
;<z>
mv.visitCode();<z>
;<z>
, cf);<z>
{<z>
()) {<z>
() +<z>
".generateCode opted out of compilation: " + ex.getMessage());<z>
;<z>
lastDescriptor());<z>
lastDescriptor())) {<z>
ACONST_NULL);<z>
);<z>
visitMaxs(0, 0);<z>
visitEnd();<z>
visitEnd();<z>
cf.finish();<z>
data = cw.toByteArray();<z>
);<z>
void registerProcessedProperty(String propertyName) {<z>
) {<z>
4);<z>
;<z>
@Nullable String className, @Nullable String parentName)<z>
throws ClassNotFoundException {<z>
BeanDefinitionReaderUtils.createBeanDefinition(<z>
));<z>
? extends Annotation> annotationType) {<z>
= new ArrayList<>();<z>
: this.beans.keySet()) {<z>
null) {<z>
results.add(beanName);<z>
;<z>
<T> action) throws JmsException {<z>
action, "Callback object must not be null");<z>
session -> {<z>
MessageProducer producer = createProducer(session, destination);<z>
, producer);<z>
closeMessageProducer(producer);<z>
;<z>
protected void applyHeaders() {<z>
);<z>
entrySet()<z>
()<z>
))<z>
));<z>
ACCEPT)) {<z>
.ACCEPT, MediaType.ALL_VALUE);<z>
void visitMainClass(final String mainClass) {<z>
null) {<z>
);<z>
{<z>
.getErrorMessage();<z>
)) {<z>
;<z>
valueOf(statusCode).getReasonPhrase();<z>
ex) {<z>
;<z>
> mappingFunction) {<z>
sql = getRequiredSql(sqlSupplier);<z>
connection -> {<z>
if (logger.isDebugEnabled()) {<z>
;<z>
if (sqlSupplier instanceof PreparedOperation<?>) {<z>
sql);<z>
(statement);<z>
sqlSupplier).bindTo(bindTarget);<z>
statement;<z>
DefaultDatabaseClient.this.namedParameterExpander != null) {<z>
);<z>
<>(this.byIndex);<z>
);<z>
MapBindParameterSource namedBindings = retrieveParameters(<z>
, remainderByIndex);<z>
this.namedParameterExpander.expand(<z>
);<z>
);<z>
{<z>
+ "]");<z>
= connection.createStatement(expanded);<z>
BindTarget bindTarget = new StatementWrapper(statement);<z>
);<z>
bindByName(statement, remainderByName);<z>
statement, remainderByIndex);<z>
;<z>
connection.createStatement(sql);<z>
;<z>
this.byName);<z>
return statement;<z>
Result>> resultFunction = connection -> {<z>
;<z>
.this.executeFunction))<z>
);<z>
DefaultFetchSpec<>(<z>
sql,<z>
sql, resultFunction),<z>
-> sumRowsUpdated(resultFunction, connection)),<z>
);<z>
{<z>
this.targetCacheManager == null) {<z>
("Property 'targetCacheManager' is required");<z>
JspException {<z>
;<z>
label));<z>
;<z>
private AbstractBeanDefinition createAdviceDefinition(<z>
parserContext, String aspectName, int order,<z>
RootBeanDefinition aspectFactoryDef,<z>
, List<BeanReference> beanReferences) {<z>
parserContext));<z>
);<z>
aspectName);<z>
, order);<z>
hasAttribute(RETURNING)) {<z>
).add(<z>
adviceElement.getAttribute(RETURNING));<z>
.hasAttribute(THROWING)) {<z>
).add(<z>
THROWING));<z>
{<z>
(<z>
);<z>
adviceDefinition.getConstructorArgumentValues();<z>
METHOD_INDEX, methodDef);<z>
Object pointcut = parsePointcutProperty(adviceElement, parserContext);<z>
) {<z>
.addIndexedArgumentValue(POINTCUT_INDEX, pointcut);<z>
);<z>
String) {<z>
= new RuntimeBeanReference((String) pointcut);<z>
pointcutRef);<z>
add(pointcutRef);<z>
.addIndexedArgumentValue(ASPECT_INSTANCE_FACTORY_INDEX, aspectFactoryDef);<z>
adviceDefinition;<z>
extends Annotation> annotationType) {<z>
(annotationType == null) {<z>
;<z>
AttributeMethods::compute);<z>
final void onComplete() {<z>
;<z>
.isTraceEnabled()) {<z>
+ state + "]");<z>
(this);<z>
throws IOException {<z>
(object, "Object must not be null");<z>
object instanceof String) {<z>
);<z>
;<z>
public SQLErrorCodes resolveErrorCodes(DataSource dataSource) {<z>
, "DataSource must not be null");<z>
()) {<z>
);<z>
;<z>
{<z>
this.dataSourceCache) {<z>
get(dataSource);<z>
) {<z>
dataSource,<z>
;<z>
(StringUtils.hasLength(name)) {<z>
, name);<z>
(MetaDataAccessException ex) {<z>
.warn("Error while extracting database name", ex);<z>
return null;<z>
.isDebugEnabled()) {<z>
"]");<z>
return sec;<z>
Advisor[] resolveInterceptorNames() {<z>
= this.beanFactory;<z>
;<z>
= new ArrayList<>();<z>
{<z>
cbf.isCurrentlyInCreation(beanName)) {<z>
state(bf != null, "BeanFactory required for resolving interceptor names");<z>
next = bf.getBean(beanName);<z>
);<z>
(new Advisor[0]);<z>
(MethodParameter returnType, @Nullable ReactiveAdapter reactiveAdapter) {<z>
&& reactiveAdapter.supportsEmpty()) {<z>
)) {<z>
;<z>
.getGenericParameterType();<z>
(parameterType instanceof ParameterizedType type) {<z>
{<z>
);<z>
;<z>
ServletRequest request) {<z>
= new ServletRequestParameterPropertyValues(request);<z>
(request, MultipartRequest.class);<z>
!= null) {<z>
;<z>
)) {<z>
request, HttpServletRequest.class);<z>
)) {<z>
));<z>
, request);<z>
;<z>
handlers) {<z>
super(delegate);<z>
handlersToUse = new ArrayList<>();<z>
.add(new CheckpointInsertingHandler());<z>
.addAll(handlers);<z>
exceptionHandlers = Collections.unmodifiableList(handlersToUse);<z>
ops) {<z>
) {<z>
+ ops + "]");<z>
);<z>
> supportedLocales) {<z>
> requestLocales = request.getLocales();<z>
Locale languageMatch = null;<z>
.hasMoreElements()) {<z>
();<z>
{<z>
locale.getLanguage())) {<z>
return locale;<z>
null) {<z>
: supportedLocales) {<z>
getCountry()) &&<z>
getLanguage())) {<z>
candidate;<z>
languageMatch;<z>
[] src) {<z>
== 0) {<z>
return src;<z>
.decode(src);<z>
setProtocolHandlers(List<SubProtocolHandler> protocolHandlers) {<z>
clear();<z>
;<z>
for (SubProtocolHandler handler : protocolHandlers) {<z>
;<z>
protected void setThrowingNameNoCheck(String name) {<z>
(name)) {<z>
name;<z>
.forName(name, getAspectClassLoader());<z>
ex) {<z>
+<z>
"name of a Java type on the classpath. Root cause: " + ex);<z>
groovy() {<z>
!checkBeanOfType(GroovyMarkupConfigurer.class)) {<z>
new BeanInitializationException("In addition to a Groovy markup view resolver " +<z>
"This bean may be given any name.");<z>
GroovyMarkupRegistration();<z>
getViewResolver());<z>
registration;<z>
String schemaName) {<z>
== null) {<z>
;<z>
(isStoresUpperCaseIdentifiers()) {<z>
();<z>
()) {<z>
();<z>
return schemaName;<z>
String getElementText() throws XMLStreamException {<z>
checkIfClosed();<z>
) {<z>
);<z>
= new StringBuilder();<z>
(true) {<z>
event = nextEvent();<z>
.isEndElement()) {<z>
isCharacters()) {<z>
);<z>
characters = event.asCharacters();<z>
{<z>
.asCharacters().getData());<z>
builder.toString();<z>
) {<z>
value;<z>
series;<z>
reasonPhrase;<z>
boolean matches(Class<?> clazz) {<z>
TransactionalProxy.class.isAssignableFrom(clazz) ||<z>
||<z>
.class.isAssignableFrom(clazz)) {<z>
;<z>
TransactionAttributeSource tas = getTransactionAttributeSource();<z>
isCandidateClass(clazz));<z>
, MediaType contentType, OutputStream body)<z>
, HttpMessageNotWritableException {<z>
ImageOutputStream imageOutputStream = null;<z>
;<z>
);<z>
.hasNext()) {<z>
;<z>
ImageWriteParam iwp = imageWriter.getDefaultWriteParam();<z>
);<z>
imageOutputStream = createImageOutputStream(body);<z>
);<z>
image, null, null), iwp);<z>
throw new HttpMessageNotWritableException(<z>
);<z>
(imageWriter != null) {<z>
;<z>
(imageOutputStream != null) {<z>
;<z>
IOException ex) {<z>
(ServerHttpRequest request, ServerHttpResponse response,<z>
{<z>
.get(TransportType.WEBSOCKET);<z>
if (!(transportHandler instanceof HandshakeHandler)) {<z>
.error("No handler configured for raw WebSocket messages");<z>
NOT_FOUND);<z>
new HandshakeInterceptorChain(this.interceptors, handler);<z>
;<z>
> attributes = new HashMap<>();<z>
response, attributes)) {<z>
(request, response, handler, attributes);<z>
;<z>
ex) {<z>
failure = ex;<z>
Exception ex) {<z>
;<z>
if (failure != null) {<z>
failure);<z>
throw failure;<z>
Locale locale) throws ParseException {<z>
= Monetary.getCurrency(locale);<z>
numberFormatter.parse(text, locale);<z>
(currencyUnit).create();<z>
(<z>
ClassLoader classLoader) throws ClassNotFoundException {<z>
GenericBeanDefinition bd = new GenericBeanDefinition();<z>
);<z>
) {<z>
if (classLoader != null) {<z>
, classLoader));<z>
;<z>
bd;<z>
public void setCorsConfigurationSource(CorsConfigurationSource source) {<z>
"CorsConfigurationSource must not be null");<z>
;<z>
UrlBasedCorsConfigurationSource urlConfigSource) {<z>
(false);<z>
() {<z>
"spring-ws.png"));<z>
= new DataHandler(dataSource);<z>
DataHandler.class, dataHandler);<z>
, long timeout) throws UnavailableException {<z>
endpoint = createEndpointInternal();<z>
);<z>
;<z>
extends DataBuffer> body) {<z>
applyCookiesIfNecessary();<z>
), this.contextPath,<z>
body);<z>
body, HttpHeaders headers) {<z>
;<z>
;<z>
.append(' ');<z>
append(url);<z>
builder.append(',');<z>
) {<z>
append(body);<z>
(',');<z>
append(headers);<z>
('>');<z>
.toString();<z>
) throws Exception {<z>
ArrayList<>();<z>
.locations) {<z>
ArrayList<>(<z>
.getResources(location)));<z>
r2) -> {<z>
));<z>
IOException ex) {<z>
0;<z>
;<z>
addAll(resources);<z>
0]);<z>
void registerExceptionHandlerAdvice(<z>
, AbstractExceptionHandlerMethodResolver resolver) {<z>
;<z>
) {<z>
, MediaType.TEXT_PLAIN);<z>
"ConversionService is required");<z>
conversionService;<z>
= new StringHttpMessageConverter(defaultCharset);<z>
public void visitAttribute(final Attribute attribute) {<z>
(mv != null) {<z>
);<z>
> readers) {<z>
)<z>
Entry::getValue)<z>
(Map.Entry::getKey)<z>
);<z>
) {<z>
);<z>
if (index == -1) {<z>
return false;<z>
);<z>
return true;<z>
statusText,<z>
] body, @Nullable Charset charset) {<z>
, statusText, headers, body, charset);<z>
persistenceUnitManager) {<z>
) {<z>
);<z>
persistenceUnitManager.obtainDefaultPersistenceUnitInfo();<z>
Closure<?> callable) {<z>
callable.setDelegate(this);<z>
call();<z>
finalizeDeferredProperties();<z>
this;<z>
() {<z>
()<z>
.setName("empty-sql-scripts-test-db")<z>
.build();<z>
{<z>
== null) {<z>
;<z>
new StringWriter(BUFFER_SIZE);<z>
);<z>
;<z>
getForUriString(String uriString, ServerWebExchange exchange) {<z>
= exchange.getRequest();<z>
uriString);<z>
(0, queryIndex);<z>
.substring(queryIndex);<z>
(lookupPath);<z>
(resolvedPath -><z>
);<z>
String, Object> hints) {<z>
= getContentType(message);<z>
;<z>
elementType, contentType, allHints);<z>
getConnectionFactory(String connectionFactoryName)<z>
ConnectionFactoryLookupFailureException {<z>
.beanFactory != null, "BeanFactory is required");<z>
, ConnectionFactory.class);<z>
ex) {<z>
ConnectionFactoryLookupFailureException(<z>
ex);<z>
formatSupport,<z>
Nullable ExtensionRegistry extensionRegistry) {<z>
(formatSupport != null) {<z>
this.protobufFormatSupport = formatSupport;<z>
).getClassLoader())) {<z>
new ProtobufJavaFormatSupport();<z>
).getClassLoader())) {<z>
;<z>
protobufFormatSupport = null;<z>
protobufFormatSupport != null ?<z>
}));<z>
? ExtensionRegistry.newInstance() : extensionRegistry);<z>
(ConversionService conversionService,<z>
ConfigurableBeanFactory beanFactory) {<z>
conversionService;<z>
this.configurableBeanFactory = beanFactory;<z>
, null) : null);<z>
> requiredType, @Nullable Object... args)<z>
throws BeansException {<z>
name, requiredType, args, false);<z>
... pathPatterns) {<z>
(resourceLoader, "ResourceLoader is required");<z>
(pathPatterns, "At least one path pattern is required for resource handling");<z>
resourceLoader;<z>
= pathPatterns;<z>
String descriptor, final int numDimensions) {<z>
mv != null) {<z>
.visitMultiANewArrayInsn(descriptor, numDimensions);<z>
protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {<z>
.ExtensionRegistry assignDescriptors(<z>
) {<z>
= root;<z>
).get(0);<z>
internal_static_Msg_fieldAccessorTable = new<z>
com.google.protobuf.GeneratedMessage.FieldAccessorTable(<z>
] { "Foo", "Blah", });<z>
);<z>
new<z>
GeneratedMessage.FieldAccessorTable(<z>
);<z>
null;<z>
) {<z>
;<z>
if (lr instanceof LocaleContextResolver) {<z>
LocaleContextResolver) lr).resolveLocaleContext(request);<z>
);<z>
public C createListenerContainer(JmsListenerEndpoint endpoint) {<z>
;<z>
this.connectionFactory != null) {<z>
setConnectionFactory(this.connectionFactory);<z>
{<z>
(this.destinationResolver);<z>
.messageConverter != null) {<z>
;<z>
this.exceptionListener != null) {<z>
);<z>
this.errorHandler != null) {<z>
setErrorHandler(this.errorHandler);<z>
) {<z>
.sessionTransacted);<z>
{<z>
;<z>
if (this.pubSubDomain != null) {<z>
setPubSubDomain(this.pubSubDomain);<z>
replyPubSubDomain != null) {<z>
.setReplyPubSubDomain(this.replyPubSubDomain);<z>
this.replyQosSettings != null) {<z>
(this.replyQosSettings);<z>
this.subscriptionDurable != null) {<z>
);<z>
this.subscriptionShared != null) {<z>
instance.setSubscriptionShared(this.subscriptionShared);<z>
null) {<z>
;<z>
if (this.phase != null) {<z>
instance.setPhase(this.phase);<z>
) {<z>
autoStartup);<z>
);<z>
);<z>
instance;<z>
@Nullable Connection con, boolean stop) {<z>
if (con != null) {<z>
(stop) {<z>
con.stop();<z>
;<z>
();<z>
jakarta.jms.IllegalStateException ex) {<z>
("Ignoring Connection state exception - assuming already closed: " + ex);<z>
JMSException ex) {<z>
debug("Could not close JMS Connection", ex);<z>
) {<z>
);<z>
setAcceptVersion(@Nullable String... acceptVersions) {<z>
{<z>
;<z>
forEach(version -><z>
.equals("1.2")),<z>
;<z>
ACCEPT_VERSION, StringUtils.arrayToCommaDelimitedString(acceptVersions));<z>
flush() {<z>
this.transaction instanceof SmartTransactionObject) {<z>
);<z>
{<z>
int scope = RequestAttributes.SCOPE_REQUEST;<z>
WebAsyncManager asyncManager = null;<z>
);<z>
if (asyncManagerAttr instanceof WebAsyncManager) {<z>
asyncManager = (WebAsyncManager) asyncManagerAttr;<z>
asyncManager == null) {<z>
new WebAsyncManager();<z>
.setAttribute(WEB_ASYNC_MANAGER_ATTRIBUTE, asyncManager, scope);<z>
;<z>
@Nullable Object value, boolean replace) {<z>
= this.headers.get(name);<z>
notNull(value, "Header value must not be null");<z>
(header == null || replace) {<z>
();<z>
.put(name, header);<z>
(value instanceof Collection) {<z>
?>) value);<z>
.isArray()) {<z>
addValueArray(value);<z>
.addValue(value);<z>
DefaultListableBeanFactory beanFactory) throws BeansException, IOException {<z>
(beanFactory);<z>
.getEnvironment());<z>
beanDefinitionReader.setResourceLoader(this);<z>
;<z>
initBeanDefinitionReader(beanDefinitionReader);<z>
beanDefinitionReader);<z>
() throws InvalidResultSetAccessException {<z>
this.resultSet.isAfterLast();<z>
{<z>
new InvalidResultSetAccessException(se);<z>
Nullable UserTransaction ut) {<z>
ut instanceof TransactionManager) {<z>
logger.isDebugEnabled()) {<z>
"JTA UserTransaction object [" + ut + "] implements TransactionManager");<z>
return (TransactionManager) ut;<z>
FALLBACK_TRANSACTION_MANAGER_NAMES) {<z>
lookup(jndiName, TransactionManager.class);<z>
isDebugEnabled()) {<z>
+ "]");<z>
tm;<z>
catch (NamingException ex) {<z>
()) {<z>
ex);<z>
null;<z>
?> enumeration, Object element) {<z>
{<z>
hasMoreElements()) {<z>
nextElement();<z>
{<z>
return true;<z>
;<z>
, Class<?> exposedType,<z>
String beanName) {<z>
> clazz = factoryBean.getClass();<z>
(clazz.getModifiers());<z>
));<z>
finalClass || finalMethod) {<z>
(exposedType.isInterface()) {<z>
(logger.isTraceEnabled()) {<z>
trace("Creating interface proxy for FactoryBean '" + beanName + "' of type [" +<z>
() + "] for use within another @Bean method because its " +<z>
+<z>
;<z>
;<z>
.isDebugEnabled()) {<z>
+<z>
) + "] for use within another @Bean method because its " +<z>
+<z>
;<z>
factoryBean;<z>
(NoSuchMethodException ex) {<z>
beanFactory, beanName);<z>
@Nullable Object other) {<z>
) {<z>
true;<z>
(!(other instanceof ControlFlowPointcut that)) {<z>
;<z>
that.methodName);<z>
() {<z>
this.prettyPrint != null) {<z>
);<z>
private boolean maybeEatNullReference() {<z>
(TokenKind.IDENTIFIER)) {<z>
peekToken();<z>
, "Expected token");<z>
))) {<z>
;<z>
nextToken();<z>
startPos, nullToken.endPos));<z>
true;<z>
;<z>
)<z>
IllegalStateException {<z>
notNull(synchronization, "TransactionSynchronization must not be null");<z>
);<z>
{<z>
("Transaction synchronization is not active");<z>
synchs.add(synchronization);<z>
propertyName, int startIndex) {<z>
int unclosedPrefixes = 0;<z>
.length();<z>
length; i++) {<z>
(propertyName.charAt(i)) {<z>
PropertyAccessor.PROPERTY_KEY_PREFIX_CHAR:<z>
;<z>
PROPERTY_KEY_SUFFIX_CHAR:<z>
0) {<z>
;<z>
;<z>
;<z>
arg1, Object arg2) {<z>
);<z>
= arg1;<z>
= arg2;<z>
throws JMException {<z>
(managedBean));<z>
new ArrayList<>();<z>
for (PropertyDescriptor prop : props) {<z>
();<z>
.class) {<z>
)) {<z>
null;<z>
prop.getWriteMethod();<z>
includeWriteAttribute(setter, beanKey)) {<z>
;<z>
getter != null || setter != null) {<z>
(prop, isUseStrictCasing());<z>
beanKey);<z>
setter);<z>
);<z>
{<z>
, getter.getName());<z>
(setter != null) {<z>
(FIELD_SET_METHOD, setter.getName());<z>
;<z>
.setDescriptor(desc);<z>
);<z>
0]);<z>
Mono<byte[]> getContent() {<z>
() -> {<z>
.TRUE) {<z>
.content.asMono();<z>
this.hasContentConsumer) {<z>
? this.publisher : this.publisherNested)<z>
onErrorMap(ex -> new IllegalStateException(<z>
ex))<z>
;<z>
();<z>
);<z>
private Advisor getDeclareParentsAdvisor(Field introductionField) {<z>
getAnnotation(DeclareParents.class);<z>
{<z>
;<z>
defaultImpl()) {<z>
"'defaultImpl' attribute must be set on DeclareParents");<z>
DeclareParentsAdvisor(<z>
defaultImpl());<z>
IOException, ClassNotFoundException {<z>
;<z>
) {<z>
(this.fieldName);<z>
methodName != null) {<z>
MethodParameter(<z>
this.parameterTypes), this.parameterIndex);<z>
new MethodParameter(<z>
), this.parameterIndex);<z>
; i++) {<z>
= this.methodParameter.nested();<z>
(Throwable ex) {<z>
ex);<z>
, String... headerHints) {<z>
;<z>
;<z>
.asList(headerHints);<z>
... values) {<z>
for (String value : values) {<z>
);<z>
this;<z>
ModelAndView writeTo(HttpServletRequest request, HttpServletResponse response,<z>
context) throws ServletException, IOException {<z>
writeStatusAndHeaders(response);<z>
lastModified = headers().getLastModified();<z>
, response);<z>
(request.getMethod());<z>
&&<z>
)) {<z>
null;<z>
, response, context);<z>
Throwable throwable) {<z>
(throwable, request, response, context);<z>
<List<V>> iterator() {<z>
;<z>
<>() {<z>
() {<z>
iterator.hasNext();<z>
() {<z>
iterator.next());<z>
() {<z>
);<z>
getChildCount();<z>
++) {<z>
;<z>
.toString();<z>
) {<z>
parameter.getNestedParameterType().getSimpleName();<z>
"' for method " +<z>
;<z>
(CacheManager cacheManager, String cacheName) {<z>
cacheName);<z>
cache == null) {<z>
"' not found");<z>
;<z>
url, boolean suppressClose) {<z>
.get(url));<z>
= suppressClose;<z>
;<z>
(Object message, Throwable exception) {<z>
)) {<z>
), null, exception);<z>
(ClassGenerator cg) throws Exception {<z>
transformer = new ClassEmitterTransformer() {<z>
public void end_class() {<z>
;<z>
.end_class();<z>
new TransformingClassGenerator(cg, transformer);<z>
resolveNamedBean(<z>
{<z>
(beanName, null, args);<z>
if (bean instanceof NullBean) {<z>
;<z>
.toClass()));<z>
TypeDescriptor sourceType, TypeDescriptor targetType) {<z>
{<z>
null;<z>
();<z>
);<z>
= getValidatedMember(targetClass, sourceClass);<z>
method) {<z>
;<z>
) {<z>
invoke(source);<z>
return method.invoke(null, source);<z>
(member instanceof Constructor) {<z>
ctor = (Constructor<?>) member;<z>
ReflectionUtils.makeAccessible(ctor);<z>
.newInstance(source);<z>
ex) {<z>
getTargetException());<z>
(Throwable ex) {<z>
(sourceType, targetType, source, ex);<z>
.format("No to%3$s() method exists on %1$s, " +<z>
)));<z>
void removeCookie(HttpServletResponse response) {<z>
, "HttpServletResponse must not be null");<z>
Cookie cookie = createCookie("");<z>
.setMaxAge(0);<z>
) {<z>
true);<z>
isCookieHttpOnly()) {<z>
setHttpOnly(true);<z>
response.addCookie(cookie);<z>
isTraceEnabled()) {<z>
) + "'");<z>
Object source) {<z>
> strategyMap = new ManagedMap<>();<z>
);<z>
class);<z>
source);<z>
.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
.addPropertyValue("strategyMap", strategyMap);<z>
beanElement : DomUtils.getChildElements(element)) {<z>
beanElement.getAttribute("patterns"));<z>
strategy = null;<z>
())) {<z>
ConstructorArgumentValues cargs = new ConstructorArgumentValues();<z>
("version"));<z>
= new RootBeanDefinition(FixedVersionStrategy.class);<z>
strategyDef.setSource(source);<z>
BeanDefinition.ROLE_INFRASTRUCTURE);<z>
(cargs);<z>
= strategyDef;<z>
())) {<z>
ContentVersionStrategy.class);<z>
source);<z>
);<z>
strategy = strategyDef;<z>
())) {<z>
.get(0);<z>
.parsePropertySubElement(childElement, null);<z>
(String pattern : patterns) {<z>
pattern, strategy);<z>
return versionResolverDef;<z>
) {<z>
Assert.notNull(method, "HttpMethod must not be null");<z>
this.method = method;<z>
return this;<z>
Exception {<z>
);<z>
());<z>
());<z>
();<z>
{<z>
);<z>
getRequestContextAttribute();<z>
null) {<z>
requestContextAttribute);<z>
Boolean exposePathVariables = getExposePathVariables();<z>
(exposePathVariables != null) {<z>
exposePathVariables);<z>
();<z>
exposeContextBeansAsAttributes != null) {<z>
;<z>
[] exposedContextBeanNames = getExposedContextBeanNames();<z>
{<z>
);<z>
return view;<z>
?> value) {<z>
instanceof List) {<z>
;<z>
if (value instanceof Set) {<z>
;<z>
COLLECTION;<z>
Void> handleEncodedContent(<z>
<?> message) {<z>
);<z>
RESPONSE_HEADER + "'");<z>
PayloadUtils::createPayload));<z>
();<z>
) {<z>
clock.millis();<z>
initialDelay, delay, TimeUnit.MILLISECONDS);<z>
ex) {<z>
task, ex);<z>
parameter, NativeWebRequest request) throws Exception {<z>
<String, String>) request.getAttribute(<z>
;<z>
name) : null);<z>
FailureCallback callback) {<z>
;<z>
(this.mutex) {<z>
switch (this.state) {<z>
NEW:<z>
;<z>
:<z>
);<z>
Integer computeHashCode() {<z>
0;<z>
size(); i++) {<z>
;<z>
getAttributeValue(attribute);<z>
)) ^ getValueHashCode(value);<z>
hashCode;<z>
static void insertNumericUnboxOrPrimitiveTypeCoercion(<z>
Nullable String stackDescriptor, char targetDescriptor) {<z>
) {<z>
(mv, targetDescriptor, stackDescriptor);<z>
insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor);<z>
Object other) {<z>
{<z>
return true;<z>
{<z>
return false;<z>
);<z>
{<z>
);<z>
;<z>
(getIndexedReadMethod());<z>
());<z>
return hashCode;<z>
, String comments) throws IOException {<z>
StringWriter();<z>
.omitComments ? null : comments));<z>
stringWriter.toString();<z>
line : contents.split(EOL)) {<z>
.startsWith("#"))) {<z>
writer.write(line + EOL);<z>
int numStack) {<z>
abstractOutputType & DIM_MASK;<z>
abstractOutputType & KIND_MASK;<z>
== LOCAL_KIND) {<z>
;<z>
& TOP_IF_LONG_OR_DOUBLE_FLAG) != 0<z>
== LONG || concreteOutputType == DOUBLE)) {<z>
concreteOutputType = TOP;<z>
concreteOutputType;<z>
{<z>
VALUE_MASK)];<z>
(abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0<z>
== LONG || concreteOutputType == DOUBLE)) {<z>
;<z>
;<z>
{<z>
return abstractOutputType;<z>
bodyTypeRef) {<z>
responseMono.flatMap(response -><z>
,<z>
bodyToMono(bodyTypeRef))));<z>
String beanName) {<z>
(beanName)) {<z>
return false;<z>
this.registry.getBeanDefinition(beanName);<z>
if (existingBeanDef instanceof ConfigurationClassBeanDefinition ccbd) {<z>
getClassName().equals(<z>
))) {<z>
) {<z>
);<z>
;<z>
return false;<z>
{<z>
return false;<z>
> BeanDefinition.ROLE_APPLICATION) {<z>
;<z>
(this.registry instanceof DefaultListableBeanFactory &&<z>
)) {<z>
).getDescription(),<z>
+ existingBeanDef);<z>
logger.isDebugEnabled()) {<z>
format("Skipping bean definition for %s: a definition for bean '%s' " +<z>
beanName));<z>
;<z>
HttpMessageReader<T> findReader(<z>
Context context) {<z>
context.messageReaders().stream()<z>
elementType, mediaType))<z>
.findFirst()<z>
::<T>cast)<z>
IllegalStateException(<z>
mediaType + "\" and \"" + elementType + "\""));<z>
otherDesc) {<z>
] anns = getAnnotations();<z>
();<z>
) {<z>
true;<z>
.length != otherAnns.length) {<z>
;<z>
.length > 0) {<z>
i++) {<z>
])) {<z>
false;<z>
return true;<z>
HttpServletRequest request) {<z>
return new TimeZoneAwareLocaleContext() {<z>
getLocale() {<z>
.getSessionAttribute(request, localeAttributeName);<z>
{<z>
);<z>
return locale;<z>
public TimeZone getTimeZone() {<z>
timeZoneAttributeName);<z>
if (timeZone == null) {<z>
);<z>
return timeZone;<z>
subscription) {<z>
(subscription.isPattern()) {<z>
()) {<z>
) {<z>
.getId());<z>
());<z>
Nullable String propertyPath) {<z>
propertyPath == null) {<z>
;<z>
{<z>
;<z>
if (ch == PropertyAccessor.NESTED_PROPERTY_SEPARATOR_CHAR ||<z>
ch == PropertyAccessor.PROPERTY_KEY_PREFIX_CHAR) {<z>
true;<z>
return false;<z>
(String listenerBeanName) {<z>
this.defaultRetriever) {<z>
add(listenerBeanName);<z>
.clear();<z>
{<z>
;<z>
= expectedSize;<z>
.actualSize = -1;<z>
String resolvePlaceholder(String placeholderName) {<z>
(placeholderName);<z>
(propVal == null) {<z>
(placeholderName);<z>
propVal;<z>
) {<z>
+ placeholderName + "' in [" +<z>
;<z>
return null;<z>
BeanCreationException {<z>
();<z>
null);<z>
);<z>
(BeanCreationException ex) {<z>
ex;<z>
) {<z>
throw new BeanCreationException(<z>
+ "]", ex);<z>
visitNestMember(final String nestMember) {<z>
if (nestMemberClasses == null) {<z>
= new ByteVector();<z>
numberOfNestMemberClasses;<z>
symbolTable.addConstantClass(nestMember).index);<z>
(String className, @Nullable ClassLoader classLoader)<z>
IllegalArgumentException {<z>
);<z>
) {<z>
"Readability mismatch in inheritance hierarchy of class [" +<z>
.getMessage(), err);<z>
{<z>
+ className + "]", err);<z>
ClassNotFoundException ex) {<z>
, ex);<z>
void setUseIsoFormat(boolean useIsoFormat) {<z>
.NONE);<z>
);<z>
NONE);<z>
, Endpoint endpoint) {<z>
.hasText(path, "Path must not be empty");<z>
(endpoint, "Endpoint must not be null");<z>
= path;<z>
endpoint;<z>
;<z>
forPropertyAccessors(PropertyAccessor... accessors) {<z>
accessors) {<z>
{<z>
throw new IllegalArgumentException("SimpleEvaluationContext is not designed for use with a plain " +<z>
"ReflectivePropertyAccessor. Consider using DataBindingPropertyAccessor or a custom subclass.");<z>
Builder(accessors);<z>
(Object entity, HttpServletRequest request,<z>
throws ServletException, IOException {<z>
, request, response, context);<z>
ServletException ex) {<z>
response, context);<z>
(<z>
labels) {<z>
code.length;<z>
% 4);<z>
put(code, lastBytecodeOffset, true);<z>
).putInt(max);<z>
for (Label label : labels) {<z>
put(code, lastBytecodeOffset, true);<z>
dflt, labels);<z>
expectation) {<z>
{<z>
);<z>
expectations.remove(expectation);<z>
Nullable Object other) {<z>
this == other) {<z>
true;<z>
(!(other instanceof ClassPathResource otherRes)) {<z>
false;<z>
(otherRes.path) &&<z>
this.classLoader, otherRes.classLoader) &&<z>
);<z>
) {<z>
headers.get(key);<z>
.tryFromString(key), value);<z>
;<z>
getResource(LookupElement element, @Nullable String requestingBeanName)<z>
{<z>
jndiName = null;<z>
element.mappedName)) {<z>
= element.mappedName;<z>
{<z>
;<z>
!= null) {<z>
if (this.jndiFactory == null) {<z>
,<z>
"No JNDI factory configured - specify the 'jndiFactory' property");<z>
(jndiName, element.lookupType);<z>
this.resourceFactory == null) {<z>
throw new NoSuchBeanDefinitionException(element.lookupType,<z>
;<z>
element, requestingBeanName);<z>
, ?> model, String name) {<z>
BindingResult bindingResult = getBindingResult(model, name);<z>
) {<z>
+<z>
"'- have you exposed the correct model?");<z>
return bindingResult;<z>
(Object body) {<z>
body;<z>
, this.contextPath, this.headers,<z>
this.queryParams, this.pathVariables,<z>
this.localAddress,<z>
.messageReaders, this.exchange);<z>
() {<z>
, this.name);<z>
);<z>
copy;<z>
> MergedAnnotation<A> get(String annotationType,<z>
A>> predicate,<z>
<A> selector) {<z>
annotationType)) {<z>
;<z>
result = scan(annotationType,<z>
);<z>
result : MergedAnnotation.missing());<z>
getSslInfo() {<z>
this.sslInfo == null) {<z>
sslInfo = initSslInfo();<z>
return this.sslInfo;<z>
Nullable Map<String, Object> jpaProperties) {<z>
if (jpaProperties != null) {<z>
this.jpaPropertyMap.putAll(jpaProperties);<z>
Nullable Object value, int sqlType) {<z>
notNull(paramName, "Parameter name must not be null");<z>
paramName, value);<z>
paramName, sqlType);<z>
return this;<z>
> resolveUrlPathInternal(String resourceUrlPath,<z>
locations, ResourceResolverChain chain) {<z>
.resolveUrlPath(resourceUrlPath, locations)<z>
.flatMap(baseUrl -> {<z>
) {<z>
strategy = getStrategyForPath(resourceUrlPath);<z>
strategy == null) {<z>
.just(baseUrl);<z>
resolveResource(null, baseUrl, locations)<z>
.getResourceVersion(resource)<z>
));<z>
empty();<z>
;<z>
Object resolveDependency(<z>
, AutowireCapableBeanFactory beanFactory)<z>
throws BeansException {<z>
, "Parameter must not be null");<z>
.notNull(containingClass, "Containing class must not be null");<z>
.notNull(beanFactory, "AutowireCapableBeanFactory must not be null");<z>
;<z>
(annotatedParameter, Autowired.class);<z>
());<z>
forExecutable(<z>
;<z>
required);<z>
descriptor.setContainingClass(containingClass);<z>
;<z>
dataBuffer, ResolvableType targetType,<z>
> hints) throws DecodingException {<z>
());<z>
= dataBuffer.asByteBuffer();<z>
newInstance(buffer), this.extensionRegistry);<z>
();<z>
{<z>
DecodingException("I/O error while parsing input stream", ex);<z>
catch (Exception ex) {<z>
;<z>
dataBuffer);<z>
public void onComplete() {<z>
)) {<z>
new DecodingException("Could not find end of headers"));<z>
getRSocketStrategies() {<z>
result;<z>
strategiesConfigurers.isEmpty()) {<z>
=<z>
;<z>
c.accept(builder));<z>
.build();<z>
.builder().build();<z>
;<z>
;<z>
;<z>
?> enumType) {<z>
(enumType, "Enum type must not be null");<z>
)) {<z>
);<z>
enumType.asSubclass(Enum.class);<z>
columnIndex) throws InvalidResultSetAccessException {<z>
return this.resultSet.getString(columnIndex);<z>
SQLException se) {<z>
);<z>
bindStatus) {<z>
.containsKey(candidateValue)) {<z>
return true;<z>
) {<z>
), candidateValue, bindStatus);<z>
request, AsyncContext context)<z>
IOException, URISyntaxException {<z>
.notNull(this.servletPath, "Servlet path is not initialized");<z>
new ServletServerHttpRequest(<z>
;<z>
attributes, String attributeName,<z>
E defaultValue) {<z>
);<z>
{<z>
defaultValue;<z>
;<z>
SAXException {<z>
, length);<z>
this.inCData) {<z>
;<z>
cDataInternal(data);<z>
XMLStreamException ex) {<z>
;<z>
@Nullable MediaType mediaType)<z>
{<z>
) {<z>
;<z>
HttpResource httpResource) {<z>
httpResource.getResponseHeaders();<z>
(headerName, headerValues) -> {<z>
= true;<z>
headerValues) {<z>
{<z>
;<z>
addHeader(headerName, headerValue);<z>
;<z>
);<z>
(HttpHeaders.ACCEPT_RANGES, "bytes");<z>
throws ParseException {<z>
expressionString.isEmpty()) {<z>
new LiteralExpression("");<z>
= parseExpressions(expressionString, context);<z>
.length == 1) {<z>
expressions[0];<z>
, expressions);<z>
private final ParserContext beanExpressionParserContext = new ParserContext() {<z>
boolean isTemplate() {<z>
return true;<z>
() {<z>
;<z>
) {<z>
return expressionSuffix;<z>
int cacheSeconds) {<z>
useExpiresHeader || !this.useCacheControlHeader) {<z>
cacheSeconds > 0) {<z>
(response, cacheSeconds);<z>
if (cacheSeconds == 0) {<z>
;<z>
cControl;<z>
{<z>
, TimeUnit.SECONDS);<z>
this.alwaysMustRevalidate) {<z>
);<z>
(cacheSeconds == 0) {<z>
());<z>
;<z>
);<z>
, String relativePath) {<z>
.lastIndexOf(FOLDER_SEPARATOR);<z>
separatorIndex != -1) {<z>
, separatorIndex);<z>
startsWith(FOLDER_SEPARATOR)) {<z>
newPath += FOLDER_SEPARATOR;<z>
+ relativePath;<z>
return relativePath;<z>
private RuntimeBeanReference cronTaskReference(String runnableBeanName,<z>
ParserContext parserContext) {<z>
.genericBeanDefinition(<z>
);<z>
runnableBeanName);<z>
addConstructorArgValue(cronExpression);<z>
parserContext, builder);<z>
private void emitSetThreadCallbacks(ClassEmitter ce) {<z>
Constants.ACC_STATIC,<z>
null);<z>
;<z>
(0);<z>
);<z>
.return_value();<z>
end_method();<z>
Mono<String> getBodyAsString() {<z>
::getCharset)<z>
.UTF_8);<z>
)<z>
buffer -> {<z>
charset);<z>
buffer);<z>
return s;<z>
;<z>
T beanOfType(<z>
)<z>
BeansException {<z>
(lbf, "ListableBeanFactory must not be null");<z>
, allowEagerInit);<z>
beansOfType);<z>
parserContext) {<z>
= element.getAttribute("mode");<z>
)) {<z>
parserContext);<z>
;<z>
null;<z>
public void stop() {<z>
if (isRunning()) {<z>
.running = false;<z>
()) {<z>
if (handler instanceof Lifecycle) {<z>
) handler).stop();<z>
ServletContext servletContext) {<z>
.FMT_TIME_ZONE);<z>
) {<z>
= request.getSession(false);<z>
!= null) {<z>
FMT_TIME_ZONE);<z>
servletContext != null) {<z>
FMT_TIME_ZONE);<z>
TimeZone ? (TimeZone) timeZoneObject : null);<z>
customizeBeanFactory(DefaultListableBeanFactory beanFactory) {<z>
allowBeanDefinitionOverriding != null) {<z>
);<z>
(this.allowCircularReferences != null) {<z>
.allowCircularReferences);<z>
, Method candidateMethod) {<z>
()) &&<z>
rootMethod.getName()) &&<z>
, candidateMethod));<z>
ClassUtils.isPresent("groovy.lang.Closure",<z>
WebDelegatingSmartContextLoader.class.getClassLoader())<z>
&& ClassUtils.isPresent(GROOVY_XML_WEB_CONTEXT_LOADER_CLASS_NAME,<z>
());<z>
final SmartContextLoader xmlLoader;<z>
SmartContextLoader annotationConfigLoader;<z>
) {<z>
{<z>
.forName(GROOVY_XML_WEB_CONTEXT_LOADER_CLASS_NAME,<z>
());<z>
;<z>
Throwable ex) {<z>
new IllegalStateException("Failed to enable support for Groovy scripts; "<z>
;<z>
new GenericXmlWebContextLoader();<z>
this.annotationConfigLoader = new AnnotationConfigWebContextLoader();<z>
unwrap(WebSocketHandler handler) {<z>
(handler instanceof WebSocketHandlerDecorator) {<z>
handler).getLastHandler();<z>
;<z>
DateTimeFormatter createStrictDateTimeFormatter(String pattern) {<z>
, "uu");<z>
patternToUse).withResolverStyle(ResolverStyle.STRICT);<z>
String sourceValue, String attributeName,<z>
parameter, WebDataBinderFactory binderFactory, NativeWebRequest request)<z>
{<z>
;<z>
.getConversionService();<z>
{<z>
.class);<z>
target = new TypeDescriptor(parameter);<z>
{<z>
;<z>
;<z>
() {<z>
return new SortedProperties(false) {<z>
(String key) {<z>
key);<z>
;<z>
) throws JMSException {<z>
this.message);<z>
.springframework.messaging.Message) {<z>
getPayload();<z>
payload;<z>
(Method method, @Nullable Object returnValue) {<z>
?> type = getDiscoveredReturningType();<z>
);<z>
, method, returnValue) &&<z>
null || genericType == type ||<z>
);<z>
Nullable Class<T> requiredType) {<z>
(requiredType != null) {<z>
isInstance(request)) {<z>
T) request;<z>
ServletRequestWrapper wrapper) {<z>
(wrapper.getRequest(), requiredType);<z>
null;<z>
(String value) {<z>
;<z>
.getBit(0)) {<z>
(7);<z>
);<z>
result;<z>
String textToSearch, String substring, String message) {<z>
) &&<z>
) {<z>
);<z>
T> exceptionType,<z>
<ServerResponse>> responseProvider) {<z>
);<z>
notNull(responseProvider, "ResponseProvider must not be null");<z>
request)<z>
;<z>
return this;<z>
protected XStream constructXStream() {<z>
, new ClassLoaderReference(this.beanClassLoader),<z>
, this.converterLookup, this.converterRegistry) {<z>
{<z>
MapperWrapper mapperToWrap = next;<z>
mapperWrappers != null) {<z>
extends MapperWrapper> mapperWrapper : mapperWrappers) {<z>
;<z>
Mapper.class);<z>
(NoSuchMethodException ex) {<z>
mapperWrapper.getConstructor(MapperWrapper.class);<z>
{<z>
"No appropriate MapperWrapper constructor found: " + mapperWrapper);<z>
(mapperToWrap);<z>
) {<z>
IllegalStateException("Failed to construct MapperWrapper: " + mapperWrapper);<z>
mapperToWrap;<z>
String paramName) {<z>
int sqlType = super.getSqlType(paramName);<z>
(sqlType != TYPE_UNKNOWN) {<z>
sqlType;<z>
.getPropertyType(paramName);<z>
);<z>
other) {<z>
(this == other) {<z>
;<z>
other instanceof ResponseCookie otherCookie)) {<z>
false;<z>
.equalsIgnoreCase(otherCookie.getName()) &&<z>
()) &&<z>
;<z>
AnnotationAttributes attributes) {<z>
getStringArray(COMMENT_PREFIX);<z>
= attributes.getStringArray(COMMENT_PREFIXES);<z>
(Arrays.equals(commentPrefix, commentPrefixes),<z>
);<z>
.DEFAULT_COMMENT_PREFIXES);<z>
next(Date date) {<z>
calendar = new GregorianCalendar();<z>
);<z>
);<z>
.set(Calendar.MILLISECOND, 0);<z>
long originalTimestamp = calendar.getTimeInMillis();<z>
.get(Calendar.YEAR));<z>
originalTimestamp) {<z>
Calendar.SECOND, 1);<z>
YEAR));<z>
.getTime();<z>
{<z>
Assert.notNull(path, "Path must not be null");<z>
pathToUse = StringUtils.cleanPath(path);<z>
("/")) {<z>
.substring(1);<z>
.path = pathToUse;<z>
: ClassUtils.getDefaultClassLoader());<z>
void complete() {<z>
request, MockHttpServletRequest.class);<z>
!= null) {<z>
;<z>
for (AsyncListener listener : this.listeners) {<z>
, this.response));<z>
IOException ex) {<z>
ex);<z>
ObjectStreamClass classDesc) throws IOException, ClassNotFoundException {<z>
!= null) {<z>
, this.classLoader);<z>
;<z>
catch (ClassNotFoundException ex) {<z>
(classDesc.getName(), ex);<z>
;<z>
[] properties() default {};<z>
String[] bcc) throws MessagingException {<z>
);<z>
= new InternetAddress[bcc.length];<z>
i < bcc.length; i++) {<z>
] = parseAddress(bcc[i]);<z>
(addresses);<z>
>> responseBodyAdvice) {<z>
(responseBodyAdvice != null) {<z>
requestResponseBodyAdvice.addAll(responseBodyAdvice);<z>
] callbacks) {<z>
.length == 0) {<z>
);<z>
callbacks = callbacks;<z>
,<z>
) {<z>
MockServletContext());<z>
? request : new MockHttpServletRequest(servletContext));<z>
response : new MockHttpServletResponse());<z>
);<z>
elementType, @Nullable MimeType mimeType) {<z>
canEncode(elementType, mimeType)) {<z>
.toClass();<z>
isAnnotationPresent(XmlRootElement.class) ||<z>
));<z>
;<z>
parameterSource) {<z>
);<z>
.getParameterNames();<z>
) {<z>
: paramNames) {<z>
toLowerCase(), name);<z>
;<z>
public void afterCompletion(<z>
, HttpServletResponse response, Object handler, Exception ex)<z>
ServletException {<z>
getAttribute("test2y") != null) {<z>
new ServletException("Wrong interceptor order");<z>
getAttribute("test1y") == null) {<z>
"afterCompletion invoked twice");<z>
;<z>
ServerHttpRequest request) {<z>
).getQuery();<z>
().getQueryParams();<z>
value = params.getFirst("c");<z>
(value)) {<z>
null;<z>
;<z>
: null);<z>
endPos, double value) {<z>
startPos, endPos);<z>
.value = new TypedValue(value);<z>
"D";<z>
{<z>
(this.lifecycleMonitor) {<z>
{<z>
getResourceAdapter();<z>
resourceAdapter != null, "No ResourceAdapter set");<z>
());<z>
false;<z>
@Nullable String scheme, int port) {<z>
port == -1) {<z>
)) {<z>
= 80;<z>
)) {<z>
= 443;<z>
;<z>
void addOrMergeIndexedArgumentValue(Integer key, ValueHolder newValue) {<z>
);<z>
) {<z>
)) {<z>
currentValue.getValue()));<z>
.indexedArgumentValues.put(key, newValue);<z>
protected EntityManager createEntityManagerForTransaction() {<z>
emf = obtainEntityManagerFactory();<z>
getJpaPropertyMap();<z>
;<z>
EntityManagerFactoryInfo) {<z>
(properties);<z>
= (!CollectionUtils.isEmpty(properties) ?<z>
.createEntityManager());<z>
) {<z>
accept(em);<z>
em;<z>
(int status, String reasonPhrase,<z>
, @Nullable Charset charset,<z>
Nullable HttpRequest request) {<z>
headers, body, charset, request);<z>
() {<z>
) {<z>
.TYPE_OBJECT, GET_CLASS);<z>
JavaType targetJavaType) throws JMSException, IOException {<z>
) {<z>
targetJavaType);<z>
{<z>
) message, targetJavaType);<z>
;<z>
) {<z>
"beanName")) {<z>
;<z>
"source")) {<z>
);<z>
else if (this.beanDefinition != null) {<z>
return new GroovyPropertyValue(<z>
(property));<z>
;<z>
boolean equals(Object o) {<z>
== o) return true;<z>
)) return false;<z>
) o;<z>
that.id);<z>
boolean finalPart) {<z>
(this.channel);<z>
.blockingOperationScheduler));<z>
(finalPart) {<z>
emitComplete();<z>
) throws IOException {<z>
= this.response.getBody();<z>
null) {<z>
return true;<z>
)) {<z>
;<z>
1) {<z>
true;<z>
reset();<z>
;<z>
= new PushbackInputStream(body);<z>
.read();<z>
(b == -1) {<z>
true;<z>
pushbackInputStream.unread(b);<z>
return false;<z>
) {<z>
(task);<z>
.taskDecorator, future);<z>
;<z>
) {<z>
(<z>
+ task, ex);<z>
) {<z>
, key -> {<z>
.getMethods();<z>
));<z>
methods;<z>
;<z>
{<z>
(this.connectionMonitor) {<z>
!= null) {<z>
connection);<z>
;<z>
) {<z>
;<z>
>();<z>
(Object argValue : argValues) {<z>
));<z>
() :<z>
Collections.unmodifiableList(stringArgValues));<z>
) {<z>
: this.inactivityTasks) {<z>
cancel(true);<z>
{<z>
lastReadTime = -1;<z>
.lastWriteTime = -1;<z>
inactivityTasks.clear();<z>
public Theme getTheme(String themeName) {<z>
.themeCache.get(themeName);<z>
{<z>
this.themeCache) {<z>
.get(themeName);<z>
== null) {<z>
String basename = this.basenamePrefix + themeName;<z>
(basename);<z>
= new SimpleTheme(themeName, messageSource);<z>
theme);<z>
;<z>
.isDebugEnabled()) {<z>
themeName + "', basename [" + basename + "]");<z>
return theme;<z>
servletRequest) {<z>
<?> errorHandler : this.errorHandlers) {<z>
t)) {<z>
(ServerRequest)<z>
servletRequest.getAttribute(RouterFunctions.REQUEST_ATTRIBUTE);<z>
serverRequest);<z>
return null;<z>
name)<z>
{<z>
;<z>
previousFlushMode = prepareFlushMode(session, readOnly);<z>
);<z>
Class<?> clazz,<z>
>> requiredReturnTypes) {<z>
methods = getSortedMethods(clazz);<z>
{<z>
methods) {<z>
.equals(prefix + methodSuffix) &&<z>
) == numberOfParams &&<z>
.getModifiers())) &&<z>
)) {<z>
method;<z>
null;<z>
deserializer) {<z>
.notNull(serializer, "Serializer must not be null");<z>
Assert.notNull(deserializer, "Deserializer must not be null");<z>
serializer = serializer;<z>
.deserializer = deserializer;<z>
void doOptions(HttpServletRequest request, HttpServletResponse response)<z>
ServletException, IOException {<z>
.isPreFlightRequest(request)) {<z>
, response);<z>
{<z>
) {<z>
value) {<z>
equals(name)) {<z>
.PATCH.name();<z>
(name, value);<z>
);<z>
> getAdvice(Class<?> adviceType) {<z>
class == adviceType) {<z>
this.requestBodyAdvice;<z>
{<z>
.responseBodyAdvice;<z>
throw new IllegalArgumentException("Unexpected adviceType: " + adviceType);<z>
ListenableFuture<WebSocketSession> doHandshake(<z>
) {<z>
);<z>
);<z>
, uri);<z>
resolveAndCacheLookupPath(HttpServletRequest request) {<z>
request);<z>
PATH_ATTRIBUTE, lookupPath);<z>
lookupPath;<z>
(HttpMethod method, URI url) {<z>
.method = method;<z>
this.uri = url;<z>
null;<z>
.uriVarsArray = null;<z>
= null;<z>
protected Object nextInstance(Object instance) {<z>
EnhancerFactoryData data = (EnhancerFactoryData) instance;<z>
(classOnly) {<z>
.generatedClass;<z>
Class[] argumentTypes = this.argumentTypes;<z>
this.arguments;<z>
if (argumentTypes == null) {<z>
argumentTypes = Constants.EMPTY_CLASS_ARRAY;<z>
null;<z>
);<z>
environment, @Nullable String agentId)<z>
MBeanServerNotFoundException {<z>
(serviceUrl != null) {<z>
)) {<z>
.debug("Connecting to remote MBeanServer at URL [" + serviceUrl + "]");<z>
;<z>
;<z>
IOException ex) {<z>
+ serviceUrl + "]", ex);<z>
);<z>
return JmxUtils.locateMBeanServer(agentId);<z>
) {<z>
switch (ch) {<z>
case 'Z':<z>
"(Z)Ljava/lang/Boolean;", false);<z>
:<z>
, "valueOf", "(B)Ljava/lang/Byte;", false);<z>
case 'C':<z>
false);<z>
'D':<z>
false);<z>
:<z>
"java/lang/Float", "valueOf", "(F)Ljava/lang/Float;", false);<z>
case 'I':<z>
);<z>
case 'J':<z>
, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long;", false);<z>
case 'S':<z>
, "valueOf", "(S)Ljava/lang/Short;", false);<z>
'L':<z>
:<z>
case '[':<z>
new IllegalArgumentException("Boxing should not be attempted for descriptor '" + ch + "'");<z>
, @Nullable Object value) {<z>
notNull(name, "Name must not be null");<z>
= name;<z>
value;<z>
,<z>
ServletException, IOException {<z>
DeferredResult<>();<z>
, deferredResult);<z>
, deferredResult));<z>
;<z>
[] getParameterNames() {<z>
.parameterNames;<z>
== null) {<z>
);<z>
= parameterNames;<z>
return parameterNames;<z>
{<z>
= context.getBeansOfType(SimpleUrlHandlerMapping.class);<z>
values());<z>
AnnotationAwareOrderComparator.sort(mappings);<z>
-><z>
((pattern, handler) -> {<z>
instanceof ResourceWebHandler resourceHandler) {<z>
;<z>
));<z>
(this.handlerMap.isEmpty()) {<z>
("No resource handling mappings found");<z>
{<z>
);<z>
.multipartReader = other.multipartReader;<z>
other.sseEncoder;<z>
public void setServletContext(ServletContext servletContext) {<z>
ServletContextAware) {<z>
).setServletContext(servletContext);<z>
int writeToOutputStream(DataBuffer dataBuffer) throws IOException {<z>
= this.outputStream;<z>
dataBuffer.asInputStream();<z>
= 0;<z>
= new byte[this.bufferSize];<z>
bytesRead;<z>
!= -1) {<z>
(buffer, 0, bytesRead);<z>
;<z>
;<z>
resource, IOException ex) {<z>
FIRST_FOUND &&<z>
!= ResolutionMethod.OVERRIDE_AND_IGNORE) {<z>
IllegalStateException(ex);<z>
()) {<z>
+ ": " + ex.getMessage());<z>
{<z>
if (ex != null) {<z>
;<z>
public void validate() {<z>
{<z>
this.problemReporter);<z>
stop() {<z>
(isRunning()) {<z>
;<z>
) {<z>
();<z>
synchronized Session getSession() {<z>
{<z>
);<z>
this.session;<z>
<?>> converters,<z>
{<z>
);<z>
.google.protobuf.Message other) {<z>
{<z>
;<z>
{<z>
;<z>
return this;<z>
String name, Object value) {<z>
(name, "'name' must not be null");<z>
notNull(value, "'value' must not be null");<z>
value);<z>
return this;<z>
{<z>
(this.tagWriter != null, "No TagWriter set");<z>
this.tagWriter.endTag();<z>
EVAL_PAGE;<z>
String> parameters) {<z>
"Extension name must not be empty");<z>
= name;<z>
)) {<z>
ENGLISH);<z>
parameters);<z>
(map);<z>
();<z>
context, Class<?> source,<z>
> processor, boolean includeInterfaces, boolean includeEnclosing) {<z>
, source, processor,<z>
;<z>
int parameterIndex, int nestingLevel) {<z>
"Method must not be null");<z>
.executable = method;<z>
.parameterIndex = validateIndex(method, parameterIndex);<z>
nestingLevel = nestingLevel;<z>
supportedMediaTypes) {<z>
Assert.notEmpty(supportedMediaTypes, "MediaType List must not be empty");<z>
this.mediaTypes.clear();<z>
addAll(supportedMediaTypes);<z>
? super S> predicate) {<z>
it -> {<z>
mapped = mapper.apply(it);<z>
it) : Stream.empty();<z>
);<z>
<?> containingClass) {<z>
();<z>
containingClass;<z>
= null;<z>
;<z>
expression) {<z>
(expression.startsWith("!")) {<z>
;<z>
;<z>
false;<z>
(expression);<z>
{<z>
this.lifecycleMonitor) {<z>
() || this.stopCallback != null) {<z>
;<z>
= callback;<z>
();<z>
boolean isAfterAdvice(Advisor anAdvisor) {<z>
);<z>
) {<z>
.isAfterAdvice();<z>
AfterAdvice);<z>
{<z>
.done) {<z>
.elementRef.lazySet(null);<z>
boolean isTerminated = this.terminated;<z>
();<z>
if (element != null) {<z>
null);<z>
!= null, "No subscription");<z>
send(element);<z>
1);<z>
final Throwable ex) {<z>
)) {<z>
emitter + " failed: " + ex);<z>
;<z>
{<z>
true;<z>
error;<z>
error = null;<z>
if (ex != null) {<z>
{<z>
this.emitter + " failed: " + ex);<z>
this.emitter.completeWithError(ex);<z>
) {<z>
;<z>
this.emitter.complete();<z>
executing.decrementAndGet() != 0) {<z>
);<z>
, Charset charset, Type type) {<z>
!StringUtils.hasLength(source)) {<z>
;<z>
"Charset must not be null");<z>
);<z>
(charset);<z>
;<z>
(byte b : bytes) {<z>
(!type.isAllowed(b)) {<z>
;<z>
if (original) {<z>
source;<z>
bytes.length);<z>
byte b : bytes) {<z>
)) {<z>
);<z>
baos.write('%');<z>
4) & 0xF, 16));<z>
));<z>
(hex1);<z>
baos.write(hex2);<z>
copyToString(baos, charset);<z>
oldPattern, @Nullable String newPattern) {<z>
(oldPattern) || newPattern == null) {<z>
return inString;<z>
= inString.indexOf(oldPattern);<z>
(index == -1) {<z>
;<z>
capacity = inString.length();<z>
() > oldPattern.length()) {<z>
+= 16;<z>
);<z>
= 0;<z>
patLen = oldPattern.length();<z>
(index >= 0) {<z>
pos, index);<z>
;<z>
patLen;<z>
, pos);<z>
);<z>
return sb.toString();<z>
paramTypes) {<z>
, paramTypes);<z>
NoSuchMethodException ex) {<z>
!= null) {<z>
.getSuperclass(), methodName, paramTypes);<z>
;<z>
MethodParameter param) {<z>
) {<z>
return true;<z>
this.useDefaultResolution) {<z>
BeanUtils::isSimpleProperty) ||<z>
nestedIfOptional().getNestedParameterType());<z>
;<z>
, int priority,<z>
completionListener) throws JMSException {<z>
, completionListener);<z>
Object[] beanMethodArgs,<z>
MethodProxy cglibMethodProxy) throws Throwable {<z>
enhancedConfigInstance);<z>
;<z>
isScopedProxy(beanMethod)) {<z>
(beanName);<z>
isCurrentlyInCreation(scopedBeanName)) {<z>
;<z>
+ beanName) &&<z>
)) {<z>
beanName);<z>
) {<z>
getReturnType(), beanFactory, beanName);<z>
beanMethod)) {<z>
.isInfoEnabled() &&<z>
.getReturnType())) {<z>
info(String.format("@Bean method %s.%s is non-static and returns an object " +<z>
);<z>
(enhancedConfigInstance, beanMethodArgs);<z>
beanMethodArgs, beanFactory, beanName);<z>
) {<z>
0];<z>
;<z>
.isCompilable() &&<z>
null);<z>
.springframework.protobuf.Msg buildPartial() {<z>
(this);<z>
;<z>
to_bitField0_ = 0;<z>
0x00000001) == 0x00000001)) {<z>
to_bitField0_ |= 0x00000001;<z>
.foo_ = foo_;<z>
{<z>
to_bitField0_ |= 0x00000002;<z>
blahBuilder_ == null) {<z>
;<z>
} else {<z>
build();<z>
to_bitField0_;<z>
onBuilt();<z>
result;<z>
Object other) {<z>
if (this == other) {<z>
return true;<z>
(!(other instanceof CacheOperationCacheKey otherKey)) {<z>
return false;<z>
equals(otherKey.cacheOperation) &&<z>
.equals(otherKey.methodCacheKey));<z>
HttpServletRequest request) {<z>
) {<z>
.resourceUrlProvider;<z>
getAttribute(<z>
.RESOURCE_URL_PROVIDER_ATTR);<z>
{<z>
) {<z>
.registerComponent(<z>
AopConfigUtils.AUTO_PROXY_CREATOR_BEAN_NAME));<z>
() {<z>
= 0;<z>
++) {<z>
];<z>
size();<z>
);<z>
+= numberOfMappings;<z>
;<z>
private RelativeRedirectResponseWrapper(HttpServletResponse response, HttpStatus redirectStatus) {<z>
response);<z>
"'redirectStatus' is required");<z>
redirectStatus;<z>
(Class<?> beanClass) {<z>
||<z>
class.isAssignableFrom(beanClass) ||<z>
isAssignableFrom(beanClass) ||<z>
AopInfrastructureBean.class.isAssignableFrom(beanClass);<z>
isTraceEnabled()) {<z>
;<z>
retVal;<z>
) {<z>
0;<z>
) {<z>
);<z>
) {<z>
skipped;<z>
= pos + skipped;<z>
)) {<z>
;<z>
charAt(currPos)) {<z>
;<z>
;<z>
) {<z>
{<z>
argName, ref);<z>
RuntimeBeanNameReference ref) {<z>
.getBeanName();<z>
valueOf(doEvaluate(refName));<z>
refName)) {<z>
(<z>
;<z>
;<z>
BeanDefinitionHolder bdHolder) {<z>
);<z>
instanceof BeanDefinition bd) {<z>
String innerBeanName = "(inner bean)" + BeanFactoryUtils.GENERATED_BEAN_NAME_SEPARATOR +<z>
;<z>
, bd);<z>
) {<z>
(4);<z>
.beanFactory.resolveDependency(<z>
this.typeConverter);<z>
String autowiredBeanName : autowiredBeanNames) {<z>
{<z>
autowiredBeanName, this.beanName);<z>
;<z>
managedArray) {<z>
?> elementType = managedArray.resolvedElementType;<z>
) {<z>
();<z>
.hasText(elementTypeName)) {<z>
this.beanFactory.getBeanClassLoader());<z>
elementType;<z>
catch (Throwable ex) {<z>
new BeanCreationException(<z>
), this.beanName,<z>
"Error resolving array type for " + argName, ex);<z>
.class;<z>
;<z>
ManagedList<?> managedList) {<z>
return resolveManagedList(argName, managedList);<z>
?> managedSet) {<z>
(argName, managedSet);<z>
, ?> managedMap) {<z>
return resolveManagedMap(argName, managedMap);<z>
else if (value instanceof ManagedProperties original) {<z>
copy = new Properties();<z>
forEach((propKey, propValue) -> {<z>
{<z>
;<z>
typedStringValue) {<z>
propValue = evaluate(typedStringValue);<z>
(propKey == null || propValue == null) {<z>
BeanCreationException(<z>
), this.beanName,<z>
+ argName + ": resolved to null");<z>
(propKey, propValue);<z>
});<z>
copy;<z>
(value instanceof TypedStringValue typedStringValue) {<z>
typedStringValue);<z>
<?> resolvedTargetType = resolveTargetType(typedStringValue);<z>
!= null) {<z>
typeConverter.convertIfNecessary(valueObject, resolvedTargetType);<z>
;<z>
ex) {<z>
(<z>
), this.beanName,<z>
;<z>
(value instanceof NullBean) {<z>
;<z>
value);<z>
String msg, @Nullable Throwable cause) {<z>
msg, cause);<z>
= beanClass;<z>
;<z>
NumberFormat annotation) {<z>
annotation.pattern());<z>
StringUtils.hasLength(pattern)) {<z>
NumberStyleFormatter(pattern);<z>
();<z>
style == Style.CURRENCY) {<z>
CurrencyStyleFormatter();<z>
style == Style.PERCENT) {<z>
PercentStyleFormatter();<z>
return new NumberStyleFormatter();<z>
exchange) {<z>
routerFunction != null) {<z>
create(exchange, this.messageReaders);<z>
route(request)<z>
(), request, handler));<z>
empty();<z>
JsonDeserializer<?> deserializerInstance(DeserializationConfig config,<z>
annotated, Class<?> implClass) {<z>
beanFactory.createBean(implClass);<z>
@Nullable Object other) {<z>
(this == other) {<z>
;<z>
)) {<z>
return false;<z>
other).delegate);<z>
public String getScriptAsString() throws IOException {<z>
.lastModifiedMonitor) {<z>
= retrieveLastModifiedTime();<z>
;<z>
reader);<z>
static URL extractArchiveURL(URL jarUrl) throws MalformedURLException {<z>
();<z>
;<z>
(endIndex != -1) {<z>
substring(0, endIndex);<z>
jarUrl.getProtocol())) {<z>
;<z>
.indexOf(WAR_URL_PREFIX);<z>
-1) {<z>
));<z>
;<z>
NativeWebRequest webRequest, MethodParameter parameter,<z>
{<z>
getNativeRequest(HttpServletRequest.class);<z>
);<z>
servletRequest);<z>
paramType);<z>
parameter)) {<z>
("Required request body is missing: " +<z>
().toGenericString(), inputMessage);<z>
return arg;<z>
startInternal() {<z>
{<z>
) {<z>
getSimpleName());<z>
= true;<z>
);<z>
URI getURI() throws IOException {<z>
URL url = getURL();<z>
;<z>
URISyntaxException ex) {<z>
"]", ex);<z>
,<z>
@Nullable String user) {<z>
+ sessionId;<z>
String, Object> model, HttpServletRequest request,<z>
throws Exception {<z>
temporaryStream = null;<z>
stream;<z>
(this.updateContentLength) {<z>
createTemporaryOutputStream();<z>
= temporaryStream;<z>
;<z>
;<z>
stream, value);<z>
null) {<z>
(response, temporaryStream);<z>
public void setBeanFactory(BeanFactory beanFactory) throws BeansException {<z>
beanFactory);<z>
{<z>
throw new BeanDefinitionStoreException(<z>
;<z>
(Object codec, boolean applyDefaultConfig) {<z>
if (codec instanceof Decoder) {<z>
(Decoder<?>) codec);<z>
else if (codec instanceof Encoder) {<z>
<?>) codec);<z>
instanceof HttpMessageReader) {<z>
codec;<z>
class), null);<z>
);<z>
instanceof HttpMessageWriter) {<z>
<?>) codec;<z>
Object.class), null);<z>
.put(writer, applyDefaultConfig);<z>
().getName());<z>
ClientHttpResponse response) throws IOException {<z>
);<z>
== null) {<z>
new UnknownHttpStatusCodeException(<z>
null, null);<z>
(httpStatus != HttpStatus.OK) {<z>
(<z>
(), null, null);<z>
{<z>
());<z>
;<z>
();<z>
true) {<z>
()) {<z>
(logger.isDebugEnabled()) {<z>
logger.debug("SockJS sockJsSession closed, closing response.");<z>
);<z>
;<z>
) {<z>
) {<z>
(os);<z>
if (logger.isTraceEnabled()) {<z>
);<z>
) {<z>
;<z>
write(b);<z>
return null;<z>
) {<z>
{<z>
StringUtils.tokenizeToStringArray(argsSpec, ",");<z>
i < tokens.length; i++) {<z>
strip();<z>
maybeExtractVariableName(tokens[i]);<z>
!= null) {<z>
add(varName);<z>
Flux<DataBuffer> write(<z>
, long position) {<z>
);<z>
;<z>
"'position' must be >= 0");<z>
> flux = Flux.from(source);<z>
return Flux.create(sink -> {<z>
position);<z>
.onDispose(handler);<z>
subscribe(handler);<z>
);<z>
(Method method)<z>
InvalidMetadataException {<z>
= getRepeatableAnnotations(<z>
.class, ManagedOperationParameters.class);<z>
metadata.ManagedOperationParameter.class);<z>
(<z>
<HttpMessageReader<?>> messageReaders,<z>
>> messageWriters,<z>
viewResolvers,<z>
,<z>
,<z>
) {<z>
this.messageReaders = unmodifiableCopy(messageReaders);<z>
= unmodifiableCopy(messageWriters);<z>
= unmodifiableCopy(viewResolvers);<z>
);<z>
);<z>
localeContextResolver = localeContextResolver;<z>
IllegalArgumentException {<z>
Resource[]))) {<z>
value));<z>
LinkedHashSet<>();<z>
(Object element : input) {<z>
(element instanceof String) {<z>
.trim();<z>
.resourcePatternResolver.getResources(pattern);<z>
;<z>
IOException ex) {<z>
.isDebugEnabled()) {<z>
, ex);<z>
element instanceof Resource) {<z>
((Resource) element);<z>
throw new IllegalArgumentException("Cannot convert element [" + element + "] to [" +<z>
() + "]: only location String and Resource object supported");<z>
0]));<z>
;<z>
value, Class<T> targetType) {<z>
convertValue(<z>
, TypeDescriptor.valueOf(targetType));<z>
if (result == null) {<z>
+ "]");<z>
return result;<z>
EntityManagerFactory createNativeEntityManagerFactory() throws PersistenceException {<z>
) {<z>
() + "'");<z>
;<z>
provider != null) {<z>
());<z>
if (emf == null) {<z>
new IllegalStateException(<z>
provider + "] did not return an EntityManagerFactory for name '" +<z>
getPersistenceUnitName() + "'");<z>
return emf;<z>
), getJpaPropertyMap());<z>
,<z>
IOException {<z>
contentType = getFormContentType(contentType);<z>
getHeaders().setContentType(contentType);<z>
getCharset();<z>
charset, "No charset");<z>
(charset);<z>
).setContentLength(bytes.length);<z>
) {<z>
bytes, outputStream));<z>
(bytes, outputMessage.getBody());<z>
ClassNotFoundException {<z>
) {<z>
result = loadClassForOverriding(name);<z>
(result != null) {<z>
if (resolve) {<z>
);<z>
result;<z>
, resolve);<z>
{<z>
= StaxUtils.getXMLStreamReader(staxSource);<z>
) {<z>
(streamReader);<z>
StaxUtils.getXMLEventReader(staxSource);<z>
if (eventReader != null) {<z>
(eventReader);<z>
);<z>
{<z>
) {<z>
concurrentResult != RESULT_NONE) {<z>
result;<z>
this.errorHandlingInProgress = (result instanceof Throwable);<z>
this.asyncWebRequest.isAsyncComplete()) {<z>
)) {<z>
+ formatRequestUri());<z>
isDebugEnabled()) {<z>
Throwable;<z>
());<z>
.dispatch();<z>
endCurrentBasicBlockWithNoSuccessor() {<z>
== COMPUTE_ALL_FRAMES) {<z>
Label();<z>
new Frame(nextBasicBlock);<z>
);<z>
lastBasicBlock.nextBasicBlock = nextBasicBlock;<z>
lastBasicBlock = nextBasicBlock;<z>
;<z>
== COMPUTE_MAX_STACK_AND_LOCAL) {<z>
= (short) maxRelativeStackSize;<z>
null;<z>
scope) {<z>
.isWarnEnabled()) {<z>
callback + "] for attribute '" + name +<z>
"' because FacesRequestAttributes does not support such callbacks");<z>
String expressionString, String message) {<z>
);<z>
expressionString = expressionString;<z>
;<z>
void writeEntityWithMessageConverters(Object entity, HttpServletRequest request,<z>
ServerResponse.Context context)<z>
throws ServletException, IOException {<z>
response);<z>
(response);<z>
();<z>
= this.entityType;<z>
entityClass)) {<z>
"bytes");<z>
(HttpHeaders.RANGE);<z>
(rangeHeader != null) {<z>
resource = (Resource) entity;<z>
= HttpRange.parseRanges(rangeHeader);<z>
;<z>
(httpRanges, resource);<z>
.getClass();<z>
;<z>
IllegalArgumentException ex) {<z>
.contentLength());<z>
;<z>
) {<z>
genericMessageConverter) {<z>
entityClass, contentType)) {<z>
;<z>
entityClass, contentType)) {<z>
, serverResponse);<z>
;<z>
throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);<z>
xmlReader, InputSource inputSource)<z>
XmlMappingException, IOException {<z>
new UnsupportedOperationException(<z>
"XStreamMarshaller does not support unmarshalling using SAX XMLReaders");<z>
int index,<z>
,<z>
,<z>
,<z>
,<z>
final long data,<z>
int hashCode) {<z>
data);<z>
this.hashCode = hashCode;<z>
InvalidResultSetAccessException {<z>
this.resultSetMetaData.getColumnCount();<z>
{<z>
throw new InvalidResultSetAccessException(se);<z>
beanName) {<z>
[] cachedMethodArguments = this.cachedMethodArguments;<z>
null) {<z>
null;<z>
cachedMethodArguments.length];<z>
) {<z>
, cachedMethodArguments[i]);<z>
return arguments;<z>
String descriptor, final boolean visible) {<z>
(visible) {<z>
return lastRuntimeVisibleAnnotation =<z>
, descriptor, lastRuntimeVisibleAnnotation);<z>
} else {<z>
=<z>
descriptor, lastRuntimeInvisibleAnnotation);<z>
<?>> predicate) {<z>
= parameter.getParameterType();<z>
= getAdapterRegistry().getAdapter(type);<z>
(adapter != null) {<z>
assertHasValues(adapter, parameter);<z>
.getNestedParameterType();<z>
);<z>
)<z>
throws MessagingException {<z>
, request, null, targetClass);<z>
atMidnight() {<z>
temporal -> {<z>
.NANO_OF_DAY)) {<z>
;<z>
return temporal;<z>
accept(Throwable t) {<z>
= true;<z>
(this.delegate != null) {<z>
(t);<z>
Object newValue,<z>
?> arrayComponentType) throws EvaluationException {<z>
.TYPE) {<z>
array = (boolean[]) ctx;<z>
checkAccess(array.length, idx);<z>
, Boolean.class);<z>
TYPE) {<z>
ctx;<z>
length, idx);<z>
Byte.class);<z>
== Character.TYPE) {<z>
;<z>
);<z>
(converter, newValue, Character.class);<z>
arrayComponentType == Double.TYPE) {<z>
;<z>
idx);<z>
;<z>
Float.TYPE) {<z>
[]) ctx;<z>
(array.length, idx);<z>
converter, newValue, Float.class);<z>
TYPE) {<z>
;<z>
(array.length, idx);<z>
.class);<z>
TYPE) {<z>
(long[]) ctx;<z>
.length, idx);<z>
class);<z>
else if (arrayComponentType == Short.TYPE) {<z>
] array = (short[]) ctx;<z>
idx);<z>
;<z>
= (Object[]) ctx;<z>
idx);<z>
);<z>
rootObject) throws EvaluationException {<z>
StringBuilder sb = new StringBuilder();<z>
.expressions) {<z>
getValue(rootObject, String.class);<z>
null) {<z>
);<z>
sb.toString();<z>
nextChildIs(Class<?>... classes) {<z>
) {<z>
this.parent.children;<z>
) {<z>
if (this == peers[i]) {<z>
) {<z>
;<z>
i + 1].getClass();<z>
> desiredClass : classes) {<z>
peerClass == desiredClass) {<z>
;<z>
;<z>
false;<z>
) {<z>
Assert.notNull(routerFunction, "RouterFunction must not be null");<z>
(strategies, "HandlerStrategies must not be null");<z>
return new RouterFunctionWebHandler(strategies, routerFunction);<z>
shutdown(DataSource dataSource, String databaseName) {<z>
null;<z>
);<z>
null) {<z>
= con.createStatement()) {<z>
;<z>
catch (SQLException ex) {<z>
);<z>
if (con != null) {<z>
();<z>
SQLException ex) {<z>
debug("Could not close JDBC Connection on shutdown", ex);<z>
ex) {<z>
);<z>
void setBeanFactory(BeanFactory beanFactory) {<z>
.targetBeanName == null) {<z>
("Property 'targetBeanName' is required");<z>
beanFactory;<z>
{<z>
cause;<z>
;<z>
.callbacks.success(result);<z>
catch (InterruptedException ex) {<z>
.interrupt();<z>
(ExecutionException ex) {<z>
);<z>
null) {<z>
ex;<z>
(Throwable ex) {<z>
;<z>
callbacks.failure(cause);<z>
public Set<ConvertiblePair> getConvertibleTypes() {<z>
new LinkedHashSet<>(4);<z>
.class));<z>
Optional.class));<z>
.class));<z>
convertibleTypes;<z>
{<z>
, "Cannot set error status - response is already committed");<z>
.status = status;<z>
.errorMessage = errorMessage;<z>
);<z>
HttpServletRequest request, ServletRequestAttributes requestAttributes) {<z>
(), this.threadContextInheritable);<z>
, this.threadContextInheritable);<z>
(logger.isTraceEnabled()) {<z>
+ request);<z>
extends Annotation>... annotationTypes) {<z>
.filters.add(param -><z>
> 0 ?<z>
.noneMatch(param::hasParameterAnnotation) :<z>
).length == 0));<z>
;<z>
Session session, @Nullable Connection connection) {<z>
frozen, "Cannot add Session because JmsResourceHolder is frozen");<z>
"Session must not be null");<z>
)) {<z>
;<z>
(connection != null) {<z>
Session> sessions =<z>
>());<z>
add(session);<z>
) {<z>
);<z>
);<z>
;<z>
if (beanNameGenerator != null) {<z>
beanNameGenerator);<z>
);<z>
(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);<z>
scopeMetadataResolver = getScopeMetadataResolver();<z>
!= null) {<z>
scopeMetadataResolver);<z>
);<z>
{<z>
(logger.isDebugEnabled()) {<z>
logger.debug("Registering component classes: [" +<z>
collectionToCommaDelimitedString(this.componentClasses) + "]");<z>
ClassUtils.toClassArray(this.componentClasses));<z>
{<z>
.isDebugEnabled()) {<z>
logger.debug("Scanning base packages: [" +<z>
) + "]");<z>
.basePackages));<z>
();<z>
configLocations != null) {<z>
configLocation : configLocations) {<z>
.forName(configLocation, getClassLoader());<z>
(logger.isTraceEnabled()) {<z>
+ "]");<z>
register(clazz);<z>
ClassNotFoundException ex) {<z>
.isTraceEnabled()) {<z>
+<z>
"] - trying package scan. " + ex);<z>
.scan(configLocation);<z>
{<z>
.debug("No component classes found for specified class/package [" + configLocation + "]");<z>
resetHierarchicalComponents() {<z>
null;<z>
;<z>
this.port = null;<z>
CompositePathComponentBuilder();<z>
clear();<z>
method(HttpMethod method) {<z>
);<z>
= method;<z>
;<z>
, boolean forMirrorResolution) {<z>
null;<z>
useMergedValues || forMirrorResolution) {<z>
;<z>
if (value == null) {<z>
().get(attributeIndex);<z>
this.mapping.getAnnotation());<z>
return value;<z>
String[] sig)<z>
throws MBeanException, ReflectionException {<z>
Thread.currentThread().getContextClassLoader();<z>
);<z>
);<z>
).setContextClassLoader(currentClassLoader);<z>
other, HttpServletRequest request) {<z>
request);<z>
(lookupPath);<z>
);<z>
();<z>
()) {<z>
());<z>
!= 0) {<z>
;<z>
(iterator.hasNext()) {<z>
;<z>
) {<z>
;<z>
;<z>
{<z>
);<z>
, "'targetBeanName' must not be empty");<z>
.beanFactory = beanFactory;<z>
targetBeanName = targetBeanName;<z>
(Date source) {<z>
();<z>
(source);<z>
calendar;<z>
public UrlBasedViewResolverRegistration scriptTemplate() {<z>
checkBeanOfType(ScriptTemplateConfigurer.class)) {<z>
+<z>
;<z>
;<z>
);<z>
registration;<z>
) throws XMLStreamException {<z>
(this.emptyElement) {<z>
false;<z>
writeEndElement();<z>
) {<z>
headers.names();<z>
= 0;<z>
while (names.hasMoreElements()) {<z>
();<z>
size++;<z>
return size;<z>
ConfigurableListableBeanFactory beanFactory) throws BeansException {<z>
) {<z>
((scopeKey, value) -> {<z>
) {<z>
Scope) value);<z>
?> scopeClass) {<z>
);<z>
Scope) BeanUtils.instantiateClass(scopeClass));<z>
if (value instanceof String) {<z>
);<z>
scopeClass, "Invalid scope class");<z>
);<z>
"] for scope key [" +<z>
.class.getName() +<z>
;<z>
});<z>
(Element beanEle, MethodOverrides overrides) {<z>
getChildNodes();<z>
); i++) {<z>
Node node = nl.item(i);<z>
&& nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) {<z>
Element replacedMethodEle = (Element) node;<z>
= replacedMethodEle.getAttribute(NAME_ATTRIBUTE);<z>
getAttribute(REPLACER_ATTRIBUTE);<z>
(name, callback);<z>
.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);<z>
for (Element argTypeEle : argTypeEles) {<z>
argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);<z>
getTextValue(argTypeEle));<z>
{<z>
(match);<z>
;<z>
replaceOverride);<z>
headers, Content content) {<z>
;<z>
!= null) {<z>
(headers, content);<z>
headers, content);<z>
(PreparedStatement ps) throws SQLException {<z>
) {<z>
.length; i++) {<z>
];<z>
i + 1, arg);<z>
TargetSource targetSource) {<z>
{<z>
new IllegalArgumentException("Cannot create class proxy for TargetSource with null target class");<z>
();<z>
setTargetSource(targetSource);<z>
.setProxyTargetClass(true);<z>
);<z>
> attributes,<z>
> messageReaders) {<z>
this.request = request;<z>
= attributes;<z>
.delegate = delegate;<z>
formDataMono = initFormData(request, messageReaders);<z>
;<z>
void maxInMemorySize(int byteCount) {<z>
) {<z>
maxInMemorySize = byteCount;<z>
initReaders();<z>
default AspectJWeaving.AUTODETECT;<z>
AspectJWeaving {<z>
isString() {<z>
() {<z>
, ParseException {<z>
assertValueIsString(request.getBodyAsString());<z>
retainAll(Collection<?> c) {<z>
= super.retainAll(c);<z>
) {<z>
null;<z>
return success;<z>
getOrderFromAnnotations(AnnotatedElement element, MergedAnnotations annotations) {<z>
if (!(element instanceof Class)) {<z>
return findOrder(annotations);<z>
);<z>
null) {<z>
? (Integer) cached : null);<z>
findOrder(annotations);<z>
, result != null ? result : NOT_ANNOTATED);<z>
;<z>
parseDateValue(@Nullable String headerValue) {<z>
null) {<z>
-1;<z>
(headerValue.length() >= 3) {<z>
{<z>
dateFormat, Locale.US);<z>
simpleDateFormat.setTimeZone(GMT);<z>
.parse(headerValue).getTime();<z>
(ParseException ex) {<z>
;<z>
messageSupplier) {<z>
) {<z>
new IllegalArgumentException(nullSafeGet(messageSupplier));<z>
JMSException {<z>
con;<z>
this.connectionMonitor) {<z>
= Boolean.TRUE;<z>
createConnection();<z>
if (!(con instanceof TopicConnection)) {<z>
jms.IllegalStateException(<z>
+ con);<z>
TopicConnection) con);<z>
> doHandshake(WebSocketHandler webSocketHandler,<z>
WebSocketHttpHeaders headers, URI uri) {<z>
notNull(webSocketHandler, "WebSocketHandler must not be null");<z>
);<z>
()) {<z>
;<z>
headersToUse = new HttpHeaders();<z>
if (headers != null) {<z>
, values) -> {<z>
.toLowerCase())) {<z>
(header, values);<z>
);<z>
=<z>
Collections.emptyList());<z>
List<WebSocketExtension> extensions =<z>
));<z>
extensions,<z>
.emptyMap());<z>
, RequestCondition<?> otherCondition) {<z>
= thisCondition.getClass();<z>
.getClass();<z>
)) {<z>
"Incompatible request conditions: " + clazz + " and " + otherClazz);<z>
(<z>
,<z>
String type,<z>
final int offset,<z>
length,<z>
char[] charBuffer,<z>
final int codeAttributeOffset,<z>
] labels) {<z>
: attributePrototypes) {<z>
attributePrototype.type.equals(type)) {<z>
attributePrototype.read(<z>
, length, charBuffer, codeAttributeOffset, labels);<z>
null, -1, null);<z>
>... typesToMatch) {<z>
getTargetType();<z>
targetType == null) {<z>
() != null ?<z>
:<z>
));<z>
) || getTempClassLoader() == null) {<z>
resolvedTargetType = targetType;<z>
return targetType;<z>
setNonUniqueFactoryMethodName(String name) {<z>
;<z>
(name);<z>
= false;<z>
) {<z>
null) {<z>
this;<z>
);<z>
);<z>
, other.allowedOriginPatterns);<z>
);<z>
= patterns;<z>
()));<z>
);<z>
;<z>
allowCredentials = other.getAllowCredentials();<z>
) {<z>
.setAllowCredentials(allowCredentials);<z>
;<z>
(maxAge != null) {<z>
);<z>
config;<z>
T> expectedClass) {<z>
evaluationType;<z>
) {<z>
evaluationType = XPathConstants.NUMBER;<z>
.isAssignableFrom(expectedClass)) {<z>
STRING;<z>
class.isAssignableFrom(expectedClass)) {<z>
evaluationType = XPathConstants.BOOLEAN;<z>
expectedClass)) {<z>
= XPathConstants.NODE;<z>
class.isAssignableFrom(expectedClass)) {<z>
.NODESET;<z>
+<z>
;<z>
;<z>
(Class type, Class[] parameterTypes) {<z>
constructor = type.getDeclaredConstructor(parameterTypes);<z>
.setAccessible(true);<z>
constructor;<z>
) {<z>
new CodeGenerationException(e);<z>
headers)<z>
{<z>
headers, null);<z>
WebSocketHandler handler,<z>
Nullable Map<String, Object> attributes) {<z>
, "Session id must not be null");<z>
, "SockJsServiceConfig must not be null");<z>
(handler, "WebSocketHandler must not be null");<z>
;<z>
this.config = config;<z>
this.handler = handler;<z>
(attributes != null) {<z>
putAll(attributes);<z>
) {<z>
> routerFunction : this.routerFunctions) {<z>
);<z>
()) {<z>
result;<z>
return Optional.empty();<z>
,<z>
@Nullable ResolvableType implementationType) {<z>
;<z>
implementationType != null ? implementationType :<z>
forType(methodParameter.getContainingClass()));<z>
getDeclaringClass());<z>
, owner.asVariableResolver()).<z>
methodParameter.typeIndexesPerLevel);<z>
<String, ?> model,<z>
, HttpServletResponse response) {<z>
"unchecked")<z>
pathVars = (this.exposePathVariables ?<z>
.PATH_VARIABLES) : null);<z>
= this.staticAttributes.size();<z>
size() : 0);<z>
? pathVars.size() : 0);<z>
mergedModel = CollectionUtils.newLinkedHashMap(size);<z>
putAll(this.staticAttributes);<z>
null) {<z>
(pathVars);<z>
model != null) {<z>
model);<z>
.requestContextAttribute != null) {<z>
;<z>
mergedModel;<z>
Token peekToken() {<z>
this.tokenStreamLength) {<z>
null;<z>
);<z>
public void setUniqueFactoryMethodName(String name) {<z>
hasText(name, "Factory method name must not be empty");<z>
name);<z>
true;<z>
{<z>
);<z>
== null) {<z>
;<z>
== possible2);<z>
Map<String, Object> attributes,<z>
> annotationType, @Nullable AnnotatedElement annotatedElement) {<z>
);<z>
IllegalStateException ex) {<z>
new IllegalArgumentException(ex);<z>
{<z>
null) {<z>
patterns;<z>
String[patterns.length];<z>
length; i++) {<z>
;<z>
;<z>
(Element root) {<z>
getAttribute("cache");<z>
;<z>
.getAttribute("key-generator");<z>
);<z>
root.getAttribute("condition");<z>
= root.getAttribute(METHOD_ATTRIBUTE);<z>
(StringUtils.hasText(defaultCache)) {<z>
;<z>
] toByteArray() {<z>
= new byte[this.size];<z>
= 0;<z>
Object o : this) {<z>
] src) {<z>
length);<z>
position += src.length;<z>
o;<z>
result;<z>
(final Attribute attribute) {<z>
{<z>
new Attribute[data.length + SIZE_INCREMENT];<z>
, size);<z>
data = newData;<z>
++] = attribute;<z>
SockJsFrame frame) {<z>
CloseStatus closeStatus = CloseStatus.NO_STATUS_CODE;<z>
frameData = frame.getFrameData();<z>
!= null) {<z>
= getMessageCodec().decode(frameData);<z>
null && data.length == 2) {<z>
data[1]);<z>
()) {<z>
+ this);<z>
{<z>
logger.isErrorEnabled()) {<z>
, ex);<z>
;<z>
() throws ResourceException {<z>
== null) {<z>
("'resourceAdapter' or 'resourceAdapterClass' is required");<z>
bootstrapContext == null) {<z>
workManager, this.xaTerminator);<z>
bootstrapContext);<z>
resolveResourceLocations() {<z>
result = new ArrayList<>();<z>
!this.locationValues.isEmpty()) {<z>
obtainApplicationContext();<z>
this.locationValues) {<z>
null) {<z>
.embeddedValueResolver.resolveStringValue(location);<z>
if (resolvedLocation == null) {<z>
);<z>
resolvedLocation;<z>
;<z>
.trim();<z>
(URL_RESOURCE_CHARSET_PREFIX)) {<z>
.length());<z>
{<z>
new IllegalArgumentException("Invalid charset syntax in location: " + location);<z>
URL_RESOURCE_CHARSET_PREFIX.length(), endIndex);<z>
);<z>
);<z>
(location);<z>
resource instanceof ServletContextResource)) {<z>
IllegalStateException(<z>
resource.getClass() + ". " +<z>
;<z>
.add(resource);<z>
) {<z>
(!(resource instanceof UrlResource)) {<z>
+ resource);<z>
put(resource, charset);<z>
.addAll(this.locationResources);<z>
isOptimizeLocations()) {<z>
;<z>
);<z>
locationsToUse.addAll(result);<z>
getOriginatingContextPath(HttpServletRequest request) {<z>
(WebUtils.FORWARD_CONTEXT_PATH_ATTRIBUTE);<z>
== null) {<z>
= request.getContextPath();<z>
request, contextPath);<z>
> handleMissingPathVariable(<z>
WebRequest request) {<z>
);<z>
{<z>
;<z>
true;<z>
ex) {<z>
;<z>
registry) {<z>
);<z>
LocalDateTimeToLocalDateConverter());<z>
LocalDateTimeToLocalTimeConverter());<z>
ZonedDateTimeToLocalDateConverter());<z>
;<z>
;<z>
;<z>
;<z>
());<z>
);<z>
OffsetDateTimeToLocalDateTimeConverter());<z>
OffsetDateTimeToZonedDateTimeConverter());<z>
OffsetDateTimeToInstantConverter());<z>
;<z>
(new CalendarToOffsetDateTimeConverter());<z>
(new CalendarToLocalDateConverter());<z>
new CalendarToLocalTimeConverter());<z>
());<z>
new CalendarToInstantConverter());<z>
());<z>
registry.addConverter(new InstantToLongConverter());<z>
file) {<z>
, "File must not be null");<z>
.getPath());<z>
= file;<z>
.toPath();<z>
updateStompHeadersFromSimpMessageHeaders() {<z>
= getDestination();<z>
{<z>
(STOMP_DESTINATION_HEADER, destination);<z>
contentType = getContentType();<z>
contentType != null) {<z>
));<z>
;<z>
> dataBuffers) {<z>
fromIterable(dataBuffers)<z>
.concatMap(this::writeInternal)<z>
then()<z>
blockingOperationScheduler)<z>
subscribe(null,<z>
,<z>
;<z>
(final Label label) {<z>
(code.data, code.length);<z>
) {<z>
{<z>
currentBasicBlock != null) {<z>
label.bytecodeOffset == currentBasicBlock.bytecodeOffset) {<z>
);<z>
frame = currentBasicBlock.frame;<z>
JUMP, label);<z>
(lastBasicBlock != null) {<z>
bytecodeOffset) {<z>
.flags & Label.FLAG_JUMP_TARGET);<z>
= lastBasicBlock.frame;<z>
= lastBasicBlock;<z>
= label;<z>
lastBasicBlock = label;<z>
= label;<z>
);<z>
compute == COMPUTE_INSERTED_FRAMES) {<z>
(currentBasicBlock == null) {<z>
label;<z>
{<z>
currentBasicBlock.frame.owner = label;<z>
== COMPUTE_MAX_STACK_AND_LOCAL) {<z>
currentBasicBlock != null) {<z>
currentBasicBlock.outputStackMax = (short) maxRelativeStackSize;<z>
addSuccessorToCurrentBasicBlock(relativeStackSize, label);<z>
label;<z>
= 0;<z>
0;<z>
(lastBasicBlock != null) {<z>
lastBasicBlock.nextBasicBlock = label;<z>
lastBasicBlock = label;<z>
currentBasicBlock == null) {<z>
= label;<z>
void prepareResponse(HttpServletRequest request, HttpServletResponse response) {<z>
()) {<z>
setHeader("Pragma", "private");<z>
response.setHeader("Cache-Control", "private, must-revalidate");<z>
Object adaptForAttribute(Method attribute, Object value) {<z>
resolvePrimitiveIfNecessary(attribute.getReturnType());<z>
().isArray()) {<z>
value.getClass(), 1);<z>
(array, 0, value);<z>
attribute, array);<z>
)) {<z>
) attributeType);<z>
isAnnotation()) {<z>
[Array.getLength(value)];<z>
++) {<z>
.get(value, i),<z>
Annotation>) attributeType.getComponentType());<z>
;<z>
String) ||<z>
instanceof String[]) ||<z>
value instanceof Class) ||<z>
])) {<z>
return value;<z>
{<z>
getComponentType());<z>
isInstance(value)) {<z>
("Attribute '" + attribute.getName() +<z>
().getName() + " should be compatible with " +<z>
).getName() +<z>
);<z>
return value;<z>
> type) {<z>
type &&<z>
(ClassUtils.isPrimitiveOrWrapper(type) ||<z>
Enum.class.isAssignableFrom(type) ||<z>
CharSequence.class.isAssignableFrom(type) ||<z>
type) ||<z>
type) ||<z>
type) ||<z>
||<z>
URL.class == type ||<z>
== type ||<z>
);<z>
remainderByName,<z>
<String> parameterNames, String parameterName) {<z>
) {<z>
remainderByName.remove(parameterName);<z>
;<z>
.indexOf(parameterName);<z>
)) {<z>
remainderByIndex.remove(index);<z>
(index);<z>
;<z>
clazz) {<z>
if (candidateAdvisors.isEmpty()) {<z>
candidateAdvisors;<z>
new ArrayList<>();<z>
: candidateAdvisors) {<z>
)) {<z>
candidate);<z>
);<z>
candidateAdvisors) {<z>
candidate instanceof IntroductionAdvisor) {<z>
)) {<z>
.add(candidate);<z>
return eligibleAdvisors;<z>
String attributeName, String attributeValue) throws JspException {<z>
.isBlockTag()) {<z>
IllegalStateException("Cannot write attributes after opening tag is closed.");<z>
.append("=\"")<z>
attributeValue).append("\"");<z>
Object other) {<z>
{<z>
return true;<z>
AbstractRegexpMethodPointcut otherPointcut)) {<z>
return false;<z>
.patterns, otherPointcut.patterns) &&<z>
excludedPatterns, otherPointcut.excludedPatterns));<z>
{<z>
(!this.externallyManaged) {<z>
.jettyClient.stop();<z>
{<z>
"Error stopping Jetty WebSocketClient", ex);<z>
{<z>
;<z>
();<z>
= extensionContext.getRequiredTestClass();<z>
(extensionContext);<z>
ParameterResolutionDelegate.resolveDependency(parameter, index, testClass,<z>
applicationContext.getAutowireCapableBeanFactory());<z>
request) throws MultipartException {<z>
new LinkedMultiValueMap<>();<z>
request.getParts()) {<z>
part);<z>
parts;<z>
{<z>
MultipartException("Failed to get request parts", ex);<z>
{<z>
.source;<z>
(sourceToProcess instanceof Class) {<z>
= (Class<?>) sourceToProcess;<z>
declaredClasses = sourceClass.getDeclaredClasses();<z>
new ArrayList<>(declaredClasses.length);<z>
?> declaredClass : declaredClasses) {<z>
;<z>
return members;<z>
(NoClassDefFoundError err) {<z>
getName());<z>
sourceToProcess;<z>
().getMemberClassNames();<z>
length);<z>
String memberClassName : memberClassNames) {<z>
, DEFAULT_EXCLUSION_FILTER));<z>
catch (IOException ex) {<z>
.isDebugEnabled()) {<z>
.debug("Failed to resolve member class [" + memberClassName +<z>
"] - not considering it as a configuration class candidate");<z>
;<z>
public <A extends Annotation> A findAnnotationOnBean(<z>
Class<A> annotationType, boolean allowFactoryBeanInit)<z>
throws NoSuchBeanDefinitionException {<z>
beanName, annotationType, allowFactoryBeanInit)<z>
orElse(null);<z>
public ClientResponse build() {<z>
new BuiltClientHttpResponse(<z>
.body, this.originalResponse);<z>
return new DefaultClientResponse(httpResponse, this.strategies,<z>
.originalResponse.logPrefix() : "",<z>
),<z>
);<z>
Validator... validators) {<z>
Object target = getTarget();<z>
Validator validator : validators) {<z>
))) {<z>
("Invalid target for Validator [" + validator + "]: " + target);<z>
filters, WebHandler handler) {<z>
filters, handler, null, null);<z>
;<z>
(iterator.hasPrevious()) {<z>
, chain);<z>
return chain;<z>
localSqlConfig, Class<?> testClass) {<z>
;<z>
"testClass must not be null");<z>
(localSqlConfig, testClass);<z>
getString("dataSource");<z>
("transactionManager");<z>
, "transactionMode", TransactionMode.DEFAULT,<z>
.INFERRED);<z>
mergedAttributes.getString("encoding");<z>
(mergedAttributes, "separator", ScriptUtils.DEFAULT_STATEMENT_SEPARATOR);<z>
(mergedAttributes);<z>
this.blockCommentStartDelimiter = getString(mergedAttributes, "blockCommentStartDelimiter",<z>
);<z>
, "blockCommentEndDelimiter",<z>
ScriptUtils.DEFAULT_BLOCK_COMMENT_END_DELIMITER);<z>
;<z>
) {<z>
synchronized (recoveryMonitor) {<z>
this.lastRecoveryMarker = currentRecoveryMarker;<z>
private String formatMethod() {<z>
) +<z>
getParameters())<z>
(this::formatParameter)<z>
"(\n\t", "\n)")));<z>
) throws MalformedObjectNameException {<z>
;<z>
;<z>
(this.mergedMappings != null) {<z>
;<z>
) {<z>
= beanKey;<z>
(objectName);<z>
AbstractBeanDefinition(BeanDefinition original) {<z>
;<z>
());<z>
));<z>
setAbstract(original.isAbstract());<z>
));<z>
);<z>
(original.getRole());<z>
());<z>
original);<z>
AbstractBeanDefinition originalAbd) {<z>
hasBeanClass()) {<z>
);<z>
(originalAbd.hasConstructorArgumentValues()) {<z>
;<z>
)) {<z>
)));<z>
if (originalAbd.hasMethodOverrides()) {<z>
.getMethodOverrides()));<z>
originalAbd.getLazyInit();<z>
(lazyInit != null) {<z>
lazyInit);<z>
());<z>
;<z>
originalAbd.getDependsOn());<z>
.isAutowireCandidate());<z>
originalAbd.isPrimary());<z>
copyQualifiersFrom(originalAbd);<z>
());<z>
());<z>
(originalAbd.isLenientConstructorResolution());<z>
setInitMethodName(originalAbd.getInitMethodName());<z>
);<z>
));<z>
.isEnforceDestroyMethod());<z>
;<z>
());<z>
(original.getConstructorArgumentValues()));<z>
MutablePropertyValues(original.getPropertyValues()));<z>
);<z>
setResourceDescription(original.getResourceDescription());<z>
(String path) {<z>
(StringUtils.hasText(path)) {<z>
= getLastBuilder(PathSegmentComponentBuilder.class);<z>
(FullPathComponentBuilder.class);<z>
!= null) {<z>
"/") ? path : "/" + path);<z>
null) {<z>
();<z>
.add(fpBuilder);<z>
path);<z>
> componentType) {<z>
input instanceof Collection) {<z>
) input;<z>
;<z>
int i = 0;<z>
it.hasNext(); i++) {<z>
value = convertIfNecessary(<z>
next(), componentType);<z>
);<z>
;<z>
{<z>
getComponentType()) &&<z>
) {<z>
input;<z>
getLength(input);<z>
);<z>
) {<z>
(<z>
), componentType);<z>
(result, i, value);<z>
result;<z>
Array.newInstance(componentType, 1);<z>
convertIfNecessary(<z>
);<z>
);<z>
;<z>
> determineDatabaseDialectClass(Database database) {<z>
switch (database) {<z>
class;<z>
return DerbyTenSevenDialect.class;<z>
H2: return H2Dialect.class;<z>
HANAColumnStoreDialect.class;<z>
HSQL: return HSQLDialect.class;<z>
return Informix10Dialect.class;<z>
MYSQL: return MySQL57Dialect.class;<z>
return Oracle12cDialect.class;<z>
POSTGRESQL: return PostgreSQL95Dialect.class;<z>
return SQLServer2012Dialect.class;<z>
SYBASE: return SybaseDialect.class;<z>
return null;<z>
BeanFactory beanFactory) throws BeansException {<z>
(beanFactory);<z>
createPool();<z>
{<z>
new BeanInitializationException("Could not create instance pool for TargetSource", ex);<z>
{<z>
other) {<z>
return true;<z>
!(other instanceof ServletContextResource otherRes)) {<z>
return false;<z>
equals(otherRes.path));<z>
DependencyDescriptor descriptor) {<z>
, descriptor);<z>
if (match) {<z>
);<z>
(match) {<z>
getMethodParameter();<z>
(methodParam != null) {<z>
getMethod();<z>
) {<z>
bdHolder, methodParam.getMethodAnnotations());<z>
return match;<z>
> targetClass, boolean hasIntroductions) {<z>
();<z>
targetClass);<z>
) {<z>
true;<z>
)) {<z>
;<z>
hasIntroductions) {<z>
return true;<z>
);<z>
;<z>
() throws ParserConfigurationException {<z>
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();<z>
setValidating(false);<z>
setNamespaceAware(true);<z>
!isSupportDtd());<z>
"http://xml.org/sax/features/external-general-entities", isProcessExternalEntities());<z>
return factory;<z>
V value) {<z>
this.value;<z>
this.value = value;<z>
return previous;<z>
Class<?> exceptionClass) {<z>
class.isAssignableFrom(exceptionClass)) {<z>
new IllegalArgumentException("Invalid exception class [" + exceptionClass +<z>
;<z>
= exceptionClass;<z>
) {<z>
!CollectionUtils.isEmpty(configurers)) {<z>
);<z>
Nullable BeanDefinition containingBd) {<z>
(ele);<z>
) {<z>
;<z>
);<z>
if (handler == null) {<z>
;<z>
null;<z>
.readerContext, this, containingBd));<z>
, Map<String, Object> hints) {<z>
extract(request(),<z>
() {<z>
() {<z>
;<z>
Optional<ServerHttpResponse> serverResponse() {<z>
().getResponse());<z>
, Object> hints() {<z>
hints;<z>
;<z>
JdkDynamicAopProxy(AdvisedSupport config) throws AopConfigException {<z>
notNull(config, "AdvisedSupport must not be null");<z>
.EMPTY_TARGET_SOURCE) {<z>
;<z>
this.advised = config;<z>
true);<z>
(this.proxiedInterfaces);<z>
viewName, Locale locale) {<z>
return Flux.fromIterable(getViewResolvers())<z>
resolveViewName(viewName, locale))<z>
)<z>
{<z>
{<z>
IllegalStateException(<z>
+ "'.");<z>
(getDefaultViews());<z>
return views;<z>
});<z>
{<z>
response =<z>
dataBufferFactory, result, this.context);<z>
(response);<z>
public void afterSingletonsInstantiated() {<z>
nonAnnotatedClasses.clear();<z>
applicationContext == null) {<z>
);<z>
void renderMergedOutputModel(<z>
request, HttpServletResponse response)<z>
{<z>
= newFeed();<z>
request);<z>
);<z>
(request, response);<z>
hasText(wireFeed.getEncoding())) {<z>
.setEncoding("UTF-8");<z>
);<z>
out = response.getOutputStream();<z>
));<z>
.flush();<z>
str, char trailingCharacter) {<z>
)) {<z>
;<z>
() - 1;<z>
trailingCharacter == str.charAt(endIdx)) {<z>
;<z>
(0, endIdx + 1);<z>
String password) throws SQLException {<z>
Properties();<z>
);<z>
if (connProps != null) {<z>
(connProps);<z>
{<z>
;<z>
if (password != null) {<z>
password);<z>
;<z>
catalog != null) {<z>
setCatalog(this.catalog);<z>
null) {<z>
con.setSchema(this.schema);<z>
return con;<z>
)<z>
, SystemException {<z>
if (getTransactionManager() == null) {<z>
new TransactionSuspensionNotSupportedException(<z>
);<z>
suspendedTransaction);<z>
, HttpClient> applyLoopResources(ReactorResourceFactory factory) {<z>
return httpClient -> {<z>
();<z>
(resources, "No LoopResources: is ReactorResourceFactory not initialized yet?");<z>
);<z>
String> resolveUrlPath(String resourcePath, ServerWebExchange exchange,<z>
, ResourceTransformerChain transformerChain) {<z>
(resourcePath.startsWith("/")) {<z>
);<z>
.empty());<z>
.getResolverChain()<z>
.singletonList(resource));<z>
void initMessagingAdviceCache(List<MessagingAdviceBean> beans) {<z>
beans) {<z>
> type = bean.getBeanType();<z>
!= null) {<z>
resolver = new AnnotationExceptionHandlerMethodResolver(type);<z>
resolver.hasExceptionMappings()) {<z>
registerExceptionHandlerAdvice(bean, resolver);<z>
logger.isTraceEnabled()) {<z>
bean);<z>
returnType, NativeWebRequest webRequest)<z>
, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {<z>
ServletServerHttpRequest inputMessage = createInputMessage(webRequest);<z>
ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);<z>
, outputMessage);<z>
{<z>
!= null) {<z>
findAncestorWithClass(this, EditorAwareTag.class);<z>
if (tag == null) {<z>
JspException("TransformTag can only be used within EditorAwareTag (e.g. BindTag)");<z>
= null;<z>
.getEditor();<z>
editor != null) {<z>
value);<z>
.getAsText();<z>
);<z>
htmlEscape(result);<z>
null) {<z>
TagUtils.getScope(this.scope));<z>
.print(result);<z>
(IOException ex) {<z>
new JspException(ex);<z>
return SKIP_BODY;<z>
{<z>
&& this.actualObjectNames != null) {<z>
for (ObjectName actualObjectName : this.actualObjectNames) {<z>
(<z>
), getHandback());<z>
(Exception ex) {<z>
.isDebugEnabled()) {<z>
"Unable to unregister NotificationListener", ex);<z>
this.connector.close();<z>
model, HttpServletRequest request,<z>
Exception {<z>
isDebugEnabled()) {<z>
+<z>
Collections.emptyMap()) +<z>
;<z>
createMergedOutputModel(model, request, response);<z>
(request, response);<z>
response);<z>
String key) {<z>
System.getProperty(key);<z>
searchSystemEnvironment) {<z>
value = System.getenv(key);<z>
return value;<z>
{<z>
(logger.isDebugEnabled()) {<z>
("Could not access system property '" + key + "': " + ex);<z>
;<z>
void checkOnDataAvailable() {<z>
{<z>
);<z>
mbeanExporter() {<z>
new AnnotationMBeanExporter();<z>
null, "No EnableMBeanExport annotation found");<z>
(exporter, this.enableMBeanExport);<z>
;<z>
, this.enableMBeanExport);<z>
return exporter;<z>
@Nullable String defaultValueType) {<z>
!isDefaultNamespace(ele)) {<z>
parseNestedCustomElement(ele, bd);<z>
nodeNameEquals(ele, BEAN_ELEMENT)) {<z>
BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);<z>
nestedBd != null) {<z>
bd);<z>
return nestedBd;<z>
(nodeNameEquals(ele, REF_ELEMENT)) {<z>
String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);<z>
toParent = false;<z>
hasLength(refName)) {<z>
;<z>
;<z>
{<z>
, ele);<z>
return null;<z>
{<z>
;<z>
null;<z>
refName, toParent);<z>
));<z>
ref;<z>
{<z>
parseIdRefElement(ele);<z>
VALUE_ELEMENT)) {<z>
, defaultValueType);<z>
NULL_ELEMENT)) {<z>
TypedStringValue nullHolder = new TypedStringValue(null);<z>
setSource(extractSource(ele));<z>
;<z>
nodeNameEquals(ele, ARRAY_ELEMENT)) {<z>
bd);<z>
, LIST_ELEMENT)) {<z>
return parseListElement(ele, bd);<z>
)) {<z>
;<z>
(ele, MAP_ELEMENT)) {<z>
parseMapElement(ele, bd);<z>
, PROPS_ELEMENT)) {<z>
);<z>
+ "]", ele);<z>
;<z>
) {<z>
DEMAND)) {<z>
.READING) {<z>
);<z>
databaseName) {<z>
.driverClass);<z>
"jdbc:h2:mem:%s;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=false", databaseName));<z>
("sa");<z>
.setPassword("");<z>
AsyncAnnotationAdvisor(<z>
{<z>
ofNullable(exceptionHandler));<z>
() {<z>
s = new StringBuilder();<z>
.kind.toString());<z>
()) {<z>
;<z>
);<z>
(')');<z>
s.toString();<z>
onError(Throwable ex) {<z>
isTraceEnabled()) {<z>
this.logPrefix + "onError: " + ex);<z>
completionFlag, () -> {<z>
) {<z>
this.logPrefix + "Dispatch to container, to raise the error on servlet thread");<z>
().setAttribute(WRITE_ERROR_ATTRIBUTE_NAME, ex);<z>
();<z>
trace(this.logPrefix + "Setting ServletResponse status to 500 Server Error");<z>
).resetBuffer();<z>
);<z>
.complete();<z>
);<z>
event) {<z>
;<z>
.onRefreshMonitor) {<z>
);<z>
) throws EvaluationException {<z>
;<z>
).getValue();<z>
.getTypeDescriptor();<z>
arguments = getArguments(state);<z>
, value, targetType, arguments);<z>
();<z>
;<z>
{<z>
Assert.notNull(cf1, "First ClassFilter must not be null");<z>
notNull(cf2, "Second ClassFilter must not be null");<z>
] {cf1, cf2});<z>
(RootBeanDefinition beanDefinition) {<z>
injectedElements.size());<z>
InjectedElement element : this.injectedElements) {<z>
.getMember();<z>
)) {<z>
.registerExternallyManagedConfigMember(member);<z>
.add(element);<z>
= checkedElements;<z>
{<z>
eldest) {<z>
getCacheLimit()) {<z>
eldest.getKey());<z>
true;<z>
return false;<z>
HttpMessageConverter<?>> messageConverters) {<z>
);<z>
initSseConverters(messageConverters);<z>
.reactiveHandler = new ReactiveTypeHandler();<z>
Class<A> annotationType) {<z>
matches(annotationType) ||<z>
hasPlainJavaAnnotationsOnly(element)) {<z>
);<z>
findAnnotations(element)<z>
())<z>
isPresent).orElse(null);<z>
) {<z>
)) {<z>
.match(basePackage, this.packageName);<z>
basePackage);<z>
void afterPropertiesSet() {<z>
null) {<z>
configure(this.objectMapper);<z>
builder.build();<z>
public ObjectRetrievalFailureException(<z>
msg, @Nullable Throwable cause) {<z>
cause);<z>
persistentClass = persistentClass;<z>
identifier;<z>
{<z>
(routerFunction, "RouterFunction must not be null");<z>
this.routerFunctions.add(routerFunction);<z>
return this;<z>
{<z>
).getContentDisposition().getFilename();<z>
(filename) ?<z>
: Hints.none());<z>
void registerDefaults(boolean registerDefaults) {<z>
!= registerDefaults) {<z>
registerDefaults = registerDefaults;<z>
);<z>
initWriters();<z>
Throwable {<z>
= true;<z>
;<z>
while (retry) {<z>
false;<z>
;<z>
= jp.proceed();<z>
.commitCalls++;<z>
re) {<z>
rollbackCalls++;<z>
throw re;<z>
RetryableException re) {<z>
retry = true;<z>
return o;<z>
{<z>
= null;<z>
();<z>
catch (Exception ex) {<z>
logger.error("Failed to obtain session.getAcceptedProtocol(): " +<z>
"will use the default protocol handler (if configured).", ex);<z>
handler;<z>
protocol)) {<z>
protocol);<z>
) {<z>
new IllegalStateException(<z>
.protocolHandlerLookup);<z>
) {<z>
;<z>
.protocolHandlers.size() == 1) {<z>
next();<z>
IllegalStateException("Multiple protocol handlers configured and " +<z>
;<z>
;<z>
ResponseBodyProcessor(StreamSinkChannel channel) {<z>
));<z>
(channel, "StreamSinkChannel must not be null");<z>
= channel;<z>
c -> {<z>
.writePossible = true;<z>
);<z>
});<z>
);<z>
<?> getSseEncoder() {<z>
!= null ? this.sseEncoder :<z>
) :<z>
getKotlinSerializationJsonEncoder() :<z>
, String statusText,<z>
] body, @Nullable Charset charset) {<z>
, headers, body, charset);<z>
public InputStream getResourceAsStream(String requestedPath) {<z>
containsKey(requestedPath)) {<z>
);<z>
.getResourceAsStream(overriddenPath) : null);<z>
;<z>
IOException {<z>
= getInputStream();<z>
;<z>
byte[256];<z>
;<z>
buf)) != -1) {<z>
+= read;<z>
size;<z>
();<z>
{<z>
getDescription(), ex);<z>
{<z>
) {<z>
;<z>
.pattern.startsWith(CURRENCY_CODE_PATTERN)) {<z>
.substring(0, 3));<z>
pattern.endsWith(CURRENCY_CODE_PATTERN)) {<z>
() - 3));<z>
);<z>
(IllegalArgumentException ex) {<z>
+ text + "]", ex);<z>
freeMarker() {<z>
{<z>
BeanInitializationException("In addition to a FreeMarker view resolver " +<z>
);<z>
registration = new FreeMarkerRegistration();<z>
.getViewResolver();<z>
!= null) {<z>
(this.applicationContext);<z>
resolver);<z>
;<z>
, Method bridgedMethod) {<z>
bridgeMethod == bridgedMethod) {<z>
return true;<z>
equals(bridgedMethod.getReturnType()) &&<z>
== bridgedMethod.getParameterCount() &&<z>
, bridgedMethod.getParameterTypes()));<z>
LocalSessionFactoryBuilder scanPackages(String... packagesToScan) throws HibernateException {<z>
>();<z>
;<z>
<>();<z>
) {<z>
+<z>
pkg) + RESOURCE_PATTERN;<z>
;<z>
new CachingMetadataReaderFactory(this.resourcePatternResolver);<z>
for (Resource resource : resources) {<z>
reader = readerFactory.getMetadataReader(resource);<z>
getClassName();<z>
(reader, readerFactory)) {<z>
);<z>
)) {<z>
add(className);<z>
(className.endsWith(PACKAGE_INFO_SUFFIX)) {<z>
()));<z>
{<z>
) {<z>
throw new MappingException("Failed to scan classpath for unlisted classes", ex);<z>
getClassLoader();<z>
{<z>
.forName(className, cl));<z>
: converterClassNames) {<z>
cl));<z>
{<z>
addPackage(packageName);<z>
(ClassNotFoundException ex) {<z>
("Failed to load annotated classes from classpath", ex);<z>
return this;<z>
) {<z>
(consumes) ?<z>
consumes));<z>
;<z>
(String name) {<z>
[] tcs = values();<z>
++) {<z>
)) {<z>
tcs[i];<z>
return OBJECT;<z>
, boolean alreadyRecovered) {<z>
instanceof JMSException) {<z>
((JMSException) ex);<z>
) {<z>
!alreadyRecovered) {<z>
);<z>
alreadyRecovered) {<z>
;<z>
new StringBuilder();<z>
append("Setup of JMS message listener invoker failed for destination '");<z>
;<z>
getMessage());<z>
logger.isDebugEnabled()) {<z>
);<z>
msg);<z>
parameter, HttpServletRequest request)<z>
Exception {<z>
MultipartHttpServletRequest multipartRequest =<z>
getNativeRequest(request, MultipartHttpServletRequest.class);<z>
multipartRequest != null || isMultipartContent(request));<z>
== parameter.getNestedParameterType()) {<z>
{<z>
null;<z>
{<z>
new StandardMultipartHttpServletRequest(request);<z>
name);<z>
else if (isMultipartFileCollection(parameter)) {<z>
{<z>
return null;<z>
if (multipartRequest == null) {<z>
request);<z>
= multipartRequest.getFiles(name);<z>
);<z>
{<z>
isMultipart) {<z>
;<z>
multipartRequest == null) {<z>
= new StandardMultipartHttpServletRequest(request);<z>
= multipartRequest.getFiles(name);<z>
new MultipartFile[0]) : null);<z>
()) {<z>
isMultipart) {<z>
null;<z>
request.getPart(name);<z>
(parameter)) {<z>
) {<z>
null;<z>
;<z>
: null);<z>
parameter)) {<z>
) {<z>
;<z>
);<z>
;<z>
return UNRESOLVABLE;<z>
) throws NoSuchBeanDefinitionException {<z>
.get(beanName);<z>
null) {<z>
if (logger.isTraceEnabled()) {<z>
"' found in " + this);<z>
(beanName);<z>
bd;<z>
{<z>
Source source = this.source;<z>
== null) {<z>
.descriptor);<z>
source;<z>
;<z>
beanClass, @Nullable String beanName,<z>
{<z>
ConfigurableListableBeanFactory) {<z>
beanName, beanClass);<z>
ProxyFactory();<z>
.copyFrom(this);<z>
proxyFactory.isProxyTargetClass()) {<z>
(beanClass)) {<z>
beanClass.getInterfaces()) {<z>
(ifc);<z>
beanName)) {<z>
(true);<z>
, proxyFactory);<z>
, specificInterceptors);<z>
addAdvisors(advisors);<z>
targetSource);<z>
proxyFactory);<z>
proxyFactory.setFrozen(this.freezeProxy);<z>
()) {<z>
(true);<z>
= getProxyClassLoader();<z>
()) {<z>
(SmartClassLoader) classLoader).getOriginalClassLoader();<z>
classLoader);<z>
] arguments, Executable executable,<z>
) throws EvaluationException {<z>
;<z>
if (varargsPosition == null) {<z>
i < arguments.length; i++) {<z>
, i));<z>
;<z>
.forObject(argument), targetType);<z>
[i]);<z>
; i++) {<z>
(executable, i));<z>
[i];<z>
), targetType);<z>
;<z>
varargsPosition);<z>
.length - 1) {<z>
arguments[varargsPosition];<z>
);<z>
(argument);<z>
(argument == null) {<z>
getObjectType() == Optional.class) {<z>
empty();<z>
conversionOccurred = true;<z>
())) {<z>
sourceType, targetType);<z>
!= arguments[varargsPosition] &&<z>
])) {<z>
= true;<z>
();<z>
targetType != null, "No element type");<z>
++) {<z>
Object argument = arguments[i];<z>
.forObject(argument), targetType);<z>
|= (argument != arguments[i]);<z>
conversionOccurred;<z>
doSetRollbackOnly(TransactionSynchronizationManager synchronizationManager,<z>
{<z>
(<z>
"returns true, appropriate 'doSetRollbackOnly' behavior must be provided");<z>
headerAccessor, StompCommand command) {<z>
= (command != StompCommand.CONNECT &&<z>
CONNECTED &&<z>
;<z>
{<z>
ByteArrayOutputStream(256);<z>
;<z>
while (byteBuffer.hasRemaining()) {<z>
{<z>
= true;<z>
(byteBuffer.get());<z>
0 && headerComplete) {<z>
, StandardCharsets.UTF_8);<z>
);<z>
if (colonIndex <= 0) {<z>
{<z>
throw new StompConversionException("Illegal header: '" + header +<z>
;<z>
(0, colonIndex);<z>
+ 1);<z>
;<z>
{<z>
) > 0) {<z>
;<z>
executeRequest(<z>
, @Nullable String body) {<z>
);<z>
;<z>
ClientConnection connection =<z>
.optionMap).get();<z>
());<z>
);<z>
(StringUtils.hasLength(body)) {<z>
HttpString.tryFromString(HttpHeaders.CONTENT_LENGTH);<z>
));<z>
);<z>
latch));<z>
);<z>
;<z>
.valueOf(response.getResponseCode());<z>
;<z>
;<z>
return (responseBody != null ?<z>
(responseBody, responseHeaders, status) :<z>
<>(responseHeaders, status));<z>
;<z>
{<z>
SockJsTransportFailureException("Failed to execute request to " + url, ex);<z>
(InterruptedException ex) {<z>
.currentThread().interrupt();<z>
new SockJsTransportFailureException("Interrupted while processing request to " + url, ex);<z>
Object getSessionMutex() {<z>
get(SESSION_MUTEX_NAME);<z>
{<z>
;<z>
return mutex;<z>
sc, String msg) throws IOException {<z>
(false);<z>
super.sendError(sc, msg);<z>
) {<z>
msg);<z>
{<z>
;<z>
;<z>
);<z>
);<z>
Element opElement : cacheableCacheMethods) {<z>
(opElement, parserContext.getReaderContext());<z>
TypedStringValue nameHolder = new TypedStringValue(name);<z>
(parserContext.extractSource(opElement));<z>
builder = prop.merge(opElement,<z>
;<z>
(opElement, "unless", ""));<z>
"sync", "false")));<z>
>(2));<z>
builder.build());<z>
(definition, CACHE_EVICT_ELEMENT);<z>
) {<z>
opElement, parserContext.getReaderContext());<z>
= new TypedStringValue(name);<z>
(opElement));<z>
,<z>
;<z>
;<z>
hasText(wide)) {<z>
)));<z>
opElement.getAttribute("before-invocation");<z>
{<z>
(after.trim()));<z>
);<z>
));<z>
DomUtils.getChildElementsByTagName(definition, CACHE_PUT_ELEMENT);<z>
(Element opElement : putCacheMethods) {<z>
;<z>
;<z>
(parserContext.extractSource(opElement));<z>
Builder builder = prop.merge(opElement,<z>
);<z>
(opElement, "unless", ""));<z>
(2));<z>
));<z>
new RootBeanDefinition(NameMatchCacheOperationSource.class);<z>
setSource(parserContext.extractSource(definition));<z>
.add("nameMap", cacheOpMap);<z>
attributeSourceDefinition;<z>
MergedContextConfiguration mergedConfig) {<z>
.classes,<z>
, mergedConfig.activeProfiles, mergedConfig.propertySourceLocations,<z>
propertySourceProperties, mergedConfig.contextCustomizers,<z>
.cacheAwareContextLoaderDelegate, mergedConfig.parent);<z>
protected DataSource determineTargetDataSource() {<z>
this.resolvedDataSources, "DataSource router not initialized");<z>
= determineCurrentLookupKey();<z>
(lookupKey);<z>
|| lookupKey == null)) {<z>
.resolvedDefaultDataSource;<z>
null) {<z>
"Cannot determine target DataSource for lookup key [" + lookupKey + "]");<z>
;<z>
() {<z>
= size();<z>
totalSize == 0) {<z>
[0];<z>
;<z>
return this.buffers.getFirst();<z>
JspException {<z>
= evaluate(MODEL_ATTRIBUTE, getModelAttribute());<z>
== null) {<z>
" must not be null");<z>
String) resolvedModelAttribute;<z>
public void afterPropertiesSet() throws Exception {<z>
(this.executor == null) {<z>
hashCode());<z>
.newCachedThreadPool(new CustomizableThreadFactory(name));<z>
.executor instanceof LifeCycle) {<z>
executor).start();<z>
dataSource() default "";<z>
() default "";<z>
.DEFAULT;<z>
"";<z>
default "";<z>
;<z>
commentPrefixes() default {};<z>
{<z>
, "The 'cacheOperationSource' property is required: " +<z>
;<z>
return this.cacheOperationSource;<z>
column) throws InvalidResultSetAccessException {<z>
getCatalogName(column);<z>
{<z>
se);<z>
endPos, boolean value) {<z>
payload, startPos, endPos);<z>
;<z>
.exitTypeDescriptor = "Z";<z>
{<z>
= getClientInboundChannelRegistration().taskExecutor();<z>
();<z>
.setThreadNamePrefix("clientInboundChannel-");<z>
executor;<z>
BeanFactoryTransactionAttributeSourceAdvisor transactionAdvisor(<z>
, TransactionInterceptor transactionInterceptor) {<z>
BeanFactoryTransactionAttributeSourceAdvisor advisor = new BeanFactoryTransactionAttributeSourceAdvisor();<z>
setTransactionAttributeSource(transactionAttributeSource);<z>
.setAdvice(transactionInterceptor);<z>
.enableTx != null) {<z>
"order"));<z>
return advisor;<z>
public void shutdown() throws JmsException {<z>
;<z>
boolean wasRunning;<z>
{<z>
.running;<z>
= false;<z>
;<z>
.pausedTasks.clear();<z>
();<z>
)) {<z>
stopSharedConnection();<z>
{<z>
);<z>
();<z>
(JMSException ex) {<z>
throw convertJmsAccessException(ex);<z>
) {<z>
this.sharedConnectionMonitor) {<z>
, getConnectionFactory(), false);<z>
;<z>
getCompletions(<z>
, String userText) {<z>
);<z>
(@Nullable ServletContext context, String path) {<z>
{<z>
dispatchedPath = path;<z>
::run);<z>
BeanFactory beanFactory) {<z>
beanFactory);<z>
(this.owningContext != null)<z>
RuntimeException("Factory called setBeanFactory after setApplicationContext");<z>
void setAttributes(<z>
ServerRequest serverRequest, HandlerFunction<?> handlerFunction) {<z>
(RouterFunctions.REQUEST_ATTRIBUTE, serverRequest);<z>
.put(BEST_MATCHING_HANDLER_ATTRIBUTE, handlerFunction);<z>
RouterFunctions.MATCHING_PATTERN_ATTRIBUTE);<z>
matchingPattern != null) {<z>
BEST_MATCHING_PATTERN_ATTRIBUTE, matchingPattern);<z>
String> uriVariables =<z>
attributes.get(RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE);<z>
uriVariables != null) {<z>
(URI_TEMPLATE_VARIABLES_ATTRIBUTE, uriVariables);<z>
(<z>
, final SymbolTable symbolTable) {<z>
, symbolArg, symbolTable);<z>
;<z>
(symbolTable, successor, 0);<z>
successor);<z>
public ClientRequest build() {<z>
(<z>
headers, this.cookies, this.body,<z>
attributes, this.httpRequestConsumer);<z>
() {<z>
;<z>
);<z>
return tokenBuffer;<z>
(ReactiveAdapterRegistry registry) {<z>
registerReactiveType(<z>
.multiValue(<z>
rxjava3.core.Flowable.class,<z>
.Flowable::empty),<z>
core.Flowable<?>) source,<z>
.Flowable::fromPublisher);<z>
(<z>
multiValue(<z>
.class,<z>
.core.Observable::empty),<z>
>) source).toFlowable(<z>
BUFFER),<z>
);<z>
.registerReactiveType(<z>
class),<z>
),<z>
);<z>
(<z>
singleOptionalValue(<z>
.rxjava3.core.Maybe.class,<z>
),<z>
>) source).toFlowable(),<z>
core.Maybe::fromPublisher);<z>
(<z>
noValue(<z>
.Completable.class,<z>
),<z>
.toFlowable(),<z>
.core.Completable::fromPublisher);<z>
Void> populate(ConnectionFactory connectionFactory) throws DataAccessException {<z>
Assert.notNull(connectionFactory, "ConnectionFactory must not be null");<z>
getConnection(connectionFactory),<z>
,<z>
),<z>
(connection, connectionFactory),<z>
-> ConnectionFactoryUtils.releaseConnection(connection, connectionFactory))<z>
ex instanceof ScriptException),<z>
UncategorizedScriptException("Failed to execute database script", ex));<z>
(ClassEmitter ce, List constructors) {<z>
false;<z>
.hasNext(); ) {<z>
MethodInfo) it.next();<z>
) {<z>
;<z>
();<z>
dup();<z>
e.load_args();<z>
getSignature();<z>
("()V");<z>
);<z>
{<z>
BIND_CALLBACKS);<z>
{<z>
load_this();<z>
;<z>
CONSTRUCTED_FIELD);<z>
.return_value();<z>
;<z>
)<z>
IllegalArgumentException("Superclass has no null constructors but no arguments were given");<z>
)<z>
IOException, HttpMessageNotReadableException {<z>
);<z>
| HttpMessageConversionException ex) {<z>
;<z>
(Exception ex) {<z>
),<z>
;<z>
public int getPoolSize() {<z>
this.threadPoolExecutor == null) {<z>
corePoolSize;<z>
getPoolSize();<z>
mediaTypes) {<z>
mediaTypes, "'mediaTypes' must not be null");<z>
1) {<z>
;<z>
beanName, Object cacheKey) {<z>
this.targetSourcedBeans.contains(beanName)) {<z>
bean;<z>
get(cacheKey))) {<z>
;<z>
) {<z>
Boolean.FALSE);<z>
return bean;<z>
), beanName, null);<z>
!= DO_NOT_PROXY) {<z>
TRUE);<z>
proxy = createProxy(<z>
bean));<z>
proxy.getClass());<z>
return proxy;<z>
FALSE);<z>
bean;<z>
) {<z>
);<z>
decorated, this.exceptionHandlers);<z>
new HttpWebHandlerAdapter(decorated);<z>
(this.sessionManager != null) {<z>
setSessionManager(this.sessionManager);<z>
(this.codecConfigurer != null) {<z>
(this.codecConfigurer);<z>
if (this.localeContextResolver != null) {<z>
;<z>
forwardedHeaderTransformer != null) {<z>
this.forwardedHeaderTransformer);<z>
if (this.applicationContext != null) {<z>
);<z>
();<z>
);<z>
(Lockable mixin) {<z>
if (mixin.locked()) {<z>
throw new IllegalStateException("locked");<z>
) throws JspException {<z>
.startTag(LABEL_TAG);<z>
(FOR_ATTRIBUTE, resolveFor());<z>
writeDefaultAttributes(tagWriter);<z>
();<z>
this.tagWriter = tagWriter;<z>
;<z>
A> get(Class<A> annotationType,<z>
? super MergedAnnotation<A>> predicate,<z>
A> selector) {<z>
.annotationFilter.matches(annotationType)) {<z>
;<z>
annotationType,<z>
(annotationType, predicate, selector));<z>
missing());<z>
setClientPasscode(String passcode) {<z>
.hasText(passcode, "clientPasscode must not be empty");<z>
this.clientPasscode = passcode;<z>
return this;<z>
) {<z>
;<z>
!it.hasNext()) {<z>
IllegalStateException(<z>
+ "]");<z>
.next();<z>
) {<z>
pathLength) {<z>
false;<z>
(pathIndex);<z>
) == 0) {<z>
false;<z>
{<z>
(candidateCapture);<z>
) {<z>
(<z>
);<z>
.matches()) {<z>
false;<z>
false;<z>
++;<z>
) {<z>
{<z>
;<z>
true;<z>
pathLength);<z>
.isMatchOptionalTrailingSeparator()) {<z>
) == matchingContext.pathLength &&<z>
.isSeparator(pathIndex);<z>
next != null) {<z>
next.matches(pathIndex, matchingContext);<z>
.extractingVariables) {<z>
candidateCapture,<z>
());<z>
return match;<z>
@Nullable Class<T> requiredType) {<z>
) {<z>
;<z>
) {<z>
request;<z>
;<z>
) {<z>
DateTimeFormatter dateTimeFormatter = null;<z>
{<z>
= DateTimeFormatterUtils.createStrictDateTimeFormatter(this.pattern);<z>
&& this.iso != ISO.NONE) {<z>
iso) {<z>
:<z>
ISO_DATE;<z>
TIME:<z>
dateTimeFormatter = DateTimeFormatter.ISO_TIME;<z>
case DATE_TIME:<z>
.ISO_DATE_TIME;<z>
iso);<z>
&& this.timeStyle != null) {<z>
);<z>
else if (this.dateStyle != null) {<z>
dateStyle);<z>
) {<z>
;<z>
{<z>
);<z>
fallbackFormatter);<z>
int code, String message) {<z>
kind;<z>
= code;<z>
this.message = message;<z>
determineContextInitializerClasses(ServletContext servletContext) {<z>
classes =<z>
);<z>
String globalClassNames = servletContext.getInitParameter(GLOBAL_INITIALIZER_CLASSES_PARAM);<z>
!= null) {<z>
{<z>
(className));<z>
servletContext.getInitParameter(CONTEXT_INITIALIZER_CLASSES_PARAM);<z>
localClassNames != null) {<z>
tokenizeToStringArray(localClassNames, INIT_PARAM_DELIMITERS)) {<z>
));<z>
return classes;<z>
Predicate<MergedAnnotation<A>> unique(<z>
>, K> keyExtractor) {<z>
return new UniquePredicate<>(keyExtractor);<z>
) {<z>
CloseStatus(statusCode, reason);<z>
(this.wsSession, closeStatus);<z>
(Exception ex) {<z>
logger.isWarnEnabled()) {<z>
;<z>
Object postProcessBeforeInitialization(Object bean, String beanName) {<z>
if (bean instanceof ImportAware importAware) {<z>
.getBean(IMPORT_REGISTRY_BEAN_NAME, ImportRegistry.class);<z>
).getName());<z>
!= null) {<z>
setImportMetadata(importingClass);<z>
;<z>
(MutablePropertyValues mpvs) {<z>
isIgnoreUnknownFields(), isIgnoreInvalidFields());<z>
PropertyBatchUpdateException ex) {<z>
: ex.getPropertyAccessExceptions()) {<z>
pae, getInternalBindingResult());<z>
Builder mergeFrom(SecondMsg other) {<z>
.getDefaultInstance()) return this;<z>
other.hasBlah()) {<z>
getBlah());<z>
());<z>
this;<z>
) {<z>
(servletRequest);<z>
new ServletServerHttpRequest(servletRequest);<z>
.fromHttpRequest(request).build();<z>
);<z>
= uriComponents.getScheme();<z>
equals(this.scheme);<z>
= uriComponents.getHost();<z>
80) : port);<z>
request.getRemoteAddress());<z>
: ":" + port);<z>
HttpServletRequest) getRequest();<z>
forwardedPrefixExtractor = new ForwardedPrefixExtractor(delegateRequest, baseUrl);<z>
@Nullable CacheDefaults defaults, CacheRemoveAll ann) {<z>
));<z>
CacheResolverFactory cacheResolverFactory =<z>
(defaults, ann.cacheResolverFactory());<z>
(method, ann, cacheName);<z>
= getCacheResolver(cacheResolverFactory, methodDetails);<z>
methodDetails, cacheResolver);<z>
Route> captureRoutes() {<z>
Arrays.asList(<z>
"/guides"),<z>
,<z>
"/guides/gs/scheduling-tasks",<z>
"/guides/gs/consuming-rest", "/guides/gs/relational-data-access"),<z>
),<z>
"/projects/{name}",<z>
,<z>
),<z>
("/blog/category/{category}.atom",<z>
"/blog/category/releases.atom", "/blog/category/engineering.atom",<z>
),<z>
Route("/tools/{name}", "/tools/eclipse", "/tools/vscode"),<z>
,<z>
),<z>
Route("/api/projects/{projectId}",<z>
, "/api/projects/spring-framework",<z>
"/api/projects/spring-data",<z>
),<z>
("/api/projects/{projectId}/releases/{version}",<z>
, "/api/projects/spring-framework/releases/5.3.0",<z>
, "/api/projects/spring-framework/releases/5.2.0")<z>
getStrategyForPath(String requestPath) {<z>
);<z>
);<z>
.versionStrategyMap.keySet()) {<z>
pathMatcher.match(pattern, path)) {<z>
(pattern);<z>
isEmpty()) {<z>
);<z>
;<z>
);<z>
;<z>
String> expand(<z>
paramSource) {<z>
(sql);<z>
(parsedSql, bindMarkersFactory, paramSource);<z>
> builderClass) {<z>
builders.isEmpty()) {<z>
this.builders.getLast();<z>
builderClass.isInstance(last)) {<z>
) last;<z>
null;<z>
{<z>
.expand(uriVariables);<z>
);<z>
encodedComponents.toUri();<z>
, Method method, Object[] args) {<z>
(this.initialized) {<z>
getTargetClass(target);<z>
getCacheOperationSource();<z>
cacheOperationSource != null) {<z>
(method, targetClass);<z>
{<z>
invoker, method,<z>
);<z>
();<z>
value) {<z>
addIndexedArgumentValue(<z>
constructorArgIndex++, value);<z>
this;<z>
private MimeType getDataMimeType(RSocketStrategies strategies) {<z>
!= null) {<z>
;<z>
.decoders()) {<z>
getDecodableMimeTypes().isEmpty()) {<z>
;<z>
strategies.decoders()) {<z>
{<z>
;<z>
);<z>
public Object convert(byte[] source) {<z>
(source);<z>
return this.deserializer.deserialize(byteStream);<z>
ex) {<z>
throw new SerializationFailedException("Failed to deserialize payload. " +<z>
+ "?", ex);<z>
public ObjectOptimisticLockingFailureException(String msg, Throwable cause) {<z>
cause);<z>
= null;<z>
= null;<z>
ClientHttpRequestFactory requestFactory,<z>
uri, HttpMethod method) {<z>
.requestFactory = requestFactory;<z>
.interceptors = interceptors;<z>
method;<z>
;<z>
, BeanDefinitionParserDelegate delegate,<z>
Nullable BeanDefinition containingBeanDefinition) {<z>
;<z>
.delegate = delegate;<z>
this.containingBeanDefinition = containingBeanDefinition;<z>
throws JMSException {<z>
{<z>
(!this.locallyStarted) {<z>
this.locallyStarted = true;<z>
) {<z>
.start();<z>
startedCount++;<z>
, MessageChannel channel, boolean sent) {<z>
interceptor : interceptors) {<z>
sent);<z>
... expectedValues) {<z>
return request -> {<z>
request);<z>
, params, expectedValues.length);<z>
++) {<z>
(name).get(i));<z>
public int hashCode() {<z>
(getScheme());<z>
ObjectUtils.nullSafeHashCode(this.ssp);<z>
nullSafeHashCode(getFragment());<z>
;<z>
> getMetaSource() {<z>
.getSource();<z>
{<z>
return null;<z>
source,<z>
, this.resolvedRootMirrors);<z>
) {<z>
(this.url == null) {<z>
new UnsupportedOperationException();<z>
.url;<z>
SAXException {<z>
{<z>
entityDeclaration.getPublicId(),<z>
entityDeclaration.getNotationName());<z>
,<z>
mediaType, ServerHttpRequest request, ServerHttpResponse response) {<z>
));<z>
enable(@Nullable String defaultServletName) {<z>
new DefaultServletHttpRequestHandler();<z>
(defaultServletName != null) {<z>
(defaultServletName);<z>
this.servletContext);<z>
[]> message, String sessionId,<z>
) {<z>
;<z>
(Object object) {<z>
();<z>
Map)) {<z>
result.put("document", object);<z>
;<z>
>) object;<z>
.forEach((key, value) -> {<z>
{<z>
;<z>
if (key instanceof CharSequence) {<z>
value);<z>
;<z>
);<z>
return result;<z>
Object createMainInterceptor() {<z>
);<z>
this.pointcut != null) {<z>
);<z>
return new TransactionAttributeSourceAdvisor(this.transactionInterceptor);<z>
Class<?> clazz) {<z>
.notNull(clazz, "Class must not be null");<z>
.get(clazz);<z>
== null) {<z>
);<z>
));<z>
(Throwable ex) {<z>
"Failed to introspect Class [" + clazz.getName() +<z>
) + "]", ex);<z>
result;<z>
transformer) {<z>
.invoke(this.classLoader, transformer);<z>
InvocationTargetException ex) {<z>
.getCause());<z>
ex) {<z>
IllegalStateException("Could not invoke Tomcat addTransformer method", ex);<z>
) {<z>
0x00000002;<z>
();<z>
;<z>
(int value) {<z>
) {<z>
;<z>
.checkValidIntValue(value);<z>
(DateTimeException ex) {<z>
), ex);<z>
objectWriter)<z>
JMSException, MessageConversionException {<z>
Message message;<z>
{<z>
:<z>
objectWriter);<z>
case BYTES:<z>
objectWriter);<z>
);<z>
IOException ex) {<z>
object + "]", ex);<z>
(object, message);<z>
return message;<z>
String toString() {<z>
return String.format("Content-Type: %s",<z>
() == 1) ?<z>
).next().toString() :<z>
;<z>
boolean containsWhitespace(@Nullable CharSequence str) {<z>
{<z>
false;<z>
str.length();<z>
++) {<z>
.charAt(i))) {<z>
true;<z>
;<z>
<String> messageSupplier) {<z>
{<z>
) {<z>
(element == null) {<z>
(messageSupplier));<z>
(Object beanInstance) {<z>
= getDependencyComparator();<z>
if (comparator instanceof OrderComparator) {<z>
beanInstance);<z>
;<z>
Nullable LocaleContext localeContext) {<z>
null) {<z>
locale = localeContext.getLocale();<z>
(locale != null) {<z>
;<z>
;<z>
Nullable MediaType contentType) {<z>
) != null) {<z>
;<z>
;<z>
(@Nullable Object other) {<z>
if (this == other) {<z>
return true;<z>
{<z>
return false;<z>
nameMap);<z>
targetCapacity) {<z>
);<z>
targetCapacity];<z>
;<z>
resizedBuffer;<z>
public boolean equals(Object o) {<z>
(this == o) {<z>
return true;<z>
)) {<z>
;<z>
o;<z>
that.endIndex<z>
;<z>
writeMethod)<z>
{<z>
null;<z>
) {<z>
!= 0) {<z>
"Bad read method arg count: " + readMethod);<z>
.getReturnType();<z>
== Void.TYPE) {<z>
("Read method returns void: " + readMethod);<z>
(writeMethod != null) {<z>
.getParameterTypes();<z>
if (params.length != 1) {<z>
"Bad write method arg count: " + writeMethod);<z>
propertyType != null) {<z>
(params[0])) {<z>
params[0];<z>
propertyType)) {<z>
new IntrospectionException(<z>
"Type mismatch between read and write methods: " + readMethod + " - " + writeMethod);<z>
[0];<z>
propertyType;<z>
MediaType mediaType) {<z>
{<z>
).getMediaType())) {<z>
i;<z>
;<z>
(ApplicationContext applicationContext) {<z>
props;<z>
path = "DispatcherServlet.properties";<z>
path, DispatcherServlet.class);<z>
PropertiesLoaderUtils.loadProperties(resource);<z>
(IOException ex) {<z>
getMessage());<z>
HandlerMapping.class.getName());<z>
StringUtils.commaDelimitedListToStringArray(value);<z>
names.length);<z>
names) {<z>
class.getClassLoader());<z>
getAutowireCapableBeanFactory().createBean(clazz);<z>
mapping);<z>
catch (ClassNotFoundException ex) {<z>
"Could not find default HandlerMapping [" + name + "]");<z>
;<z>
Nullable Map<String, Object> headers) {<z>
{<z>
Collections.emptyList();<z>
new ArrayList<>();<z>
keySet()) {<z>
.simpleMatch(pattern, key)) {<z>
matchingHeaderNames.add(key);<z>
return matchingHeaderNames;<z>
inputStream, ResolvableType elementType,<z>
Map<String, Object> hints) {<z>
contentType = updateContentType(message, mediaType);<z>
encoder.encode(<z>
), elementType, contentType, hints);<z>
{<z>
singleOrEmpty()<z>
switchIfEmpty(Mono.defer(() -> {<z>
(0);<z>
.empty());<z>
)<z>
{<z>
logger);<z>
readableByteCount());<z>
just(buffer)<z>
class, DataBufferUtils::release));<z>
.class, DataBufferUtils::release);<z>
isStreamingMediaType(contentType)) {<z>
{<z>
buffer, hints, logger);<z>
class, DataBufferUtils::release);<z>
;<z>
logger.isDebugEnabled()) {<z>
));<z>
writeWith(body);<z>
void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {<z>
factoryId = System.identityHashCode(beanFactory);<z>
this.factoriesPostProcessed.contains(factoryId)) {<z>
throw new IllegalStateException(<z>
beanFactory);<z>
);<z>
factoryId)) {<z>
processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);<z>
;<z>
ImportAwareBeanPostProcessor(beanFactory));<z>
fieldAdder) {<z>
this.fieldAdders == null) {<z>
.fieldAdders = new ArrayList<>();<z>
;<z>
lookupPath, HttpServletRequest request) throws Exception {<z>
= getDirectMatch(lookupPath, request);<z>
!= null) {<z>
return handler;<z>
);<z>
()) {<z>
(registeredPattern, lookupPath)) {<z>
add(registeredPattern);<z>
{<z>
{<z>
registeredPattern + "/");<z>
= null;<z>
getPathMatcher().getPatternComparator(lookupPath);<z>
)) {<z>
patternComparator);<z>
matchingPatterns.size() > 1) {<z>
trace("Matching patterns " + matchingPatterns);<z>
matchingPatterns.get(0);<z>
) {<z>
get(bestMatch);<z>
) {<z>
) {<z>
length() - 1));<z>
== null) {<z>
throw new IllegalStateException(<z>
"Could not find handler for best pattern match [" + bestMatch + "]");<z>
handlerName) {<z>
(handlerName);<z>
(handler, request);<z>
(bestMatch, lookupPath);<z>
LinkedHashMap<>();<z>
matchingPatterns) {<z>
) {<z>
;<z>
.decodePathVariables(request, vars);<z>
decodedVars);<z>
() > 0) {<z>
("URI variables " + uriTemplateVariables);<z>
bestMatch, pathWithinMapping, uriTemplateVariables);<z>
return null;<z>
int addNamedParameter(<z>
, int j, String parameter) {<z>
- escapes));<z>
;<z>
return totalParameterCount;<z>
(Object transaction) {<z>
(HibernateTransactionObject) transaction;<z>
isNewSessionHolder()) {<z>
TransactionSynchronizationManager.unbindResource(obtainSessionFactory());<z>
() != null) {<z>
;<z>
;<z>
needsConnectionReset() &&<z>
().isPhysicallyConnected()) {<z>
;<z>
previousHoldability = txObject.getPreviousHoldability();<z>
null) {<z>
previousHoldability);<z>
(<z>
, txObject.isReadOnly());<z>
ex) {<z>
("Could not access JDBC Connection of Hibernate Session", ex);<z>
) {<z>
debug("Could not reset JDBC Connection after transaction", ex);<z>
txObject.isNewSession()) {<z>
.isDebugEnabled()) {<z>
+ "] after transaction");<z>
session);<z>
{<z>
"Not closing pre-bound Hibernate Session [" + session + "] after transaction");<z>
) != null) {<z>
.getSessionHolder().getPreviousFlushMode());<z>
hibernateManagedSession) {<z>
session);<z>
.clear();<z>
Class<?> clazz, String annotationName) {<z>
{<z>
;<z>
.hasPlainJavaAnnotationsOnly(clazz)) {<z>
;<z>
;<z>
PropertyValues pvs) throws Throwable {<z>
Field) this.member;<z>
Object value;<z>
.cached) {<z>
beanName, this.cachedFieldValue);<z>
(NoSuchBeanDefinitionException ex) {<z>
bean, beanName);<z>
= resolveFieldValue(field, bean, beanName);<z>
) {<z>
field);<z>
;<z>
, Blackhole bh) {<z>
mediaTypes) {<z>
);<z>
<String> getBeanNamesIterator() {<z>
);<z>
;<z>
.iterator());<z>
return iterator;<z>
, BeanDefinitionBuilder builder) {<z>
;<z>
) {<z>
;<z>
{<z>
getAttribute("location"));<z>
, StringUtils.toStringArray(locations));<z>
Object getPayload() {<z>
this.payload == null) {<z>
this.payload = unwrapPayload();<z>
(JMSException ex) {<z>
MessageConversionException(<z>
+ this.message + "]", ex);<z>
return this.payload;<z>
element, ParserContext parserContext) {<z>
);<z>
"data-source"));<z>
getAttribute("enabled"));<z>
, builder);<z>
));<z>
);<z>
) {<z>
environment == null) {<z>
);<z>
return this.environment;<z>
protected AbstractJackson2HttpMessageConverter(ObjectMapper objectMapper) {<z>
;<z>
;<z>
"\ndata:"));<z>
prettyPrinter;<z>
Exception ex) {<z>
{<z>
.size() < SUPPRESSED_EXCEPTIONS_LIMIT) {<z>
ex);<z>
DefaultExchangeStrategies(ClientCodecConfigurer codecConfigurer) {<z>
= codecConfigurer;<z>
;<z>
.getWriters());<z>
<RequestMappingInfo> infos, HttpServletRequest request) {<z>
: infos) {<z>
{<z>
PartialMatch(info, request));<z>
public DependencyDescriptor(DependencyDescriptor original) {<z>
super(original);<z>
declaringClass = original.declaringClass;<z>
methodName;<z>
this.parameterTypes = original.parameterTypes;<z>
original.parameterIndex;<z>
;<z>
= original.containingClass;<z>
required;<z>
eager = original.eager;<z>
;<z>
method) {<z>
{<z>
null;<z>
;<z>
function.getParameters()) : null);<z>
{<z>
null;<z>
public void copyToUriComponentsBuilder(UriComponentsBuilder builder) {<z>
(PathComponent pathComponent : this.pathComponents) {<z>
copyToUriComponentsBuilder(builder);<z>
(String paramName) throws IllegalArgumentException {<z>
!hasValue(paramName)) {<z>
+ paramName + "'");<z>
.get(paramName).getValue();<z>
{<z>
request);<z>
isEmpty(flashMap)) {<z>
();<z>
.getPath());<z>
uriComponents.getQueryParams());<z>
getFlashMapManager(request);<z>
!= null, "No FlashMapManager. Is this a DispatcherServlet handled request?");<z>
;<z>
public boolean equals(@Nullable Object other) {<z>
other) {<z>
return true;<z>
(other instanceof MimeType otherType)) {<z>
false;<z>
.type.equalsIgnoreCase(otherType.type) &&<z>
subtype.equalsIgnoreCase(otherType.subtype) &&<z>
(otherType));<z>
public void sendNotification(Notification notification) {<z>
notification, "Notification must not be null");<z>
(notification);<z>
AttributeChangeNotification) {<z>
) notification);<z>
sendNotification(notification);<z>
ex) {<z>
ex);<z>
{<z>
beanName);<z>
(beanName);<z>
: getBeanPostProcessorCache().mergedDefinition) {<z>
beanName);<z>
) {<z>
equals(bdName)) {<z>
beanDefinitionMap.get(bdName);<z>
(bd.getParentName())) {<z>
(bdName);<z>
ClassUtils.isPresent("com.fasterxml.jackson.databind.ObjectMapper", classLoader) &&<z>
"com.fasterxml.jackson.core.JsonGenerator", classLoader);<z>
classLoader);<z>
.isPresent("com.fasterxml.jackson.dataformat.smile.SmileFactory", classLoader);<z>
);<z>
);<z>
.isPresent("kotlinx.serialization.json.Json", classLoader);<z>
{<z>
if (!shouldIgnoreXml) {<z>
>());<z>
) {<z>
&& !jackson2XmlPresent) {<z>
(new Jaxb2RootElementHttpMessageConverter());<z>
{<z>
addPartConverter(new MappingJackson2HttpMessageConverter());<z>
else if (gsonPresent) {<z>
));<z>
(jsonbPresent) {<z>
());<z>
) {<z>
);<z>
&& !shouldIgnoreXml) {<z>
());<z>
(jackson2SmilePresent) {<z>
addPartConverter(new MappingJackson2SmileHttpMessageConverter());<z>
(@Nullable Object other) {<z>
(this == other) {<z>
;<z>
) {<z>
return false;<z>
ObjectError otherError = (ObjectError) other;<z>
otherError.getObjectName());<z>
(String path, String[] pattDirs) {<z>
(!this.trimTokens) {<z>
0;<z>
String pattDir : pattDirs) {<z>
this.pathSeparator);<z>
;<z>
path, pos, pattDir);<z>
)) {<z>
pattDir.charAt(0))));<z>
;<z>
return true;<z>
Nullable String ranges) {<z>
ranges)) {<z>
;<z>
.startsWith(BYTE_RANGE_PREFIX)) {<z>
"' does not start with 'bytes='");<z>
;<z>
;<z>
tokens.length > MAX_RANGES) {<z>
IllegalArgumentException("Too many ranges: " + tokens.length);<z>
length);<z>
: tokens) {<z>
(token));<z>
;<z>
> encoder) {<z>
(encoder, "Encoder is required");<z>
(encoder);<z>
this.encoder = encoder;<z>
));<z>
this.mediaTypes);<z>
UriComponentsBuilder initUriComponentsBuilder(String uriTemplate) {<z>
UriComponentsBuilder result;<z>
)) {<z>
());<z>
) {<z>
builder = UriComponentsBuilder.fromUriString(uriTemplate);<z>
uri = builder.build();<z>
uriComponents(uri) : builder);<z>
;<z>
(EncodingMode.TEMPLATE_AND_VALUES)) {<z>
();<z>
);<z>
result;<z>
receiveSelected(String messageSelector) throws JmsException {<z>
;<z>
defaultDestination != null) {<z>
);<z>
);<z>
(FilterConfig config, Set<String> requiredProperties)<z>
throws ServletException {<z>
) ?<z>
: null);<z>
getInitParameterNames();<z>
{<z>
);<z>
(property);<z>
new PropertyValue(property, value));<z>
null) {<z>
);<z>
.isEmpty(missingProps)) {<z>
new ServletException(<z>
.getFilterName() +<z>
));<z>
checkSessions() {<z>
);<z>
) {<z>
) {<z>
sessions.values()) {<z>
()) {<z>
getCreateTime();<z>
if (timeSinceCreated < getTimeToFirstMessage()) {<z>
getSession();<z>
logger.isInfoEnabled()) {<z>
info("No messages received after " + timeSinceCreated + " ms. " +<z>
".");<z>
);<z>
CloseStatus.SESSION_NOT_RELIABLE);<z>
{<z>
)) {<z>
("Failed to close unreliable " + session, ex);<z>
lastSessionCheckTime = currentTime;<z>
sessionCheckLock.unlock();<z>
[] sourceArguments, Object[] additionalArguments) {<z>
.isEmpty(sourceArguments)) {<z>
;<z>
.length];<z>
length);<z>
, additionalArguments.length);<z>
arguments;<z>
Builder setFoo(<z>
String value) {<z>
(value == null) {<z>
);<z>
bitField0_ |= 0x00000001;<z>
foo_ = value;<z>
;<z>
;<z>
beanFactory, String beanName,<z>
boolean isFactoryBean) {<z>
(beanFactory, beanName);<z>
Assert.notNull(scriptFactory, "ScriptFactory must not be null");<z>
);<z>
;<z>
= scriptSource;<z>
= isFactoryBean;<z>
public ViewResolverRegistry(<z>
@Nullable ApplicationContext context) {<z>
= contentNegotiationManager;<z>
applicationContext = context;<z>
setInterceptors(List<ChannelInterceptor> interceptors) {<z>
"'interceptors' must not contain null elements");<z>
clear();<z>
.interceptors.addAll(interceptors);<z>
(String optionName, @Nullable String optionValue) {<z>
)) {<z>
;<z>
{<z>
(optionValue);<z>
initInfoReceiver(List<Transport> transports) {<z>
) {<z>
{<z>
return infoReceiver;<z>
;<z>
(final String... sql) throws DataAccessException {<z>
Assert.notEmpty(sql, "SQL array must not be empty");<z>
()) {<z>
.length + " statements");<z>
<int[]>, SqlProvider {<z>
;<z>
{<z>
length];<z>
)) {<z>
) {<z>
currSql, sqlStmt);<z>
.addBatch(sqlStmt);<z>
;<z>
catch (BatchUpdateException ex) {<z>
String batchExceptionSql = null;<z>
getUpdateCounts().length; i++) {<z>
] == Statement.EXECUTE_FAILED) {<z>
, sql[i]);<z>
) {<z>
= batchExceptionSql;<z>
ex;<z>
.length; i++) {<z>
];<z>
sql[i])) {<z>
[i] = stmt.getUpdateCount();<z>
);<z>
rowsAffected;<z>
) {<z>
statement : statement);<z>
String getSql() {<z>
;<z>
), true);<z>
result != null, "No update counts");<z>
;<z>
eatNonDottedNode() {<z>
(TokenKind.LSQUARE)) {<z>
{<z>
return pop();<z>
null;<z>
{<z>
= createHeaderAccessor(StompCommand.CONNECT);<z>
.connectHeaders);<z>
return accessor;<z>
public SourceClass getSuperClass() throws IOException {<z>
this.source instanceof Class) {<z>
);<z>
asSourceClass(<z>
).getSuperClassName(), DEFAULT_EXCLUSION_FILTER);<z>
desc, ManagedMetric metric) {<z>
));<z>
(metric.getPersistPolicy())) {<z>
());<z>
) {<z>
)));<z>
.getDisplayName())) {<z>
FIELD_DISPLAY_NAME, metric.getDisplayName());<z>
hasLength(metric.getUnit())) {<z>
getUnit());<z>
{<z>
FIELD_METRIC_CATEGORY, metric.getCategory());<z>
());<z>
(WebSocketSession session, TextMessage message) {<z>
CloseStatus.NOT_ACCEPTABLE.withReason("Text messages not supported"));<z>
{<z>
ResolvableType type,<z>
MediaType mediaType, ReactiveHttpOutputMessage message,<z>
{<z>
()<z>
map(request -> {<z>
message;<z>
);<z>
));<z>
ServletRequest request, String name)<z>
throws ServletRequestBindingException {<z>
) == null) {<z>
;<z>
));<z>
void loadBeanDefinitions(GenericApplicationContext context, MergedContextConfiguration mergedConfig) {<z>
getClasses();<z>
if (logger.isDebugEnabled()) {<z>
"Registering component classes: " + ObjectUtils.nullSafeToString(componentClasses));<z>
(componentClasses);<z>
() {<z>
return (this.detectHandlerMethodsInAncestorContexts ?<z>
Object.class) :<z>
.getBeanNamesForType(Object.class));<z>
createNewDelegate() {<z>
);<z>
ex) {<z>
+<z>
ex);<z>
{<z>
(getBeanClassName());<z>
+ ObjectUtils.nullSafeHashCode(this.scope);<z>
if (hasConstructorArgumentValues()) {<z>
nullSafeHashCode(this.constructorArgumentValues);<z>
) {<z>
(this.propertyValues);<z>
;<z>
(this.factoryMethodName);<z>
hashCode();<z>
return hashCode;<z>
> unwrap() {<z>
> result = new ArrayList<>();<z>
for (RequestConditionHolder holder : this.requestConditions) {<z>
));<z>
return result;<z>
() {<z>
this.headersWritten) {<z>
;<z>
this.headers);<z>
void setBeanFactory(BeanFactory beanFactory) {<z>
(!(beanFactory instanceof ConfigurableBeanFactory)) {<z>
new IllegalStateException("ScriptFactoryPostProcessor doesn't work with " +<z>
+ beanFactory.getClass());<z>
ConfigurableBeanFactory) beanFactory;<z>
beanFactory);<z>
.copyConfigurationFrom(this.beanFactory);<z>
).removeIf(beanPostProcessor -><z>
AopInfrastructureBean);<z>
IOException {<z>
() == null) {<z>
);<z>
SAXException | ParserConfigurationException ex) {<z>
new UnmarshallingFailureException("Could not create XMLReader for SAXSource", ex);<z>
.getInputSource() == null) {<z>
setInputSource(new InputSource());<z>
), saxSource.getInputSource());<z>
catch (NullPointerException ex) {<z>
if (!isSupportDtd()) {<z>
new UnmarshallingFailureException("NPE while unmarshalling. " +<z>
"declarations, which are disabled.");<z>
ex;<z>
objectWriter)<z>
, IOException {<z>
(1024);<z>
.encoding != null) {<z>
this.encoding);<z>
writeValue(writer, object);<z>
);<z>
= session.createBytesMessage();<z>
.writeBytes(bos.toByteArray());<z>
this.encodingPropertyName != null) {<z>
.setStringProperty(this.encodingPropertyName,<z>
;<z>
;<z>
] argTypes) throws DataAccessException {<z>
if (batchArgs.isEmpty()) {<z>
new int[0];<z>
(<z>
() {<z>
, int i) throws SQLException {<z>
get(i);<z>
;<z>
: values) {<z>
colIndex++;<z>
paramValue) {<z>
, paramValue.getValue());<z>
;<z>
(argTypes.length < colIndex) {<z>
SqlTypeValue.TYPE_UNKNOWN;<z>
;<z>
colType, value);<z>
public int getBatchSize() {<z>
size();<z>
);<z>
, Object obj) {<z>
(logger.isInfoEnabled()) {<z>
+ obj + "]");<z>
);<z>
) {<z>
value == BooleanTypedValue.TRUE) {<z>
.visitLdcInsn(1);<z>
visitLdcInsn(0);<z>
);<z>
> buildContextHierarchyMap(Class<?> testClass) {<z>
;<z>
;<z>
: resolveContextHierarchyAttributes(testClass)) {<z>
: configAttributesList) {<z>
();<z>
{<z>
= GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + hierarchyLevel;<z>
map.containsKey(name)) {<z>
;<z>
<>());<z>
get(name).add(configAttributes);<z>
.values());<z>
!= map.size()) {<z>
String.format("The @ContextConfiguration elements configured via @ContextHierarchy in " +<z>
testClass.getName());<z>
(msg);<z>
IllegalStateException(msg);<z>
map;<z>
) throws IOException {<z>
;<z>
) {<z>
is = mappingLocation.getInputStream()) {<z>
new MimetypesFileTypeMap(is);<z>
new MimetypesFileTypeMap();<z>
if (mappings != null) {<z>
{<z>
mapping);<z>
fileTypeMap;<z>
task) {<z>
);<z>
));<z>
) {<z>
, ex);<z>
HttpRequestMethodNotSupportedException ex,<z>
Object handler) throws IOException {<z>
supportedMethods = ex.getSupportedMethods();<z>
if (supportedMethods != null) {<z>
.arrayToDelimitedString(supportedMethods, ", "));<z>
, ex.getMessage());<z>
return new ModelAndView();<z>
{<z>
aNode instanceof Element)) {<z>
false;<z>
().getLocalName(aNode);<z>
AFTER_RETURNING_ELEMENT.equals(name) ||<z>
;<z>
@Nullable String name) {<z>
) {<z>
+ "'");<z>
.valueIterator.next();<z>
retrieveMaxCacheSize() {<z>
MAX_CONTEXT_CACHE_SIZE_PROPERTY_NAME);<z>
if (StringUtils.hasText(maxSize)) {<z>
.trim());<z>
{<z>
;<z>
(String factoryId, Element containerEle, ParserContext parserContext,<z>
) {<z>
);<z>
getAttribute(CONTAINER_TYPE_ATTRIBUTE);<z>
CONTAINER_CLASS_ATTRIBUTE);<z>
hasLength(containerClass)) {<z>
null;<z>
) || containerType.startsWith("default")) {<z>
setBeanClassName("org.springframework.jms.config.DefaultJmsListenerContainerFactory");<z>
(containerType.startsWith("simple")) {<z>
setBeanClassName("org.springframework.jms.config.SimpleJmsListenerContainerFactory");<z>
).addPropertyValues(commonContainerProperties);<z>
.getPropertyValues().addPropertyValues(specificContainerProperties);<z>
factoryDef;<z>
onNext(DataBuffer buffer) {<z>
.boundary.match(buffer);<z>
!= -1) {<z>
isTraceEnabled()) {<z>
);<z>
1;<z>
{<z>
(buffer.readPosition(), len);<z>
(body);<z>
(null);<z>
else if (len < 0) {<z>
previous.get();<z>
() + len;<z>
(prevLen > 0) {<z>
;<z>
(previous);<z>
this.previous.set(body);<z>
(null);<z>
.release(previous);<z>
previous.set(null);<z>
(null);<z>
(buffer, endIdx);<z>
;<z>
HeadersState(), remainder);<z>
;<z>
;<z>
) {<z>
);<z>
returnValue;<z>
).getGeneric();<z>
, ServerHttpResponse response) throws IOException {<z>
GET) {<z>
response);<z>
if (checkOrigin(request, response)) {<z>
UTF_8));<z>
String.format(<z>
(), isWebSocketEnabled());<z>
.getBytes());<z>
getMethod() == HttpMethod.OPTIONS) {<z>
(request, response)) {<z>
(response);<z>
;<z>
HttpMethod.OPTIONS);<z>
throws Exception {<z>
.getReadMethod();<z>
makeAccessible(readMethod);<z>
);<z>
[] paramTypes) {<z>
lvtIndex = new int[paramTypes.length];<z>
);<z>
++) {<z>
;<z>
])) {<z>
+= 2;<z>
;<z>
;<z>
(Cache cache, boolean immediate) {<z>
if (immediate) {<z>
cache.invalidate();<z>
();<z>
{<z>
handleCacheClearError(ex, cache);<z>
public void initialize() {<z>
) {<z>
beanName + "'" : ""));<z>
threadNamePrefixSet && this.beanName != null) {<z>
this.beanName + "-");<z>
this.rejectedExecutionHandler);<z>
throws IOException {<z>
;<z>
!= null) {<z>
);<z>
.classLoader != null) {<z>
classLoader.getResourceAsStream(this.path);<z>
);<z>
) {<z>
+ " cannot be opened because it does not exist");<z>
return is;<z>
{<z>
!= null, "No PlatformTransactionManager set");<z>
debug("Initiating transaction rollback on application exception", ex);<z>
status);<z>
catch (TransactionSystemException ex2) {<z>
logger.error("Application exception overridden by rollback exception", ex);<z>
;<z>
ex2;<z>
) {<z>
("Application exception overridden by rollback exception", ex);<z>
;<z>
Object... args) {<z>
();<z>
(bean.equals(null)) {<z>
null;<z>
.makeAccessible(this.method);<z>
args);<z>
ex) {<z>
, args);<z>
), ex);<z>
IllegalAccessException ex) {<z>
;<z>
(InvocationTargetException ex) {<z>
;<z>
instanceof RuntimeException) {<z>
) targetException;<z>
bean, "Failed to invoke event listener method", args);<z>
new UndeclaredThrowableException(targetException, msg);<z>
{<z>
();<z>
(path)) {<z>
this.pageContext.getAttribute(<z>
FormTag.MODEL_ATTRIBUTE_VARIABLE_NAME, PageContext.REQUEST_SCOPE);<z>
deleteAny(path, "[]") + ".errors";<z>
void afterPropertiesSet() throws IOException {<z>
&& !this.metadataSourcesAccessed) {<z>
metadataSources = null;<z>
LocalSessionFactoryBuilder sfb = new LocalSessionFactoryBuilder(<z>
getMetadataSources());<z>
(this.configLocations != null) {<z>
this.configLocations) {<z>
(resource.getURL());<z>
(this.mappingResources != null) {<z>
) {<z>
.getClassLoader());<z>
(mr.getInputStream());<z>
null) {<z>
mappingLocations) {<z>
.getInputStream());<z>
null) {<z>
this.cacheableMappingLocations) {<z>
resource.getFile());<z>
!= null) {<z>
for (Resource resource : this.mappingJarLocations) {<z>
(resource.getFile());<z>
mappingDirectoryLocations != null) {<z>
(Resource resource : this.mappingDirectoryLocations) {<z>
file = resource.getFile();<z>
file.isDirectory()) {<z>
(<z>
);<z>
);<z>
(this.entityInterceptor != null) {<z>
.entityInterceptor);<z>
{<z>
this.implicitNamingStrategy);<z>
) {<z>
;<z>
.jtaTransactionManager != null) {<z>
);<z>
this.beanFactory != null) {<z>
;<z>
) {<z>
cacheRegionFactory);<z>
null) {<z>
this.multiTenantConnectionProvider);<z>
this.currentTenantIdentifierResolver != null) {<z>
this.currentTenantIdentifierResolver);<z>
) {<z>
.addProperties(this.hibernateProperties);<z>
(this.entityTypeFilters != null) {<z>
);<z>
annotatedClasses != null) {<z>
.annotatedClasses);<z>
null) {<z>
addPackages(this.annotatedPackages);<z>
(this.packagesToScan != null) {<z>
packagesToScan);<z>
;<z>
buildSessionFactory(sfb);<z>
throws JspException, NoSuchMessageException {<z>
;<z>
if (this.message != null) {<z>
).getLocale());<z>
null || this.text != null) {<z>
resolveArguments(this.arguments);<z>
nestedArguments.isEmpty()) {<z>
nestedArguments.toArray());<z>
this.text != null) {<z>
getMessage(<z>
.getLocale());<z>
(msg != null ? msg : "");<z>
.getMessage(<z>
getLocale());<z>
;<z>
) {<z>
Assert.notNull(clazz, "Class must not be null");<z>
Assert.notNull(methodName, "Method name must not be null");<z>
getDeclaredMethods();<z>
declaredMethods) {<z>
equals(methodName)) {<z>
return true;<z>
;<z>
> ifc : ifcs) {<z>
{<z>
;<z>
));<z>
> message) {<z>
getHeaders();<z>
;<z>
String sessionId = SimpMessageHeaderAccessor.getSessionId(headers);<z>
(sessionId);<z>
{<z>
SimpMessageType messageType = SimpMessageHeaderAccessor.getMessageType(headers);<z>
{<z>
);<z>
destination, message);<z>
) {<z>
logMessage(message);<z>
{<z>
] heartbeatIn = SimpMessageHeaderAccessor.getHeartbeat(headers);<z>
heartbeatOut = getHeartbeatValue();<z>
user = SimpMessageHeaderAccessor.getUser(headers);<z>
MessageChannel outChannel = getClientOutboundChannelForSession(sessionId);<z>
));<z>
SimpMessageHeaderAccessor.create(SimpMessageType.CONNECT_ACK);<z>
connectAck);<z>
connectAck.setSessionId(sessionId);<z>
null) {<z>
;<z>
CONNECT_MESSAGE_HEADER, message);<z>
(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, heartbeatOut);<z>
(EMPTY_PAYLOAD, connectAck.getMessageHeaders());<z>
messageOut);<z>
DISCONNECT.equals(messageType)) {<z>
);<z>
sessionId != null) {<z>
Principal user = SimpMessageHeaderAccessor.getUser(headers);<z>
handleDisconnect(sessionId, user, message);<z>
(messageType)) {<z>
logMessage(message);<z>
this.subscriptionRegistry.registerSubscription(message);<z>
(messageType)) {<z>
;<z>
.unregisterSubscription(message);<z>
visitor) {<z>
.startAnd();<z>
visitor);<z>
visitor.and();<z>
right.accept(visitor);<z>
endAnd();<z>
, HttpServletResponse response, Transformer transformer) {<z>
;<z>
);<z>
ENCODING);<z>
)) {<z>
mediaType;<z>
encoding)) {<z>
).contains(WebUtils.CONTENT_TYPE_CHARSET_PREFIX)) {<z>
.CONTENT_TYPE_CHARSET_PREFIX + encoding;<z>
setContentType(contentType);<z>
() {<z>
null,<z>
);<z>
defaultRollback;<z>
.getTransaction(this.transactionDefinition);<z>
.transactionsStarted.incrementAndGet();<z>
(logger.isInfoEnabled()) {<z>
(<z>
.flaggedForRollback));<z>
getObject(String key) {<z>
this.beanFactory.containsBean(key)) {<z>
);<z>
if (this.scope != null) {<z>
.resolveContextualObject(key);<z>
;<z>
{<z>
) {<z>
("Creating JAXBContext with classes to be bound [" +<z>
.arrayToCommaDelimitedString(classesToBeBound) + "]");<z>
this.jaxbContextProperties != null) {<z>
);<z>
.newInstance(classesToBeBound);<z>
) {<z>
= null;<z>
: this.expressions) {<z>
) {<z>
<>();<z>
.add(expression);<z>
return result;<z>
registerAspectJAutoProxyCreatorIfNecessary(<z>
ParserContext parserContext, Element sourceElement) {<z>
.registerAspectJAutoProxyCreatorIfNecessary(<z>
(sourceElement));<z>
.getRegistry(), sourceElement);<z>
;<z>
Resource resource, long position, long count) {<z>
resource, "Resource must not be null");<z>
.isTrue(position >= 0, "'position' must be larger than or equal to 0");<z>
(count >= 0, "'count' must be larger than or equal to 0");<z>
resource = resource;<z>
;<z>
count;<z>
(HttpStatus statusCode, String statusText,<z>
responseBody, @Nullable Charset responseCharset) {<z>
responseBody, responseCharset);<z>
String body) {<z>
body, "Body must not be null");<z>
);<z>
).<z>
-> {<z>
UTF_8);<z>
sharedInstance.wrap(bytes);<z>
;<z>
return this;<z>
(HttpServletRequest request, HttpServletResponse response) {<z>
= getViewNameForRequest(request);<z>
) {<z>
"Returning view name '" + viewName + "'");<z>
getInputFlashMap(request));<z>
Nullable TypeDescriptor keyTypeDescriptor,<z>
) {<z>
(mapType, "Map type must not be null");<z>
.class.isAssignableFrom(mapType)) {<z>
;<z>
!= null ? keyTypeDescriptor.resolvableType : null);<z>
valueTypeDescriptor.resolvableType : null);<z>
null);<z>
{<z>
= 0;<z>
cachedSessions) {<z>
) {<z>
{<z>
.size();<z>
return count;<z>
) {<z>
first.route(request);<z>
{<z>
firstRoute;<z>
route(request);<z>
JmsException ex) {<z>
||<z>
ex instanceof InvalidDestinationException) {<z>
(), ex);<z>
) {<z>
.getMessage(), ex);<z>
);<z>
parameter) {<z>
);<z>
;<z>
);<z>
) {<z>
{<z>
getSharedInstance();<z>
;<z>
{<z>
) status.getTransaction();<z>
{<z>
.debug("Rolling back JPA transaction on EntityManager [" +<z>
.getEntityManager() + "]");<z>
;<z>
) {<z>
rollback();<z>
catch (PersistenceException ex) {<z>
ex);<z>
isNewEntityManagerHolder()) {<z>
).getEntityManager().clear();<z>
Exception {<z>
{<z>
;<z>
.toJson(object, writer);<z>
public CorsConfiguration(CorsConfiguration other) {<z>
other.allowedOrigins;<z>
= other.allowedOriginPatterns;<z>
;<z>
.resolvedMethods = other.resolvedMethods;<z>
= other.allowedHeaders;<z>
exposedHeaders = other.exposedHeaders;<z>
.allowCredentials = other.allowCredentials;<z>
= other.maxAge;<z>
TypeDescriptor targetTypeDescriptor) throws EvaluationException {<z>
);<z>
.getTypeConverter().convertValue(<z>
targetTypeDescriptor);<z>
{<z>
context.extractSource(element);<z>
element.getTagName(), source));<z>
>(4);<z>
setSource(context.extractSource(element));<z>
String[] {<z>
, "ref"};<z>
, names)) {<z>
();<z>
) {<z>
parsePropertySubElement(resolverElement, null));<z>
resolverBeanDef;<z>
{<z>
RootBeanDefinition(InternalResourceViewResolver.class);<z>
, "/WEB-INF/");<z>
("suffix", ".jsp");<z>
resolverBeanDef);<z>
if ("freemarker".equals(name)) {<z>
FreeMarkerViewResolver.class);<z>
, ".ftl");<z>
, resolverBeanDef);<z>
) {<z>
GroovyMarkupViewResolver.class);<z>
("suffix", ".tpl");<z>
);<z>
) {<z>
.class);<z>
(resolverElement, resolverBeanDef);<z>
(name)) {<z>
class);<z>
new IllegalStateException("Unexpected element name: " + name);<z>
source);<z>
);<z>
resolverBeanDef);<z>
String beanName = VIEW_RESOLVER_BEAN_NAME;<z>
new RootBeanDefinition(ViewResolverComposite.class);<z>
setSource(source);<z>
;<z>
};<z>
getChildElementsByTagName(element, names);<z>
contentNegotiationElements.isEmpty()) {<z>
resolvers);<z>
== 1) {<z>
context);<z>
).add("viewResolvers", resolvers);<z>
<>(1);<z>
beanDef);<z>
);<z>
.add("viewResolvers", list);<z>
new IllegalArgumentException("Only one <content-negotiation> element is allowed.");<z>
element.hasAttribute("order")) {<z>
"order", element.getAttribute("order"));<z>
.registerBeanDefinition(beanName, compositeResolverBeanDef);<z>
));<z>
);<z>
;<z>
?> exType) {<z>
(exType == null) {<z>
false;<z>
isInstance(this)) {<z>
return true;<z>
();<z>
if (cause == this) {<z>
return false;<z>
) {<z>
exType);<z>
while (cause != null) {<z>
)) {<z>
true;<z>
cause.getCause() == cause) {<z>
();<z>
;<z>
)<z>
{<z>
mergedContextConfiguration.getContextLoader();<z>
(contextLoader, "Cannot load an ApplicationContext with a NULL 'contextLoader'. " +<z>
;<z>
applicationContext;<z>
if (contextLoader instanceof SmartContextLoader smartContextLoader) {<z>
applicationContext = smartContextLoader.loadContext(mergedContextConfiguration);<z>
locations = mergedContextConfiguration.getLocations();<z>
locations, "Cannot load an ApplicationContext with a NULL 'locations' array. " +<z>
;<z>
contextLoader.loadContext(locations);<z>
return applicationContext;<z>
{<z>
type == null) {<z>
return null;<z>
DeclaredType declaredType) {<z>
getEnclosingElement();<z>
instanceof TypeElement) {<z>
;<z>
getQualifiedName(declaredType.asElement());<z>
toString();<z>
registerRequestHandler(<z>
, ParserContext ctx, @Nullable Object source) {<z>
RootBeanDefinition beanDef;<z>
(<z>
ctx, source);<z>
if (sockJsService != null) {<z>
);<z>
(0, sockJsService);<z>
subProtoHandler);<z>
null);<z>
(SCHEDULER_BEAN_NAME, SOCKJS_SCHEDULER_BEAN_NAME);<z>
);<z>
= DomUtils.getChildElementByTagName(element, "handshake-interceptors");<z>
parseBeanSubElements(interceptElem, ctx);<z>
.getAttribute("allowed-origins");<z>
.tokenizeToStringArray(allowedOrigins, ","));<z>
= element.getAttribute("allowed-origin-patterns");<z>
tokenizeToStringArray(allowedOriginPatterns, ","));<z>
);<z>
) {<z>
.setAllowedOriginPatterns(originPatterns);<z>
.add(interceptor);<z>
= new ConstructorArgumentValues();<z>
0, subProtoHandler);<z>
1, handler);<z>
);<z>
("handshakeInterceptors", interceptors);<z>
(beanDef, ctx, source));<z>
void registerInfrastructureBean(<z>
BeanDefinitionBuilder builder, String beanName) {<z>
(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
beanName, builder.getBeanDefinition());<z>
.getBeanDefinition(), beanName);<z>
BeanComponentDefinition(holder));<z>
{<z>
.bindMarkers.next(this.namedParameter);<z>
this.placeholders.add(bindMarker);<z>
);<z>
capacity) {<z>
) {<z>
>();<z>
List) {<z>
>(capacity);<z>
else if (collection instanceof EnumSet enumSet) {<z>
copyOf(enumSet);<z>
.clear();<z>
return copy;<z>
collection instanceof SortedSet sortedSet) {<z>
comparator());<z>
capacity);<z>
request,<z>
{<z>
;<z>
put(RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE,<z>
;<z>
= mergePatterns(<z>
MATCHING_PATTERN_ATTRIBUTE),<z>
);<z>
MATCHING_PATTERN_ATTRIBUTE, pattern);<z>
result;<z>
(RequestExpectationManager manager) {<z>
;<z>
server.new MockClientHttpRequestFactory();<z>
this.bufferContent) {<z>
;<z>
.restTemplate.setRequestFactory(factory);<z>
;<z>
pattern) {<z>
;<z>
{<z>
initCounters();<z>
= this.pattern.equals("/**");<z>
"/**");<z>
{<z>
() : 0);<z>
headers)<z>
MessagingException {<z>
);<z>
doResolveException(<z>
Nullable Object handler, Exception ex) {<z>
(ex instanceof HttpRequestMethodNotSupportedException) {<z>
return handleHttpRequestMethodNotSupported(<z>
;<z>
(ex instanceof HttpMediaTypeNotSupportedException) {<z>
(<z>
request, response, handler);<z>
ex instanceof HttpMediaTypeNotAcceptableException) {<z>
handleHttpMediaTypeNotAcceptable(<z>
, handler);<z>
else if (ex instanceof MissingPathVariableException) {<z>
return handleMissingPathVariable(<z>
response, handler);<z>
{<z>
(<z>
, request, response, handler);<z>
) {<z>
return handleServletRequestBindingException(<z>
, handler);<z>
) {<z>
return handleConversionNotSupported(<z>
ex, request, response, handler);<z>
else if (ex instanceof TypeMismatchException) {<z>
handleTypeMismatch(<z>
, response, handler);<z>
(ex instanceof HttpMessageNotReadableException) {<z>
return handleHttpMessageNotReadable(<z>
, request, response, handler);<z>
ex instanceof HttpMessageNotWritableException) {<z>
handleHttpMessageNotWritable(<z>
);<z>
else if (ex instanceof MethodArgumentNotValidException) {<z>
(<z>
, request, response, handler);<z>
MissingServletRequestPartException) {<z>
handleMissingServletRequestPartException(<z>
;<z>
(ex instanceof BindException) {<z>
) ex, request, response, handler);<z>
(ex instanceof NoHandlerFoundException) {<z>
handleNoHandlerFoundException(<z>
, request, response, handler);<z>
ex instanceof AsyncRequestTimeoutException) {<z>
(<z>
request, response, handler);<z>
handlerEx) {<z>
if (logger.isWarnEnabled()) {<z>
);<z>
;<z>
) {<z>
, charset -> {<z>
[];<z>
.size(); i++) {<z>
;<z>
;<z>
});<z>
buffer) {<z>
(true) {<z>
)) {<z>
)) {<z>
"SockJS sockJsSession closed, closing response.");<z>
.getId(), null));<z>
== 0) {<z>
b = buffer.get();<z>
{<z>
);<z>
outputStream.write(b);<z>
EncodedResource resource) throws ScriptException {<z>
, DefaultDataBufferFactory.sharedInstance, false, false,<z>
,<z>
);<z>
writeTagContent(TagWriter tagWriter) throws JspException {<z>
);<z>
)) {<z>
tagWriter.startTag("input");<z>
tagWriter.writeAttribute("type", "hidden");<z>
);<z>
.writeAttribute("name", name);<z>
, "hidden"));<z>
();<z>
;<z>
HttpServletResponse response, FilterChain filterChain)<z>
{<z>
;<z>
ERROR_EXCEPTION_ATTRIBUTE) == null) {<z>
(this.methodParam);<z>
) {<z>
toUpperCase(Locale.ENGLISH);<z>
(method)) {<z>
method);<z>
;<z>
response, FilterChain filterChain)<z>
{<z>
instanceof HttpServletResponse)) {<z>
ServletException("ResourceUrlEncodingFilter only supports HTTP requests");<z>
wrappedRequest =<z>
);<z>
ResourceUrlEncodingResponseWrapper wrappedResponse =<z>
HttpServletResponse) response);<z>
(wrappedRequest, wrappedResponse);<z>
private void startIfNecessary(MessageListenerContainer listenerContainer) {<z>
.contextRefreshed || listenerContainer.isAutoStartup()) {<z>
);<z>
EMPTY_URL_ENUMERATION = new Enumeration<>() {<z>
boolean hasMoreElements() {<z>
;<z>
public URL nextElement() {<z>
("Should not be called. I am empty.");<z>
annotationsToSearch) {<z>
) {<z>
;<z>
SimpleTypeConverter();<z>
Annotation annotation : annotationsToSearch) {<z>
= annotation.annotationType();<z>
;<z>
;<z>
if (isQualifier(type)) {<z>
) {<z>
fallbackToMeta = true;<z>
checkMeta = false;<z>
(checkMeta) {<z>
foundMeta = false;<z>
)) {<z>
= metaAnn.annotationType();<z>
isQualifier(metaType)) {<z>
foundMeta = true;<z>
))) ||<z>
metaAnn, typeConverter)) {<z>
return false;<z>
!foundMeta) {<z>
;<z>
;<z>
, Charset charset, MediaType contentType,<z>
, Message.Builder builder)<z>
, HttpMessageConversionException {<z>
if (contentType.isCompatibleWith(APPLICATION_JSON)) {<z>
, builder);<z>
) {<z>
builder);<z>
(<z>
;<z>
TcpConnectionHandler<P> handler) {<z>
;<z>
) {<z>
;<z>
handler)<z>
)<z>
()<z>
afterConnectFailure)<z>
.then();<z>
return new MonoToListenableFutureAdapter<>(connectMono);<z>
{<z>
"Parameter name must not be null");<z>
name);<z>
[0] : null);<z>
(ServletRequest request, String name)<z>
{<z>
);<z>
) {<z>
DispatcherServlet.LOCALE_RESOLVER_BEAN_NAME)) {<z>
);<z>
setSource(source);<z>
setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
registerBeanDefinition(DispatcherServlet.LOCALE_RESOLVER_BEAN_NAME, beanDef);<z>
(beanDef, DispatcherServlet.LOCALE_RESOLVER_BEAN_NAME));<z>
> inputStream, ResolvableType elementType,<z>
{<z>
getMessageBuilder(elementType.toClass());<z>
);<z>
.getName());<z>
getFullName());<z>
if (inputStream instanceof Flux) {<z>
{<z>
.get(0));<z>
ProtobufEncoder.DELIMITED_KEY))) {<z>
.getParameters());<z>
.DELIMITED_VALUE);<z>
.getSubtype(), parameters));<z>
;<z>
) {<z>
.getMessage(), ex));<z>
public void destroySingleton(String beanName) {<z>
);<z>
;<z>
synchronized (this.disposableBeans) {<z>
disposableBeans.remove(beanName);<z>
, disposableBean);<z>
innerName, int access) {<z>
outerName != null) {<z>
;<z>
= toClassName(outerName);<z>
.equals(className)) {<z>
;<z>
0);<z>
(outerClassName)) {<z>
memberClassNames.add(className);<z>
@Nullable ServletContext servletContext) {<z>
if (servletContext == null) {<z>
null;<z>
.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);<z>
);<z>
trySetStompHeaderForSubscriptionId() {<z>
getSubscriptionId();<z>
(subscriptionId != null) {<z>
= getCommand();<z>
command)) {<z>
STOMP_SUBSCRIPTION_HEADER, subscriptionId);<z>
;<z>
(messageType)) {<z>
, subscriptionId);<z>
public String getFrameData() {<z>
.HEARTBEAT) {<z>
;<z>
return getContent().substring(1);<z>
, String bestMatchingPattern,<z>
uriTemplateVariables) {<z>
rawHandler);<z>
pathWithinMapping));<z>
(uriTemplateVariables)) {<z>
);<z>
;<z>
void maybeBindThisJoinPointStaticPart() {<z>
) {<z>
THIS_JOIN_POINT_STATIC_PART);<z>
public DefaultBuilder headers(String... headers) {<z>
for (String header : headers) {<z>
this.hasContentType ||<z>
"content-type");<z>
hasAccept = this.hasAccept ||<z>
;<z>
headers = headers;<z>
;<z>
loadTimeWeaver() {<z>
, "No ClassLoader set");<z>
null;<z>
!= null) {<z>
= this.ltwConfigurer.getLoadTimeWeaver();<z>
== null) {<z>
DefaultContextLoadTimeWeaver(this.beanClassLoader);<z>
if (this.enableLTW != null) {<z>
.enableLTW.getEnum("aspectjWeaving");<z>
) {<z>
:<z>
AUTODETECT:<z>
{<z>
loadTimeWeaver, this.beanClassLoader);<z>
ENABLED:<z>
beanClassLoader);<z>
return loadTimeWeaver;<z>
) {<z>
Method readMethod = propertyDescriptor.getReadMethod();<z>
writeMethod = propertyDescriptor.getWriteMethod();<z>
=<z>
.getManagedAttribute(readMethod) : null);<z>
=<z>
) : null);<z>
())) {<z>
);<z>
setter.getDescription())) {<z>
setter.getDescription();<z>
(readMethod) : null);<z>
))) {<z>
;<z>
propertyDescriptor.getDisplayName();<z>
Element element) {<z>
<>();<z>
(element)));<z>
.isEmpty()) {<z>
element), stereotypes));<z>
, Object> headers,<z>
postProcessor) throws MessagingException {<z>
doConvert(payload, headers, postProcessor);<z>
(destinationName, message);<z>
() throws SQLException {<z>
.content != null) {<z>
);<z>
null) {<z>
this.characterStream);<z>
);<z>
());<z>
ex) {<z>
);<z>
?> targetType) {<z>
getAnnotation(CacheResult.class);<z>
method.getAnnotation(CachePut.class);<z>
= method.getAnnotation(CacheRemove.class);<z>
= method.getAnnotation(CacheRemoveAll.class);<z>
cacheRemove, cacheRemoveAll);<z>
== 0) {<z>
;<z>
1) {<z>
;<z>
CacheDefaults defaults = getCacheDefaults(method, targetType);<z>
!= null) {<z>
;<z>
else if (cachePut != null) {<z>
;<z>
cacheRemove != null) {<z>
return createCacheRemoveOperation(method, defaults, cacheRemove);<z>
cacheRemoveAll);<z>
) {<z>
port >= -1, "Port must be >= -1");<z>
.port = String.valueOf(port);<z>
1) {<z>
resetSchemeSpecificPart();<z>
this;<z>
(String sql, SqlParameterSource paramSource) throws DataAccessException {<z>
;<z>
null, "No result map");<z>
result;<z>
Object> getKeys() throws InvalidDataAccessApiUsageException {<z>
(this.keyList.isEmpty()) {<z>
;<z>
1) {<z>
(<z>
;<z>
return this.keyList.get(0);<z>
{<z>
;<z>
length) {<z>
, this.count + additionalCapacity);<z>
newCapacity);<z>
parse(Element element, ParserContext parserContext) {<z>
= parseInternal(element, parserContext);<z>
()) {<z>
definition, parserContext);<z>
)) {<z>
getReaderContext().error(<z>
.getLocalName(element)<z>
"' when used as a top-level tag", element);<z>
aliases = null;<z>
{<z>
NAME_ATTRIBUTE);<z>
(StringUtils.hasLength(name)) {<z>
(name));<z>
, aliases);<z>
());<z>
)) {<z>
(holder);<z>
;<z>
);<z>
) {<z>
= ex.getMessage();<z>
;<z>
return null;<z>
;<z>
) {<z>
synchronized (mbd.constructorArgumentLock) {<z>
mbd.resolvedConstructorOrFactoryMethod = constructorOrFactoryMethod;<z>
true;<z>
(this.resolveNecessary) {<z>
;<z>
arguments;<z>
@Nullable Class<T> requiredType)<z>
TypeMismatchDataAccessException {<z>
(results);<z>
.isInstance(result)) {<z>
{<z>
= result.toString();<z>
instanceof Number) {<z>
;<z>
IllegalArgumentException ex) {<z>
;<z>
(<z>
).getName() +<z>
);<z>
) result;<z>
private static void assertValueCount(<z>
> map, int count) {<z>
get(name);<z>
valueType + " <" + name + ">";<z>
values == null) {<z>
+ " to exist but was null");<z>
(count > values.size()) {<z>
+ "> values but found " + values);<z>
) {<z>
).keySet()) {<z>
{<z>
.getValue());<z>
{<z>
).getSeconds());<z>
null) {<z>
.setDomain(httpCookie.getDomain());<z>
getPath() != null) {<z>
setPath(httpCookie.getPath());<z>
));<z>
.isHttpOnly());<z>
());<z>
).putIfAbsent(name, cookie);<z>
original) {<z>
;<z>
original.returnValue;<z>
.returnType = original.returnType;<z>
{<z>
(session -> {<z>
checkWriteOperationAllowed(session);<z>
(Object entity : entities) {<z>
);<z>
;<z>
;<z>
, MonoSink<Void> sink) {<z>
;<z>
= sink;<z>
position;<z>
this.count = count;<z>
getSessionMutex(HttpSession session) {<z>
;<z>
mutex = session.getAttribute(SESSION_MUTEX_ATTRIBUTE);<z>
== null) {<z>
mutex = session;<z>
;<z>
HttpMethod httpMethod) {<z>
{<z>
) {<z>
);<z>
int length, String mimeType,<z>
, String elementLocalName) {<z>
offset, length);<z>
;<z>
throws ParseException {<z>
this.formatter);<z>
DateTimeParseException ex) {<z>
.fallbackPatterns)) {<z>
(String pattern : this.fallbackPatterns) {<z>
createStrictDateTimeFormatter(pattern);<z>
return doParse(text, locale, fallbackFormatter);<z>
{<z>
this.source != null) {<z>
DateTimeParseException(<z>
,<z>
getErrorIndex(), ex);<z>
;<z>
invokeForHandlerResult(ServerWebExchange exchange,<z>
BindingContext bindingContext, Object... providedArgs) {<z>
> future =<z>
toFuture();<z>
)) {<z>
(<z>
;<z>
;<z>
future.get();<z>
catch (ExecutionException ex) {<z>
ex.getCause();<z>
InterruptedException ex) {<z>
ex;<z>
ServerErrorException(<z>
;<z>
getComponentType() {<z>
NONE) {<z>
NONE;<z>
if (this.componentType != null) {<z>
this.componentType;<z>
this.type instanceof Class) {<z>
.getComponentType();<z>
forType(componentType, this.variableResolver);<z>
(this.type instanceof GenericArrayType) {<z>
);<z>
getComponentType();<z>
final FieldVisitor visitField(<z>
int access,<z>
final String name,<z>
descriptor,<z>
,<z>
final Object value) {<z>
FieldWriter fieldWriter =<z>
, descriptor, signature, value);<z>
) {<z>
= fieldWriter;<z>
else {<z>
fieldWriter;<z>
= fieldWriter;<z>
{<z>
= ObjectUtils.nullSafeHashCode(getCodes());<z>
;<z>
;<z>
return hashCode;<z>
closeStatus) throws Exception {<z>
).afterConnectionClosed(session, closeStatus);<z>
(session);<z>
() {<z>
timeoutInProgress = false;<z>
this.errorInProgress = false;<z>
.sessionFactory, this.sessionHolder);<z>
visitFieldInsn(<z>
final String descriptor) {<z>
!= null) {<z>
, name, descriptor);<z>
access, @Nullable String enclosingClassName,<z>
boolean independentInnerClass, Set<String> interfaceNames,<z>
<MethodMetadata> declaredMethods, MergedAnnotations annotations) {<z>
= className;<z>
this.access = access;<z>
;<z>
.superClassName = superClassName;<z>
independentInnerClass = independentInnerClass;<z>
;<z>
memberClassNames;<z>
declaredMethods;<z>
annotations = annotations;<z>
getRepeatableAnnotations(<z>
> annotationType,<z>
> containerAnnotationType) {<z>
annotatedElement, SearchStrategy.TYPE_HIERARCHY,<z>
.of(annotationType, containerAnnotationType))<z>
)<z>
(MergedAnnotation::getAggregateIndex))<z>
(MergedAnnotation::withNonMergedAttributes)<z>
.toList());<z>
Handler handler) throws IOException {<z>
handler;<z>
for (DataWithMediaType sendAttempt : this.earlySendAttempts) {<z>
);<z>
earlySendAttempts.clear();<z>
) {<z>
) {<z>
;<z>
this.handler.complete();<z>
this.timeoutCallback);<z>
handler.onError(this.errorCallback);<z>
);<z>
(BeanDefinitionHolder beanDefinitionHolder) {<z>
(beanDefinitionHolder, "BeanDefinitionHolder must not be null");<z>
this.beanDefinition = beanDefinitionHolder.getBeanDefinition();<z>
.beanName = beanDefinitionHolder.getBeanName();<z>
.getAliases();<z>
{<z>
;<z>
::completeExceptionally);<z>
return completable;<z>
,<z>
Nullable WebDataBinderFactory binderFactory) throws Exception {<z>
getNativeRequest(HttpServletRequest.class);<z>
);<z>
RequestPart.class);<z>
());<z>
);<z>
parameter.nestedIfOptional();<z>
arg = null;<z>
resolveMultipartArgument(name, parameter, servletRequest);<z>
!= MultipartResolutionDelegate.UNRESOLVABLE) {<z>
= mpArg;<z>
name);<z>
parameter, parameter.getNestedGenericParameterType());<z>
(binderFactory != null) {<z>
(request, arg, name);<z>
{<z>
);<z>
, parameter)) {<z>
);<z>
null) {<z>
name, binder.getBindingResult());<z>
) {<z>
) {<z>
throw ex;<z>
&& isRequired) {<z>
isMultipartRequest(servletRequest)) {<z>
);<z>
name);<z>
return adaptArgumentIfNecessary(arg, parameter);<z>
context) {<z>
.class);<z>
()) {<z>
localeResolver);<z>
.isDebugEnabled()) {<z>
).getSimpleName());<z>
(NoSuchBeanDefinitionException ex) {<z>
);<z>
)) {<z>
+ LOCALE_RESOLVER_BEAN_NAME +<z>
);<z>
int statusCode, HttpHeaders headers,<z>
, Type entityType) {<z>
(statusCode, headers, cookies);<z>
entity;<z>
entityType = entityType;<z>
String> result) {<z>
.forEach((alias, registeredName) -> {<z>
(registeredName.equals(name)) {<z>
add(alias);<z>
(alias, result);<z>
});<z>
?>... scriptInterfaces) {<z>
scriptSourceLocator, "'scriptSourceLocator' must not be empty");<z>
scriptSourceLocator;<z>
scriptInterfaces = scriptInterfaces;<z>
void init(LoadTimeWeaver loadTimeWeaver) {<z>
, "LoadTimeWeaver must not be null");<z>
.loadTimeWeaver = loadTimeWeaver;<z>
);<z>
{<z>
"Packages array must not be null");<z>
= new String[packages.length];<z>
i++) {<z>
];<z>
pkg, "Packages array must not have empty elements");<z>
prefixes[i] = pkg + ".";<z>
sort(this.prefixes);<z>
(this.prefixes);<z>
ServletContext servletContext) {<z>
= servletContext;<z>
(this.defaultServletName)) {<z>
!= null) {<z>
= COMMON_DEFAULT_SERVLET_NAME;<z>
null) {<z>
;<z>
{<z>
defaultServletName = RESIN_DEFAULT_SERVLET_NAME;<z>
.getNamedDispatcher(WEBLOGIC_DEFAULT_SERVLET_NAME) != null) {<z>
defaultServletName = WEBLOGIC_DEFAULT_SERVLET_NAME;<z>
null) {<z>
defaultServletName = WEBSPHERE_DEFAULT_SERVLET_NAME;<z>
IllegalStateException("Unable to locate the default servlet for serving static content. " +<z>
"Please set the 'defaultServletName' property explicitly.");<z>
Object o) {<z>
(!(o instanceof PlaceOfBirth)) {<z>
;<z>
;<z>
));<z>
throws EvaluationException {<z>
= typeName;<z>
classLoader);<z>
catch (ClassNotFoundException ey) {<z>
(String prefix : this.knownPackagePrefixes) {<z>
;<z>
classLoader);<z>
ex) {<z>
SpelEvaluationException(SpelMessage.TYPE_NOT_FOUND, typeName);<z>
mbd, BeanWrapper bw) {<z>
TreeSet<>();<z>
PropertyValues pvs = mbd.getPropertyValues();<z>
] pds = bw.getPropertyDescriptors();<z>
: pds) {<z>
.contains(pd.getName()) &&<z>
))) {<z>
getName());<z>
toStringArray(result);<z>
(Object key, DeferredResultProcessingInterceptor interceptor) {<z>
, "Key is required");<z>
"DeferredResultProcessingInterceptor is required");<z>
put(key, interceptor);<z>
> context) {<z>
cacheNames = getCacheNames(context);<z>
if (cacheNames == null) {<z>
.emptyList();<z>
size());<z>
String cacheName : cacheNames) {<z>
).getCache(cacheName);<z>
cache == null) {<z>
("Cannot find cache named '" +<z>
));<z>
cache);<z>
return result;<z>
rollbackForValue) {<z>
StringUtils.commaDelimitedListToStringArray(rollbackForValue);<z>
: exceptionTypeNames) {<z>
));<z>
(JsonSerializer<?>... serializers) {<z>
<?> serializer : serializers) {<z>
handledType = serializer.handledType();<z>
== Object.class) {<z>
().getName());<z>
, serializer);<z>
;<z>
) {<z>
) == null) {<z>
("Property 'notificationListener' is required");<z>
mappedObjectNames)) {<z>
new IllegalArgumentException("Property 'mappedObjectName' is required");<z>
);<z>
doSomething(HttpServletRequest request) throws ServletException, IllegalAccessException {<z>
findWebApplicationContext(request);<z>
) {<z>
throw new ServletException("Incorrect WebApplicationContext");<z>
) {<z>
throw new ServletException("Not in a MultipartHttpServletRequest");<z>
getParameter("fail") != null) {<z>
);<z>
request.getParameter("access") != null) {<z>
);<z>
request.getParameter("servlet") != null) {<z>
new ServletRequestBindingException("servlet");<z>
null) {<z>
);<z>
request) instanceof SessionLocaleResolver)) {<z>
new ServletException("Incorrect LocaleResolver");<z>
request))) {<z>
("Incorrect Locale");<z>
())) {<z>
;<z>
{<z>
;<z>
())) {<z>
("Incorrect TimeZone");<z>
getThemeResolver(request) instanceof SessionThemeResolver)) {<z>
);<z>
(request))) {<z>
;<z>
RequestContext(request);<z>
("GMT+1"));<z>
);<z>
RequestContextUtils.getLocale(request))) {<z>
throw new ServletException("Incorrect Locale");<z>
equals(LocaleContextHolder.getLocale())) {<z>
("Incorrect Locale");<z>
)) {<z>
new ServletException("Incorrect TimeZone");<z>
LocaleContextHolder.getTimeZone())) {<z>
);<z>
.resolveThemeName(request))) {<z>
);<z>
attributeNameIndex, final ByteVector output) {<z>
= 2;<z>
;<z>
annotationWriter = this;<z>
;<z>
annotationWriter != null) {<z>
();<z>
annotationWriter.annotation.length;<z>
numAnnotations++;<z>
firstAnnotation = annotationWriter;<z>
previousAnnotation;<z>
putShort(attributeNameIndex);<z>
putInt(attributeLength);<z>
.putShort(numAnnotations);<z>
= firstAnnotation;<z>
while (annotationWriter != null) {<z>
.annotation.length);<z>
nextAnnotation;<z>
{<z>
List<TransactionSynchronization> suspendedSynchronizations =<z>
TransactionSynchronizationManager.getSynchronizations();<z>
(TransactionSynchronization synchronization : suspendedSynchronizations) {<z>
synchronization.suspend();<z>
);<z>
;<z>
() throws Exception {<z>
) {<z>
).stop();<z>
ex) {<z>
scheduler != null) {<z>
);<z>
(Throwable ex) {<z>
public WebMvcStompEndpointRegistry(WebSocketHandler webSocketHandler,<z>
TaskScheduler defaultSockJsTaskScheduler) {<z>
, "WebSocketHandler is required ");<z>
"WebSocketTransportRegistration is required");<z>
this.webSocketHandler = webSocketHandler;<z>
.subProtocolWebSocketHandler = unwrapSubProtocolWebSocketHandler(webSocketHandler);<z>
(transportRegistration.getSendTimeLimit() != null) {<z>
;<z>
{<z>
;<z>
transportRegistration.getTimeToFirstMessage() != null) {<z>
());<z>
();<z>
(transportRegistration.getMessageSizeLimit() != null) {<z>
(transportRegistration.getMessageSizeLimit());<z>
this.sockJsScheduler = defaultSockJsTaskScheduler;<z>
public SingleCharWildcardedPathElement(<z>
) {<z>
, separator);<z>
len = literalText.length;<z>
questionMarkCount;<z>
caseSensitive;<z>
(caseSensitive) {<z>
= literalText;<z>
;<z>
; i++) {<z>
i]);<z>
> extractData(ResultSet rs) throws SQLException {<z>
());<z>
0;<z>
while (rs.next()) {<z>
(rs, rowNum++));<z>
results;<z>
bufferFactory) {<z>
UndertowServerHttpRequest.this.getLogPrefix());<z>
channel = exchange.getRequestChannel();<z>
= bufferFactory;<z>
getByteBufferPool();<z>
() {<z>
peekToken();<z>
TokenKind.LCURLY, true)) {<z>
;<z>
;<z>
expr = null;<z>
();<z>
.RCURLY, true)) {<z>
);<z>
);<z>
)) {<z>
;<z>
;<z>
eatExpression();<z>
) {<z>
ArrayList<>();<z>
firstExpression);<z>
;<z>
(new SpelNodeImpl[0]));<z>
{<z>
= new ArrayList<>();<z>
add(firstExpression);<z>
());<z>
TokenKind.COMMA, true));<z>
= eatToken(TokenKind.RCURLY);<z>
SpelNodeImpl[0]));<z>
TokenKind.COLON, true)) {<z>
<>();<z>
);<z>
);<z>
{<z>
.add(eatExpression());<z>
TokenKind.COLON);<z>
));<z>
TokenKind.RCURLY);<z>
));<z>
startPos, SpelMessage.OOD);<z>
;<z>
;<z>
<?> exType) {<z>
(exType == null) {<z>
false;<z>
{<z>
return true;<z>
Throwable cause = getCause();<z>
== this) {<z>
false;<z>
instanceof NestedCheckedException) {<z>
contains(exType);<z>
while (cause != null) {<z>
if (exType.isInstance(cause)) {<z>
true;<z>
{<z>
.getCause();<z>
false;<z>
) {<z>
(this.defaultRetriever) {<z>
getSingletonTarget(listener);<z>
singletonTarget instanceof ApplicationListener) {<z>
.defaultRetriever.applicationListeners.remove(singletonTarget);<z>
defaultRetriever.applicationListeners.add(listener);<z>
retrieverCache.clear();<z>
factory) {<z>
MultipartHttpOutputMessage(factory);<z>
message.getHeaders();<z>
;<z>
= null;<z>
) {<z>
) value;<z>
putAll(httpEntity.getHeaders());<z>
.getBody();<z>
body != null, "MultipartHttpMessageWriter only supports HttpEntity with body");<z>
if (httpEntity instanceof ResolvableTypeProvider) {<z>
(ResolvableTypeProvider) httpEntity).getResolvableType();<z>
body = value;<z>
== null) {<z>
());<z>
CONTENT_DISPOSITION)) {<z>
body instanceof Resource) {<z>
) body).getFilename());<z>
() == Resource.class) {<z>
o -> headers<z>
);<z>
(name, null);<z>
headers.getContentType();<z>
ResolvableType finalBodyType = resolvableType;<z>
> writer = this.partWriters.stream()<z>
canWrite(finalBodyType, contentType))<z>
();<z>
{<z>
(new CodecException("No suitable writer found for part: " + name));<z>
=<z>
) body : Mono.just(body);<z>
T>) writer.get())<z>
message, DEFAULT_HINTS);<z>
(message::getBody));<z>
return Flux.concat(<z>
),<z>
(factory));<z>
DataBuffer> content() {<z>
return DataBufferUtils.readByteChannel(<z>
READ),<z>
.sharedInstance, 1024)<z>
(this.scheduler);<z>
setStatus(int status, String errorMessage) {<z>
(!this.isCommitted()) {<z>
status = status;<z>
= errorMessage;<z>
<String, String> toSingleValueMap() {<z>
;<z>
headers.forEach(values -><z>
), values.getFirst()));<z>
;<z>
{<z>
.registrations.stream()<z>
.map(ServletWebSocketHandlerRegistration::getSockJsServiceRegistration)<z>
(Objects::nonNull)<z>
.getTaskScheduler() == null)<z>
;<z>
(final String descriptor, final boolean visible) {<z>
!= null) {<z>
visitAnnotation(descriptor, visible);<z>
return null;<z>
private void updateLastWriteTime() {<z>
lastWriteTime = this.lastWriteTime;<z>
(lastWriteTime != -1) {<z>
);<z>
Nullable String[] array, String str) {<z>
(ObjectUtils.isEmpty(array)) {<z>
[] {str};<z>
;<z>
, array.length);<z>
length] = str;<z>
newArr;<z>
domainName, Hashtable<String, String> properties)<z>
throws MalformedObjectNameException {<z>
, properties);<z>
private void updateUserDestinationResolver(<z>
AbstractBrokerMessageHandler handler, UserDestinationResolver userDestinationResolver,<z>
Nullable String userDestinationPrefix) {<z>
();<z>
next().startsWith("/")) {<z>
(true);<z>
{<z>
));<z>
() {<z>
str = new StringBuilder();<z>
append(this.name);<z>
('=').append(value));<z>
.toString();<z>
String[] getMemberClassNames() {<z>
<>(4);<z>
this.introspectedClass.getDeclaredClasses()) {<z>
));<z>
(memberClassNames);<z>
viewResolvers,<z>
registry) {<z>
);<z>
(viewResolvers);<z>
.sort(this.viewResolvers);<z>
array) {<z>
null) {<z>
return NULL_STRING;<z>
.length;<z>
0) {<z>
;<z>
;<z>
{<z>
valueOf(s));<z>
toString();<z>
(final int lineNumber) {<z>
(this.lineNumber == 0) {<z>
lineNumber;<z>
{<z>
) {<z>
= new int[LINE_NUMBERS_CAPACITY_INCREMENT];<z>
;<z>
otherLineNumbers.length) {<z>
LINE_NUMBERS_CAPACITY_INCREMENT];<z>
0, otherLineNumbers.length);<z>
;<z>
[otherLineNumberIndex] = lineNumber;<z>
) {<z>
);<z>
(mv, cf.lastDescriptor());<z>
, "No type available");<z>
)) {<z>
(POP);<z>
(ICONST_0);<z>
));<z>
.exitTypeDescriptor);<z>
(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,<z>
Nullable WebDataBinderFactory binderFactory) throws Exception {<z>
if (mavContainer != null) {<z>
(true);<z>
;<z>
isAssignableFrom(paramType)) {<z>
resolveNativeResponse(webRequest, paramType);<z>
ServletResponse.class));<z>
provider) {<z>
() -> {<z>
get();<z>
);<z>
) {<z>
.registerConverters(registry);<z>
(Type.DATE);<z>
TIME);<z>
Type.DATE_TIME);<z>
.addFormatterForFieldType(LocalDate.class,<z>
new TemporalAccessorPrinter(<z>
,<z>
LocalDate.class, df));<z>
class,<z>
new TemporalAccessorPrinter(<z>
.ISO_LOCAL_TIME : tf),<z>
tf));<z>
LocalDateTime.class,<z>
(<z>
ISO_LOCAL_DATE_TIME : dtf),<z>
dtf));<z>
.class,<z>
(dtf),<z>
;<z>
OffsetDateTime.class,<z>
TemporalAccessorPrinter(dtf),<z>
OffsetDateTime.class, dtf));<z>
.addFormatterForFieldType(OffsetTime.class,<z>
new TemporalAccessorPrinter(tf),<z>
);<z>
InstantFormatter());<z>
class, new PeriodFormatter());<z>
));<z>
YearFormatter());<z>
MonthFormatter());<z>
, new YearMonthFormatter());<z>
));<z>
addFormatterForFieldAnnotation(new Jsr310DateTimeFormatAnnotationFormatterFactory());<z>
boolean isJarURL(URL url) {<z>
= url.getProtocol();<z>
|| URL_PROTOCOL_WAR.equals(protocol) ||<z>
protocol) ||<z>
URL_PROTOCOL_WSJAR.equals(protocol));<z>
(SubscribableChannel clientInChannel,<z>
clientOutChannel, SimpMessageSendingOperations brokerTemplate) {<z>
, brokerTemplate);<z>
void addTask(Runnable task, boolean successTask) {<z>
Assert.notNull(this.receiptId,<z>
"To track receipts, set autoReceiptEnabled=true or add 'receiptId' header");<z>
) {<z>
result == successTask) {<z>
(Collections.singletonList(task));<z>
) {<z>
task);<z>
this.receiptLostCallbacks.add(task);<z>
cause) {<z>
null, cause);<z>
notNull(status, "HttpStatus is required");<z>
;<z>
reason = reason;<z>
?> adviceClass) {<z>
;<z>
) {<z>
: this.advisors) {<z>
advisor.getAdvice())) {<z>
++;<z>
;<z>
DataBuffer> input, ResolvableType elementType,<z>
hints) {<z>
join(input, this.maxInMemorySize)<z>
, hints));<z>
void setBeanFactory(BeanFactory beanFactory) {<z>
null) {<z>
.setBeanFactory(beanFactory);<z>
final String descriptor, final String value) {<z>
;<z>
(useNamedValues) {<z>
);<z>
addConstantUtf8(descriptor))<z>
(symbolTable.addConstantUtf8(value));<z>
connectionEquals(ConnectionHolder conHolder, Connection passedInCon) {<z>
(!conHolder.hasConnection()) {<z>
false;<z>
conHolder.getConnection();<z>
passedInCon) ||<z>
heldCon).equals(passedInCon));<z>
(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,<z>
WebDataBinderFactory binderFactory) throws Exception {<z>
state(mavContainer != null, "ModelAndViewContainer is required for model exposure");<z>
getModel();<z>
toString() {<z>
new StringBuilder();<z>
);<z>
());<z>
.append(getResourceDescription());<z>
null) {<z>
;<z>
toString();<z>
{<z>
StringBuilder(160);<z>
).append(<z>
"' is not writable or has an invalid setter method. ");<z>
) {<z>
);<z>
append("Does the parameter type of the setter match the return type of the getter?");<z>
toString();<z>
<? extends PropertyEditor> propertyEditorClass) {<z>
(requiredType, "Required type must not be null");<z>
Assert.notNull(propertyEditorClass, "PropertyEditor class must not be null");<z>
);<z>
maxLength,<z>
) {<z>
"Prefix must not be null");<z>
Assert.notNull(namePrefix, "Index prefix must not be null");<z>
hintFilterFunction, "Hint filter function must not be null");<z>
, maxLength, hintFilterFunction);<z>
data, Blackhole bh) {<z>
requestPaths) {<z>
{<z>
pattern, path));<z>
{<z>
this.contentType)) {<z>
= this.contentType;<z>
{<z>
characterEncoding;<z>
);<z>
(<z>
String, ?> attributes) {<z>
attributes);<z>
elementTypeDescriptor) {<z>
, "Collection type must not be null");<z>
class.isAssignableFrom(collectionType)) {<z>
;<z>
: null);<z>
;<z>
, Callable<T> task) {<z>
class);<z>
{<z>
.getNativeResponse(HttpServletResponse.class);<z>
initContextHolders(request, buildLocaleContext(request),<z>
, null));<z>
MBeanServerNotFoundException {<z>
this.agentId != null) {<z>
locateMBeanServer(this.agentId);<z>
) {<z>
(this.agentId != null) {<z>
throw ex;<z>
debug("No existing MBeanServer found - creating new one");<z>
.server == null) {<z>
(this.defaultDomain, this.registerWithFactory);<z>
= this.registerWithFactory;<z>
Map<?, ?> other) {<z>
!= null) {<z>
-> addPropertyValue(<z>
)));<z>
return this;<z>
<?> genericIfc) {<z>
.notNull(method, "Method must not be null");<z>
;<z>
) instanceof WildcardType) {<z>
return null;<z>
return getSingleGeneric(resolvableType);<z>
(String name) {<z>
(name)) {<z>
().getFirst(name) + "]";<z>
(message));<z>
return this.responseSpec;<z>
{<z>
) {<z>
isClosed()) {<z>
sendHeartbeat();<z>
(Throwable ex) {<z>
true;<z>
(Method operation) throws SQLException {<z>
null) {<z>
(logger.isTraceEnabled()) {<z>
.getName() + "'");<z>
?<z>
password) :<z>
().getConnection();<z>
this.target);<z>
{<z>
.target.setReadOnly(true);<z>
{<z>
.debug("Could not set JDBC Connection read-only", ex);<z>
if (this.transactionIsolation != null &&<z>
)) {<z>
transactionIsolation);<z>
!= this.target.getAutoCommit()) {<z>
this.autoCommit);<z>
()) {<z>
getName() + "'");<z>
return this.target;<z>
patterns,<z>
, @Nullable ParamsRequestCondition params,<z>
Nullable HeadersRequestCondition headers, @Nullable ConsumesRequestCondition consumes,<z>
custom) {<z>
(name, null,<z>
),<z>
),<z>
(params != null ? params : EMPTY_PARAMS),<z>
headers != null ? headers : EMPTY_HEADERS),<z>
,<z>
: EMPTY_PRODUCES),<z>
EMPTY_CUSTOM),<z>
());<z>
(FlashMap other) {<z>
1 : 0);<z>
);<z>
(thisUrlPath != otherUrlPath) {<z>
thisUrlPath;<z>
size();<z>
param) {<z>
.isNoValue()) {<z>
(<z>
param.getGenericParameterType());<z>
>> route(ServerRequest request) {<z>
second.route(request)))<z>
)<z>
map(this::cast);<z>
() {<z>
]> multipartParameters = getMultipartParameters();<z>
()) {<z>
return super.getParameterNames();<z>
);<z>
super.getParameterNames()));<z>
(multipartParameters.keySet());<z>
;<z>
Nullable Object other) {<z>
this == other) {<z>
true;<z>
.getClass()) {<z>
false;<z>
>) other).getContent());<z>
NoSuchMethodException {<z>
);<z>
);<z>
);<z>
length; i++) {<z>
, array[i]));<z>
resultArray;<z>
(MethodArgumentNotValidException ex,<z>
, @Nullable Object handler) throws IOException {<z>
);<z>
);<z>
toString() {<z>
)<z>
())<z>
)<z>
, getParentContextCount())<z>
("hitCount", getHitCount())<z>
("missCount", getMissCount())<z>
.toString();<z>
(String expression, TimeZone timeZone) {<z>
this.expression = expression;<z>
.timeZone = timeZone;<z>
;<z>
assertPresentAndGetIndex(String name) {<z>
));<z>
if (index == -1) {<z>
IllegalArgumentException("PropertySource named '" + name + "' does not exist");<z>
;<z>
getPropertyValue(Object obj) {<z>
BeanWrapperImpl(false);<z>
);<z>
);<z>
catch (BeansException ex) {<z>
);<z>
return null;<z>
{<z>
Throwable cause = getCause();<z>
{<z>
.getErrorCode();<z>
return null;<z>
public String toUriString() {<z>
StringBuilder uriBuilder = new StringBuilder();<z>
{<z>
).append(':');<z>
|| this.host != null) {<z>
("//");<z>
null) {<z>
.userInfo).append('@');<z>
this.host != null) {<z>
uriBuilder.append(this.host);<z>
if (getPort() != -1) {<z>
).append(this.port);<z>
;<z>
.hasLength(path)) {<z>
!= PATH_DELIMITER) {<z>
(PATH_DELIMITER);<z>
.append(path);<z>
();<z>
{<z>
.append(query);<z>
getFragment() != null) {<z>
append(getFragment());<z>
();<z>
QueueConnection doCreateQueueConnection(<z>
username, @Nullable String password) throws JMSException {<z>
);<z>
QueueConnectionFactory queueFactory)) {<z>
);<z>
StringUtils.hasLength(username)) {<z>
.createQueueConnection(username, password);<z>
);<z>
value) {<z>
(value instanceof String &&<z>
getHeaderNames().stream()<z>
map(this.headers::get)<z>
values.contains(value)));<z>
{<z>
this.partialMatches) {<z>
) {<z>
return false;<z>
return true;<z>
element, @Nullable String requestingBeanName)<z>
throws NoSuchBeanDefinitionException {<z>
Object resource;<z>
Set<String> autowiredBeanNames;<z>
;<z>
factory instanceof AutowireCapableBeanFactory autowireCapableBeanFactory) {<z>
getDependencyDescriptor();<z>
.containsBean(name)) {<z>
();<z>
descriptor, requestingBeanName, autowiredBeanNames, null);<z>
(resource == null) {<z>
);<z>
resolveBeanByName(name, descriptor);<z>
;<z>
lookupType);<z>
(name);<z>
instanceof ConfigurableBeanFactory configurableBeanFactory) {<z>
{<z>
configurableBeanFactory.containsBean(autowiredBeanName)) {<z>
);<z>
;<z>
generateBeanName(<z>
)<z>
BeanDefinitionStoreException {<z>
;<z>
generatedBeanName == null) {<z>
null) {<z>
.getParentName() + "$child";<z>
(definition.getFactoryBeanName() != null) {<z>
"$created";<z>
(generatedBeanName)) {<z>
("Unnamed bean definition specifies neither " +<z>
;<z>
(isInnerBean) {<z>
definition);<z>
, registry);<z>
) {<z>
repeatableContainers = repeatableContainers;<z>
= filter;<z>
= new ConcurrentReferenceHashMap<>();<z>
> getProducibleMediaTypes(<z>
targetType) {<z>
mediaTypes =<z>
PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);<z>
isEmpty(mediaTypes)) {<z>
<>(mediaTypes);<z>
> result = new ArrayList<>();<z>
: this.messageConverters) {<z>
{<z>
valueClass, null)) {<z>
.getSupportedMediaTypes(valueClass));<z>
canWrite(valueClass, null)) {<z>
));<z>
ALL) : result);<z>
) {<z>
);<z>
{<z>
.messageConverters.clear();<z>
(messageConverters);<z>
buffer, int offset, int length) {<z>
{<z>
[offset + i]);<z>
() {<z>
get(this.id);<z>
{<z>
result = ref.get();<z>
) {<z>
;<z>
= new DefaultListableBeanFactory();<z>
.id;<z>
return dummyFactory;<z>
public ObjectError getGlobalError() {<z>
) {<z>
)) {<z>
objectError;<z>
return null;<z>
Object messageListener) {<z>
&& !(messageListener instanceof MessageListener ||<z>
messageListener instanceof SessionAwareMessageListener)) {<z>
(<z>
+ MessageListener.class.getName() +<z>
.class.getName() + "]");<z>
isResourceUnderLocation(Resource resource) throws IOException {<z>
!= this.location.getClass()) {<z>
false;<z>
resourcePath;<z>
String locationPath;<z>
(resource instanceof UrlResource) {<z>
;<z>
().toString());<z>
instanceof ClassPathResource) {<z>
getPath();<z>
getPath());<z>
().getPath();<z>
));<z>
(resourcePath)) {<z>
return true;<z>
locationPath + "/");<z>
(locationPath)) {<z>
false;<z>
.UTF_8).contains("../")) {<z>
return false;<z>
return true;<z>
(DefaultTransactionStatus status, int completionStatus) {<z>
(status.isNewSynchronization()) {<z>
TransactionSynchronizationManager.getSynchronizations();<z>
();<z>
() || status.isNewTransaction()) {<z>
invokeAfterCompletion(synchronizations, completionStatus);<z>
{<z>
.getTransaction(), synchronizations);<z>
Object value) {<z>
);<z>
get(key);<z>
) {<z>
new AssertionError("Excepted value to be put in cache with key " + key);<z>
;<z>
!= actual) {<z>
". " +<z>
"Expected=" + value + ", but got=" + actual);<z>
) {<z>
)<z>
.filter(binderMethod -> {<z>
(InitBinder.class);<z>
(ann != null, "No InitBinder annotation");<z>
] names = ann.value();<z>
(names) ||<z>
names, dataBinder.getObjectName()));<z>
dataBinder, exchange, method));<z>
;<z>
List<String> locationValues) {<z>
notNull(locationValues, "Location values list must not be null");<z>
);<z>
.locationValues.addAll(locationValues);<z>
hashCode) {<z>
final byte[] bootstrapMethodsData = bootstrapMethods.data;<z>
);<z>
(entry != null) {<z>
.hashCode == hashCode) {<z>
int) entry.data;<z>
;<z>
; ++i) {<z>
+ i]) {<z>
= false;<z>
if (isSameBootstrapMethod) {<z>
.length = offset;<z>
;<z>
= entry.next;<z>
));<z>
IOException {<z>
;<z>
if (ResourceUtils.isJarURL(url)) {<z>
(url);<z>
startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {<z>
getFile();<z>
, "Jar URL");<z>
();<z>
{<z>
condition : this.messageConditions) {<z>
)) {<z>
T) condition;<z>
IllegalStateException("No condition of type: " + messageConditionType);<z>
executor, Callable<V> callable) {<z>
(callable);<z>
(executor, "Executor must not be null");<z>
this.executor = executor;<z>
.timeout = timeout;<z>
Style style() default Style.DEFAULT;<z>
;<z>
Style {<z>
,<z>
qualifiers, @Nullable Supplier<T> supplier,<z>
{<z>
new AnnotatedGenericBeanDefinition(beanClass);<z>
shouldSkip(abd.getMetadata())) {<z>
(supplier);<z>
abd);<z>
));<z>
;<z>
.processCommonDefinitionAnnotations(abd);<z>
(qualifiers != null) {<z>
Annotation> qualifier : qualifiers) {<z>
) {<z>
.setPrimary(true);<z>
== qualifier) {<z>
setLazyInit(true);<z>
(qualifier));<z>
) {<z>
BeanDefinitionCustomizer customizer : customizers) {<z>
);<z>
new BeanDefinitionHolder(abd, beanName);<z>
;<z>
, this.registry);<z>
beanName, String msg) {<z>
super("Error creating bean with name '" + beanName + "'" +<z>
;<z>
this.resourceDescription = resourceDescription;<z>
beanName = beanName;<z>
null;<z>
int actualSize, Throwable ex) {<z>
super(msg, ex);<z>
= expectedSize;<z>
actualSize = actualSize;<z>
) {<z>
(getCacheResolver() == null) {<z>
!= null, "CacheResolver or BeanFactory must be set on cache aspect");<z>
class));<z>
(NoUniqueBeanDefinitionException ex) {<z>
throw new IllegalStateException("No CacheResolver specified, and no unique bean of type " +<z>
, ex);<z>
(NoSuchBeanDefinitionException ex) {<z>
throw new IllegalStateException("No CacheResolver specified, and no bean of type CacheManager found. " +<z>
);<z>
true;<z>
) {<z>
if (value instanceof boolean[]) {<z>
((boolean[]) value);<z>
[]) {<z>
byte[]) value);<z>
instanceof char[]) {<z>
char[]) value);<z>
[]) {<z>
[]) value);<z>
if (value instanceof float[]) {<z>
;<z>
int[]) {<z>
);<z>
if (value instanceof long[]) {<z>
;<z>
[]) {<z>
value);<z>
[]) {<z>
hashCode((Object[]) value);<z>
return value.hashCode();<z>
{<z>
Assert.notNull(fc, "FacesContext must not be null");<z>
(<z>
WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);<z>
{<z>
null;<z>
if (attr instanceof RuntimeException) {<z>
(RuntimeException) attr;<z>
{<z>
attr;<z>
) {<z>
);<z>
attr;<z>
public PropertyValue(PropertyValue original) {<z>
;<z>
= original.getName();<z>
);<z>
original.isOptional();<z>
this.converted = original.converted;<z>
convertedValue = original.convertedValue;<z>
;<z>
this.resolvedTokens = original.resolvedTokens;<z>
.getSource());<z>
;<z>
) {<z>
null) {<z>
fixedRateTasks = new ArrayList<>();<z>
);<z>
boolean checkInherited) {<z>
Assert.notNull(annotationType, "Annotation type must not be null");<z>
this.annotationType = annotationType;<z>
.checkInherited = checkInherited;<z>
) {<z>
.notEmpty(parts, "'parts' must not be empty");<z>
for (Part part : parts) {<z>
.getName(), part);<z>
this;<z>
key, @Nullable final Object value) {<z>
)) {<z>
) {<z>
public void afterCommit() {<z>
put(key, value);<z>
;<z>
;<z>
<?> propertySource) {<z>
(this.propertySourceList) {<z>
(name);<z>
.propertySourceList.set(index, propertySource);<z>
visitor) {<z>
.ACCEPT,<z>
) == 1) ?<z>
).toString() :<z>
this.mediaTypes.toString());<z>
private Builder(<z>
GeneratedMessage.BuilderParent parent) {<z>
);<z>
();<z>
{<z>
StaxWriter writer;<z>
StaxDriver staxDriver) {<z>
staxDriver.createStaxWriter(streamWriter);<z>
, this.nameCoder);<z>
doMarshal(graph, writer, null);<z>
(XMLStreamException ex) {<z>
(ex, true);<z>
() throws Throwable {<z>
; i++) {<z>
> 1 && logger.isInfoEnabled()) {<z>
i + 1),<z>
.testMethod.getName()));<z>
.next.evaluate();<z>
void afterSingletonsInstantiated() {<z>
.nonAnnotatedClasses.clear();<z>
{<z>
JmsListenerConfigurer> beans =<z>
getBeansOfType(JmsListenerConfigurer.class);<z>
);<z>
(configurers);<z>
configurers) {<z>
);<z>
null) {<z>
);<z>
null) {<z>
this.endpointRegistry == null) {<z>
(this.beanFactory != null, "BeanFactory must be set to find endpoint registry by bean name");<z>
beanFactory.getBean(<z>
);<z>
;<z>
);<z>
) {<z>
setMessageHandlerMethodFactory(handlerMethodFactory);<z>
.registrar.afterPropertiesSet();<z>
path) {<z>
.elements();<z>
.size();<z>
int startIndex = 0;<z>
.head;<z>
) {<z>
elem.getCaptureCount() != 0) {<z>
elem = elem.next;<z>
;<z>
== null) {<z>
.parsePath("");<z>
Separator)) {<z>
++;<z>
int endIndex = pathElements.size();<z>
)) {<z>
endIndex--;<z>
false;<z>
) {<z>
i+1) instanceof Separator)) {<z>
;<z>
= null;<z>
(multipleAdjacentSeparators) {<z>
= new StringBuilder();<z>
= startIndex;<z>
i < endIndex) {<z>
e = pathElements.get(i++);<z>
);<z>
{<z>
)) {<z>
++;<z>
.toString(), this.pathOptions);<z>
if (startIndex >= endIndex) {<z>
resultPath = PathContainer.parsePath("");<z>
path.subPath(startIndex, endIndex);<z>
return resultPath;<z>
inputStream, DataBufferFactory bufferFactory,<z>
) {<z>
inputStream, "'inputStream' must not be null");<z>
Assert.notNull(bufferFactory, "'bufferFactory' must not be null");<z>
.notNull(elementType, "'elementType' must not be null");<z>
inputStream instanceof Mono) {<z>
Mono.from(inputStream)<z>
)<z>
;<z>
(mimeType);<z>
!= null) {<z>
;<z>
null) {<z>
throw new IllegalStateException("No ObjectMapper for " + elementType);<z>
null, hints);<z>
)._getBufferRecycler());<z>
encoding = getJsonEncoding(mimeType);<z>
encoding);<z>
generator);<z>
inputStream)<z>
,<z>
separator))<z>
doAfterTerminate(() -> {<z>
();<z>
;<z>
IOException ex) {<z>
error("Could not close Encoder resources", ex);<z>
});<z>
catch (IOException ex) {<z>
.error(ex);<z>
(List.class, elementType);<z>
inputStream)<z>
.collectList()<z>
listType, mimeType, hints))<z>
;<z>
IsPresent(RepeatableContainers repeatableContainers,<z>
annotationFilter, boolean directOnly) {<z>
.repeatableContainers = repeatableContainers;<z>
annotationFilter;<z>
directOnly;<z>
Map<String, Object> argumentBindings) {<z>
getScriptEngine(script);<z>
{<z>
.eval(script.getScriptAsString());<z>
);<z>
(script.getScriptAsString(), bindings);<z>
ex) {<z>
ScriptCompilationException(script, "Cannot access script for ScriptEngine", ex);<z>
(ScriptException ex) {<z>
, new StandardScriptEvalException(ex));<z>
Consumer<List<String>> consumer) {<z>
(name);<z>
(values));<z>
return this.responseSpec;<z>
Class<?> beanClass, String beanName) {<z>
();<z>
);<z>
(eligibleAdvisors);<z>
if (!eligibleAdvisors.isEmpty()) {<z>
eligibleAdvisors);<z>
eligibleAdvisors;<z>
default void metadataToExtract(<z>
targetType, @Nullable String name) {<z>
name : mimeType.toString();<z>
.put(key, value));<z>
fieldError) {<z>
equals(fieldError.getField())) {<z>
true;<z>
endIndex = field.length() - 1;<z>
== '*' &&<z>
, endIndex)));<z>
{<z>
beanClass, getProxyClassLoader());<z>
= false;<z>
ifc : targetInterfaces) {<z>
) && !isInternalLanguageInterface(ifc) &&<z>
.length > 0) {<z>
hasReasonableProxyInterface = true;<z>
if (hasReasonableProxyInterface) {<z>
Class<?> ifc : targetInterfaces) {<z>
.addInterface(ifc);<z>
proxyFactory.setProxyTargetClass(true);<z>
throws IOException {<z>
= determineRootDir(locationPattern);<z>
;<z>
);<z>
);<z>
{<z>
;<z>
();<z>
().startsWith("bundle")) {<z>
equinoxResolveMethod, null, rootDirUrl);<z>
null) {<z>
resolvedUrl;<z>
new UrlResource(rootDirUrl);<z>
startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {<z>
;<z>
(rootDirUrl) || isJarResource(rootDirResource)) {<z>
doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern));<z>
(doFindPathMatchingFileResources(rootDirResource, subPattern));<z>
{<z>
+ "] to resources " + result);<z>
[0]);<z>
filePath) {<z>
new ClassPathResource("test/", EncodedResourceResolverTests.class);<z>
(filePath).getFile());<z>
.getAbsolutePath() + ".gz");<z>
;<z>
;<z>
FileOutputStream(gzFile));<z>
(), out);<z>
(gzFile);<z>
) {<z>
;<z>
requestUrl,<z>
String sessionId,<z>
, @Nullable Throwable failureCause) {<z>
failureCause);<z>
requestUrl;<z>
;<z>
= method;<z>
;<z>
1;<z>
{<z>
event.isProcessingInstruction()) {<z>
event).getData();<z>
IllegalStateException();<z>
HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {<z>
= this.argumentResolverCache.get(parameter);<z>
(result == null) {<z>
this.argumentResolvers) {<z>
supportsParameter(parameter)) {<z>
methodArgumentResolver;<z>
);<z>
;<z>
String toString() {<z>
StringBuilder sb = new StringBuilder("ReflectiveMethodInvocation: ");<z>
append("; ");<z>
== null) {<z>
;<z>
getName()).append(']');<z>
return sb.toString();<z>
] getParameterValues(String name) {<z>
(name);<z>
().get(name);<z>
) {<z>
parameterValues;<z>
|| getQueryString() == null) {<z>
mpValues;<z>
+ parameterValues.length];<z>
.length);<z>
parameterValues.length);<z>
result;<z>
) {<z>
.getTransactionPhase() == TransactionPhase.BEFORE_COMMIT) {<z>
();<z>
,<z>
Nullable Object source, String descriptor, boolean visible,<z>
consumer) {<z>
(!visible) {<z>
null;<z>
(descriptor).getClassName();<z>
.PLAIN.matches(typeName)) {<z>
return null;<z>
(typeName, classLoader);<z>
consumer);<z>
{<z>
return null;<z>
classLoader)<z>
{<z>
);<z>
> clazz = resolvePrimitiveClassName(name);<z>
(clazz == null) {<z>
(name);<z>
if (clazz != null) {<z>
clazz;<z>
if (name.endsWith(ARRAY_SUFFIX)) {<z>
;<z>
);<z>
();<z>
) && name.endsWith(";")) {<z>
.length() - 1);<z>
classLoader);<z>
getClass();<z>
.startsWith(INTERNAL_ARRAY_PREFIX)) {<z>
.substring(INTERNAL_ARRAY_PREFIX.length());<z>
, classLoader);<z>
);<z>
clToUse = classLoader;<z>
== null) {<z>
getDefaultClassLoader();<z>
(name, false, clToUse);<z>
ClassNotFoundException ex) {<z>
.lastIndexOf(PACKAGE_SEPARATOR);<z>
) {<z>
=<z>
substring(lastDotIndex + 1);<z>
);<z>
) {<z>
;<z>
Object bean, String beanName) {<z>
bean instanceof TaskScheduler ||<z>
) {<z>
bean;<z>
);<z>
(targetClass) &&<z>
class, Schedules.class))) {<z>
= MethodIntrospector.selectMethods(targetClass,<z>
>>) method -> {<z>
Set<Scheduled> scheduledAnnotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(<z>
, Schedules.class);<z>
: null);<z>
;<z>
.isEmpty()) {<z>
targetClass);<z>
) {<z>
"No @Scheduled annotations found on bean class: " + targetClass);<z>
) -><z>
)));<z>
if (logger.isTraceEnabled()) {<z>
+ " @Scheduled methods processed on bean '" + beanName +<z>
+ annotatedMethods);<z>
return bean;<z>
, Object> buildJpaPropertyMap(boolean connectionReleaseOnClose) {<z>
= new HashMap<>();<z>
(getDatabasePlatform() != null) {<z>
));<z>
> databaseDialectClass = determineDatabaseDialectClass(getDatabase());<z>
null) {<z>
.DIALECT, databaseDialectClass.getName());<z>
{<z>
);<z>
{<z>
);<z>
if (connectionReleaseOnClose) {<z>
AvailableSettings.CONNECTION_HANDLING,<z>
;<z>
return jpaProperties;<z>
task) {<z>
(task, "Runnable must not be null");<z>
task)) {<z>
"Quartz SimpleThreadPool already shut down");<z>
{<z>
map);<z>
) {<z>
new InvalidResultSetAccessException(se);<z>
() {<z>
String toString() {<z>
(<z>
);<z>
provider) {<z>
null;<z>
) {<z>
parser);<z>
!= null) {<z>
) {<z>
;<z>
() + annOps.size());<z>
;<z>
(annOps);<z>
;<z>
ops;<z>
() {<z>
= 0;<z>
.aggregateCursor;<z>
(); aggregateIndex++) {<z>
= this.aggregates.get(aggregateIndex);<z>
aggregate.size(); annotationIndex++) {<z>
;<z>
();<z>
.mappingCursors != null) {<z>
mappings.size());<z>
;<z>
size;<z>
) {<z>
;<z>
isTraceEnabled()) {<z>
""));<z>
void addStatusController(String urlPath, HttpStatus statusCode) {<z>
ViewControllerRegistration registration = new ViewControllerRegistration(urlPath);<z>
.setApplicationContext(this.applicationContext);<z>
(statusCode);<z>
.setStatusOnly(true);<z>
this.registrations.add(registration);<z>
Member member, Class<?> sourceClass) {<z>
(member instanceof Method method) {<z>
method.getModifiers()) ?<z>
), sourceClass) :<z>
[0] == sourceClass);<z>
(member instanceof Constructor) {<z>
<?>) member;<z>
0] == sourceClass);<z>
false;<z>
() {<z>
) {<z>
;<z>
>(values)));<z>
readOnlyHttpHeaders(copy);<z>
null;<z>
sourceObject) throws Exception {<z>
(sourceObject instanceof Source source) {<z>
;<z>
if (sourceObject instanceof Document document) {<z>
());<z>
if (sourceObject instanceof Node node) {<z>
DOMSource(node);<z>
Reader reader) {<z>
StreamSource(reader);<z>
instanceof InputStream inputStream) {<z>
return new StreamSource(inputStream);<z>
if (sourceObject instanceof Resource resource) {<z>
());<z>
("Value '" + sourceObject + "' cannot be converted to XSLT Source");<z>
@Nullable ApplicationContext parent)<z>
BeansException {<z>
;<z>
setBlah(<z>
.SecondMsg.Builder builderForValue) {<z>
if (blahBuilder_ == null) {<z>
blah_ = builderForValue.build();<z>
;<z>
else {<z>
builderForValue.build());<z>
0x00000002;<z>
this;<z>
{<z>
{<z>
candidate instanceof AbstractHttpMessageConverter<?> converter) {<z>
(converter.getDefaultCharset() != null) {<z>
(this.charset);<z>
, CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate) {<z>
(testClass, "Test class must not be null");<z>
cacheAwareContextLoaderDelegate, "CacheAwareContextLoaderDelegate must not be null");<z>
testClass;<z>
;<z>
protected boolean handleInternal(ServerWebExchange exchange,<z>
boolean preFlightRequest) {<z>
();<z>
();<z>
= response.getHeaders();<z>
().getOrigin();<z>
, requestOrigin);<z>
if (allowOrigin == null) {<z>
;<z>
);<z>
;<z>
;<z>
;<z>
) {<z>
);<z>
rejectRequest(response);<z>
false;<z>
;<z>
checkHeaders(config, requestHeaders);<z>
{<z>
requestHeaders + "' are not allowed");<z>
;<z>
return false;<z>
.setAccessControlAllowOrigin(allowOrigin);<z>
) {<z>
allowMethods);<z>
)) {<z>
setAccessControlAllowHeaders(allowHeaders);<z>
))) {<z>
());<z>
{<z>
true);<z>
null) {<z>
getMaxAge());<z>
;<z>
(ApplicationContext applicationContext) throws BeansException {<z>
owningFactory == null)<z>
new RuntimeException("Factory called setApplicationContext before setBeanFactory");<z>
owningContext = applicationContext;<z>
DestinationResolver getDestinationResolver() {<z>
{<z>
getDestinationResolver();<z>
return null;<z>
AbstractBeanFactoryBasedTargetSource createBeanFactoryBasedTargetSource(<z>
) {<z>
) {<z>
=<z>
).getBeanDefinition(beanName);<z>
(definition.isLazyInit()) {<z>
);<z>
return null;<z>
, ParserContext parserContext) {<z>
=<z>
registerScriptFactoryPostProcessorIfNecessary(parserContext.getRegistry());<z>
getAttribute(REFRESH_CHECK_DELAY_ATTRIBUTE);<z>
hasText(refreshCheckDelay)) {<z>
refreshCheckDelay));<z>
);<z>
hasText(proxyTargetClass)) {<z>
;<z>
;<z>
, @Nullable Object[] args) {<z>
null) {<z>
false;<z>
();<z>
)) {<z>
(this.evaluator, "EventExpressionEvaluator must not be null");<z>
evaluator.condition(<z>
methodKey, args, this.applicationContext);<z>
return true;<z>
) {<z>
switch (state) {<z>
STATE_COMMITTED:<z>
return "committed";<z>
STATE_ROLLED_BACK:<z>
"rolled back";<z>
case STATE_MIXED:<z>
;<z>
"unknown";<z>
toStringAST() {<z>
;<z>
; i++) {<z>
());<z>
sj.toString();<z>
session) {<z>
session != null) {<z>
session.close();<z>
JMSException ex) {<z>
trace("Could not close JMS Session", ex);<z>
catch (Throwable ex) {<z>
.trace("Unexpected exception on closing JMS Session", ex);<z>
void cleanupTransaction(@Nullable Object transactionData) {<z>
SessionTransactionData) {<z>
);<z>
type,<z>
{<z>
type.resolve() : null);<z>
(resolved);<z>
>();<z>
()) {<z>
);<z>
;<z>
beanInstance instanceof FactoryBean && !isFactoryType) {<z>
(FactoryBean<?>) beanInstance;<z>
getObjectType();<z>
)) &&<z>
isAssignableFrom(objectType))) {<z>
matches.add(beanName);<z>
(beanInstance)) {<z>
.add(beanName);<z>
.toStringArray(matches);<z>
String name) {<z>
(name);<z>
getName() + " is deprecated and equivalent to NoOpLog in spring-jcl. " +<z>
;<z>
<?> results)<z>
{<z>
class).intValue();<z>
>> includes,<z>
> excludes, boolean matchIfEmpty) {<z>
matchIfEmpty);<z>
{<z>
delimiter()[getMatches()]) {<z>
) - 1]);<z>
);<z>
) {<z>
name).getSameSite();<z>
(() -> {<z>
" sameSite";<z>
expected, sameSite);<z>
;<z>
;<z>
Object[] args) throws Throwable {<z>
.getName()) {<z>
:<z>
0]);<z>
"hashCode":<z>
hashCode();<z>
"getTargetEntityManager":<z>
return this.target;<z>
case "unwrap":<z>
?>) args[0];<z>
(targetClass == null) {<z>
;<z>
isInstance(proxy)) {<z>
return proxy;<z>
"isOpen":<z>
) {<z>
true;<z>
case "close":<z>
{<z>
;<z>
= (ExtendedEntityManagerSynchronization)<z>
TransactionSynchronizationManager.getResource(this.target);<z>
null) {<z>
true;<z>
;<z>
:<z>
) {<z>
new IllegalStateException(<z>
);<z>
:<z>
doJoinTransaction(true);<z>
null;<z>
:<z>
jta) {<z>
TransactionSynchronizationManager.hasResource(this.target);<z>
).isInterface()) {<z>
doJoinTransaction(false);<z>
invoke(this.target, args);<z>
) {<z>
;<z>
)<z>
throws BeansException {<z>
LinkedHashMap<>();<z>
)) {<z>
{<z>
, getBean(beanName));<z>
return results;<z>
Type type, @Nullable ResolvableType owner) {<z>
;<z>
owner != null) {<z>
;<z>
);<z>
void sortBySpecificityAndQuality(List<MediaType> mediaTypes) {<z>
"'mediaTypes' must not be null");<z>
(mediaTypes.size() > 1) {<z>
SPECIFICITY_COMPARATOR.thenComparing(MediaType.QUALITY_VALUE_COMPARATOR));<z>
public StreamingSockJsSession createSession(<z>
Map<String, Object> attributes) {<z>
(), handler, attributes);<z>
public void start() {<z>
) {<z>
this.running = true;<z>
(Transport transport : this.transports) {<z>
)) {<z>
();<z>
() throws ResourceException {<z>
null, "Not initialized");<z>
.beforeDeliveryCalled = false;<z>
);<z>
null;<z>
transactionDelegate.endTransaction();<z>
{<z>
;<z>
("Failed to complete transaction", ex);<z>
V>> entrySet() {<z>
entrySet;<z>
if (entrySet == null) {<z>
.entrySet());<z>
;<z>
entrySet;<z>
Lifecycle> lifecycleBeans, final String beanName,<z>
, final Set<String> countDownBeanNames) {<z>
bean = lifecycleBeans.remove(beanName);<z>
) {<z>
getBeanFactory().getDependentBeans(beanName);<z>
dependentBean : dependentBeans) {<z>
);<z>
bean.isRunning()) {<z>
if (bean instanceof SmartLifecycle) {<z>
)) {<z>
trace("Asking bean '" + beanName + "' of type [" +<z>
() + "] to stop");<z>
);<z>
(() -> {<z>
countDown();<z>
remove(beanName);<z>
) {<z>
"Bean '" + beanName + "' completed its stop procedure");<z>
});<z>
.isTraceEnabled()) {<z>
("Stopping bean '" + beanName + "' of type [" +<z>
) + "]");<z>
);<z>
logger.isDebugEnabled()) {<z>
);<z>
if (bean instanceof SmartLifecycle) {<z>
();<z>
catch (Throwable ex) {<z>
isWarnEnabled()) {<z>
ex);<z>
(MethodParameter parameter) {<z>
PathVariable.class);<z>
, "No PathVariable annotation");<z>
new PathVariableNamedValueInfo(ann);<z>
() {<z>
{<z>
+ this);<z>
void assertSortAndCompareListModelAttribute(<z>
String modelName, List expectedList, Comparator comparator) {<z>
class);<z>
+<z>
== modelList.size());<z>
.sort(comparator);<z>
comparator);<z>
"' is not equal to the expected list.",<z>
));<z>
) {<z>
{<z>
) throws IOException, ParseException {<z>
request.getBodyAsString());<z>
template, SimpleHash model, HttpServletResponse response)<z>
IOException, TemplateException {<z>
());<z>
void visitEnd() {<z>
(fv != null) {<z>
);<z>
scope) {<z>
.notNull(beanFactory, "BeanFactory must not be null");<z>
beanFactory;<z>
;<z>
Object value, Class<T> type) {<z>
value == null) {<z>
null;<z>
(attribute, value);<z>
type = getAdaptType(attribute, type);<z>
Class && type == String.class) {<z>
.getName();<z>
&& type == Class.class) {<z>
);<z>
String[].class) {<z>
) value;<z>
];<z>
i < classes.length; i++) {<z>
].getName();<z>
value = names;<z>
{<z>
;<z>
.length; i++) {<z>
[i], getClassLoader());<z>
;<z>
MergedAnnotation && type.isAnnotation()) {<z>
value;<z>
);<z>
isAnnotation()) {<z>
<?>[]) value;<z>
);<z>
; i++) {<z>
annotations[i].synthesize());<z>
;<z>
value)) {<z>
new IllegalArgumentException("Unable to adapt value of type " +<z>
+ " to " + type.getName());<z>
) value;<z>
@Nullable Object... providedArgs) {<z>
(!ObjectUtils.isEmpty(providedArgs)) {<z>
) {<z>
getParameterType().isInstance(providedArg)) {<z>
return providedArg;<z>
return null;<z>
{<z>
;<z>
: this.variableNames) {<z>
variableName.length();<z>
variableNames.size());<z>
protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception {<z>
request);<z>
;<z>
, request);<z>
);<z>
);<z>
buildDefaultBeanName(BeanDefinition definition) {<z>
= definition.getBeanClassName();<z>
;<z>
String shortClassName = ClassUtils.getShortName(beanClassName);<z>
Introspector.decapitalize(shortClassName);<z>
void registerJobsAndTriggers() throws SchedulerException {<z>
TransactionStatus transactionStatus = null;<z>
null) {<z>
withDefaults());<z>
) {<z>
= new ResourceLoaderClassLoadHelper(this.resourceLoader);<z>
);<z>
XMLSchedulingDataProcessor dataProcessor = new XMLSchedulingDataProcessor(clh);<z>
jobSchedulingDataLocations) {<z>
.processFileAndScheduleJobs(location, getScheduler());<z>
.jobDetails != null) {<z>
: this.jobDetails) {<z>
jobDetail);<z>
.jobDetails = new ArrayList<>();<z>
{<z>
this.calendars.keySet()) {<z>
calendars.get(calendarName);<z>
(calendarName, calendar, true, true);<z>
!= null) {<z>
for (Trigger trigger : this.triggers) {<z>
addTriggerToScheduler(trigger);<z>
{<z>
{<z>
transactionManager.rollback(transactionStatus);<z>
TransactionException tex) {<z>
.error("Job registration exception overridden by rollback exception", ex);<z>
;<z>
(ex instanceof SchedulerException) {<z>
ex;<z>
) {<z>
+ ex.getMessage(), ex);<z>
.getMessage());<z>
transactionStatus != null) {<z>
);<z>
, Object value) {<z>
;<z>
value, () -> String.format(<z>
index));<z>
byIndex);<z>
if (value instanceof Parameter) {<z>
(index, (Parameter) value);<z>
getClass()));<z>
this.filterFunction);<z>
RequestPath requestPath, String contextPath) {<z>
;<z>
);<z>
this.fullPath, this.contextPath);<z>
ex) {<z>
instanceof NoSuchMethodException) {<z>
("Method not found: " + ex.getMessage());<z>
instanceof IllegalAccessException) {<z>
;<z>
(ex instanceof InvocationTargetException) {<z>
;<z>
ex instanceof RuntimeException) {<z>
RuntimeException) ex;<z>
UndeclaredThrowableException(ex);<z>
> getAllowedOrigins() {<z>
.corsConfiguration.getAllowedOrigins();<z>
.emptySet() :<z>
));<z>
{<z>
(msg, cause);<z>
();<z>
= null;<z>
<String, Object> map) {<z>
map);<z>
.annotationType = null;<z>
.displayName = UNKNOWN;<z>
) {<z>
)) {<z>
"\"");<z>
mapping);<z>
<?> getDependencyType() {<z>
if (this.field != null) {<z>
{<z>
();<z>
;<z>
();<z>
().getNestedParameterType();<z>
getMergedAnnotationAttributes(AnnotatedElement element,<z>
) {<z>
(element, annotationName, false, false);<z>
{<z>
;<z>
== 0) {<z>
null;<z>
processDestinations(ann.value());<z>
new CompositeMessageCondition(<z>
)));<z>
Object invoke(<z>
CacheOperationInvoker invoker) {<z>
getOperation();<z>
context);<z>
.isEarlyPut();<z>
getValueParameter().getValue();<z>
earlyPut) {<z>
);<z>
.invoke();<z>
earlyPut) {<z>
(context, value);<z>
;<z>
ThrowableWrapper ex) {<z>
ex.getOriginal();<z>
getClass())) {<z>
;<z>
;<z>
Expression expression) {<z>
.getExpressionString() + "' - AST start");<z>
.getAST(), "");<z>
+ "' - AST end");<z>
) {<z>
<>();<z>
.SECOND);<z>
emptyList();<z>
SECOND, Calendar.MINUTE, emptyList);<z>
second == updateSecond) {<z>
.add(Calendar.SECOND);<z>
Calendar.MINUTE);<z>
Calendar.HOUR_OF_DAY, resets);<z>
{<z>
;<z>
dot);<z>
HOUR_OF_DAY);<z>
;<z>
{<z>
HOUR_OF_DAY);<z>
);<z>
.get(Calendar.DAY_OF_WEEK);<z>
calendar.get(Calendar.DAY_OF_MONTH);<z>
;<z>
== updateDayOfMonth) {<z>
);<z>
dot);<z>
(Calendar.MONTH);<z>
Calendar.YEAR, resets);<z>
{<z>
- dot > 4) {<z>
expression +<z>
);<z>
dot);<z>
,<z>
final Label endPc,<z>
handlerPc,<z>
int catchType,<z>
catchTypeDescriptor) {<z>
= startPc;<z>
this.endPc = endPc;<z>
handlerPc;<z>
catchType;<z>
= catchTypeDescriptor;<z>
(Runnable task) {<z>
FutureTask<>(task, null);<z>
(future);<z>
future;<z>
SimpleBrokerMessageHandler getMessageHandler(SubscribableChannel brokerChannel) {<z>
handler = new SimpleBrokerMessageHandler(getClientInboundChannel(),<z>
, getDestinationPrefixes());<z>
taskScheduler != null) {<z>
taskScheduler);<z>
{<z>
;<z>
this.selectorHeaderName);<z>
;<z>
boolean nonEmptyDataBuffer(DataBuffer buffer) {<z>
> 0) {<z>
;<z>
(buffer);<z>
false;<z>
ele, ParserContext parserContext) {<z>
ele.getAttribute(ACKNOWLEDGE_ATTRIBUTE);<z>
StringUtils.hasText(acknowledge)) {<z>
Session.AUTO_ACKNOWLEDGE;<z>
(acknowledge)) {<z>
.SESSION_TRANSACTED;<z>
)) {<z>
DUPS_OK_ACKNOWLEDGE;<z>
.equals(acknowledge)) {<z>
.CLIENT_ACKNOWLEDGE;<z>
.equals(acknowledge)) {<z>
().error("Invalid listener container 'acknowledge' setting [" +<z>
ele);<z>
return acknowledgeMode;<z>
null;<z>
(<z>
Nullable Object source) {<z>
AspectJAwareAdvisorAutoProxyCreator.class, registry, source);<z>
public static ReactiveAdapterRegistry getSharedInstance() {<z>
registry = sharedInstance;<z>
(registry == null) {<z>
class) {<z>
;<z>
registry == null) {<z>
);<z>
= registry;<z>
return registry;<z>
{<z>
));<z>
(IOException ex) {<z>
;<z>
(ResourceUrlProvider urlProvider) {<z>
this.resourceUrlProvider = urlProvider;<z>
.indexLookupPath == null) {<z>
();<z>
getRequestUri(this);<z>
lookupPath = pathHelper.getLookupPathForRequest(this);<z>
lastIndexOf(lookupPath);<z>
if (this.indexLookupPath == -1) {<z>
LookupPathIndexException(lookupPath, requestUri);<z>
(0, this.indexLookupPath);<z>
{<z>
this);<z>
if (requestUri.equals(contextPath)) {<z>
.indexLookupPath = requestUri.length();<z>
prefixLookupPath = requestUri;<z>
] persistenceXmlLocations) {<z>
(logger);<z>
(1);<z>
;<z>
persistenceXmlLocations) {<z>
);<z>
{<z>
toString();<z>
()) {<z>
stream);<z>
;<z>
{<z>
("Cannot parse persistence unit from " + resourceLocation, ex);<z>
ex) {<z>
ex);<z>
{<z>
IllegalArgumentException("Internal error parsing persistence unit from " + resourceLocation);<z>
]);<z>
String name) {<z>
);<z>
)) {<z>
empty();<z>
get(0);<z>
{<z>
= "";<z>
return Optional.of(value);<z>
compareTo(ConsumesRequestCondition other, HttpServletRequest request) {<z>
{<z>
return 0;<z>
isEmpty()) {<z>
1;<z>
)) {<z>
-1;<z>
));<z>
(DataBufferFactory dataBufferFactory, HttpHeaders headers) {<z>
notNull(dataBufferFactory, "DataBufferFactory must not be null");<z>
"HttpHeaders must not be null");<z>
= dataBufferFactory;<z>
= headers;<z>
;<z>
viewName, Locale locale) throws Exception {<z>
viewName);<z>
View result = applyLifecycleMethods(viewName, view);<z>
result : null);<z>
) {<z>
ClassUtils.getUserClass(beanClass);<z>
new FactoryBeanMethodTypeFinder(factoryMethodName);<z>
factoryBeanClass, finder, ReflectionUtils.USER_DECLARED_METHODS);<z>
.getResult();<z>
String userInfo,<z>
Nullable String port, @Nullable PathComponent path,<z>
query, boolean encoded) {<z>
;<z>
.userInfo = userInfo;<z>
host;<z>
.port = port;<z>
!= null ? path : NULL_PATH_COMPONENT;<z>
.unmodifiableMultiValueMap(query) : EMPTY_QUERY_PARAMS;<z>
.FULLY_ENCODED : EncodeState.RAW;<z>
(encoded) {<z>
verify();<z>
DataBuffer> encodePartValues(<z>
bufferFactory) {<z>
return Flux.fromIterable(values)<z>
, name, value, bufferFactory));<z>
initPropertySources() {<z>
env = getEnvironment();<z>
(env instanceof ConfigurableWebEnvironment) {<z>
null);<z>
, SessionAttributeStore sessionAttributeStore) {<z>
(sessionAttributeStore, "SessionAttributeStore may not be null");<z>
= sessionAttributeStore;<z>
.class);<z>
ann != null) {<z>
.names());<z>
());<z>
.knownAttributeNames.addAll(this.attributeNames);<z>
request)<z>
{<z>
(<z>
HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, RequestAttributes.SCOPE_REQUEST);<z>
?<z>
(request) : mediaTypes;<z>
protected void loadProperties(Properties props) throws IOException {<z>
locations != null) {<z>
for (Resource location : this.locations) {<z>
isTraceEnabled()) {<z>
"Loading properties file from " + location);<z>
fillProperties(<z>
.fileEncoding), this.propertiesPersister);<z>
ex) {<z>
if (this.ignoreResourceNotFound) {<z>
if (logger.isDebugEnabled()) {<z>
());<z>
ex;<z>
IOException {<z>
.getChildElementsByTagName(persistenceUnit, JAR_FILE_URL);<z>
) {<z>
(element).trim();<z>
{<z>
);<z>
= false;<z>
{<z>
{<z>
;<z>
));<z>
found) {<z>
unitInfo.getPersistenceUnitRootUrl();<z>
null) {<z>
rootUrl, value));<z>
+<z>
getPersistenceUnitName() + "' without root URL");<z>
private void resetConnection() {<z>
.connection;<z>
this.connection = null;<z>
if (conn != null) {<z>
close();<z>
{<z>
public String toString() {<z>
).getSimpleName());<z>
sb.append(" [payload=");<z>
this.payload instanceof byte[]) {<z>
.length).append(']');<z>
(this.payload);<z>
.append(']');<z>
.toString();<z>
?> bodyClass) throws ServletException, IOException {<z>
).orElse(MediaType.APPLICATION_OCTET_STREAM);<z>
this.messageConverters) {<z>
GenericHttpMessageConverter<?> genericMessageConverter) {<z>
)) {<z>
(bodyType, bodyClass, this.serverHttpRequest);<z>
, contentType)) {<z>
HttpMessageConverter<T> theConverter =<z>
(HttpMessageConverter<T>) messageConverter;<z>
? extends T>) bodyClass;<z>
read(clazz, this.serverHttpRequest);<z>
));<z>
name) {<z>
servletContext.getAttribute(name);<z>
!= null) {<z>
destructionCallbacks) {<z>
;<z>
this.servletContext.removeAttribute(name);<z>
scopedObject;<z>
return null;<z>
) {<z>
synchronized (this.preparationMonitor) {<z>
.server != null) {<z>
serverToUse = this.server;<z>
serverToUse = null;<z>
);<z>
= null;<z>
useStrictCasing) {<z>
objectName != null, "No ObjectName set");<z>
this.serverToUse, this.objectName,<z>
managementInterface)));<z>
retrieveMBeanInfo(this.serverToUse);<z>
dataBufferFactory) {<z>
delegate);<z>
;<z>
dataBufferFactory = dataBufferFactory;<z>
leakError = createLeakError(delegate);<z>
{<z>
if (getNativeHeaders() == null) {<z>
String value = getFirstNativeHeader(STOMP_DESTINATION_HEADER);<z>
) {<z>
(value);<z>
(STOMP_CONTENT_TYPE_HEADER);<z>
value != null) {<z>
MimeTypeUtils.parseMimeType(value));<z>
command = getCommand();<z>
command)) {<z>
= getFirstNativeHeader(STOMP_SUBSCRIPTION_HEADER);<z>
) {<z>
.setSubscriptionId(value);<z>
command)) {<z>
);<z>
!= null) {<z>
(value);<z>
.equals(command)) {<z>
protectPasscode();<z>
) {<z>
exceptionTranslator = this.exceptionTranslator;<z>
!= null) {<z>
;<z>
{<z>
exceptionTranslator;<z>
) {<z>
) {<z>
();<z>
exceptionTranslator = new SQLErrorCodeSQLExceptionTranslator(obtainDataSource());<z>
= exceptionTranslator;<z>
;<z>
populateActivationSpecProperties(BeanWrapper bw, JmsActivationSpecConfig config) {<z>
bw, config);<z>
getMaxConcurrency() > 0) {<z>
bw.isWritableProperty("maxSessions")) {<z>
;<z>
{<z>
)));<z>
){<z>
));<z>
getPrefetchSize() > 0) {<z>
isWritableProperty("maxMessagesPerSessions")) {<z>
));<z>
(bw.isWritableProperty("maxMessages")) {<z>
)));<z>
if (bw.isWritableProperty("maxBatchSize")){<z>
config.getPrefetchSize()));<z>
) {<z>
(getUpgradeStrategy() instanceof Lifecycle) {<z>
()).stop();<z>
) {<z>
(handler, "Dispatch handler must not be null");<z>
(this) {<z>
(this.dispatchedPath == null) {<z>
.add(handler);<z>
run();<z>
public List<String> getDoublesAsStringList() {<z>
result = new ArrayList<>();<z>
);<z>
);<z>
;<z>
(ServerWebExchange exchange, Object handler) {<z>
) handler;<z>
exchange);<z>
Mono.empty());<z>
{<z>
logger.debug("Returning CLOB as string");<z>
(this.wrapAsLob) {<z>
clob = rs.getClob(columnIndex);<z>
length());<z>
getString(columnIndex);<z>
getType(String paramName) {<z>
"Parameter name must not be null");<z>
this.values.get(paramName);<z>
if (parameter != null) {<z>
();<z>
class;<z>
protected String resolveSql() {<z>
getSql();<z>
;<z>
sql;<z>
) {<z>
(this.nextPotentialReferencePosition != this.currentPosition) {<z>
?<z>
;<z>
.currentPosition > 3) {<z>
originalMessage, this.currentPosition, skipUntilIndex);<z>
skipUntilIndex;<z>
(this.currentPosition < skipUntilIndex) {<z>
this.currentPosition++));<z>
ViewResolver viewResolver) {<z>
) {<z>
new BeanInitializationException(<z>
"Please use the method enableContentNegotiation instead.");<z>
.add(viewResolver);<z>
servletPath(String servletPath) {<z>
.hasText(servletPath)) {<z>
;<z>
, "Servlet path must not end with a '/'");<z>
this.servletPath = servletPath;<z>
return this;<z>
) {<z>
if (dateTimeContext == null) {<z>
;<z>
set(dateTimeContext);<z>
void initExceptionHandlerAdviceCache() {<z>
() == null) {<z>
);<z>
(ControllerAdviceBean adviceBean : adviceBeans) {<z>
= adviceBean.getBeanType();<z>
) {<z>
;<z>
ExceptionHandlerMethodResolver resolver = new ExceptionHandlerMethodResolver(beanType);<z>
hasExceptionMappings()) {<z>
exceptionHandlerAdviceCache.put(adviceBean, resolver);<z>
isAssignableFrom(beanType)) {<z>
(adviceBean);<z>
()) {<z>
size();<z>
= this.responseBodyAdvice.size();<z>
&& adviceSize == 0) {<z>
logger.debug("ControllerAdvice beans: none");<z>
.debug("ControllerAdvice beans: " +<z>
+ adviceSize + " ResponseBodyAdvice");<z>
ProtobufJsonFormatMessageConverter(<z>
) {<z>
, null);<z>
getPartValues(<z>
@Nullable RequestPart requestPart, boolean isRequired,<z>
{<z>
name = getPartName(parameter, requestPart);<z>
)<z>
map -> {<z>
list = map.get(name);<z>
(list)) {<z>
) {<z>
String reason = "Required request part '" + name + "' is not present";<z>
ServerWebInputException(reason, parameter);<z>
();<z>
list;<z>
});<z>
ServletInputStream getInputStream() throws IOException {<z>
(this.inputStream == null) {<z>
(getRequest().getInputStream());<z>
inputStream;<z>
IOException {<z>
isUserSetStatus(status)) {<z>
status);<z>
if (logger.isDebugEnabled()) {<z>
("Closing session with " + status + " in " + this);<z>
(status);<z>
, int toIndex) {<z>
> elements = container.elements();<z>
.size()) {<z>
container;<z>
(fromIndex == toIndex) {<z>
return EMPTY_PATH;<z>
, () -> "Invalid fromIndex: " + fromIndex);<z>
-> "Invalid toIndex: " + toIndex);<z>
+ toIndex);<z>
(fromIndex, toIndex);<z>
);<z>
subList);<z>
messageSupplier) {<z>
.log.isWarnEnabled()) {<z>
of(messageSupplier));<z>
] decode(byte[] src) {<z>
src.length == 0) {<z>
;<z>
(src);<z>
() {<z>
.applyDefaultConfig(this.customCodecs);<z>
);<z>
keySet());<z>
getTypedReaders());<z>
());<z>
(this.defaultCodecs.getObjectReaders());<z>
));<z>
;<z>
(HttpServletRequest request) {<z>
initFromRequest(request);<z>
));<z>
());<z>
return builder;<z>
, Object newArray, TypeConverter typeConverter,<z>
) {<z>
= (double[]) newArray;<z>
{<z>
getChild(i).getTypedValue(state);<z>
;<z>
WebTestClient.ResponseSpec exists(String name) {<z>
) {<z>
(name) + " does not exist";<z>
-> AssertionErrors.fail(message));<z>
return this.responseSpec;<z>
createSubcontext(String name) {<z>
.root + name;<z>
(!subcontextName.endsWith("/")) {<z>
"/";<z>
boundObjects, this.environment);<z>
name, subcontext);<z>
subcontext;<z>
getAnnotationArray(<z>
{<z>
attributeIndex = getAttributeIndex(attributeName, true);<z>
getAttributes().get(attributeIndex);<z>
().getComponentType();<z>
(type, "Type must not be null");<z>
);<z>
" component type mismatch:");<z>
, attributeName);<z>
servletResponse)<z>
IOException {<z>
new ServletServerHttpRequest(servletRequest);<z>
response = new ServletServerHttpResponse(servletResponse);<z>
;<z>
(Exception ex) {<z>
, ex);<z>
encodeUrlSafe(byte[] src) {<z>
length == 0) {<z>
;<z>
().encode(src);<z>
(boolean finalPart) {<z>
!this.bodySink.isCancelled()) {<z>
bodySink.complete();<z>
) {<z>
();<z>
static TaskExecutorAdapter getAdaptedExecutor(Executor concurrentExecutor) {<z>
) {<z>
;<z>
concurrentExecutor);<z>
, PropertyDescriptor target) {<z>
.setExpert(source.isExpert());<z>
source.isHidden());<z>
source.isPreferred());<z>
.getName());<z>
);<z>
(source.getDisplayName());<z>
> keys = source.attributeNames();<z>
.hasMoreElements()) {<z>
String key = keys.nextElement();<z>
));<z>
;<z>
());<z>
.setConstrained(source.isConstrained());<z>
compatibleWithCloseBracket(char closeBracket) {<z>
bracket == '{') {<z>
== '}';<z>
'[') {<z>
;<z>
return closeBracket == ')';<z>
{<z>
();<z>
ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();<z>
classLoaderToUse.equals(threadContextClassLoader)) {<z>
;<z>
threadContextClassLoader;<z>
;<z>
(@Nullable MethodOverrides other) {<z>
other != null) {<z>
);<z>
Nullable Type rhsType) {<z>
== null) {<z>
return true;<z>
if (lhsType == null) {<z>
false;<z>
isAssignable(lhsType, rhsType);<z>
[] supportedMethods, String msg) {<z>
super(msg);<z>
;<z>
;<z>
) {<z>
{<z>
SecondMsg)other);<z>
else {<z>
other);<z>
this;<z>
prefix) throws SAXException {<z>
)) {<z>
prefix);<z>
.remove(prefix);<z>
{<z>
;<z>
< max; c++) {<z>
getChild(c);<z>
(!(child instanceof Literal)) {<z>
instanceof InlineList inlineList) {<z>
)) {<z>
;<z>
;<z>
(isConstant) {<z>
;<z>
= getChildCount();<z>
c++) {<z>
= getChild(c);<z>
) {<z>
;<z>
(child instanceof InlineList inlineList) {<z>
.getConstantValue());<z>
unmodifiableList(constantList));<z>
,<z>
) {<z>
logger.isDebugEnabled()) {<z>
getLogPrefix() + "View " + formatViewName() +<z>
emptyMap()));<z>
null) {<z>
.setContentType(contentType);<z>
(mergedModel -> {<z>
if (this.requestContextAttribute != null) {<z>
);<z>
(mergedModel, contentType, exchange);<z>
;<z>
afterPropertiesSet() throws IOException {<z>
(this.serviceUrl == null) {<z>
;<z>
connectOnStartup) {<z>
);<z>
);<z>
String[] destinations) {<z>
) {<z>
stream(destinations)<z>
.resolveStringValue(s))<z>
);<z>
;<z>
{<z>
defaultConnection, "Default WebConnection must not be null");<z>
, "Connections List must not be empty");<z>
;<z>
;<z>
<MediaType> getProducibleMediaTypes() {<z>
.filter(PartialMatch::hasConsumesMatch).<z>
.getProducibleMediaTypes().stream()).<z>
LinkedHashSet::new));<z>
String headerName, String... headerValues) {<z>
for (String headerValue : headerValues) {<z>
, headerValue);<z>
this;<z>
parser,<z>
extensionRegistry) {<z>
;<z>
@Nullable Object other) {<z>
{<z>
return true;<z>
instanceof HttpHeaders)) {<z>
return false;<z>
(HttpHeaders) other));<z>
AndRequestPredicate(RequestPredicate left, RequestPredicate right) {<z>
Assert.notNull(left, "Left RequestPredicate must not be null");<z>
Assert.notNull(right, "Right RequestPredicate must not be null");<z>
;<z>
this.right = right;<z>
, String[] prefixes, int offset) {<z>
prefixes) {<z>
)) {<z>
return true;<z>
false;<z>
, OutputStream outputStream, @Nullable DataHolder dataHolder)<z>
IOException {<z>
streamDriver != null) {<z>
createWriter(outputStream), dataHolder);<z>
, dataHolder);<z>
static UriComponentsBuilder fromOriginHeader(String origin) {<z>
;<z>
{<z>
new UriComponentsBuilder();<z>
group(2);<z>
host = matcher.group(6);<z>
8);<z>
)) {<z>
builder.scheme(scheme);<z>
(host);<z>
hasLength(port)) {<z>
port(port);<z>
builder;<z>
IllegalArgumentException("[" + origin + "] is not a valid \"Origin\" header value");<z>
registerDestructionCallback(String name, Runnable callback) {<z>
)) {<z>
)) {<z>
+ " already completed");<z>
.put(DESTRUCTION_CALLBACK_NAME_PREFIX + name, callback);<z>
Duration maxAge, @Nullable String domain,<z>
, @Nullable String sameSite) {<z>
name, value);<z>
(maxAge, "Max age must not be null");<z>
maxAge = maxAge;<z>
this.domain = domain;<z>
path;<z>
secure;<z>
;<z>
.sameSite = sameSite;<z>
(name);<z>
;<z>
.validateDomain(domain);<z>
path);<z>
private List<Aggregate> getAggregates() {<z>
aggregates;<z>
if (aggregates == null) {<z>
);<z>
) {<z>
aggregates = Collections.emptyList();<z>
this.aggregates = aggregates;<z>
return aggregates;<z>
annotation, Class<?> fieldType) {<z>
);<z>
());<z>
style)) {<z>
;<z>
.iso());<z>
pattern());<z>
)) {<z>
factory.setPattern(pattern);<z>
return factory.createDateTimeFormatter();<z>
onApplicationEvent(ContextRefreshedEvent event) {<z>
.applicationContext) {<z>
finishRegistration();<z>
addAttributes(final Attribute attributeList) {<z>
Attribute attribute = attributeList;<z>
while (attribute != null) {<z>
if (!contains(attribute)) {<z>
;<z>
attribute = attribute.nextAttribute;<z>
aliases) {<z>
aliases);<z>
= this;<z>
while (mapping != null) {<z>
-1 && mapping != this.root) {<z>
size(); i++) {<z>
i))) {<z>
;<z>
;<z>
.claimedAliases.addAll(aliases);<z>
(mapping.annotation != null) {<z>
mapping.mirrorSets.resolve(null,<z>
;<z>
i++) {<z>
)) {<z>
;<z>
.annotationValueSource[attributeIndex] = mapping;<z>
mapping = mapping.source;<z>
name) throws AccessException {<z>
if (this.variableResolver == null) {<z>
return null;<z>
variableResolver.resolveVariable(name);<z>
{<z>
AccessException(<z>
"' as an implicit variable", ex);<z>
> parse(AnnotationAttributes componentScan, String declaringClass) {<z>
.registry,<z>
;<z>
("nameGenerator");<z>
== generatorClass);<z>
useInheritedGenerator ? this.beanNameGenerator :<z>
instantiateClass(generatorClass));<z>
.getEnum("scopedProxy");<z>
if (scopedProxyMode != ScopedProxyMode.DEFAULT) {<z>
);<z>
("scopeResolver");<z>
instantiateClass(resolverClass));<z>
"resourcePattern"));<z>
{<z>
.createTypeFiltersFor(includeFilterAttributes, this.environment,<z>
this.registry);<z>
{<z>
typeFilter);<z>
"excludeFilters")) {<z>
,<z>
.resourceLoader, this.registry);<z>
) {<z>
typeFilter);<z>
= componentScan.getBoolean("lazyInit");<z>
lazyInit) {<z>
(true);<z>
;<z>
("basePackages");<z>
(String pkg : basePackagesArray) {<z>
(this.environment.resolvePlaceholders(pkg),<z>
);<z>
basePackages, tokenized);<z>
) {<z>
ClassUtils.getPackageName(clazz));<z>
) {<z>
.getPackageName(declaringClass));<z>
) {<z>
className) {<z>
;<z>
;<z>
StringUtils.toStringArray(basePackages));<z>
, Supplier<T> instanceSupplier) {<z>
beanDefinition = new RootBeanDefinition();<z>
;<z>
setInstanceSupplier(instanceSupplier);<z>
beanDefinition);<z>
(ConverterLookup converterLookup) {<z>
.converterLookup = converterLookup;<z>
converterLookup instanceof ConverterRegistry registry) {<z>
= registry;<z>
?> proxySuperClass, @Nullable ClassLoader proxyClassLoader) {<z>
.isInfoEnabled()) {<z>
synchronized (validatedClasses) {<z>
!validatedClasses.containsKey(proxySuperClass)) {<z>
,<z>
));<z>
.put(proxySuperClass, Boolean.TRUE);<z>
(<z>
extends Resource> locations) {<z>
!= null && this.nextChain != null ?<z>
.nextChain) : null);<z>
{<z>
other) {<z>
true;<z>
otherValue)) {<z>
;<z>
(this.value, otherValue.value) &&<z>
, otherValue.targetType));<z>
String name) {<z>
name);<z>
) {<z>
];<z>
boolean isAutowirable(Parameter parameter, int parameterIndex) {<z>
, "Parameter must not be null");<z>
parameterIndex);<z>
annotatedParameter, Autowired.class) ||<z>
class) ||<z>
));<z>
equals(Object o) {<z>
(this == o) {<z>
;<z>
o instanceof BitsCronField other)) {<z>
return false;<z>
this.bits == other.bits;<z>
, ResolvableType elementType, ServerHttpRequest request,<z>
, Object> hints) {<z>
;<z>
(<z>
BeanFactoryPostProcessor> postProcessors, ConfigurableListableBeanFactory beanFactory) {<z>
: postProcessors) {<z>
start("spring.context.bean-factory.post-process")<z>
tag("postProcessor", postProcessor::toString);<z>
postProcessor.postProcessBeanFactory(beanFactory);<z>
end();<z>
WebSocketHttpHeaders httpHeaders) {<z>
;<z>
[] supportedVersions = getSupportedVersions();<z>
: supportedVersions) {<z>
).equals(version)) {<z>
;<z>
;<z>
) {<z>
(exchange)<z>
Mono.defer(() -> {<z>
(exchange.getLogPrefix() + "Resource not found");<z>
.NOT_FOUND));<z>
))<z>
flatMap(resource -> {<z>
).getMethod())) {<z>
.add("Allow", "GET,HEAD,OPTIONS");<z>
.empty();<z>
.getRequest().getMethod();<z>
)) {<z>
new MethodNotAllowedException(<z>
), SUPPORTED_METHODS));<z>
))) {<z>
.getLogPrefix() + "Resource not modified");<z>
;<z>
();<z>
cacheControl != null) {<z>
.setCacheControl(cacheControl);<z>
MediaType mediaType = getMediaType(resource);<z>
resource, mediaType);<z>
ResourceHttpMessageWriter writer = getResourceHttpMessageWriter();<z>
(writer != null, "No ResourceHttpMessageWriter");<z>
(Mono.just(resource),<z>
forClass(Resource.class), mediaType,<z>
),<z>
)));<z>
(IOException ex) {<z>
Mono.error(ex);<z>
;<z>
public HeaderPredicate noAttributes() {<z>
.name = "";<z>
;<z>
;<z>
return this;<z>
createInstance() {<z>
beanFactory = getBeanFactory();<z>
!= null, "No BeanFactory available");<z>
targetBeanName != null, "No target bean name specified");<z>
targetBeanName);<z>
) throws IllegalArgumentException, BeanInitializationException {<z>
{<z>
new IllegalArgumentException("'connectionFactory' or 'jmsTemplate' is required");<z>
initGateway();<z>
ex) {<z>
(), ex);<z>
{<z>
) {<z>
(SessionFlashMapManager.class);<z>
;<z>
.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
.FLASH_MAP_MANAGER_BEAN_NAME, beanDef);<z>
));<z>
(boolean includeModifier, boolean includeReturnTypeAndArgs,<z>
useLongReturnAndArgumentTypeName, boolean useLongTypeName) {<z>
StringBuilder();<z>
) {<z>
(getModifiers()));<z>
(' ');<z>
includeReturnTypeAndArgs) {<z>
getReturnType(), useLongReturnAndArgumentTypeName);<z>
append(' ');<z>
getDeclaringType(), useLongTypeName);<z>
append('.');<z>
);<z>
);<z>
>[] parametersTypes = getParameterTypes();<z>
useLongReturnAndArgumentTypeName);<z>
);<z>
toString();<z>
?> paramMap, PreparedStatementCallback<T> action)<z>
throws DataAccessException {<z>
new MapSqlParameterSource(paramMap), action);<z>
String toString() {<z>
64);<z>
= 0;<z>
.Entry entry : this.state) {<z>
(i > 0) {<z>
.append('\n');<z>
j++) {<z>
append('\t');<z>
sb.append("-> ");<z>
entry);<z>
i++;<z>
.toString();<z>
) {<z>
Assert.notNull(bootstrapExecutor, "AsyncTaskExecutor must not be null");<z>
.getClassLoader(),<z>
},<z>
));<z>
{<z>
();<z>
(Exception ex) {<z>
"Failed to start Jetty WebSocketClient", ex);<z>
JspException {<z>
);<z>
= tagWriter;<z>
)) {<z>
);<z>
return EVAL_BODY_BUFFERED;<z>
SKIP_BODY;<z>
protected String transformPath(String lookupPath) {<z>
lookupPath;<z>
.startsWith(SLASH)) {<z>
path.substring(1);<z>
.endsWith(SLASH)) {<z>
);<z>
if (this.stripExtension) {<z>
path = StringUtils.stripFilenameExtension(path);<z>
.separator)) {<z>
path, SLASH, this.separator);<z>
return path;<z>
candidateName) {<z>
||<z>
)) ||<z>
));<z>
?> entity, ParameterizedTypeReference<T> responseType)<z>
RestClientException {<z>
;<z>
requestCallback = httpEntityCallback(entity, type);<z>
responseEntityExtractor(type);<z>
requestCallback, responseExtractor));<z>
onComplete() {<z>
)) {<z>
);<z>
String sessionId, SockJsServiceConfig config,<z>
Object> attributes) {<z>
;<z>
,<z>
.MonoProcessor<Void> completionMono) {<z>
;<z>
();<z>
int calculateHashCode(<z>
@Nullable PathPatternsRequestCondition pathPatterns, @Nullable PatternsRequestCondition patterns,<z>
params, HeadersRequestCondition headers,<z>
consumes, ProducesRequestCondition produces, RequestConditionHolder custom) {<z>
31 +<z>
+<z>
() + produces.hashCode() +<z>
hashCode();<z>
Nullable Object result) {<z>
.generateKey(result);<z>
if (key == null) {<z>
IllegalArgumentException("Null key returned for cache operation (maybe you are " +<z>
metadata.operation);<z>
) {<z>
);<z>
;<z>
Nullable Map<String, ?> headersToCopy) {<z>
== null || this.headers == headersToCopy) {<z>
value) -> {<z>
!isReadOnly(key)) {<z>
key, value);<z>
;<z>
TriggerTask(Runnable runnable, Trigger trigger) {<z>
);<z>
trigger, "Trigger must not be null");<z>
= trigger;<z>
JCacheCacheAspect cacheAspect(JCacheOperationSource jCacheOperationSource) {<z>
aspectOf();<z>
;<z>
;<z>
BeansException {<z>
"/locale.do", LocaleChecker.class);<z>
, "test message");<z>
("test", Locale.CANADA, "Canadian & test message");<z>
, Locale.ENGLISH, "test {0} message {1}");<z>
.ENGLISH, "test {0} message {1,number,#.##} X");<z>
;<z>
registerSingleton("handlerMapping", BeanNameUrlHandlerMapping.class);<z>
;<z>
= new MutablePropertyValues();<z>
("location", "org/springframework/web/context/WEB-INF/sessionContext.xml");<z>
view.XmlViewResolver.class, pvs);<z>
;<z>
{<z>
.notNull(voidPublisher, "Publisher must not be null");<z>
exchange, handlerStrategies) -><z>
.setComplete()));<z>
object, Message message) throws JMSException {<z>
this.typeIdPropertyName != null) {<z>
));<z>
) {<z>
getClass().getName();<z>
typeId);<z>
receiptId) {<z>
receiptId = receiptId;<z>
{<z>
);<z>
, HttpMethod httpMethod) throws IOException {<z>
), this.proxy);<z>
(connection, httpMethod.name());<z>
{<z>
);<z>
outputStreaming);<z>
<HttpMessageConverter<?>> converters) {<z>
{<z>
;<z>
{<z>
loader = this.clazz.getClassLoader();<z>
args.length];<z>
.args.length; i++) {<z>
getClassName(), loader);<z>
.equals(this.name)) {<z>
return this.clazz.getDeclaredConstructor(argTypes);<z>
argTypes);<z>
ex) {<z>
+ this.name +<z>
ex);<z>
public void configureEndpoint(Object listenerContainer) {<z>
if (listenerContainer instanceof JmsMessageEndpointManager) {<z>
listenerContainer);<z>
IllegalArgumentException("Could not configure endpoint with the specified container '" +<z>
.getName() +<z>
;<z>
{<z>
();<z>
;<z>
) {<z>
return null;<z>
DayOfWeek parseDayOfWeek(String value) {<z>
int dayOfWeek = Integer.parseInt(value);<z>
) {<z>
;<z>
(dayOfWeek);<z>
DateTimeException ex) {<z>
"'";<z>
throw new IllegalArgumentException(msg, ex);<z>
(<z>
) throws Exception {<z>
objectName);<z>
OutputStream out) throws IOException {<z>
Assert.notNull(in, "No InputStream specified");<z>
"No OutputStream specified");<z>
in, out);<z>
close(in);<z>
out);<z>
() {<z>
(this.type instanceof ParameterizedType) {<z>
variableResolver);<z>
) {<z>
);<z>
resolved == null) {<z>
));<z>
forType(resolved, this.variableResolver);<z>
type instanceof TypeVariable) {<z>
(TypeVariable<?>) this.type;<z>
.variableResolver != null) {<z>
(variable);<z>
!= null) {<z>
return resolved;<z>
)), this.variableResolver);<z>
NONE;<z>
(<z>
protobuf.ByteString data,<z>
.ExtensionRegistryLite extensionRegistry)<z>
.InvalidProtocolBufferException {<z>
return PARSER.parseFrom(data, extensionRegistry);<z>
subscriber) {<z>
Assert.notNull(publisher, "Publisher must not be null");<z>
;<z>
.changeState(this, SUBSCRIBING)) {<z>
);<z>
= subscriber;<z>
onSubscribe(subscription);<z>
SUBSCRIBING, NO_DEMAND);<z>
;<z>
throw new IllegalStateException("Failed to transition to SUBSCRIBING, " +<z>
subscriber);<z>
) {<z>
oldValue != null) {<z>
, this.oldValue);<z>
= null;<z>
(VALUE_VARIABLE_NAME);<z>
this.oldDisplayValue != null) {<z>
this.oldDisplayValue);<z>
oldDisplayValue = null;<z>
;<z>
, Object... providedArgs) {<z>
-> {<z>
value;<z>
false;<z>
getBridgedMethod();<z>
isSuspendingFunction(method)) {<z>
= true;<z>
;<z>
);<z>
catch (IllegalArgumentException ex) {<z>
;<z>
getMessage() : "Illegal argument");<z>
));<z>
(InvocationTargetException ex) {<z>
());<z>
{<z>
, ex));<z>
returnType = getReturnType();<z>
);<z>
getAdapter(reactiveType);<z>
) ?<z>
;<z>
);<z>
array, String message) {<z>
)) {<z>
new IllegalArgumentException(message);<z>
Object[]> getMethodArgumentValues(<z>
, BindingContext bindingContext, Object... providedArgs) {<z>
);<z>
) {<z>
;<z>
parameters.length);<z>
) {<z>
.parameterNameDiscoverer);<z>
providedArgs);<z>
!= null) {<z>
(providedArg));<z>
(parameter)) {<z>
return Mono.error(new IllegalStateException(<z>
;<z>
, exchange)<z>
defaultIfEmpty(NO_ARG_VALUE)<z>
, ex)));<z>
ex) {<z>
(exchange, parameter, ex);<z>
));<z>
, values -><z>
());<z>
createWriteProcessor() {<z>
new ResponseBodyProcessor();<z>
processor;<z>
processor;<z>
{<z>
this == other) {<z>
return true;<z>
)) {<z>
return false;<z>
));<z>
,<z>
typeRef) {<z>
, headers, body);<z>
.resolvableType = ResolvableType.forType(typeRef);<z>
(Locale locale, TimeZone timeZone) {<z>
.request);<z>
)) {<z>
;<z>
(this.request, this.response,<z>
));<z>
this.locale = locale;<z>
timeZone = timeZone;<z>
(HeaderMap headerMap) {<z>
HttpHeaders();<z>
)) {<z>
: headerMap.get(name)) {<z>
;<z>
httpHeaders;<z>
void releaseTarget(Object target) throws Exception {<z>
if (this.pool != null) {<z>
.returnObject(target);<z>
resolveReturnTypeForFactoryMethod(<z>
, @Nullable ClassLoader classLoader) {<z>
(method, "Method must not be null");<z>
Assert.notNull(args, "Argument array must not be null");<z>
getTypeParameters();<z>
getGenericReturnType();<z>
;<z>
.length, "Argument array does not match parameter count");<z>
locallyDeclaredTypeVariableMatchesReturnType = false;<z>
Method> currentTypeVariable : declaredTypeVariables) {<z>
genericReturnType)) {<z>
;<z>
(locallyDeclaredTypeVariableMatchesReturnType) {<z>
i < methodParameterTypes.length; i++) {<z>
methodParameterType = methodParameterTypes[i];<z>
Object arg = args[i];<z>
(methodParameterType.equals(genericReturnType)) {<z>
) {<z>
hasTargetType()) {<z>
;<z>
(classLoader);<z>
if (resolvedType != null) {<z>
;<z>
catch (ClassNotFoundException ex) {<z>
IllegalStateException("Failed to resolve value type [" +<z>
);<z>
instanceof BeanMetadataElement)) {<z>
arg.getClass();<z>
);<z>
parameterizedType) {<z>
[] actualTypeArguments = parameterizedType.getActualTypeArguments();<z>
{<z>
if (typeArg.equals(genericReturnType)) {<z>
arg instanceof Class) {<z>
arg;<z>
className = null;<z>
instanceof String) {<z>
String) arg;<z>
typedValue) {<z>
);<z>
targetTypeName)) {<z>
;<z>
if (className != null) {<z>
forName(className, classLoader);<z>
{<z>
+ arg +<z>
, ex);<z>
.getReturnType();<z>
return method.getReturnType();<z>
, String placeholderSuffix,<z>
) {<z>
placeholderPrefix, "'placeholderPrefix' must not be null");<z>
(placeholderSuffix, "'placeholderSuffix' must not be null");<z>
;<z>
.placeholderSuffix = placeholderSuffix;<z>
);<z>
simplePrefixForSuffix)) {<z>
simplePrefixForSuffix;<z>
.simplePrefix = this.placeholderPrefix;<z>
valueSeparator;<z>
ignoreUnresolvablePlaceholders = ignoreUnresolvablePlaceholders;<z>
String text) {<z>
(this.sb == null) {<z>
new StringBuilder();<z>
(text);<z>
return this;<z>
SockJsFrame frame) {<z>
(!isOpen()) {<z>
isErrorEnabled()) {<z>
+ this.state + " in " + this);<z>
null;<z>
();<z>
!= null) {<z>
);<z>
) {<z>
(logger.isErrorEnabled()) {<z>
ex);<z>
BAD_DATA);<z>
(messages == null) {<z>
if (logger.isTraceEnabled()) {<z>
.getContent() + " in " + this);<z>
messages) {<z>
)) {<z>
TextMessage(message));<z>
Exception ex) {<z>
);<z>
Object[] arrayVal) {<z>
.length; i++) {<z>
arrayVal[i];<z>
= resolveValue(elem);<z>
nullSafeEquals(newVal, elem)) {<z>
] = newVal;<z>
argTypes, RowMapper<T> rowMapper)<z>
{<z>
rowMapper, 1));<z>
.nullableSingleResult(results);<z>
{<z>
null) {<z>
throw new IllegalStateException("LifecycleProcessor not initialized - " +<z>
);<z>
.lifecycleProcessor;<z>
{<z>
> matchingBeans =<z>
class).values();<z>
(this.viewResolvers == null) {<z>
(matchingBeans.size());<z>
) {<z>
if (this != viewResolver) {<z>
viewResolvers.add(viewResolver);<z>
i++) {<z>
= this.viewResolvers.get(i);<z>
{<z>
getName() + i;<z>
initializeBean(vr, name);<z>
;<z>
this.cnmFactoryBean.setServletContext(servletContext);<z>
public void onException(JMSException ex) {<z>
);<z>
(this.recoverOnException) {<z>
(logger.isDebugEnabled()) {<z>
;<z>
consumersMonitor) {<z>
;<z>
null;<z>
();<z>
();<z>
;<z>
catch (JMSException recoverEx) {<z>
"Failed to recover JMS Connection", recoverEx);<z>
, ex);<z>
) throws EvaluationException {<z>
;<z>
null) {<z>
getChild(0).getStartPosition(),<z>
);<z>
(state);<z>
;<z>
return result;<z>
() {<z>
this.keepTaskList) {<z>
UnsupportedOperationException("Task info is not being kept!");<z>
.toArray(new TaskInfo[0]);<z>
handler) {<z>
getRequest();<z>
;<z>
HttpHeaders headers = request.getHeaders();<z>
{<z>
(<z>
singleton(HttpMethod.GET)));<z>
{<z>
handleBadRequest(exchange, "Invalid 'Upgrade' header: " + headers);<z>
connectionValue = headers.getConnection();<z>
!connectionValue.contains("upgrade")) {<z>
return handleBadRequest(exchange, "Invalid 'Connection' header: " + headers);<z>
= headers.getFirst(SEC_WEBSOCKET_KEY);<z>
null) {<z>
return handleBadRequest(exchange, "Missing \"Sec-WebSocket-Key\" header");<z>
protocol = selectProtocol(headers, handler);<z>
).flatMap(attributes -><z>
upgradeStrategy.upgrade(exchange, handler, protocol,<z>
exchange, request, protocol, attributes))<z>
(ScriptEngineManager scriptEngineManager, String engineName) {<z>
scriptEngineManager.getEngineByName(engineName);<z>
null) {<z>
new LinkedHashSet<>();<z>
: scriptEngineManager.getEngineFactories()) {<z>
getNames();<z>
.contains(engineName)) {<z>
();<z>
);<z>
Throwable ex) {<z>
"Script engine with name '" + engineName +<z>
;<z>
addAll(factoryNames);<z>
IllegalArgumentException("Script engine with name '" + engineName +<z>
engineNames);<z>
engine;<z>
query) {<z>
if (query != null) {<z>
query);<z>
) {<z>
);<z>
);<z>
3);<z>
;<z>
();<z>
.queryParams.clear();<z>
this;<z>
> getConverterStrings() {<z>
();<z>
: this.converters.values()) {<z>
;<z>
converterStrings);<z>
converterStrings;<z>
> resolveReturnValueType(HandlerResult result) {<z>
toClass();<z>
result.getReturnValue();<z>
Object.class && value != null) {<z>
.getClass();<z>
valueType;<z>
int pathIndex, MatchingContext matchingContext) {<z>
)) {<z>
return false;<z>
{<z>
;<z>
extractingVariables) {<z>
,String> parametersCollector = null;<z>
) {<z>
get(i);<z>
) {<z>
);<z>
) {<z>
if (parametersCollector == null) {<z>
>();<z>
parametersCollector.addAll(parameters);<z>
.pathElements),<z>
parametersCollector == null?NO_PARAMETERS:parametersCollector);<z>
true;<z>
(<z>
) {<z>
class) {<z>
"void");<z>
{<z>
;<z>
quoteReplacement(returnValue.toString()));<z>
public void visitTryCatchBlock(<z>
{<z>
Handler newHandler =<z>
new Handler(<z>
type).index : 0, type);<z>
null) {<z>
firstHandler = newHandler;<z>
{<z>
newHandler;<z>
;<z>
Object value, DataBufferFactory bufferFactory,<z>
String, Object> hints) {<z>
)) {<z>
, traceOn -> {<z>
.formatValue(value, !traceOn);<z>
formatted + "]";<z>
;<z>
release = true;<z>
;<z>
OutputStream outputStream = buffer.asOutputStream();<z>
value);<z>
Marshaller marshaller = initMarshaller(clazz);<z>
;<z>
false;<z>
;<z>
ex) {<z>
.getClass() + " to XML", ex);<z>
(JAXBException ex) {<z>
("Invalid JAXB configuration", ex);<z>
) {<z>
buffer);<z>
(MimePart mimePart, String text) throws MessagingException {<z>
!= null) {<z>
setText(text, getEncoding());<z>
setText(text);<z>
<A> annotationType)<z>
throws NoSuchBeanDefinitionException {<z>
(beanName, annotationType, true);<z>
getClassForDescriptor(Object managedBean) {<z>
(managedBean)) {<z>
managedBean)[0];<z>
return getClassToExpose(managedBean);<z>
ConfigurationClassBeanDefinitionReader(BeanDefinitionRegistry registry, SourceExtractor sourceExtractor,<z>
resourceLoader, Environment environment, BeanNameGenerator importBeanNameGenerator,<z>
ImportRegistry importRegistry) {<z>
registry;<z>
= sourceExtractor;<z>
;<z>
this.environment = environment;<z>
= importBeanNameGenerator;<z>
= importRegistry;<z>
, environment, resourceLoader);<z>
(SqlParameterSource parameterSource) {<z>
= new ArrayList<>();<z>
> caseInsensitiveParameterNames =<z>
parameterSource);<z>
this.tableColumns) {<z>
column)) {<z>
column));<z>
);<z>
(lowerCaseName)) {<z>
.getTypedValue(parameterSource, lowerCaseName));<z>
JdbcUtils.convertUnderscoreNameToPropertyName(column);<z>
hasValue(propertyName)) {<z>
parameterSource, propertyName));<z>
if (caseInsensitiveParameterNames.containsKey(lowerCaseName)) {<z>
add(SqlParameterSourceUtils.getTypedValue(<z>
.get(lowerCaseName)));<z>
;<z>
return values;<z>
other) {<z>
== other) {<z>
;<z>
(!(other instanceof BindingResult otherResult)) {<z>
;<z>
.equals(otherResult.getObjectName()) &&<z>
, otherResult.getTarget()) &&<z>
;<z>
DataBuffer> dataBuffers, JsonFactory jsonFactory,<z>
, boolean forceUseOfBigDecimal, int maxInMemorySize) {<z>
;<z>
objectMapper.getDeserializationContext();<z>
DefaultDeserializationContext) {<z>
(DefaultDeserializationContext) context).createInstance(<z>
, parser, objectMapper.getInjectableValues());<z>
tokenizer =<z>
context, tokenizeArrays, forceUseOfBigDecimal, maxInMemorySize);<z>
));<z>
) {<z>
.error(ex);<z>
public CommonAnnotationBeanPostProcessor() {<z>
LOWEST_PRECEDENCE - 3);<z>
(PostConstruct.class);<z>
);<z>
{<z>
new SimpleJndiBeanFactory();<z>
{<z>
pd instanceof GenericTypeAwarePropertyDescriptor) {<z>
).getWriteMethodParameter());<z>
Method writeMethod = pd.getWriteMethod();<z>
state(writeMethod != null, "No write method available");<z>
;<z>
] tokenizeToStringArray(<z>
) {<z>
{<z>
;<z>
, delimiters);<z>
<>();<z>
while (st.hasMoreTokens()) {<z>
token = st.nextToken();<z>
{<z>
.trim();<z>
|| token.length() > 0) {<z>
);<z>
);<z>
public StompCommand updateStompCommandAsClientMessage() {<z>
messageType = getMessageType();<z>
MESSAGE) {<z>
("Unexpected message type " + messageType);<z>
StompCommand command = getCommand();<z>
if (command == null) {<z>
StompCommand.SEND;<z>
setHeader(COMMAND_HEADER, command);<z>
.equals(StompCommand.SEND)) {<z>
new IllegalStateException("Unexpected STOMP command " + command);<z>
command;<z>
static void logFastClassGenerationFailure(Method method) {<z>
{<z>
("Failed to generate CGLIB fast class for method: " + method);<z>
, int deliveryMode, int priority, long timeToLive,<z>
completionListener) throws JMSException {<z>
completionListener);<z>
) {<z>
length == 2 &&<z>
] &&<z>
;<z>
(<z>
) throws Exception {<z>
objectName, webRequest);<z>
.initializer != null) {<z>
.initBinder(dataBinder);<z>
(dataBinder, webRequest);<z>
dataBinder;<z>
{<z>
if (this == other) {<z>
;<z>
(!(other instanceof CacheOperationSourcePointcut otherPc)) {<z>
;<z>
));<z>
String toStringAST() {<z>
new StringBuilder("T(");<z>
toStringAST());<z>
.dimensions; d++) {<z>
("[]");<z>
(')');<z>
sb.toString();<z>
, String> unwrap(HttpHeaders headers) {<z>
) {<z>
headers.headers;<z>
return headers.headers;<z>
[] fields, String value) {<z>
;<z>
this.fields = fields;<z>
value = value;<z>
controllerType) {<z>
;<z>
controllerType, RequestMapping.class);<z>
{<z>
return "/";<z>
paths = mapping.path();<z>
) {<z>
"/";<z>
&& logger.isTraceEnabled()) {<z>
"Using first of multiple paths on " + controllerType.getName());<z>
;<z>
getMultipartContentType(String paramOrFileName) {<z>
;<z>
) {<z>
return file.getContentType();<z>
().get(paramOrFileName);<z>
String hintName) {<z>
if (hints == null) {<z>
+ hintName + "'");<z>
hintName);<z>
if (hint == null) {<z>
"'");<z>
;<z>
{<z>
route;<z>
setupRouteVars = routeVars;<z>
;<z>
) {<z>
Part part = getPart(paramOrFileName);<z>
if (part != null) {<z>
HttpHeaders headers = new HttpHeaders();<z>
)) {<z>
(headerName)));<z>
return headers;<z>
return null;<z>
(Throwable ex) {<z>
;<z>
extends A> adviceType) {<z>
);<z>
(availableAdvice)) {<z>
();<z>
size());<z>
Object advice : availableAdvice) {<z>
adviceBean) {<z>
isApplicableToBeanType(parameter.getContainingClass())) {<z>
();<z>
(advice.getClass())) {<z>
);<z>
return result;<z>
{<z>
dataBuffer.readableByteCount();<z>
this.maxInMemorySize == -1 ||<z>
{<z>
(dataBuffer);<z>
();<z>
);<z>
DataBufferLimitException("Form field value exceeded the memory usage limit of " +<z>
.this.maxInMemorySize + " bytes"));<z>
String name) {<z>
, "Cookie name must not be null");<z>
for (Cookie cookie : this.cookies) {<z>
cookie.getName())) {<z>
return cookie;<z>
return null;<z>
) {<z>
.STATUS_ACTIVE);<z>
ex) {<z>
throw new TransactionException("Could not determine JTA transaction status", ex);<z>
() {<z>
pathMatcher != null) {<z>
pathMatcher;<z>
null) {<z>
new AntPathMatcher();<z>
defaultPathMatcher;<z>
boolean equals(@Nullable Object other) {<z>
(this == other) {<z>
true;<z>
getClass()) {<z>
return false;<z>
(PackagesAnnotationFilter) other).prefixes);<z>
Nullable Class<?> clazz) {<z>
) {<z>
"";<z>
getName();<z>
className.lastIndexOf(PACKAGE_SEPARATOR);<z>
packageEndIndex == -1) {<z>
"";<z>
(0, packageEndIndex);<z>
;<z>
throws SchedulerException, IOException {<z>
= new Properties();<z>
!= null) {<z>
(StdSchedulerFactory.PROP_SCHED_CLASS_LOAD_HELPER_CLASS,<z>
));<z>
if (this.taskExecutor != null) {<z>
setProperty(StdSchedulerFactory.PROP_THREAD_POOL_CLASS,<z>
);<z>
SimpleThreadPool.class.getName());<z>
(DEFAULT_THREAD_COUNT));<z>
!= null) {<z>
isDebugEnabled()) {<z>
;<z>
this.configLocation);<z>
.mergePropertiesIntoMap(this.quartzProperties, mergedProps);<z>
if (this.dataSource != null) {<z>
LocalDataSourceJobStore.class.getName());<z>
null) {<z>
, this.schedulerName);<z>
.PROP_SCHED_INSTANCE_NAME);<z>
null) {<z>
.schedulerName = nameProp;<z>
.beanName != null) {<z>
.beanName);<z>
;<z>
.initialize(mergedProps);<z>
, CacheOperationContexts contexts) {<z>
isSynchronized()) {<z>
next();<z>
isConditionPassing(context, CacheOperationExpressionEvaluator.NO_RESULT)) {<z>
);<z>
();<z>
, cache));<z>
{<z>
());<z>
return invokeOperation(invoker);<z>
CacheEvictOperation.class), true,<z>
.NO_RESULT);<z>
CacheableOperation.class));<z>
> cachePutRequests = new ArrayList<>();<z>
(cacheHit == null) {<z>
CacheableOperation.class),<z>
NO_RESULT, cachePutRequests);<z>
cacheValue;<z>
returnValue;<z>
null && !hasCachePut(contexts)) {<z>
cacheHit.get();<z>
;<z>
invoker);<z>
returnValue);<z>
, cachePutRequests);<z>
CachePutRequest cachePutRequest : cachePutRequests) {<z>
cachePutRequest.apply(cacheValue);<z>
, cacheValue);<z>
return returnValue;<z>
StandardScriptFactory(<z>
Nullable Class<?>... scriptInterfaces) {<z>
;<z>
this.scriptEngineName = scriptEngineName;<z>
.scriptSourceLocator = scriptSourceLocator;<z>
scriptInterfaces;<z>
decode(DataBuffer dataBuffer, ResolvableType elementType,<z>
, Object> hints) {<z>
readableByteCount()];<z>
(bytes);<z>
;<z>
(logger.isDebugEnabled()) {<z>
);<z>
> clazz = elementType.toClass();<z>
.get(FILENAME_HINT) : null;<z>
== InputStreamResource.class) {<z>
(bytes)) {<z>
() {<z>
filename;<z>
{<z>
return bytes.length;<z>
)) {<z>
ByteArrayResource(bytes) {<z>
public String getFilename() {<z>
filename;<z>
"Unsupported resource class: " + clazz);<z>
checkDaoConfig() {<z>
{<z>
;<z>
private int readVerificationTypeInfo(<z>
verificationTypeInfoOffset,<z>
final Object[] frame,<z>
int index,<z>
charBuffer,<z>
] labels) {<z>
currentOffset = verificationTypeInfoOffset;<z>
currentOffset++] & 0xFF;<z>
(tag) {<z>
:<z>
Opcodes.TOP;<z>
.ITEM_INTEGER:<z>
INTEGER;<z>
:<z>
] = Opcodes.FLOAT;<z>
:<z>
index] = Opcodes.DOUBLE;<z>
:<z>
LONG;<z>
.ITEM_NULL:<z>
[index] = Opcodes.NULL;<z>
.ITEM_UNINITIALIZED_THIS:<z>
UNINITIALIZED_THIS;<z>
Frame.ITEM_OBJECT:<z>
(currentOffset, charBuffer);<z>
2;<z>
Frame.ITEM_UNINITIALIZED:<z>
labels);<z>
2;<z>
new IllegalArgumentException();<z>
;<z>
beanClass, @Nullable ConstructorArgumentValues cargs,<z>
Nullable MutablePropertyValues pvs) {<z>
(cargs, pvs);<z>
(beanClass);<z>
{<z>
this.customReturnValueHandlers.clear();<z>
customReturnValueHandlers != null) {<z>
.customReturnValueHandlers.addAll(customReturnValueHandlers);<z>
, TransactionDefinition definition)<z>
{<z>
) {<z>
().getSimpleName() +<z>
;<z>
.getTransaction().begin();<z>
null;<z>
MethodProxy methodProxy) throws Throwable {<z>
new CglibMethodInvocation(<z>
, methodProxy);<z>
);<z>
, method, retVal);<z>
;<z>
AopConfigException {<z>
;<z>
) {<z>
return false;<z>
index);<z>
true;<z>
) {<z>
(!this.classLoaderConfigured) {<z>
.proxyClassLoader = classLoader;<z>
int sc) throws IOException {<z>
(false);<z>
sendError(sc);<z>
) {<z>
(sc);<z>
public String getListenerId() {<z>
this.listenerId;<z>
== null) {<z>
();<z>
.listenerId = id;<z>
;<z>
canonicalPropertyName(@Nullable String propertyName) {<z>
{<z>
"";<z>
StringBuilder sb = new StringBuilder(propertyName);<z>
= 0;<z>
while (searchIndex != -1) {<z>
PropertyAccessor.PROPERTY_KEY_PREFIX, searchIndex);<z>
1;<z>
keyStart != -1) {<z>
(<z>
.length());<z>
1) {<z>
(), keyEnd);<z>
&& key.endsWith("\""))) {<z>
+ 1, keyStart + 2);<z>
1);<z>
keyEnd = keyEnd - 2;<z>
();<z>
;<z>
equals(@Nullable Object other) {<z>
(this == other) {<z>
;<z>
{<z>
return false;<z>
method));<z>
,<z>
{<z>
"RepeatableContainers must not be null");<z>
, "AnnotationFilter must not be null");<z>
, repeatableContainers, annotationFilter);<z>
static char theOpenBracketFor(char closeBracket) {<z>
closeBracket == '}') {<z>
'{';<z>
) {<z>
;<z>
'(';<z>
source, Annotation[] annotations,<z>
, AnnotationFilter annotationFilter) {<z>
) {<z>
NONE;<z>
, annotations, repeatableContainers, annotationFilter);<z>
parseQualifierElement(Element ele, AbstractBeanDefinition bd) {<z>
.getAttribute(TYPE_ATTRIBUTE);<z>
StringUtils.hasLength(typeName)) {<z>
("Tag 'qualifier' must have a 'type' attribute", ele);<z>
typeName));<z>
;<z>
setSource(extractSource(ele));<z>
;<z>
hasLength(value)) {<z>
);<z>
.getChildNodes();<z>
{<z>
;<z>
(node, QUALIFIER_ATTRIBUTE_ELEMENT)) {<z>
= (Element) node;<z>
.getAttribute(KEY_ATTRIBUTE);<z>
);<z>
.hasLength(attributeValue)) {<z>
BeanMetadataAttribute(attributeName, attributeValue);<z>
(extractSource(attributeEle));<z>
;<z>
);<z>
bd.addQualifier(qualifier);<z>
);<z>
) {<z>
: paths) {<z>
, cacheControl);<z>
property) throws ELException {<z>
) {<z>
property.toString();<z>
;<z>
(beanName)) {<z>
;<z>
getBean(beanName);<z>
;<z>
{<z>
.parameterTypes.length == 0) {<z>
this.parameterTypes.length;<z>
);<z>
0]) ||<z>
])) {<z>
numUnboundArgs--;<z>
> 0) {<z>
(numUnboundArgs);<z>
.argumentsIntrospected = true;<z>
> inValueType) {<z>
.isAssignableFrom(inValueType) ||<z>
.class.isAssignableFrom(inValueType));<z>
> resume(TransactionSynchronizationManager synchronizationManager,<z>
@Nullable SuspendedResourcesHolder resourcesHolder)<z>
TransactionException {<z>
Void> resume = Mono.empty();<z>
null) {<z>
Object suspendedResources = resourcesHolder.suspendedResources;<z>
!= null) {<z>
= doResume(synchronizationManager, transaction, suspendedResources);<z>
> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations;<z>
suspendedSynchronizations != null) {<z>
;<z>
isolationLevel);<z>
synchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly);<z>
.name);<z>
synchronizationManager, suspendedSynchronizations));<z>
return resume;<z>
getSecWebSocketExtensions() {<z>
String> values = get(SEC_WEBSOCKET_EXTENSIONS);<z>
{<z>
.emptyList();<z>
));<z>
{<z>
WebSocketExtension.parseExtensions(value));<z>
;<z>
{<z>
documentBuilder;<z>
documentBuilderFactoryMonitor) {<z>
== null) {<z>
);<z>
(this.documentBuilderFactory);<z>
.newDocument();<z>
{<z>
;<z>
Object other) {<z>
other) {<z>
true;<z>
{<z>
false;<z>
otherPair = (ConvertiblePair) other;<z>
targetType == otherPair.targetType);<z>
String prefix)<z>
BeanDefinitionStoreException {<z>
.isTraceEnabled()) {<z>
+ encodedResource);<z>
Properties();<z>
.getResource().getInputStream()) {<z>
) {<z>
);<z>
, is);<z>
);<z>
) {<z>
" bean definitions from " + encodedResource);<z>
return count;<z>
{<z>
ex);<z>
protected AbstractNamedValueSyncArgumentResolver(<z>
ConfigurableBeanFactory factory, ReactiveAdapterRegistry registry) {<z>
;<z>
public static Object[] buildValueArray(<z>
<SqlParameter> declaredParams) {<z>
new Object[parsedSql.getTotalParameterCount()];<z>
&& parsedSql.getUnnamedParameterCount() > 0) {<z>
new InvalidDataAccessApiUsageException(<z>
" named parameter(s) and " +<z>
+ " traditional placeholder(s) in statement: " +<z>
));<z>
;<z>
paramNames.size(); i++) {<z>
String paramName = paramNames.get(i);<z>
, paramName, i);<z>
);<z>
instanceof SqlParameterValue) {<z>
i] = paramValue;<z>
, paramValue) :<z>
(paramSource, paramName));<z>
{<z>
(<z>
());<z>
paramArray;<z>
byte[] bytes) {<z>
32];<z>
) {<z>
[i / 2];<z>
) & 0xf];<z>
];<z>
chars;<z>
{<z>
(logger.isTraceEnabled()) {<z>
"Received " + message);<z>
)) {<z>
message);<z>
message)) {<z>
;<z>
(<z>
"Too many messages. Please ensure WebSocketSession.receive() is subscribed to.");<z>
();<z>
DataBuffer dataBuffer) {<z>
.asByteBuffer();<z>
{<z>
byteBuffer);<z>
Mono.empty();<z>
ex) {<z>
ex);<z>
release(dataBuffer);<z>
) {<z>
value.toByteArrayUnsafe();<z>
(this.headers));<z>
, value));<z>
{<z>
;<z>
(ConfigurationClass configClass) {<z>
configClass);<z>
if (skip == null) {<z>
) {<z>
= true;<z>
)) {<z>
importedBy)) {<z>
;<z>
if (allSkipped) {<z>
skip = true;<z>
) {<z>
ConfigurationPhase.REGISTER_BEAN);<z>
skip);<z>
skip;<z>
protected void writeTagDetails(TagWriter tagWriter) throws JspException {<z>
());<z>
boundValue = getBoundValue();<z>
valueType = getBindStatus().getValueType();<z>
== valueType) {<z>
instanceof String) {<z>
String) boundValue);<z>
);<z>
, tagWriter);<z>
;<z>
== null) {<z>
"Attribute 'value' is required when binding to non-boolean values");<z>
: value);<z>
, tagWriter);<z>
(@Nullable Object other) {<z>
this == other) {<z>
return true;<z>
) {<z>
return false;<z>
identifier));<z>
@Nullable Object other) {<z>
this == other) {<z>
;<z>
)) {<z>
;<z>
readPosition == otherBuffer.readPosition &&<z>
.writePosition == otherBuffer.writePosition &&<z>
byteBuffer));<z>
<A> annotationType) {<z>
||<z>
) {<z>
annotationType);<z>
element)<z>
, null, MergedAnnotationSelectors.firstDirectlyDeclared())<z>
orElse(null);<z>
createMessageForPayload(<z>
Nullable Object conversionHint) throws JMSException {<z>
);<z>
toStringAST() {<z>
);<z>
(this.value != null) {<z>
this.value.getValue());<z>
++) {<z>
{<z>
('.');<z>
());<z>
;<z>
@Nullable Object value) {<z>
{<z>
();<z>
state(session != null, "No HttpSession");<z>
name));<z>
public void afterPropertiesSet() {<z>
;<z>
.converters, this.conversionService);<z>
conversionService);<z>
{<z>
applicationContext;<z>
{<z>
("listener");<z>
) {<z>
();<z>
;;) {<z>
();<z>
(prev == State.COMPLETED) {<z>
(prev, State.COMPLETED)) {<z>
()) {<z>
.state);<z>
!= State.WRITING) {<z>
;<z>
public String getMimeType(String filePath) {<z>
filePath);<z>
.mimeTypes.containsKey(extension)) {<z>
);<z>
return MediaTypeFactory.getMediaType(filePath).<z>
::toString)<z>
orElse(null);<z>
{<z>
{<z>
) {<z>
SET_COOKIE, cookie.toString());<z>
clearSynchronization() throws IllegalStateException {<z>
!isSynchronizationActive()) {<z>
("Cannot deactivate transaction synchronization - not active");<z>
);<z>
{<z>
< array.length; i++) {<z>
instanceof List<?> list) {<z>
);<z>
<String> getPrefixesSet(String namespaceUri) {<z>
.notNull(namespaceUri, "No namespaceUri given");<z>
)) {<z>
return Collections.singleton(XMLConstants.DEFAULT_NS_PREFIX);<z>
namespaceUri)) {<z>
.XML_NS_PREFIX);<z>
)) {<z>
(XMLConstants.XMLNS_ATTRIBUTE);<z>
);<z>
Collections.emptySet());<z>
password, @Nullable Charset charset) {<z>
.notNull(username, "Username must not be null");<z>
, ":", "Username must not contain a colon");<z>
, "Password must not be null");<z>
(charset == null) {<z>
StandardCharsets.ISO_8859_1;<z>
charset.newEncoder();<z>
(password)) {<z>
new IllegalArgumentException(<z>
);<z>
+ ":" + password;<z>
encode(credentialsString.getBytes(charset));<z>
;<z>
key, Object value) {<z>
);<z>
;<z>
;<z>
) {<z>
.isErrorEnabled()) {<z>
;<z>
(Object delegate) {<z>
);<z>
this.delegate = delegate;<z>
delegate);<z>
IntroductionInterceptor.class);<z>
);<z>
rollback(TransactionStatus status) throws TransactionException {<z>
isCompleted()) {<z>
new IllegalTransactionStateException(<z>
"Transaction is already completed - do not call commit or rollback more than once per transaction");<z>
defStatus = (DefaultTransactionStatus) status;<z>
defStatus, false);<z>
Object bean, String message) {<z>
('\n');<z>
append("HandlerMethod details: \n");<z>
"]\n");<z>
);<z>
.toString();<z>
() {<z>
>(4);<z>
romePresent) {<z>
("atom", MediaType.APPLICATION_ATOM_XML);<z>
APPLICATION_RSS_XML);<z>
jaxb2Present || jackson2XmlPresent)) {<z>
("xml", MediaType.APPLICATION_XML);<z>
|| jsonbPresent) {<z>
MediaType.APPLICATION_JSON);<z>
if (jackson2SmilePresent) {<z>
"application/x-jackson-smile"));<z>
if (jackson2CborPresent) {<z>
;<z>
;<z>
<?> initLoggingTask(long initialDelay) {<z>
()) {<z>
scheduleWithFixedDelay(<z>
this.toString()),<z>
));<z>
null;<z>
engine) {<z>
isEmpty(this.scripts)) {<z>
.scripts) {<z>
resource = getResource(script);<z>
if (resource == null) {<z>
script + "] not found");<z>
;<z>
Throwable ex) {<z>
script + "]", ex);<z>
{<z>
persistentClass instanceof Class) {<z>
persistentClass).getName();<z>
.persistentClass.toString() : null);<z>
{<z>
(CookieValue.class);<z>
annotation != null, "No CookieValue annotation");<z>
return new CookieValueNamedValueInfo(annotation);<z>
public static void addCollectionConverters(ConverterRegistry converterRegistry) {<z>
converterRegistry;<z>
);<z>
));<z>
.addConverter(new ArrayToArrayConverter(conversionService));<z>
);<z>
;<z>
);<z>
StringToArrayConverter(conversionService));<z>
addConverter(new ArrayToObjectConverter(conversionService));<z>
(new ObjectToArrayConverter(conversionService));<z>
addConverter(new CollectionToStringConverter(conversionService));<z>
(new StringToCollectionConverter(conversionService));<z>
(conversionService));<z>
addConverter(new ObjectToCollectionConverter(conversionService));<z>
);<z>
) {<z>
UrlResource) && request != null &&<z>
) &&<z>
getCachedPath(request) instanceof PathContainer);<z>
) {<z>
;<z>
(scope) {<z>
case PAGE_SCOPE:<z>
;<z>
case REQUEST_SCOPE:<z>
);<z>
SESSION_SCOPE:<z>
(false);<z>
.getAttribute(name) : null);<z>
:<z>
getAttribute(name);<z>
throw new IllegalArgumentException("Invalid scope: " + scope);<z>
T> responseType,<z>
{<z>
, responseType);<z>
=<z>
, getMessageConverters(), logger);<z>
responseExtractor, uriVariables);<z>
args) throws Throwable {<z>
.getName();<z>
== method.getDeclaringClass()) {<z>
(methodName.equals("equals")) {<z>
(proxy == args[0]);<z>
("hashCode")) {<z>
);<z>
.equals(methodName)) {<z>
getAttributes();<z>
if ("visit".equals(methodName)) {<z>
(args[0]);<z>
null;<z>
{<z>
toString();<z>
method);<z>
(Connection connection, EncodedResource resource,<z>
, boolean ignoreFailedDrops,<z>
Nullable String separator, String blockCommentStartDelimiter,<z>
throws ScriptException {<z>
) {<z>
debug("Executing SQL script from " + resource);<z>
= System.currentTimeMillis();<z>
, separator)<z>
);<z>
AtomicInteger statementNumber = new AtomicInteger();<z>
(script -> {<z>
;<z>
) {<z>
DEFAULT_STATEMENT_SEPARATOR;<z>
(separatorToUse) &&<z>
(resource, script, separatorToUse, commentPrefixes,<z>
) {<z>
separatorToUse = FALLBACK_STATEMENT_SEPARATOR;<z>
separatorToUse, commentPrefixes,<z>
blockCommentEndDelimiter);<z>
concatMap(statement -> {<z>
incrementAndGet();<z>
continueOnError, ignoreFailedDrops, statementNumber);<z>
);<z>
if (logger.isDebugEnabled()) {<z>
(() -> {<z>
.currentTimeMillis() - startTime;<z>
+ " in " + elapsedTime + " ms.");<z>
);<z>
-> !(ex instanceof ScriptException),<z>
UncategorizedScriptException(<z>
"Failed to execute database script from resource [" + resource + "]", ex))<z>
then();<z>
() {<z>
SpringHibernateJpaPersistenceProvider();<z>
= SessionFactory.class;<z>
Session.class;<z>
<?>> getBaseObjectWriters() {<z>
writers = new ArrayList<>();<z>
kotlinSerializationJsonPresent) {<z>
<>(getKotlinSerializationJsonEncoder()));<z>
if (jackson2Present) {<z>
()));<z>
if (jackson2SmilePresent) {<z>
null ?<z>
: new Jackson2SmileEncoder()));<z>
(jaxb2Present && !shouldIgnoreXml) {<z>
(this.jaxb2Encoder != null ?<z>
()));<z>
writers;<z>
) {<z>
if (channelName.equals("brokerChannel")) {<z>
return null;<z>
);<z>
.availableProcessors() * 2);<z>
MAX_VALUE);<z>
, Integer.MAX_VALUE);<z>
, true);<z>
executorDef;<z>
resolveDestination(String name) throws DestinationResolutionException {<z>
;<z>
== null) {<z>
;<z>
resolveDestination(name);<z>
name, destination);<z>
return destination;<z>
protected void marshalStreamResult(Object graph, StreamResult streamResult)<z>
IOException {<z>
null) {<z>
;<z>
) {<z>
);<z>
new IllegalArgumentException("StreamResult contains neither OutputStream nor Writer");<z>
convertException(RuntimeException ex) {<z>
) ?<z>
:<z>
.convertJpaAccessExceptionIfPossible(ex);<z>
dae != null ? dae : ex);<z>
visitEnd() {<z>
) {<z>
av.visitEnd();<z>
toString() {<z>
+<z>
() + "]" : "no target class") +<z>
isStatic ? "static" : "dynamic");<z>
() {<z>
= new TreeSet<>(entryComparator);<z>
;<z>
Collections.synchronizedSet(sortedEntries);<z>
(Object message, Throwable exception) {<z>
{<z>
message), null, exception);<z>
) {<z>
(msg);<z>
this.resourceDescription = null;<z>
;<z>
