> filterAttributes(Predicate<String> predicate) {<z>
(this.attributeFilter != null) {<z>
;<z>
rootAttributes,<z>
,<z>
resolvedRootMirrors, this.resolvedMirrors);<z>
clazz, @Nullable PropertyValues pvs) {<z>
getName());<z>
.injectionMetadataCache.get(cacheKey);<z>
(metadata, clazz)) {<z>
synchronized (this.injectionMetadataCache) {<z>
;<z>
needsRefresh(metadata, clazz)) {<z>
!= null) {<z>
(pvs);<z>
= buildAutowiringMetadata(clazz);<z>
);<z>
return metadata;<z>
ParserContext parserContext) {<z>
(CacheManagementConfigUtils.CACHE_ASPECT_BEAN_NAME)) {<z>
def = new RootBeanDefinition();<z>
def.setBeanClassName(CACHE_ASPECT_CLASS_NAME);<z>
;<z>
def, false);<z>
);<z>
CacheManagementConfigUtils.CACHE_ASPECT_BEAN_NAME));<z>
HttpServletResponse response, ByteArrayOutputStream baos) throws IOException {<z>
getContentType());<z>
);<z>
;<z>
writeTo(out);<z>
.flush();<z>
... args) {<z>
notNull(pointcut, "Pointcut must not be null");<z>
== Pointcut.TRUE) {<z>
;<z>
matches(targetClass)) {<z>
= pointcut.getMethodMatcher();<z>
, targetClass)) {<z>
);<z>
;<z>
protected WebSocketHandler decorateWebSocketHandler(WebSocketHandler handler) {<z>
.getDecoratorFactories()) {<z>
.decorate(handler);<z>
return handler;<z>
inputStream,<z>
elementType,<z>
Nullable Map<String, Object> hints) {<z>
-><z>
, hints));<z>
int attributeIndex, boolean useConventionMapping, boolean forMirrorResolution) {<z>
mapping = this.mapping;<z>
{<z>
.mapping.getAliasMapping(attributeIndex);<z>
(mappedIndex == -1 && useConventionMapping) {<z>
(attributeIndex);<z>
if (mappedIndex != -1) {<z>
mapping.getRoot();<z>
= mappedIndex;<z>
(!forMirrorResolution) {<z>
;<z>
== -1) {<z>
null;<z>
== 0) {<z>
attributeIndex);<z>
, this.rootAttributes);<z>
getDefaultValue());<z>
);<z>
extractStereotype(TypeFilter filter) {<z>
filter instanceof AnnotationTypeFilter) {<z>
getAnnotationType().getName();<z>
if (filter instanceof AssignableTypeFilter) {<z>
getTargetType().getName();<z>
;<z>
{<z>
state);<z>
{<z>
int declaredParamCount = method.getParameterCount();<z>
length) {<z>
throw new SpelEvaluationException(SpelMessage.INCORRECT_NUMBER_OF_ARGUMENTS_TO_FUNCTION,<z>
.length, declaredParamCount);<z>
) {<z>
getStartPosition(),<z>
);<z>
state.getEvaluationContext().getTypeConverter();<z>
method);<z>
if (method.isVarArgs()) {<z>
.setupArgumentsForVarargsInvocation(<z>
(), functionArgs);<z>
= false;<z>
.makeAccessible(method);<z>
;<z>
= !argumentConversionOccurred;<z>
;<z>
catch (Exception ex) {<z>
EXCEPTION_DURING_FUNCTION_CALL,<z>
ex.getMessage());<z>
if (compilable) {<z>
getReturnType());<z>
= method;<z>
= null;<z>
method = null;<z>
(ModelAndView mav, String name) {<z>
.MODEL_KEY_PREFIX + name);<z>
);<z>
;<z>
) {<z>
.nonAnnotatedClasses.contains(targetType) &&<z>
.isCandidateClass(targetType, EventListener.class) &&<z>
)) {<z>
Map<Method, EventListener> annotatedMethods = null;<z>
annotatedMethods = MethodIntrospector.selectMethods(targetType,<z>
) method -><z>
EventListener.class));<z>
Throwable ex) {<z>
.isDebugEnabled()) {<z>
"'", ex);<z>
.isEmpty(annotatedMethods)) {<z>
;<z>
)) {<z>
getName());<z>
;<z>
);<z>
;<z>
);<z>
) {<z>
{<z>
{<z>
;<z>
<?> applicationListener =<z>
.createApplicationListener(beanName, targetType, methodToUse);<z>
applicationListener instanceof ApplicationListenerMethodAdapter) {<z>
.evaluator);<z>
addApplicationListener(applicationListener);<z>
logger.isDebugEnabled()) {<z>
(annotatedMethods.size() + " @EventListener methods processed on bean '" +<z>
);<z>
featuresToDisable(Object... featuresToDisable) {<z>
) {<z>
.put(feature, Boolean.FALSE);<z>
this;<z>
(MetadataReader metadataReader) {<z>
getAnnotationMetadata();<z>
||<z>
;<z>
, BeanDefinitionHolder definitionHolder, ParserContext parserContext) {<z>
= parserContext.getRegistry();<z>
.getBeanName();<z>
.getBeanDefinition();<z>
existingBeanName + ".TARGET");<z>
createInterceptorDefinition(node);<z>
+ getInterceptorNameSuffix(interceptorDefinition);<z>
registerBeanDefinition(<z>
, interceptorName), registry);<z>
= definitionHolder;<z>
{<z>
);<z>
class);<z>
(targetDefinition.getScope());<z>
setLazyInit(targetDefinition.isLazyInit());<z>
(targetHolder);<z>
).add("target", targetHolder);<z>
));<z>
));<z>
targetDefinition.isPrimary());<z>
if (targetDefinition instanceof AbstractBeanDefinition) {<z>
) targetDefinition);<z>
existingBeanName);<z>
getBeanDefinition());<z>
;<z>
WebSocketMessage<?> webSocketMessage) {<z>
1);<z>
]>> messages;<z>
webSocketMessage);<z>
{<z>
;<z>
: messages) {<z>
connectionHandler.handleMessage(message);<z>
public long nextBackOff() {<z>
) {<z>
STOP;<z>
long nextInterval = computeNextInterval();<z>
nextInterval;<z>
return nextInterval;<z>
) {<z>
body)<z>
.statusCode)<z>
putAll(this.headers))<z>
-> cookies.addAll(this.cookies))<z>
);<z>
) throws BeansException {<z>
isEmpty(args)) {<z>
(<z>
;<z>
requiredType);<z>
{<z>
.hasText(typeName)) {<z>
);<z>
typeName;<z>
protected boolean checkPropertySkipping(@Nullable PropertyValues pvs) {<z>
skip = this.skip;<z>
!= null) {<z>
skip;<z>
{<z>
;<z>
;<z>
(pvs) {<z>
;<z>
skip != null) {<z>
skip;<z>
null) {<z>
))) {<z>
= true;<z>
return true;<z>
if (pvs instanceof MutablePropertyValues) {<z>
());<z>
;<z>
;<z>
extends Publisher<T>> PartBuilder asyncPart(<z>
T> typeReference) {<z>
);<z>
publisher, "'publisher' must not be null");<z>
typeReference, "'typeReference' must not be null");<z>
typeReference);<z>
name, builder);<z>
;<z>
PropertyTokenHolder tokens) {<z>
.keys != null, "No token keys");<z>
(tokens.actualName);<z>
canonicalName;<z>
];<z>
);<z>
propValue;<z>
;<z>
) {<z>
), this.nestedPath + tokens.canonicalName,<z>
);<z>
== null) {<z>
(isAutoGrowNestedPaths()) {<z>
canonicalName.lastIndexOf('[');<z>
(0, lastKeyIndex);<z>
setDefaultValue(getterTokens);<z>
, this.nestedPath + tokens.canonicalName,<z>
;<z>
return propValue;<z>
removeAdvisor(int index) throws AopConfigException {<z>
if (isFrozen()) {<z>
"Cannot remove Advisor: Configuration is frozen.");<z>
size() - 1) {<z>
" is out of bounds: " +<z>
.size() + " advisors.");<z>
this.advisors.remove(index);<z>
) {<z>
getInterfaces()) {<z>
(ifc);<z>
);<z>
getFallbackTimeZone() {<z>
if (jstlPresent) {<z>
);<z>
{<z>
timeZone;<z>
null;<z>
{<z>
Assert.notNull(type, "'type' must not be null");<z>
.isInterface()) {<z>
(EmptyTargetSource.INSTANCE);<z>
addInterface(type);<z>
Supplier.class);<z>
(interceptor);<z>
();<z>
;<z>
.setSuperclass(type);<z>
class});<z>
SpringNamingPolicy.INSTANCE);<z>
);<z>
enhancer.createClass();<z>
proxy = null;<z>
()) {<z>
;<z>
(ObjenesisException ex) {<z>
("Objenesis failed, falling back to default constructor", ex);<z>
proxy == null) {<z>
).newInstance();<z>
catch (Throwable ex) {<z>
new IllegalStateException("Unable to instantiate proxy " +<z>
;<z>
Callback[] {interceptor});<z>
T) proxy;<z>
() {<z>
HttpStatus) {<z>
status).value();<z>
this.status;<z>
InvalidMetadataException {<z>
.TYPE_HIERARCHY)<z>
.class).withNonMergedAttributes();<z>
metadata.ManagedOperation.class);<z>
) {<z>
this.destinationResolver != null, "DestinationResolver is required to resolve destination names");<z>
;<z>
void onHeaders(Response response) {<z>
)) {<z>
toHttpHeaders(response.getHeaders()));<z>
(String id, SimpUserRegistry registry) {<z>
id;<z>
.getUsers();<z>
));<z>
) {<z>
), new TransferSimpUser(user));<z>
, Object newArray, TypeConverter typeConverter,<z>
initializer, Class<?> componentType) {<z>
.valueOf(componentType);<z>
newObjectArray = (Object[]) newArray;<z>
) {<z>
getChild(i);<z>
.getValue(state);<z>
[i] = typeConverter.convertValue(arrayEntry,<z>
);<z>
) {<z>
!hasPattern(patterns)) {<z>
return EMPTY_PATH_PATTERN;<z>
(patterns.length);<z>
pattern : patterns) {<z>
.startsWith("/")) {<z>
pattern;<z>
.add(pattern);<z>
;<z>
, DependencyDescriptor descriptor) {<z>
;<z>
requiredType);<z>
primaryCandidate != null) {<z>
return primaryCandidate;<z>
, requiredType);<z>
priorityCandidate != null) {<z>
return priorityCandidate;<z>
entrySet()) {<z>
getKey();<z>
getValue();<z>
beanInstance)) ||<z>
) {<z>
candidateName;<z>
null;<z>
String elementNamespace, DataHandler dataHandler) {<z>
new URI(elementNamespace);<z>
getHost();<z>
{<z>
);<z>
) {<z>
(field.contains("?")) {<z>
"*";<z>
, max);<z>
returning(ResolvableType returnType) {<z>
= returnType.toString();<z>
+ expected;<z>
(m).toString()));<z>
return this;<z>
String path) {<z>
return result -> {<z>
;<z>
cookie.getPath());<z>
public SQLErrorCodes getErrorCodes(String databaseName) {<z>
;<z>
errorCodesMap.get(databaseName);<z>
(sec == null) {<z>
this.errorCodesMap.values()) {<z>
candidate.getDatabaseProductNames(), databaseName)) {<z>
sec = candidate;<z>
if (sec != null) {<z>
, sec);<z>
(logger.isDebugEnabled()) {<z>
.debug("SQL error codes for '" + databaseName + "' found");<z>
;<z>
)) {<z>
"' not found");<z>
);<z>
setConnectTimeout(int connectTimeout) {<z>
()<z>
TimeUnit.MILLISECONDS)<z>
.build();<z>
> matcher) {<z>
result -> {<z>
, name);<z>
getComment(), matcher);<z>
public void verify() {<z>
for (String pathSegment : getPathSegments()) {<z>
verifyUriComponent(pathSegment, Type.PATH_SEGMENT);<z>
String descriptor) {<z>
int typeDescriptorOffset =<z>
Type.getReturnTypeOffset(descriptor) : 0;<z>
symbolTable, descriptor, typeDescriptorOffset);<z>
abstractType != 0) {<z>
(abstractType);<z>
|| abstractType == DOUBLE) {<z>
push(TOP);<z>
Nullable String parameterName) {<z>
== null) {<z>
;<z>
else if (isStoresUpperCaseIdentifiers()) {<z>
toUpperCase();<z>
isStoresLowerCaseIdentifiers()) {<z>
.toLowerCase();<z>
;<z>
(<z>
,<z>
> repositoryAnnotationType) {<z>
(persistenceExceptionTranslator);<z>
AnnotationMatchingPointcut(repositoryAnnotationType, true);<z>
Class<?>> ifcs) {<z>
.class) {<z>
proxySuperClass.getDeclaredMethods();<z>
Method method : methods) {<z>
int mod = method.getModifiers();<z>
{<z>
.isFinal(mod)) {<z>
) {<z>
"Unable to proxy interface-implementing method [" + method + "] because " +<z>
"it is marked as final: Consider using interface-based JDK proxies instead!");<z>
logger.isDebugEnabled()) {<z>
+ method + "] cannot get proxied via CGLIB: " +<z>
"might lead to NPEs against uninitialized fields in the proxy instance.");<z>
isProtected(mod) &&<z>
() != proxyClassLoader) {<z>
+ method + "] is package-visible across different ClassLoaders " +<z>
;<z>
), proxyClassLoader, ifcs);<z>
match(HttpServletRequest request, String pattern) {<z>
(), "This HandlerMapping uses PathPatterns.");<z>
UrlPathHelper.getResolvedLookupPath(request);<z>
)) {<z>
));<z>
()) {<z>
pattern + "/", lookupPath)) {<z>
"/", lookupPath, getPathMatcher());<z>
null;<z>
pa, String nestedPath) {<z>
{<z>
nestedPath;<z>
nestedPath) + 1);<z>
) {<z>
getRawType() : type);<z>
>) rawType : null);<z>
())<z>
)<z>
-> {<z>
() != null) {<z>
mediaType.getSubtype());<z>
return mediaType;<z>
);<z>
requiredType) throws NamingException {<z>
);<z>
convertJndiName(jndiName);<z>
jndiObject;<z>
, requiredType);<z>
NamingException ex) {<z>
(jndiName)) {<z>
()) {<z>
+<z>
;<z>
lookup(jndiName, requiredType);<z>
;<z>
)) {<z>
"]");<z>
;<z>
private void logMappings() {<z>
.isDebugEnabled()) {<z>
));<z>
!= null) {<z>
"/", getRootHandler());<z>
null) {<z>
());<z>
;<z>
) {<z>
> patterns = new ArrayList<>();<z>
{<z>
"/");<z>
) != null) {<z>
);<z>
));<z>
));<z>
Object> handleBindException(<z>
) {<z>
, null, headers, status, request);<z>
(T instance) {<z>
(instance, "Instance to match must not be null");<z>
this.includes.isEmpty();<z>
excludes.isEmpty();<z>
&& !excludesSet) {<z>
;<z>
this.includes);<z>
instance, this.excludes);<z>
if (!includesSet) {<z>
return !matchExcludes;<z>
excludesSet) {<z>
return matchIncludes;<z>
matchExcludes;<z>
(@Nullable Object other) {<z>
this == other ||<z>
other instanceof DynamicAdvisedInterceptor &&<z>
));<z>
, @Nullable Object[] specificInterceptors) {<z>
();<z>
);<z>
(specificInterceptors != null) {<z>
.length > 0) {<z>
(specificInterceptors));<z>
length > 0) {<z>
{<z>
, Arrays.asList(commonInterceptors));<z>
Arrays.asList(commonInterceptors));<z>
(logger.isTraceEnabled()) {<z>
.length;<z>
: 0);<z>
"Creating implicit proxy for bean '" + beanName + "' with " + nrOfCommonInterceptors +<z>
nrOfSpecificInterceptors + " specific interceptors");<z>
new Advisor[allInterceptors.size()];<z>
size(); i++) {<z>
get(i));<z>
;<z>
) {<z>
(this == other) {<z>
true;<z>
{<z>
;<z>
otherTv.value) &&<z>
null) ||<z>
otherTv.getTypeDescriptor())));<z>
List<Element> pathElements) {<z>
StringBuilder();<z>
< max; i++) {<z>
);<z>
PathSegment) {<z>
));<z>
(element.value());<z>
.toString();<z>
UserDestinationMessageHandler(SubscribableChannel clientInboundChannel,<z>
{<z>
;<z>
Assert.notNull(brokerChannel, "'brokerChannel' must not be null");<z>
(resolver, "resolver must not be null");<z>
clientInboundChannel = clientInboundChannel;<z>
brokerChannel = brokerChannel;<z>
= new SimpMessagingTemplate(brokerChannel);<z>
;<z>
Class<?> getTargetType() {<z>
resolvedTargetType != null) {<z>
this.resolvedTargetType;<z>
.targetType;<z>
null);<z>
(MethodParameter methodParameter) {<z>
);<z>
);<z>
;<z>
);<z>
this.methodParameter = methodParameter;<z>
typeName,<z>
SpelEvaluationException {<z>
= state.getEvaluationContext();<z>
;<z>
: ctorResolvers) {<z>
typeName, argumentTypes);<z>
if (ce != null) {<z>
ce;<z>
{<z>
getStartPosition(), ex,<z>
.CONSTRUCTOR_INVOCATION_PROBLEM, typeName,<z>
);<z>
), SpelMessage.CONSTRUCTOR_NOT_FOUND, typeName,<z>
;<z>
RootBeanDefinition beanDefinition) {<z>
new Enhancer();<z>
.getBeanClass());<z>
.setNamingPolicy(SpringNamingPolicy.INSTANCE);<z>
if (this.owner instanceof ConfigurableBeanFactory) {<z>
.getBeanClassLoader();<z>
));<z>
MethodOverrideCallbackFilter(beanDefinition));<z>
CALLBACK_TYPES);<z>
return enhancer.createClass();<z>
payloadClass) {<z>
String.class == payloadClass,<z>
-> "Payload class must be byte[] or String: " + payloadClass);<z>
payloadClass;<z>
super String> matcher) {<z>
);<z>
(() -> {<z>
;<z>
domain, matcher);<z>
);<z>
this.responseSpec;<z>
void makeAccessible(Constructor<?> ctor) {<z>
)) ||<z>
!ctor.isAccessible()) {<z>
ctor.setAccessible(true);<z>
() {<z>
(headers instanceof HttpFields.Mutable mutableHttpFields)) {<z>
;<z>
.currentName == null) {<z>
);<z>
contains(this.currentName)) {<z>
;<z>
mutableHttpFields.remove(this.currentName);<z>
) {<z>
DefaultCookie defaultCookie) {<z>
) != null) {<z>
);<z>
null;<z>
ClassNotFoundException {<z>
typeName = getTargetTypeName();<z>
typeName == null) {<z>
return null;<z>
typeName, classLoader);<z>
resolvedClass;<z>
return resolvedClass;<z>
MessageConversionException {<z>
if (object instanceof Message) {<z>
Message) object;<z>
) {<z>
(String) object, session);<z>
object instanceof byte[]) {<z>
);<z>
(object instanceof Map) {<z>
>) object, session);<z>
{<z>
object), session);<z>
("Cannot convert object of type [" +<z>
"] to JMS message. Supported message " +<z>
"payloads are: String, byte array, Map<String,?>, Serializable object.");<z>
() {<z>
);<z>
.getClassLoader();<z>
state(classLoader != null, "No ClassLoader");<z>
return classLoader;<z>
static void validateCookieName(String name) {<z>
) {<z>
charAt(i);<z>
<= 0x1F || c == 0x7F) {<z>
throw new IllegalArgumentException(<z>
);<z>
indexOf(c) >= 0) {<z>
(<z>
);<z>
) {<z>
IllegalArgumentException(<z>
Integer.toHexString(c));<z>
, DataBufferFactory bufferFactory,<z>
hints) {<z>
bufferFactory, false);<z>
(WebApplicationContext wac) {<z>
this.viewResolvers :<z>
new InternalResourceViewResolver()));<z>
.viewResolvers) {<z>
{<z>
setApplicationContext(wac);<z>
this.viewResolvers;<z>
webSocket) {<z>
readEventMethod.invoke(webSocket);<z>
ex) {<z>
ex);<z>
findSubscriptions(Message<?> message) {<z>
;<z>
headers);<z>
equals(type)) {<z>
);<z>
getDestination(headers);<z>
null) {<z>
)) {<z>
"No destination in " + message);<z>
EMPTY_MAP;<z>
, message);<z>
<Object>> buildDynamicPropertiesMap() {<z>
> map = new LinkedHashMap<>();<z>
(name, valueSupplier) -> {<z>
);<z>
"'valueSupplier' must not be null");<z>
name, valueSupplier);<z>
this.methods.forEach(method -> {<z>
);<z>
);<z>
;<z>
map);<z>
() {<z>
StringBuilder result = getAttributeDescription();<z>
rollbackRules != null) {<z>
: this.rollbackRules) {<z>
: PREFIX_ROLLBACK_RULE);<z>
rule.getExceptionName());<z>
();<z>
MvcResult mvcResult) {<z>
mvcResult.getAsyncResult();<z>
{<z>
request = mvcResult.getRequest();<z>
ASYNC);<z>
request.setAsyncStarted(false);<z>
;<z>
) {<z>
(JpaTransactionObject) transaction;<z>
null, false);<z>
= (EntityManagerHolder)<z>
TransactionSynchronizationManager.unbindResource(obtainEntityManagerFactory());<z>
txObject.setConnectionHolder(null);<z>
;<z>
{<z>
.unbindResource(getDataSource());<z>
connectionHolder);<z>
, Object> arguments) {<z>
GroovyShell groovyShell = new GroovyShell(<z>
.compilerConfiguration);<z>
?<z>
) : null);<z>
) {<z>
;<z>
());<z>
IOException ex) {<z>
;<z>
(GroovyRuntimeException ex) {<z>
new ScriptCompilationException(script, ex);<z>
) {<z>
) {<z>
error(throwable);<z>
)<z>
{<z>
getEncoding()) ?<z>
DEFAULT_CHARSET);<z>
.getHeaders().getContentType();<z>
null) {<z>
, charset);<z>
().setContentType(contentType);<z>
);<z>
charset);<z>
(wireFeed, writer);<z>
{<z>
), ex);<z>
{<z>
pageSize != this.pageSize) {<z>
this.pageSize = pageSize;<z>
{<z>
.page = 0;<z>
DefaultTransactionStatus status, TransactionDefinition definition) {<z>
if (status.isNewSynchronization()) {<z>
status.hasTransaction());<z>
(<z>
TransactionDefinition.ISOLATION_DEFAULT ?<z>
) : null);<z>
));<z>
.getName());<z>
TransactionSynchronizationManager.initSynchronization();<z>
(AnnotationFormatterFactory<? extends Annotation> annotationFormatterFactory) {<z>
getAnnotationType(annotationFormatterFactory);<z>
!= null && annotationFormatterFactory instanceof EmbeddedValueResolverAware) {<z>
(this.embeddedValueResolver);<z>
;<z>
fieldTypes) {<z>
annotationFormatterFactory, fieldType));<z>
fieldType));<z>
public HandlerMapping webSocketHandlerMapping(@Nullable TaskScheduler defaultSockJsTaskScheduler) {<z>
);<z>
if (registry.requiresTaskScheduler()) {<z>
TaskScheduler scheduler = defaultSockJsTaskScheduler;<z>
);<z>
setTaskScheduler(scheduler);<z>
return registry.getHandlerMapping();<z>
tagName) throws JspException {<z>
()) {<z>
);<z>
tagName);<z>
).append(tagName);<z>
parseFrom(<z>
[] data,<z>
ExtensionRegistryLite extensionRegistry)<z>
.protobuf.InvalidProtocolBufferException {<z>
, extensionRegistry);<z>
) {<z>
();<z>
;<z>
= null;<z>
.bodyContent = null;<z>
(final Attribute attribute) {<z>
attribute.nextAttribute = firstAttribute;<z>
= attribute;<z>
clazz) {<z>
> result = null;<z>
{<z>
{<z>
;<z>
;<z>
? getSupportedMediaTypes() : result);<z>
String name, MethodParameter parameter) throws ServerWebInputException {<z>
);<z>
+ "' " +<z>
+ paramInfo, parameter);<z>
IOException {<z>
()) {<z>
publicId +<z>
"] and system id [" + systemId + "]");<z>
) {<z>
.get(systemId);<z>
startsWith("https:")) {<z>
systemId.substring(6));<z>
{<z>
;<z>
;<z>
setPublicId(publicId);<z>
(systemId);<z>
(logger.isTraceEnabled()) {<z>
resourceLocation);<z>
;<z>
) {<z>
if (logger.isDebugEnabled()) {<z>
ex);<z>
return null;<z>
String name, MethodParameter parameter, ServerWebExchange exchange) {<z>
().getFirst(name);<z>
parameter.getNestedParameterType();<z>
{<z>
return cookie;<z>
;<z>
() {<z>
(this.source) {<z>
getPropertyNames();<z>
() {<z>
.fileStorageDirectory<z>
map(this::createFileState)<z>
this.blockingOperationScheduler)<z>
PartGenerator.this::emitError);<z>
Nullable ClassLoader classLoader) {<z>
);<z>
configSuperClass);<z>
{EnhancedConfiguration.class});<z>
setUseFactory(false);<z>
SpringNamingPolicy.INSTANCE);<z>
.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader));<z>
.setCallbackFilter(CALLBACK_FILTER);<z>
.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());<z>
;<z>
{<z>
attributesFor(importMetadata, EnableLoadTimeWeaving.class);<z>
if (this.enableLTW == null) {<z>
(<z>
getClassName());<z>
void afterPropertiesSet() throws BeansException {<z>
{<z>
: this.localesToInitialize) {<z>
initFactory(locale);<z>
) {<z>
;<z>
.size() > bufSize) {<z>
true);<z>
IOException {<z>
, this.encoding)) {<z>
);<z>
value = object;<z>
null;<z>
null;<z>
container) {<z>
.getValue();<z>
);<z>
= container.getFilters();<z>
objectWriter = (serializationView != null ?<z>
writer());<z>
(filters != null) {<z>
filters);<z>
, value);<z>
;<z>
generator.flush();<z>
() {<z>
readMethod != null) {<z>
);<z>
if (index != -1) {<z>
3;<z>
getName().indexOf("is");<z>
if (index != -1) {<z>
index += 2;<z>
0;<z>
));<z>
if (this.writeMethod != null) {<z>
;<z>
== -1) {<z>
"Not a setter method");<z>
3;<z>
).substring(index));<z>
("Property is neither readable nor writeable");<z>
AspectJAfterAdvice(<z>
, AspectInstanceFactory aif) {<z>
, aif);<z>
TagWriter tagWriter) throws JspException {<z>
.showPassword) {<z>
;<z>
()));<z>
() throws JmsException {<z>
lifecycleMonitor) {<z>
= null;<z>
.start();<z>
private static DefaultListableBeanFactory unwrapDefaultListableBeanFactory(BeanDefinitionRegistry registry) {<z>
registry instanceof DefaultListableBeanFactory) {<z>
DefaultListableBeanFactory) registry;<z>
) {<z>
(GenericApplicationContext) registry).getDefaultListableBeanFactory();<z>
return null;<z>
() {<z>
publishBrokerAvailableEvent();<z>
!= null) {<z>
();<z>
if (interval > 0) {<z>
(), interval);<z>
Assert.isTrue(getHeartbeatValue() == null ||<z>
[1] == 0),<z>
"Heartbeat values configured but no TaskScheduler provided");<z>
void destroy() {<z>
: this.scheduledTasks) {<z>
();<z>
{<z>
;<z>
) {<z>
(HttpStatus.INTERNAL_SERVER_ERROR, reason, cause);<z>
;<z>
this.parameter = parameter;<z>
throws NamingException {<z>
{<z>
+ root + "]");<z>
new NameClassPairEnumeration(this, root);<z>
, int columnIndex) throws SQLException {<z>
;<z>
this.wrapAsLob) {<z>
(columnIndex);<z>
);<z>
.getCharacterStream(columnIndex);<z>
transaction, TransactionDefinition definition) {<z>
) != TransactionDefinition.ISOLATION_DEFAULT) {<z>
);<z>
();<z>
) transaction;<z>
con = null;<z>
= null;<z>
;<z>
{<z>
LazyJmsResourceHolder(connectionFactory);<z>
;<z>
= createSession(con);<z>
if (logger.isDebugEnabled()) {<z>
session + "] from Connection [" + con + "]");<z>
new JmsResourceHolder(connectionFactory, con, session);<z>
.setSynchronizedWithTransaction(true);<z>
(definition);<z>
TransactionDefinition.TIMEOUT_DEFAULT) {<z>
(timeout);<z>
.setResourceHolder(resourceHolder);<z>
, resourceHolder);<z>
(Throwable ex) {<z>
(session != null) {<z>
);<z>
(Throwable ex2) {<z>
if (con != null) {<z>
);<z>
Throwable ex2) {<z>
new CannotCreateTransactionException("Could not create JMS transaction", ex);<z>
addAspect(Object aspectInstance) {<z>
();<z>
aspectClass.getName();<z>
, aspectName);<z>
!= PerClauseKind.SINGLETON) {<z>
throw new IllegalArgumentException(<z>
aspectClass.getName() + "] does not define a singleton aspect");<z>
aspectName));<z>
public TransactionAssert isInTransaction(boolean expected) {<z>
))<z>
"active transaction")<z>
);<z>
this;<z>
{<z>
(Object name) {<z>
return reservedClassNames.contains(name);<z>
) {<z>
{<z>
);<z>
source;<z>
lbf, Class<T> type)<z>
BeansException {<z>
);<z>
4);<z>
getBeansOfType(type));<z>
{<z>
instanceof ListableBeanFactory) {<z>
Map<String, T> parentResult = beansOfTypeIncludingAncestors(<z>
, type);<z>
) -> {<z>
hbf.containsLocalBean(beanName)) {<z>
beanName, beanInstance);<z>
;<z>
return result;<z>
public AnnotationVisitor visitTryCatchAnnotation(<z>
boolean visible) {<z>
(api < Opcodes.ASM5) {<z>
throw new UnsupportedOperationException(REQUIRES_ASM5);<z>
mv != null) {<z>
typeRef, typePath, descriptor, visible);<z>
;<z>
public static DescriptorComparison checkNumericCompatibility(<z>
rightDeclaredDescriptor,<z>
String leftActualDescriptor, @Nullable String rightActualDescriptor) {<z>
ld = leftDeclaredDescriptor;<z>
= rightDeclaredDescriptor;<z>
(ld);<z>
boolean rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd);<z>
.nullSafeEquals(ld, leftActualDescriptor)) {<z>
ld = leftActualDescriptor;<z>
;<z>
, rightActualDescriptor)) {<z>
rightActualDescriptor;<z>
);<z>
rightNumeric) {<z>
(ld, rd)) {<z>
ld));<z>
;<z>
NOT_NUMBERS;<z>
) {<z>
, index);<z>
(length >= 0, "length %d must be >= 0", length);<z>
, this.capacity);<z>
);<z>
equals(@Nullable Object other) {<z>
== other) {<z>
;<z>
!(other instanceof Credentials otherCred)) {<z>
false;<z>
.password));<z>
> responseHandler) {<z>
flatMapMany(response -> {<z>
apply(response)<z>
empty())))<z>
ex));<z>
ex) {<z>
response, ex);<z>
;<z>
void onSuccess() {<z>
) > 0) {<z>
handleFrame();<z>
.isTraceEnabled()) {<z>
"XHR receive request completed.");<z>
.safeClose(this.connection);<z>
.connectFuture);<z>
> getRequiredValues(String name) {<z>
);<z>
(values)) {<z>
.exchangeResult.assertWithDiagnostics(() -><z>
getMessage(name) + " not found"));<z>
return Objects.requireNonNull(values);<z>
public void afterPropertiesSet() throws Exception {<z>
.applicationEventClassConstructor == null) {<z>
IllegalArgumentException("Property 'applicationEventClass' is required");<z>
{<z>
;<z>
) {<z>
.getAttribute("conversion-service"));<z>
(FormattingConversionServiceFactoryBean.class);<z>
);<z>
;<z>
(conversionDef);<z>
new BeanComponentDefinition(conversionDef, conversionName));<z>
;<z>
return conversionServiceRef;<z>
, Object> model) {<z>
null;<z>
{<z>
modelKey);<z>
null) {<z>
IllegalStateException(<z>
.modelKey + "]");<z>
{<z>
) {<z>
if (value != null) {<z>
IllegalStateException("Model contains more than one object to render, only one is supported");<z>
();<z>
!= null, "Model contains no object to render");<z>
;<z>
String message) {<z>
(text)) {<z>
(message);<z>
IOException {<z>
(this.uri != null) {<z>
return this.uri;<z>
();<z>
protected final ChannelRegistration getClientOutboundChannelRegistration() {<z>
.clientOutboundChannelRegistration == null) {<z>
;<z>
configureClientOutboundChannel(registration);<z>
registration.interceptors(new ImmutableMessageChannelInterceptor());<z>
= registration;<z>
return this.clientOutboundChannelRegistration;<z>
getBeanClass(Element element) {<z>
getAttribute(SYSTEM_PROPERTIES_MODE_ATTRIBUTE))) {<z>
.class;<z>
config.PropertyPlaceholderConfigurer.class;<z>
) throws JMSException {<z>
originalDeliveryDelay == null) {<z>
);<z>
deliveryDelay);<z>
public static String getResolvedLookupPath(ServletRequest request) {<z>
(String) request.getAttribute(PATH_ATTRIBUTE);<z>
"Expected lookupPath in request attribute \"" + PATH_ATTRIBUTE + "\".");<z>
lookupPath;<z>
, boolean shouldPostProcess) {<z>
) {<z>
) {<z>
);<z>
) {<z>
);<z>
.get(beanName);<z>
!= null) {<z>
object = alreadyThere;<z>
(shouldPostProcess) {<z>
(isSingletonCurrentlyInCreation(beanName)) {<z>
;<z>
);<z>
postProcessObjectFromFactoryBean(object, beanName);<z>
{<z>
beanName,<z>
);<z>
(beanName);<z>
)) {<z>
.factoryBeanObjectCache.put(beanName, object);<z>
;<z>
Object object = doGetObjectFromFactoryBean(factory, beanName);<z>
shouldPostProcess) {<z>
, beanName);<z>
catch (Throwable ex) {<z>
, ex);<z>
;<z>
{<z>
boolean release = true;<z>
allocateBuffer(this.bufferSize);<z>
;<z>
dataBuffer.capacity());<z>
) >= 0) {<z>
;<z>
;<z>
;<z>
();<z>
(IOException ex) {<z>
ex);<z>
{<z>
;<z>
(List<HttpMessageConverter<?>> converters,<z>
manager) {<z>
(converters, manager);<z>
{<z>
) {<z>
visitBeanDefinition((BeanDefinition) value);<z>
) {<z>
).getBeanDefinition());<z>
RuntimeBeanReference ref) {<z>
;<z>
(newBeanName == null) {<z>
;<z>
(ref.getBeanName())) {<z>
;<z>
) {<z>
resolveStringValue(ref.getBeanName());<z>
(newBeanName == null) {<z>
null;<z>
getBeanName())) {<z>
RuntimeBeanNameReference(newBeanName);<z>
Object[]) {<z>
);<z>
List) {<z>
visitList((List) value);<z>
) {<z>
value);<z>
if (value instanceof Map) {<z>
) value);<z>
value instanceof TypedStringValue typedStringValue) {<z>
);<z>
{<z>
;<z>
typedStringValue.setValue(visitedString);<z>
) {<z>
value);<z>
value;<z>
@Nullable MediaType mediaType) {<z>
getCharset() != null) {<z>
.getCharset();<z>
return getDefaultCharset();<z>
() {<z>
(this.mostSpecificMethod != null) {<z>
return this.mostSpecificMethod;<z>
;<z>
) {<z>
();<z>
(bean)) {<z>
= AopProxyUtils.ultimateTargetClass(bean);<z>
targetClass);<z>
;<z>
public static <T> T convertTypedValue(<z>
> targetType) {<z>
= typedValue.getValue();<z>
null) {<z>
(T) value;<z>
null) {<z>
.getTypeConverter().convertValue(<z>
);<z>
value)) {<z>
return (T) value;<z>
+ "'");<z>
bindToThread() {<z>
get();<z>
.set(this);<z>
{<z>
> resolvers = new ArrayList<>();<z>
add(new SessionAttributeMethodArgumentResolver());<z>
;<z>
);<z>
));<z>
RedirectAttributesMethodArgumentResolver());<z>
(new ModelMethodProcessor());<z>
getCustomArgumentResolvers() != null) {<z>
());<z>
.add(new PrincipalMethodArgumentResolver());<z>
;<z>
List<InputStream> mappingStreams){<z>
(!CollectionUtils.isEmpty(mappingStreams)) {<z>
{<z>
close();<z>
ignored) {<z>
public <T> T convertSendAndReceive(<z>
{<z>
postProcessor);<z>
String propertyToConstantNamePrefix(String propertyName) {<z>
= new StringBuilder();<z>
) {<z>
= propertyName.charAt(i);<z>
)) {<z>
append('_');<z>
append(c);<z>
c));<z>
;<z>
, String beanName) {<z>
if (this.beanNames != null) {<z>
;<z>
.beanNames) {<z>
isFactoryBean) {<z>
.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {<z>
));<z>
) {<z>
;<z>
);<z>
.getAliases(beanName) : NO_ALIASES);<z>
) {<z>
) {<z>
if (isMatch(alias, mappedName)) {<z>
;<z>
;<z>
Object arg3, Object arg4) {<z>
super(format);<z>
= arg1;<z>
arg2;<z>
= arg3;<z>
= arg4;<z>
) throws IOException {<z>
Object partBody = partEntity.getBody();<z>
) {<z>
("Empty body for part '" + name + "': " + partEntity);<z>
);<z>
HttpHeaders partHeaders = partEntity.getHeaders();<z>
.getContentType();<z>
{<z>
{<z>
? StandardCharsets.US_ASCII : this.charset;<z>
multipartMessage = new MultipartHttpOutputMessage(os, charset);<z>
));<z>
) {<z>
partHeaders);<z>
;<z>
HttpMessageNotWritableException("Could not write request: no suitable HttpMessageConverter " +<z>
;<z>
getObjectCount() {<z>
) {<z>
);<z>
importedBy) {<z>
introspect(clazz);<z>
;<z>
importedBy);<z>
(CompositeMessageCondition mapping) {<z>
);<z>
)) {<z>
(pattern)) {<z>
(pattern);<z>
return result;<z>
{<z>
;<z>
this.remoteUser = null;<z>
this.authType = null;<z>
long[] getHeartbeat() {<z>
getFirstNativeHeader(STOMP_HEARTBEAT_HEADER);<z>
split(rawValue, ",");<z>
if (rawValues == null) {<z>
copyOf(DEFAULT_HEARTBEAT, 2);<z>
;<z>
, Object value, int scope) {<z>
{<z>
()) {<z>
(<z>
);<z>
;<z>
= obtainSession();<z>
);<z>
, value);<z>
) {<z>
) {<z>
"Processing SockJS open frame in " + this);<z>
) {<z>
;<z>
;<z>
this);<z>
Exception ex) {<z>
()) {<z>
);<z>
{<z>
"Open frame received in " + getId() + " but we're not connecting (current state " +<z>
+ "). The server might have been restarted and lost track of the session.");<z>
(new CloseStatus(1006, "Server lost session"));<z>
String name) {<z>
);<z>
= new ArrayList<>();<z>
) {<z>
));<z>
.isEmpty()) {<z>
() : null);<z>
(stringArgValues);<z>
wac) {<z>
new StandaloneConfiguration();<z>
(wac);<z>
sc = wac.getServletContext();<z>
;<z>
wac.addBeans(this.controllerAdvice);<z>
mvcConversionService = config.mvcConversionService();<z>
);<z>
mvcResourceUrlProvider();<z>
wac.addBean("mvcResourceUrlProvider", resourceUrlProvider);<z>
= config.mvcContentNegotiationManager();<z>
.addBean("mvcContentNegotiationManager", mvcContentNegotiationManager);<z>
.mvcValidator();<z>
addBean("mvcValidator", mvcValidator);<z>
getHandlerMapping(mvcConversionService, resourceUrlProvider);<z>
if (sc != null) {<z>
sc);<z>
wac);<z>
;<z>
wac.addBean("requestMappingHandlerMapping", hm);<z>
(mvcContentNegotiationManager,<z>
);<z>
{<z>
ha.setServletContext(sc);<z>
);<z>
afterPropertiesSet();<z>
);<z>
handlerExceptionResolver(mvcContentNegotiationManager));<z>
.addBeans(initViewResolvers(wac));<z>
);<z>
);<z>
new DefaultRequestToViewNameTranslator());<z>
new SessionFlashMapManager();<z>
DispatcherServlet.FLASH_MAP_MANAGER_BEAN_NAME, this.flashMapManager);<z>
sc).forEach(wac::addBean);<z>
Object source, String requestUrl,<z>
, String servletName,<z>
@Nullable String userName, long processingTimeMillis) {<z>
(source, sessionId, userName, processingTimeMillis);<z>
this.requestUrl = requestUrl;<z>
this.clientAddress = clientAddress;<z>
method = method;<z>
servletName = servletName;<z>
1;<z>
, PropertyDescriptor pd) {<z>
.getReadMethod(),<z>
(), pd.getPropertyEditorClass());<z>
(IntrospectionException ex) {<z>
);<z>
?> elementClass) {<z>
);<z>
, "'elementClass' must not be null");<z>
(producer.getClass());<z>
, "'producer' type is unknown to ReactiveAdapterRegistry");<z>
message, context) -><z>
elementClass), adapter);<z>
String source, Type type) {<z>
{<z>
;<z>
'{') == -1) {<z>
type);<z>
int level = 0;<z>
);<z>
(this.currentVariable);<z>
;<z>
i++) {<z>
(i);<z>
== 1) {<z>
;<z>
'{') {<z>
;<z>
1) {<z>
(this.currentLiteral, true, type);<z>
'}' && level > 0) {<z>
--;<z>
.currentVariable.append('}');<z>
(level == 0) {<z>
);<z>
);<z>
.variableWithNameAndRegex) {<z>
;<z>
0;<z>
{<z>
;<z>
(c);<z>
(level > 0) {<z>
);<z>
true, type);<z>
);<z>
applicationContext) {<z>
cac) {<z>
.addListener(new ServletContextDestroyedListener(cac));<z>
, String> hiddenFields) throws JspException {<z>
CollectionUtils.isEmpty(hiddenFields)) {<z>
, "No TagWriter set");<z>
.tagWriter.appendValue("<div>\n");<z>
entrySet()) {<z>
;<z>
;<z>
tagWriter.appendValue("/>\n");<z>
;<z>
IndexedBindMarkers(String prefix, int beginWith) {<z>
counter = 0;<z>
prefix;<z>
.offset = beginWith;<z>
instanceFactory) {<z>
.aspectFactory.getAdvisors(instanceFactory);<z>
;<z>
;<z>
.findAdvisorsThatCanApply(advisors, targetClass);<z>
(advisors);<z>
);<z>
advisors);<z>
public ServerCodecConfigurer getCodecConfigurer() {<z>
(this.codecConfigurer == null) {<z>
(ServerCodecConfigurer.create());<z>
return this.codecConfigurer;<z>
name, ObjectFactory<?> objectFactory) {<z>
this);<z>
null) {<z>
new ScopedObjectsHolder();<z>
);<z>
this, scopedObjects);<z>
= scopedObjects.scopedInstances.get(name);<z>
== null) {<z>
);<z>
);<z>
return scopedObject;<z>
result) {<z>
(result).handleResult(exchange, result)<z>
+ " [DispatcherHandler]")<z>
ex -><z>
ex).flatMap(exResult -> {<z>
= "Exception handler " + exResult.getHandler() +<z>
) + "\" [DispatcherHandler]";<z>
.checkpoint(text);<z>
}));<z>
() {<z>
this.locationResources);<z>
.locationValues.isEmpty()) {<z>
notNull(this.resourceLoader,<z>
;<z>
this.locationResources), "Please set " +<z>
"either Resource-based \"locations\" or String-based \"locationValues\", but not both.");<z>
location : this.locationValues) {<z>
;<z>
)) {<z>
.collect(Collectors.toList());<z>
this.locationsToUse.clear();<z>
(result);<z>
afterPropertiesSet() {<z>
super.afterPropertiesSet();<z>
== null || this.defaultTransactionIsolation == null) {<z>
getConnection()) {<z>
checkDefaultConnectionProperties(con);<z>
) {<z>
ex);<z>
Object getProxy(@Nullable ClassLoader classLoader) {<z>
.isTraceEnabled()) {<z>
;<z>
classLoader, this.proxiedInterfaces, this);<z>
(<z>
Exception {<z>
request);<z>
response);<z>
);<z>
response);<z>
StringBuilder getDefinitionDescription() {<z>
StringBuilder result = new StringBuilder();<z>
;<z>
(',');<z>
;<z>
this.timeout != TIMEOUT_DEFAULT) {<z>
);<z>
).append(this.timeout);<z>
.readOnly) {<z>
',');<z>
READ_ONLY_MARKER);<z>
;<z>
printStackTrace(PrintStream ps) {<z>
.isEmpty(this.messageExceptions)) {<z>
;<z>
) + "; message exception details (" +<z>
);<z>
i++) {<z>
Exception subEx = this.messageExceptions[i];<z>
i + 1) + ":");<z>
;<z>
public boolean supportsParameter(MethodParameter parameter) {<z>
parameter.hasParameterAnnotation(ModelAttribute.class)) {<z>
true;<z>
) {<z>
));<z>
false;<z>
) {<z>
();<z>
headers);<z>
)) {<z>
);<z>
SimpMessageHeaderAccessor.getSessionId(headers);<z>
) {<z>
{<z>
("No sessionId in " + message);<z>
);<z>
== null) {<z>
if (logger.isErrorEnabled()) {<z>
+ message);<z>
= SimpMessageHeaderAccessor.getDestination(headers);<z>
destination == null) {<z>
(logger.isErrorEnabled()) {<z>
+ message);<z>
subscriptionId, destination, message);<z>
transaction,<z>
SuspendedResourcesHolder suspendedResources) {<z>
getTransactionSynchronization() != SYNCHRONIZATION_NEVER);<z>
(<z>
;<z>
(transaction, definition);<z>
);<z>
;<z>
static boolean isCandidateWriteMethod(Method method) {<z>
String methodName = method.getName();<z>
();<z>
.getModifiers()) &&<z>
getModifiers())) &&<z>
);<z>
() {<z>
this.delegate.next();<z>
= entry;<z>
entry;<z>
?> resolveContainerFactory(JmsListenerEndpointDescriptor descriptor) {<z>
.containerFactory != null) {<z>
descriptor.containerFactory;<z>
!= null) {<z>
containerFactory;<z>
else if (this.containerFactoryBeanName != null) {<z>
beanFactory != null, "BeanFactory must be set to obtain container factory by bean name");<z>
.getBean(<z>
;<z>
;<z>
("Could not resolve the " +<z>
class.getSimpleName() + " to use for [" +<z>
;<z>
public void writeEndElement() throws XMLStreamException {<z>
closeEmptyElementIfNecessary();<z>
this.endElements.size() - 1;<z>
;<z>
.add(lastEndElement);<z>
, WebSocketHandler handler) {<z>
;<z>
return getHttpClient()<z>
, nettyHeaders))<z>
(buildSpec(protocols))<z>
toString())<z>
outbound) -> {<z>
;<z>
.getFirst("Sec-WebSocket-Protocol");<z>
.empty(), protocol);<z>
);<z>
(<z>
, getMaxFramePayloadLength());<z>
(logger.isDebugEnabled()) {<z>
.getId() + "' for " + url);<z>
);<z>
{<z>
logger.isDebugEnabled()) {<z>
"Connecting to " + url);<z>
.next();<z>
) {<z>
size());<z>
for (Object value : this.values) {<z>
value.toString());<z>
);<z>
(<z>
, ParameterizedTypeReference<T> elementTypeRef) {<z>
notNull(publisher, "'publisher' must not be null");<z>
.notNull(elementTypeRef, "'elementTypeRef' must not be null");<z>
(message, context) -><z>
;<z>
{<z>
);<z>
target instanceof TopicConnectionFactory) {<z>
TopicConnectionFactory) target).createTopicConnection();<z>
= target.createConnection();<z>
instanceof TopicConnection)) {<z>
jms.IllegalStateException("'targetConnectionFactory' is not a TopicConnectionFactory");<z>
return (TopicConnection) con;<z>
public PersistenceUnitInfo obtainDefaultPersistenceUnitInfo() {<z>
)) {<z>
new IllegalStateException("No persistence units parsed from " +<z>
));<z>
.persistenceUnitInfos.isEmpty()) {<z>
"All persistence units from " +<z>
+ " already obtained");<z>
this.defaultPersistenceUnitName != null) {<z>
);<z>
iterator().next();<z>
this.persistenceUnitInfos.clear();<z>
return pui;<z>
void compileInternal() {<z>
).getDataSource();<z>
!= null, "No DataSource set");<z>
());<z>
.createInsertString(getGeneratedKeyNames());<z>
.createInsertTypes();<z>
()) {<z>
.insertString + "]");<z>
();<z>
public String toString() {<z>
String.format("?%s %s", this.name,<z>
this.value != null) ?<z>
.value :<z>
.valuePredicate);<z>
public StompWebSocketEndpointRegistration addInterceptors(HandshakeInterceptor... interceptors) {<z>
)) {<z>
addAll(Arrays.asList(interceptors));<z>
this;<z>
invoke(MethodInvocation invocation) throws Throwable {<z>
) {<z>
.count++;<z>
invoke(invocation);<z>
) throws ClassNotFoundException {<z>
] bytes = bytesCache.get(name);<z>
if (bytes == null) {<z>
name);<z>
!= null) {<z>
put(name, bytes);<z>
;<z>
0, bytes.length);<z>
{<z>
.setAsText(text);<z>
();<z>
new MutablePropertyValues(props));<z>
void handleFrame(ByteArrayOutputStream os) {<z>
.toString(SockJsFrame.CHARSET);<z>
();<z>
()) {<z>
logger.trace("XHR receive content: " + content);<z>
equals(content)) {<z>
content);<z>
String... profiles) {<z>
Assert.notEmpty(profiles, "Must specify at least one profile");<z>
for (String profile : profiles) {<z>
charAt(0) == '!') {<z>
.substring(1))) {<z>
;<z>
(profile)) {<z>
return true;<z>
return false;<z>
Throwable {<z>
size() - 1) {<z>
;<z>
Object interceptorOrInterceptionAdvice =<z>
currentInterceptorIndex);<z>
dm) {<z>
: this.method.getDeclaringClass());<z>
) {<z>
return dm.interceptor.invoke(this);<z>
();<z>
) interceptorOrInterceptionAdvice).invoke(this);<z>
GsonBuilder gsonBuilderWithBase64EncodedByteArrays() {<z>
= new GsonBuilder();<z>
());<z>
;<z>
public TransferSimpSession(SimpSession session) {<z>
;<z>
TransferSimpUser();<z>
= session.getSubscriptions();<z>
);<z>
: subscriptions) {<z>
new TransferSimpSubscription(subscription));<z>
() {<z>
ALL) {<z>
emptySpliterator();<z>
spliterator(null);<z>
, Class<? extends Throwable> o2) {<z>
);<z>
o2, this.targetException, 0);<z>
depth1 - depth2);<z>
(String... paths) {<z>
addProtocolHandler(this.stompHandler);<z>
=<z>
;<z>
.registrations.add(registration);<z>
;<z>
Log4jLog(String name) {<z>
loggerContext;<z>
) {<z>
), false);<z>
logger = context.getLogger(name);<z>
(HttpServletRequest request) throws MultipartException {<z>
.multipartResolver.isMultipart(request)) {<z>
MultipartHttpServletRequest.class) != null) {<z>
) {<z>
logger.trace("Request already resolved to MultipartHttpServletRequest, e.g. by MultipartFilter");<z>
) {<z>
logger.debug("Multipart resolution previously failed for current request - " +<z>
"skipping re-resolution for undisturbed error rendering");<z>
multipartResolver.resolveMultipart(request);<z>
(MultipartException ex) {<z>
.ERROR_EXCEPTION_ATTRIBUTE) != null) {<z>
;<z>
throw ex;<z>
return request;<z>
Throwable>> detectExceptionMappings(Method method) {<z>
ArrayList<>();<z>
method, result);<z>
{<z>
)) {<z>
) {<z>
<? extends Throwable>) paramType);<z>
{<z>
);<z>
return result;<z>
DataSource obtainTargetDataSource() {<z>
();<z>
dataSource != null, "No 'targetDataSource' set");<z>
return dataSource;<z>
WebFluxConfigurer> configurers) {<z>
!CollectionUtils.isEmpty(configurers)) {<z>
.configurers.addWebFluxConfigurers(configurers);<z>
public Object getAttribute(String name) {<z>
);<z>
);<z>
attributes.get(name);<z>
String propertyName) {<z>
(propertyName, getRootClass());<z>
(), getNestedPath() + propertyName,<z>
());<z>
String name) {<z>
String headerValue = getHeader(name);<z>
headerValue == null) {<z>
return -1;<z>
();<z>
ex) {<z>
throw new IllegalArgumentException(<z>
"Value for header '" + name + "' is not a valid Date: " + headerValue);<z>
) {<z>
;<z>
{<z>
) {<z>
"No content-type, using 'application/octet-stream'");<z>
contentType = MediaType.APPLICATION_OCTET_STREAM;<z>
contentType;<z>
protected void detectHandlerMethods(final Object handler) {<z>
(handler instanceof String beanName ?<z>
.getClass());<z>
if (handlerType != null) {<z>
(handlerType);<z>
= MethodIntrospector.selectMethods(userType,<z>
);<z>
isTraceEnabled()) {<z>
));<z>
(mappingsLogger.isDebugEnabled()) {<z>
;<z>
-> {<z>
userType);<z>
invocableMethod, mapping);<z>
;<z>
MutablePropertyValues mpvs, boolean bindEmpty)<z>
throws MultipartException {<z>
key, values) -> {<z>
() == 1) {<z>
(0);<z>
{<z>
;<z>
add(key, values);<z>
);<z>
parameter,<z>
>> converterType) {<z>
;<z>
> hints, Log logger) {<z>
{<z>
Object logPrefix = hints.get(LOG_PREFIX_HINT);<z>
logPrefix != null) {<z>
(buffer, logPrefix);<z>
NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,<z>
... providedArgs) throws Exception {<z>
] parameters = getMethodParameters();<z>
(ObjectUtils.isEmpty(parameters)) {<z>
return EMPTY_ARGS;<z>
;<z>
) {<z>
[i];<z>
initParameterNameDiscovery(this.parameterNameDiscoverer);<z>
] = findProvidedArgument(parameter, providedArgs);<z>
if (args[i] != null) {<z>
)) {<z>
(formatArgumentError(parameter, "No suitable resolver"));<z>
mavContainer, request, this.dataBinderFactory);<z>
) {<z>
{<z>
);<z>
getExecutable().toGenericString())) {<z>
exMsg));<z>
;<z>
args;<z>
other) {<z>
!super.equals(other)) {<z>
;<z>
method) &&<z>
.beanName));<z>
, Throwable ex) throws TransactionException {<z>
);<z>
ex2 -> {<z>
logger.error("Application exception overridden by rollback exception", ex);<z>
TransactionSystemException) {<z>
initApplicationException(ex);<z>
;<z>
maybeBindThrowingVariable() {<z>
this.throwingName == null) {<z>
;<z>
; i++) {<z>
class, i)) {<z>
-1) {<z>
= i;<z>
new AmbiguousBindingException("Binding of throwing parameter '" +<z>
+ "' is ambiguous: could be bound to argument " +<z>
i);<z>
{<z>
("Binding of throwing parameter '" + this.throwingName<z>
;<z>
throwableIndex, this.throwingName);<z>
) {<z>
"filters cannot be null");<z>
{<z>
(f, "filters cannot contain null values");<z>
.add(f);<z>
;<z>
) {<z>
notNull(responseProcessor, "Function must not be null");<z>
handle(request));<z>
body) {<z>
.map(bytes -> {<z>
(contentType == null) {<z>
bytes.length + " bytes of content (unknown content-type).";<z>
.getCharset();<z>
(charset != null) {<z>
bytes, charset);<z>
(contentType::isCompatibleWith)) {<z>
;<z>
length + " bytes of content.";<z>
("No content")<z>
+ ex.getMessage()))<z>
.timeout);<z>
) {<z>
range(0, args.length)<z>
null ?<z>
i] + "]" :<z>
i + "] [null]"))<z>
" "));<z>
text + "\n" +<z>
"]\n" +<z>
().toGenericString() + "] " +<z>
;<z>
InternetAddress replyTo) throws MessagingException {<z>
.notNull(replyTo, "Reply-to address must not be null");<z>
);<z>
});<z>
) {<z>
;<z>
element, "mapping");<z>
if (mappings.isEmpty()) {<z>
);<z>
"/**", config);<z>
) {<z>
CorsConfiguration();<z>
)) {<z>
), ",");<z>
;<z>
{<z>
.getAttribute("allowed-origin-patterns"), ",");<z>
);<z>
mapping.hasAttribute("allowed-methods")) {<z>
;<z>
setAllowedMethods(Arrays.asList(allowedMethods));<z>
("allowed-headers")) {<z>
;<z>
);<z>
mapping.hasAttribute("exposed-headers")) {<z>
",");<z>
Arrays.asList(exposedHeaders));<z>
.hasAttribute("allow-credentials")) {<z>
);<z>
hasAttribute("max-age")) {<z>
("max-age")));<z>
;<z>
);<z>
);<z>
(<z>
.extractSource(element));<z>
return null;<z>
,<z>
Nullable Charset responseCharset) {<z>
, responseBody, responseCharset);<z>
annotationType) {<z>
();<z>
Annotation ann : anns) {<z>
annotationType.isInstance(ann)) {<z>
A) ann;<z>
;<z>
(<z>
Resource resource, ProblemReporter problemReporter,<z>
ReaderEventListener eventListener, SourceExtractor sourceExtractor,<z>
XmlBeanDefinitionReader reader, NamespaceHandlerResolver namespaceHandlerResolver) {<z>
;<z>
reader;<z>
;<z>
IllegalStateException {<z>
read) {<z>
IllegalStateException("InputStream has already been read - " +<z>
;<z>
read = true;<z>
this.inputStream;<z>
double getRequiredDoubleParameter(ServletRequest request, String name)<z>
throws ServletRequestBindingException {<z>
request.getParameter(name));<z>
servlet, Filter... filters) {<z>
filters, "filters cannot be null");<z>
filters, "filters cannot contain null values");<z>
filters);<z>
getCorsConfiguration(HttpServletRequest request) {<z>
) {<z>
(request);<z>
;<z>
sessionFactory, boolean newSession) {<z>
sessionHolder;<z>
this.sessionFactory = sessionFactory;<z>
this.newSession = newSession;<z>
,<z>
extends T> excludes, boolean matchIfEmpty) {<z>
;<z>
());<z>
;<z>
BeansException {<z>
= getBean(name);<z>
!requiredType.isInstance(bean)) {<z>
;<z>
bean;<z>
reason, @Nullable Throwable cause) {<z>
null, cause);<z>
this.status = rawStatusCode;<z>
this.reason = reason;<z>
{<z>
this.parameterName = parameterName;<z>
;<z>
this.endIndex = endIndex;<z>
static CacheControl noStore() {<z>
CacheControl cc = new CacheControl();<z>
;<z>
;<z>
Nullable MediaType mediaType) {<z>
) {<z>
;<z>
if (mediaType == null) {<z>
;<z>
) {<z>
) {<z>
)) {<z>
;<z>
false;<z>
) {<z>
exchangeResult.assertWithDiagnostics(() -> {<z>
> values = getRequiredValues(name);<z>
assertTrue(<z>
getMessage(name) + " has fewer or more values " + values +<z>
patterns),<z>
.size() == patterns.length);<z>
); i++) {<z>
values.get(i);<z>
String pattern = patterns[i];<z>
(<z>
"]='" + value + "' does not match '" + pattern + "'",<z>
value.matches(pattern));<z>
);<z>
this.responseSpec;<z>
method) {<z>
.get(CacheableOperation.class);<z>
null) {<z>
;<z>
= false;<z>
cacheOperationContexts) {<z>
()).isSync()) {<z>
;<z>
{<z>
.size() > 1) {<z>
(<z>
+ "'");<z>
size() > 1) {<z>
new IllegalStateException(<z>
;<z>
).next();<z>
(CacheableOperation) cacheOperationContext.getOperation();<z>
) {<z>
throw new IllegalStateException(<z>
+ operation + "'");<z>
)) {<z>
(<z>
+ "'");<z>
;<z>
;<z>
,<z>
Empty<Void> completionSink) {<z>
inbound;<z>
outbound = outbound;<z>
codec = codec;<z>
completionSink = completionSink;<z>
(ProcessingEnvironment processingEnvironment,<z>
CandidateComponentsMetadata previousMetadata) {<z>
;<z>
= previousMetadata;<z>
= new TypeHelper(processingEnvironment);<z>
request) {<z>
MultiValueMap<String, String> headers =<z>
(8, Locale.ENGLISH));<z>
(); ) {<z>
();<z>
; values.hasMoreElements(); ) {<z>
.nextElement());<z>
;<z>
source) {<z>
= Calendar.getInstance();<z>
(source);<z>
return calendar;<z>
byName) {<z>
.forEach((name, parameter) -> {<z>
();<z>
null) {<z>
;<z>
());<z>
});<z>
, String newName) throws NameNotFoundException {<z>
;<z>
oldName);<z>
obj);<z>
) {<z>
) {<z>
.resourceLoader.getResource(location);<z>
super.getResource(location);<z>
{<z>
return "ResolvableMethod.Builder[\n" +<z>
getName() + ",\n" +<z>
"\n]";<z>
void addAnnotationsToMap(<z>
{<z>
object != null) {<z>
: object.getAnnotations()) {<z>
, annotation);<z>
String... strings) {<z>
isEmpty(strings)) {<z>
str1;<z>
.join("-", strings);<z>
public RequestMatchResult(PathPattern pathPattern, PathContainer lookupPath) {<z>
);<z>
);<z>
= null;<z>
= null;<z>
null;<z>
pathPattern;<z>
lookupPath;<z>
void initTypedReaders() {<z>
this.typedReaders.clear();<z>
) {<z>
(new ByteArrayDecoder()));<z>
>(new ByteBufferDecoder()));<z>
new DataBufferDecoder()));<z>
nettyByteBufPresent) {<z>
>(new NettyByteBufDecoder()));<z>
));<z>
>(StringDecoder.textPlainOnly()));<z>
(protobufPresent) {<z>
this.protobufDecoder != null ?<z>
.protobufDecoder : new ProtobufDecoder()));<z>
));<z>
;<z>
String suffix) {<z>
;<z>
(prefix);<z>
;<z>
propertyName) {<z>
null) {<z>
;<z>
propertyName));<z>
{<z>
"path");<z>
StringUtils.tokenizeToStringArray(pathAttribute, ",");<z>
;<z>
= new ConstructorArgumentValues();<z>
;<z>
;<z>
.class, cargs, null);<z>
extractSource(element));<z>
);<z>
(requestHandlerDef);<z>
requestHandlerRef = new RuntimeBeanReference(requestHandlerName);<z>
mappings) {<z>
? mapping + "**" : mapping + "/**");<z>
(pathPattern, requestHandlerRef);<z>
) {<z>
: super.mvcValidator();<z>
if (mvcValidator instanceof InitializingBean) {<z>
(InitializingBean) mvcValidator).afterPropertiesSet();<z>
(Exception ex) {<z>
("Failed to initialize Validator", ex);<z>
;<z>
identityName) {<z>
> properties;<z>
task instanceof SchedulingAwareRunnable) {<z>
;<z>
.put(ManagedTask.LONGRUNNING_HINT,<z>
task).isLongLived()));<z>
2);<z>
.IDENTITY_NAME, identityName);<z>
, properties, null);<z>
throws JMSException {<z>
);<z>
initResourcesIfNecessary();<z>
;<z>
lastMessageSucceeded = true;<z>
messageReceived;<z>
this.currentReceiveThread = null;<z>
throws SAXException, XMLStreamException {<z>
false;<z>
= false;<z>
int elementDepth = 0;<z>
hasNext() && elementDepth >= 0) {<z>
);<z>
event.isEndDocument() && !documentStarted) {<z>
handleStartDocument(event);<z>
true;<z>
()) {<z>
XMLStreamConstants.START_DOCUMENT:<z>
;<z>
;<z>
:<z>
;<z>
(event.asStartElement());<z>
END_ELEMENT:<z>
--;<z>
0) {<z>
));<z>
:<z>
) event);<z>
:<z>
SPACE:<z>
.CDATA:<z>
asCharacters());<z>
:<z>
handleEndDocument();<z>
documentEnded = true;<z>
XMLStreamConstants.NOTATION_DECLARATION:<z>
handleNotationDeclaration((NotationDeclaration) event);<z>
:<z>
((EntityDeclaration) event);<z>
case XMLStreamConstants.COMMENT:<z>
event);<z>
:<z>
(DTD) event);<z>
XMLStreamConstants.ENTITY_REFERENCE:<z>
EntityReference) event);<z>
!documentEnded) {<z>
();<z>
throws IOException {<z>
servletParts = (this.multipartRequest instanceof StandardMultipartHttpServletRequest);<z>
{<z>
Part part = retrieveServletPart();<z>
null) {<z>
);<z>
multipartRequest.getFile(this.requestPartName);<z>
(file != null) {<z>
file.getInputStream();<z>
.requestPartName);<z>
{<z>
getBytes(determineCharset()));<z>
servletParts) {<z>
= retrieveServletPart();<z>
part != null) {<z>
();<z>
"'");<z>
{<z>
{<z>
)<z>
.class.getClassLoader()));<z>
return instance;<z>
public void writeEmptyElement(String localName) throws XMLStreamException {<z>
closeEmptyElementIfNecessary();<z>
writeStartElement(localName);<z>
emptyElement = true;<z>
public EmbeddedDatabaseBuilder addScripts(String... scripts) {<z>
for (String script : scripts) {<z>
addScript(script);<z>
;<z>
?>... paramTypes) {<z>
);<z>
Assert.notNull(methodName, "Method name must not be null");<z>
) {<z>
, methodName, paramTypes);<z>
, methodName);<z>
.size() == 1) {<z>
next();<z>
;<z>
, MediaType contentType,<z>
)<z>
throws IOException, HttpMessageConversionException {<z>
isCompatibleWith(APPLICATION_JSON)) {<z>
;<z>
(reader, builder);<z>
(<z>
;<z>
> testClass,<z>
configAttributes) {<z>
(testClass)) {<z>
?> clazz = ClassUtils.forName(MOCK_SERVER_CONTAINER_CONTEXT_CUSTOMIZER_CLASS_NAME,<z>
).getClassLoader());<z>
;<z>
Throwable ex) {<z>
+<z>
;<z>
return null;<z>
Method method, Object[] args) {<z>
(this.initialized) {<z>
.ultimateTargetClass(target);<z>
method, targetClass);<z>
) {<z>
=<z>
, operation);<z>
(context, invoker);<z>
invoker.invoke();<z>
) {<z>
);<z>
;<z>
return beanDefinition;<z>
StringTokenizer tokens, Context context) {<z>
ArrayList<>();<z>
= null;<z>
()) {<z>
);<z>
(token.isEmpty()) {<z>
) {<z>
:<z>
.BRACKET);<z>
) {<z>
return contents;<z>
contents);<z>
:<z>
null || operator == Operator.AND);<z>
.AND;<z>
"|":<z>
== null || operator == Operator.OR);<z>
.OR;<z>
case "!":<z>
, tokens, Context.INVERT)));<z>
")":<z>
= merge(expression, elements, operator);<z>
if (context == Context.BRACKET) {<z>
merged;<z>
.clear();<z>
);<z>
operator = null;<z>
equals(token);<z>
INVERT) {<z>
return value;<z>
elements.add(value);<z>
;<z>
@Nullable WebApplicationContext wac) {<z>
(targetBeanName, "Target Filter bean name must not be null or empty");<z>
.setTargetBeanName(targetBeanName);<z>
wac;<z>
(wac != null) {<z>
());<z>
{<z>
= methodCache.get(clazz);<z>
method == null) {<z>
clazz.getMethod("newBuilder");<z>
);<z>
method.invoke(clazz);<z>
) {<z>
(<z>
ex);<z>
{<z>
moduleClasses = modules;<z>
= true;<z>
this;<z>
throws TransformerConfigurationException {<z>
Transformer transformer = templates.newTransformer();<z>
uriResolver != null) {<z>
this.uriResolver);<z>
;<z>
Object proceed() throws Throwable {<z>
;<z>
) {<z>
;<z>
Exception ex) {<z>
.getClass()) ||<z>
))) {<z>
;<z>
UndeclaredThrowableException(ex);<z>
HandlerMapping defaultServletHandlerMapping() {<z>
"No ServletContext set");<z>
this.servletContext);<z>
);<z>
buildHandlerMapping();<z>
(<z>
.io.InputStream input,<z>
.ExtensionRegistryLite extensionRegistry)<z>
IOException {<z>
PARSER.parseDelimitedFrom(input, extensionRegistry);<z>
publisher) {<z>
(this, COMPLETED)) {<z>
> s = publisher.subscriber;<z>
);<z>
);<z>
.get().publishComplete(publisher);<z>
(DateFormat dateFormat) {<z>
) {<z>
dateFormat.setTimeZone(this.timeZone);<z>
(this.lenient);<z>
dateFormat;<z>
ResolvableType elementType,<z>
, Object> hints) {<z>
decoderFunction =<z>
maxMessageSize);<z>
)<z>
flatMapIterable(decoderFunction)<z>
(decoderFunction::discard);<z>
public final void stop() {<z>
.lifecycleMonitor) {<z>
;<z>
.unsubscribe(this);<z>
this.sessions.values()) {<z>
CloseStatus.GOING_AWAY);<z>
{<z>
()) {<z>
+ ex);<z>
> nest(ServerRequest request) {<z>
left.nest(request);<z>
{<z>
;<z>
);<z>
> getObjectMappersForType(Class<?> clazz) {<z>
getObjectMapperRegistrations().entrySet()) {<z>
().isAssignableFrom(clazz)) {<z>
entry.getValue();<z>
.emptyMap();<z>
> stopScheduler() {<z>
Mono.fromRunnable(() -> {<z>
;<z>
< 20; i++) {<z>
()) {<z>
100);<z>
catch (Throwable ex) {<z>
;<z>
parameter, @Nullable ModelAndViewContainer mavContainer,<z>
throws Exception {<z>
;<z>
binderFactory != null, "ModelAttributeMethodProcessor requires WebDataBinderFactory");<z>
getNameForParameter(parameter);<z>
;<z>
!= null) {<z>
;<z>
= null;<z>
BindingResult bindingResult = null;<z>
{<z>
).get(name);<z>
, parameter, binderFactory, webRequest);<z>
ex) {<z>
{<z>
throw ex;<z>
) {<z>
= Optional.empty();<z>
attribute = ex.getTarget();<z>
();<z>
== null) {<z>
attribute, name);<z>
() != null) {<z>
) {<z>
, webRequest);<z>
validateIfApplicable(binder, parameter);<z>
)) {<z>
.getBindingResult());<z>
{<z>
);<z>
);<z>
.getModel();<z>
bindingResultModel);<z>
mavContainer.addAllAttributes(bindingResultModel);<z>
;<z>
lookupLocalVariable(String name) {<z>
initVariableScopes()) {<z>
scope.definesVariable(name)) {<z>
(name);<z>
null;<z>
<Class<?>> ifcs) {<z>
ifc : ifcs) {<z>
hasMethod(ifc, method)) {<z>
return true;<z>
;<z>
, boolean strict) {<z>
return result -> {<z>
(StandardCharsets.UTF_8);<z>
content, strict);<z>
IllegalStateException {<z>
Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);<z>
Assert.notNull(value, "Value must not be null");<z>
;<z>
map.put(actualKey, value);<z>
(oldValue != null) {<z>
throw new IllegalStateException(<z>
oldValue + "] for key [" + actualKey + "] bound to context");<z>
?> requiredType, @Nullable Throwable cause) {<z>
.getDescriptiveType(value) + "'" +<z>
""),<z>
);<z>
this.value = value;<z>
requiredType = requiredType;<z>
{<z>
0) {<z>
return src;<z>
src);<z>
{<z>
.sql,<z>
connection -> this.resultFunction.apply(connection)<z>
.mappingFunction))));<z>
tokens) {<z>
] : "");<z>
;<z>
;<z>
country);<z>
= "";<z>
(tokens.length > 2) {<z>
)) + country.length();<z>
).stripLeading();<z>
("_")) {<z>
;<z>
.startsWith("#")) {<z>
variant = country;<z>
= "";<z>
variant) : null);<z>
Exception {<z>
=<z>
());<z>
response.setLocale(locale);<z>
View view;<z>
mv.getViewName();<z>
) {<z>
getModelInternal(), locale, request);<z>
(view == null) {<z>
.getViewName() +<z>
;<z>
.getView();<z>
null) {<z>
mv + "] neither contains a view name nor a " +<z>
+ "'");<z>
{<z>
("Rendering view [" + view + "] ");<z>
) != null) {<z>
mv.getStatus());<z>
value());<z>
getModelInternal(), request, response);<z>
Exception ex) {<z>
{<z>
"]", ex);<z>
;<z>
JspWriter getOut() {<z>
null) {<z>
new MockJspWriter(this.response);<z>
out;<z>
stream(Class<A> annotationType) {<z>
.ALL) {<z>
empty();<z>
(annotationType), false);<z>
Object> headers, byte[] payload) {<z>
);<z>
Assert.notNull(payload, "'payload' is required");<z>
)) {<z>
trace("Encoding heartbeat");<z>
StompDecoder.HEARTBEAT_PAYLOAD;<z>
getCommand(headers);<z>
{<z>
headers);<z>
Result result = new DefaultResult();<z>
));<z>
);<z>
, payload, result);<z>
);<z>
);<z>
) 0);<z>
);<z>
writer, @Nullable String comments) throws IOException {<z>
= new StringWriter();<z>
));<z>
);<z>
line : contents.split(EOL)) {<z>
&& line.startsWith("#"))) {<z>
line + EOL);<z>
String, List<String>> requestHeaders) {<z>
putAll(this.headers);<z>
logger.isTraceEnabled()) {<z>
;<z>
String> consumer){<z>
assertWith(() -> {<z>
.class);<z>
accept(value);<z>
);<z>
path(String path) {<z>
addPath(path);<z>
();<z>
this;<z>
throws IllegalStateException {<z>
getServletContext();<z>
.state(servletContext != null, "ServletContext is required");<z>
;<z>
{<z>
host != null) {<z>
value = host.getHostString();<z>
int port = host.getPort();<z>
{<z>
;<z>
set(HOST, value);<z>
(HOST, null);<z>
parameterSource) {<z>
();<z>
);<z>
(params);<z>
String findPerClause(Class<?> aspectClass) {<z>
(Aspect.class).value();<z>
) + 1;<z>
1;<z>
substring(beginIndex, endIndex);<z>
Object handler, Method method, T mapping) {<z>
, "Mapping must not be null");<z>
;<z>
this.handlerMethods.get(mapping);<z>
(newHandlerMethod)) {<z>
) +<z>
"' bean method \n" + newHandlerMethod + "\nto " + mapping + ": There is already '" +<z>
"' bean method\n" + oldHandlerMethod + " mapped.");<z>
handlerMethods.put(mapping, newHandlerMethod);<z>
String pattern : getDirectLookupDestinations(mapping)) {<z>
.add(pattern, mapping);<z>
, String beanName) {<z>
bean.getClass(), beanName);<z>
);<z>
, beanName, cacheKey);<z>
String getDetailedLogMessage(@Nullable Object payload) {<z>
(isHeartbeat()) {<z>
getSessionId();<z>
"");<z>
;<z>
if (command == null) {<z>
;<z>
new StringBuilder();<z>
append(' ');<z>
<String>> nativeHeaders = getNativeHeaders();<z>
(nativeHeaders != null) {<z>
);<z>
;<z>
) {<z>
));<z>
isBodyAllowed()) {<z>
sb.append(appendPayload(payload));<z>
sb.toString();<z>
<String> other) {<z>
other == null) {<z>
Collections.emptyList());<z>
if (source == null) {<z>
return other;<z>
DEFAULT_PERMIT_ALL || source == DEFAULT_PERMIT_METHODS) {<z>
;<z>
== DEFAULT_PERMIT_ALL || other == DEFAULT_PERMIT_METHODS) {<z>
return source;<z>
other.contains(ALL)) {<z>
ALL_LIST;<z>
.size());<z>
source);<z>
.addAll(other);<z>
<>(combined);<z>
{<z>
= props.getProperty(ifcName);<z>
());<z>
());<z>
, impl);<z>
setTransportHandlerOverrides(TransportHandler... handlers) {<z>
;<z>
handlers)) {<z>
(handlers));<z>
this;<z>
{<z>
);<z>
hashCode + getField().hashCode();<z>
;<z>
: 0);<z>
hashCode;<z>
)<z>
throws XPathExpressionException {<z>
);<z>
(this.expression, namespaces);<z>
;<z>
?> viewClass) {<z>
isAssignableFrom(viewClass)) {<z>
("Given view class [" + viewClass.getName() +<z>
);<z>
viewClass;<z>
Invocation> actualInvocations,<z>
) {<z>
());<z>
expectedInvocations.size(); i++) {<z>
.get(i), argumentAdapters);<z>
) {<z>
: System.currentTimeMillis());<z>
filename + PROPERTIES_SUFFIX);<z>
exists()) {<z>
getResource(filename + XML_SUFFIX);<z>
)) {<z>
fileTimestamp = -1;<z>
getCacheMillis() >= 0) {<z>
resource.lastModified();<z>
getFileTimestamp() == fileTimestamp) {<z>
(logger.isDebugEnabled()) {<z>
+ "] - file hasn't been modified");<z>
.setRefreshTimestamp(refreshTimestamp);<z>
propHolder;<z>
catch (IOException ex) {<z>
.isDebugEnabled()) {<z>
resource + " could not be resolved in the file system - assuming that it hasn't changed", ex);<z>
;<z>
= loadProperties(resource, filename);<z>
propHolder = new PropertiesHolder(props, fileTimestamp);<z>
) {<z>
(logger.isWarnEnabled()) {<z>
ex);<z>
propHolder = new PropertiesHolder();<z>
) {<z>
filename + "] - neither plain properties nor XML");<z>
new PropertiesHolder();<z>
refreshTimestamp);<z>
filename, propHolder);<z>
return propHolder;<z>
{<z>
"LanguageRange List must not be null");<z>
, DECIMAL_FORMAT_SYMBOLS);<z>
<String> values = languages.stream()<z>
(range -><z>
.MAX_WEIGHT ?<z>
() :<z>
format(range.getWeight()))<z>
toList());<z>
(values));<z>
) throws SQLException {<z>
(iface.isInstance(this)) {<z>
;<z>
return determineTargetDataSource().unwrap(iface);<z>
,<z>
, @Nullable WebDataBinderFactory binderFactory) throws Exception {<z>
> paramType = parameter.getParameterType();<z>
isAssignableFrom(paramType)) {<z>
String, String> result;<z>
paramType)) {<z>
();<z>
;<z>
;) {<z>
iterator.next();<z>
);<z>
(headerValues != null) {<z>
String headerValue : headerValues) {<z>
headerValue);<z>
result;<z>
();<z>
) {<z>
;<z>
.getHeader(headerName);<z>
!= null) {<z>
put(headerName, headerValue);<z>
return result;<z>
, HttpServletResponse response,<z>
{<z>
request.upgrade(TyrusHttpUpgradeHandler.class);<z>
;<z>
);<z>
));<z>
value)));<z>
response.flushBuffer();<z>
) {<z>
) {<z>
.parse(value).toMillis();<z>
value), timeUnit);<z>
value) {<z>
(value == null) {<z>
;<z>
;<z>
for (StringValueResolver resolver : this.embeddedValueResolvers) {<z>
);<z>
== null) {<z>
null;<z>
return result;<z>
@Nullable Throwable cause) {<z>
.INTERNAL_SERVER_ERROR, reason, cause);<z>
handlerMethod = null;<z>
this.parameter = null;<z>
protected final MappedInterceptor[] getMappedInterceptors() {<z>
));<z>
for (HandlerInterceptor interceptor : this.adaptedInterceptors) {<z>
instanceof MappedInterceptor mappedInterceptor) {<z>
mappedInterceptor);<z>
null);<z>
(WebSocketHandler handler,<z>
{<z>
Assert.notNull(handler, "WebSocketHandler is required");<z>
"'sessionFactory' is required");<z>
.delegateHandler = handler;<z>
= sessionFactory;<z>
?> doReceive(Destination destination) {<z>
receive(destination);<z>
(jmsMessage);<z>
JmsException ex) {<z>
);<z>
<String> patterns, PatternsRequestCondition other) {<z>
patterns;<z>
.pathMatcher = other.pathMatcher;<z>
useSuffixPatternMatch;<z>
this.useTrailingSlashMatch = other.useTrailingSlashMatch;<z>
fileExtensions.addAll(other.fileExtensions);<z>
Nullable String sql, SQLException ex) {<z>
) {<z>
if (ex instanceof SQLTransientConnectionException) {<z>
ex);<z>
ex instanceof SQLTransactionRollbackException) {<z>
ex);<z>
ex instanceof SQLTimeoutException) {<z>
sql, ex), ex);<z>
(ex instanceof SQLNonTransientException) {<z>
instanceof SQLNonTransientConnectionException) {<z>
ex);<z>
ex instanceof SQLDataException) {<z>
task, sql, ex), ex);<z>
if (ex instanceof SQLIntegrityConstraintViolationException) {<z>
, ex), ex);<z>
else if (ex instanceof SQLInvalidAuthorizationSpecException) {<z>
ex), ex);<z>
ex instanceof SQLSyntaxErrorException) {<z>
sql : ""), ex);<z>
if (ex instanceof SQLFeatureNotSupportedException) {<z>
);<z>
instanceof SQLRecoverableException) {<z>
, ex), ex);<z>
return null;<z>
> rse)<z>
DataAccessException {<z>
;<z>
HttpServletRequest request, String name) throws Exception {<z>
= request.getParts();<z>
));<z>
for (Part part : parts) {<z>
getName().equals(name)) {<z>
.add(part);<z>
return result;<z>
bean, String beanName) throws BeansException {<z>
bean instanceof AdvisorAdapter){<z>
) bean);<z>
;<z>
) throws SAXException {<z>
) != null) {<z>
getLexicalHandler().startCDATA();<z>
) != null) {<z>
),<z>
getTextLength());<z>
null) {<z>
;<z>
>... managedInterfaces) {<z>
(managedInterfaces != null) {<z>
> ifc : managedInterfaces) {<z>
)) {<z>
new IllegalArgumentException(<z>
);<z>
managedInterfaces;<z>
protected CacheOperation(Builder b) {<z>
= b.name;<z>
;<z>
key;<z>
keyGenerator = b.keyGenerator;<z>
this.cacheManager = b.cacheManager;<z>
b.cacheResolver;<z>
.condition = b.condition;<z>
;<z>
) {<z>
CollectionUtils.isEmpty(mediaTypes)) {<z>
;<z>
.size() == 1) {<z>
));<z>
(8);<z>
mediaType : mediaTypes) {<z>
mediaType));<z>
return result;<z>
final void cancel() {<z>
this.state.get();<z>
.isTraceEnabled()) {<z>
"cancel [" + state + "]");<z>
);<z>
servletRequest) {<z>
null;<z>
servletRequest.getAttribute(WEB_ASYNC_MANAGER_ATTRIBUTE);<z>
WebAsyncManager) {<z>
(WebAsyncManager) asyncManagerAttr;<z>
if (asyncManager == null) {<z>
();<z>
servletRequest.setAttribute(WEB_ASYNC_MANAGER_ATTRIBUTE, asyncManager);<z>
return asyncManager;<z>
public void destroy() {<z>
this.loadTimeWeaver instanceof InstrumentationLoadTimeWeaver) {<z>
()) {<z>
.debug("Removing all registered transformers for class loader: " +<z>
());<z>
loadTimeWeaver).removeTransformers();<z>
String declaringClassName,<z>
, Consumer<SimpleMethodMetadata> consumer) {<z>
SpringAsmInfo.ASM_VERSION);<z>
= classLoader;<z>
this.declaringClassName = declaringClassName;<z>
.access = access;<z>
this.methodName = methodName;<z>
descriptor;<z>
consumer = consumer;<z>
[] destinations) {<z>
resolvedDestinations = resolveEmbeddedValuesInDestinations(destinations);<z>
return new SimpMessageMappingInfo(SimpMessageTypeMessageCondition.SUBSCRIBE,<z>
this.pathMatcher));<z>
onError(Throwable ex) {<z>
;<z>
writeBarrier.releaseCachedItem();<z>
) {<z>
);<z>
null) {<z>
(charset));<z>
Node> matcher) {<z>
return result -> {<z>
();<z>
xmlHelper.assertNode(content, matcher);<z>
{<z>
if (ch > 255) {<z>
return false;<z>
0;<z>
isInvalidEncodedPath(String path) {<z>
if (path.contains("%")) {<z>
;<z>
)) {<z>
true;<z>
decodedPath);<z>
) {<z>
;<z>
{<z>
return false;<z>
) {<z>
assertValidators(validators);<z>
validators.clear();<z>
.asList(validators));<z>
int expected, int actual) {<z>
+ " rows, not " + expected + " as expected");<z>
expected;<z>
;<z>
String, Object> headers,<z>
T> targetClass, @Nullable MessagePostProcessor postProcessor) {<z>
postProcessor);<z>
> replyMessage = sendAndReceive(destinationName, requestMessage);<z>
null);<z>
, String beanName) throws BeansException {<z>
markBeanAsCreated(beanName);<z>
getMergedBeanDefinition(beanName);<z>
null;<z>
if (mbd instanceof RootBeanDefinition rbd) {<z>
rbd : rbd.cloneBeanDefinition());<z>
) {<z>
RootBeanDefinition(mbd);<z>
bd.isPrototype()) {<z>
.setScope(SCOPE_PROTOTYPE);<z>
, getBeanClassLoader());<z>
bw = new BeanWrapperImpl(existingBean);<z>
initBeanWrapper(bw);<z>
beanName, bd, bw);<z>
return initializeBean(beanName, existingBean, bd);<z>
expression) {<z>
= new RootBeanDefinition(AspectJExpressionPointcut.class);<z>
BeanDefinition.SCOPE_PROTOTYPE);<z>
setSynthetic(true);<z>
().add(EXPRESSION, expression);<z>
beanDefinition;<z>
entityResolver,<z>
validationMode, boolean namespaceAware) throws Exception {<z>
;<z>
isTraceEnabled()) {<z>
);<z>
= createDocumentBuilder(factory, entityResolver, errorHandler);<z>
inputSource);<z>
{<z>
.notNull(other, "DefaultWebClientBuilder must not be null");<z>
.baseUrl;<z>
.defaultUriVariables != null ?<z>
) : null);<z>
.uriBuilderFactory;<z>
null) {<z>
= new HttpHeaders();<z>
(other.defaultHeaders);<z>
.defaultHeaders = null;<z>
?<z>
) : null);<z>
;<z>
: null);<z>
connector = other.connector;<z>
strategies = other.strategies;<z>
.strategiesConfigurers != null ?<z>
null);<z>
exchangeFunction;<z>
@Nullable CacheDefaults defaults, CachePut ann) {<z>
ann.cacheName());<z>
cacheResolverFactory =<z>
(defaults, ann.cacheResolverFactory());<z>
defaults, ann.cacheKeyGenerator());<z>
ann, cacheName);<z>
(cacheResolverFactory, methodDetails);<z>
;<z>
BeansException {<z>
()) {<z>
);<z>
!= null) {<z>
cachedFactory;<z>
.basenames.length);<z>
: this.basenames) {<z>
locale));<z>
()) {<z>
);<z>
if (cachedFactory != null) {<z>
(locale, cachedFactory);<z>
return cachedFactory;<z>
GenericWebApplicationContext factory = new GenericWebApplicationContext();<z>
;<z>
factory.setServletContext(getServletContext());<z>
.PropertiesBeanDefinitionReader reader =<z>
.factory.support.PropertiesBeanDefinitionReader(factory);<z>
setDefaultParentBean(this.defaultParentView);<z>
for (ResourceBundle bundle : bundles) {<z>
(bundle);<z>
;<z>
isCache()) {<z>
locale, factory);<z>
put(bundles, factory);<z>
factory;<z>
public RequestMatcher isArray() {<z>
{<z>
, ParseException {<z>
.getBodyAsString());<z>
(MockHttpServletRequest request, final String sessionid) {<z>
;<z>
.sessions) {<z>
.get(sessionid);<z>
== null) {<z>
request, sessionid);<z>
);<z>
this.sessions) {<z>
;<z>
(request, sessionid);<z>
);<z>
;<z>
(StartElement startElement) throws SAXException {<z>
getContentHandler() != null) {<z>
getName();<z>
)) {<z>
; i.hasNext();) {<z>
) i.next();<z>
(), namespace.getNamespaceURI());<z>
); i.hasNext();){<z>
i.next();<z>
attribute.getName();<z>
, attributeName.getNamespaceURI());<z>
, toQualifiedName(qName),<z>
startElement));<z>
(startElement));<z>
(CallableStatement cs,<z>
List<SqlParameter> resultSetParameters,<z>
{<z>
LinkedHashMap<>(4);<z>
int rsIndex = 0;<z>
= 0;<z>
boolean moreResults;<z>
!this.skipResultsProcessing) {<z>
-1) {<z>
rsIndex) {<z>
) resultSetParameters.get(rsIndex);<z>
), declaredRsParam));<z>
++;<z>
!this.skipUndeclaredResults) {<z>
rsName = RETURN_RESULT_SET_PREFIX + (rsIndex + 1);<z>
new SqlReturnResultSet(rsName, getColumnMapRowMapper());<z>
(logger.isTraceEnabled()) {<z>
rsName + "'");<z>
;<z>
;<z>
size() > updateIndex) {<z>
get(updateIndex);<z>
.getName();<z>
.put(declaredUcName, updateCount);<z>
;<z>
) {<z>
;<z>
) {<z>
"Added default SqlReturnUpdateCount parameter named '" + undeclaredName + "'");<z>
;<z>
++;<z>
moreResults = cs.getMoreResults();<z>
updateCount = cs.getUpdateCount();<z>
) {<z>
("CallableStatement.getUpdateCount() returned " + updateCount);<z>
while (moreResults || updateCount != -1);<z>
results;<z>
state, Object[] arguments) {<z>
.getEvaluationContext();<z>
;<z>
getTypeDescriptor();<z>
arguments = arguments;<z>
) throws XmlMappingException {<z>
;<z>
);<z>
this.mtomEnabled && mimeContainer != null) {<z>
.setAttachmentUnmarshaller(new Jaxb2AttachmentUnmarshaller(mimeContainer));<z>
(source)) {<z>
, source);<z>
else if (this.mappedClass != null) {<z>
.getValue();<z>
.unmarshal(source);<z>
NullPointerException ex) {<z>
(!isSupportDtd()) {<z>
"NPE while unmarshalling: " +<z>
);<z>
;<z>
ex) {<z>
);<z>
{<z>
0;<z>
this.chunks) {<z>
;<z>
;<z>
throws ServletException {<z>
method = request.getMethod();<z>
)) {<z>
HttpRequestMethodNotSupportedException(method, this.supportedMethods);<z>
) {<z>
("Pre-existing session required but none found");<z>
value) {<z>
(name, "'name' must not be null");<z>
value);<z>
return this;<z>
{<z>
)) {<z>
false;<z>
attributeName, value.getClass())) {<z>
;<z>
) &&<z>
.getClass()));<z>
public void setUpdatableResults(boolean updatableResults) {<z>
{<z>
InvalidDataAccessApiUsageException(<z>
);<z>
updatableResults = updatableResults;<z>
boolean useTrailingSlashMatch,<z>
{<z>
, null, pathMatcher, useTrailingSlashMatch);<z>
initArgumentResolvers() {<z>
resolvers = new ArrayList<>();<z>
();<z>
(context instanceof ConfigurableApplicationContext ?<z>
) : null);<z>
HeaderMethodArgumentResolver(this.conversionService, beanFactory));<z>
);<z>
));<z>
)) {<z>
));<z>
().getCustomResolvers());<z>
resolvers.add(new PayloadMethodArgumentResolver(<z>
, true));<z>
;<z>
private SpelNodeImpl eatPrimaryExpression() {<z>
();<z>
;<z>
);<z>
{<z>
== null) {<z>
new ArrayList<>(4);<z>
add(start);<z>
node);<z>
node = eatNode();<z>
nodes == null) {<z>
;<z>
getEndPosition(),<z>
[0]));<z>
{<z>
SERVLET_CONFIG_PROPERTY_SOURCE_NAME));<z>
(new StubPropertySource(SERVLET_CONTEXT_PROPERTY_SOURCE_NAME));<z>
JndiLocatorDelegate.isDefaultJndiEnvironmentAvailable()) {<z>
(JNDI_PROPERTY_SOURCE_NAME));<z>
.customizePropertySources(propertySources);<z>
publishEvents(Object result) {<z>
().isArray()) {<z>
.toObjectArray(result);<z>
event : events) {<z>
);<z>
) {<z>
for (Object event : events) {<z>
);<z>
publishEvent(result);<z>
Statement base, FrameworkMethod frameworkMethod, Object testInstance) {<z>
Method testMethod = frameworkMethod.getMethod();<z>
.isDebugEnabled()) {<z>
"Applying SpringMethodRule to test method [" + testMethod + "]");<z>
();<z>
= SpringClassRule.getTestContextManager(testClass);<z>
Statement statement = base;<z>
testContextManager);<z>
(statement, testMethod, testInstance, testContextManager);<z>
testInstance, testContextManager);<z>
, testMethod, testInstance);<z>
(statement, testMethod, testInstance);<z>
);<z>
;<z>
Nullable String requiredName,<z>
ValueHolder> usedValueHolders) {<z>
valueHolder : this.genericArgumentValues) {<z>
)) {<z>
== null ||<z>
getName())))) {<z>
) != null && (requiredType == null ||<z>
)) {<z>
&&<z>
, valueHolder.getValue())) {<z>
valueHolder;<z>
;<z>
{<z>
LoaderOptions();<z>
false);<z>
,<z>
new DumperOptions(), loaderOptions);<z>
) {<z>
getParameter(name) == null) {<z>
;<z>
(request, name);<z>
ex) {<z>
defaultVal;<z>
) {<z>
builder = new StringBuilder("<");<z>
this.body != null) {<z>
;<z>
.append(',');<z>
this.headers);<z>
'>');<z>
();<z>
{<z>
>> initializerClasses =<z>
;<z>
<ConfigurableApplicationContext>> initializerClass : initializerClasses) {<z>
=<z>
);<z>
) {<z>
ApplicationContextException(String.format(<z>
, initializerContextClass.getName(),<z>
getName()));<z>
instantiateClass(initializerClass));<z>
.contextInitializers);<z>
contextInitializers) {<z>
);<z>
Nullable Object[] parameters) throws InvalidDataAccessApiUsageException {<z>
;<z>
;<z>
for (SqlParameter param : this.declaredParameters) {<z>
) {<z>
!supportsLobParameters() &&<z>
() == Types.CLOB)) {<z>
new InvalidDataAccessApiUsageException(<z>
);<z>
++;<z>
);<z>
, String servletPathPrefix) {<z>
servletPathPrefix, "`servletPathPrefix` is required");<z>
(rawPath, contextPath + servletPathPrefix);<z>
contextPath : "");<z>
final Label start) {<z>
!= null) {<z>
, start);<z>
swap) {<z>
);<z>
< len; i++) {<z>
) {<z>
list.get(j - 1);<z>
T cur = list.get(j);<z>
.test(prev, cur)) {<z>
list.set(j, prev);<z>
.set(j - 1, cur);<z>
methods) {<z>
.isEmpty(methods)) {<z>
>(Arrays.asList(methods));<z>
null;<z>
);<z>
, @Nullable Cache cache) {<z>
"'cache' is required when cacheResources=true");<z>
if (cacheResources) {<z>
add(new CachingResourceResolver(cache));<z>
);<z>
{<z>
getBody());<z>
ex) {<z>
return new byte[0];<z>
,<z>
handler) throws IOException {<z>
.getMessage());<z>
sendError(HttpServletResponse.SC_NOT_FOUND);<z>
);<z>
.Context context,<z>
ResolvableType type, HttpMessageReader<T> reader) {<z>
context.serverResponse()<z>
response, context.hints()))<z>
.hints()));<z>
{<z>
);<z>
this.eagerlyInitialized = true;<z>
.initialized = true;<z>
private void addConstantMethodHandle(<z>
index,<z>
referenceKind,<z>
owner,<z>
,<z>
final String descriptor) {<z>
int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;<z>
;<z>
));<z>
> uriVars) {<z>
method;<z>
;<z>
uriTemplate;<z>
;<z>
uriVarsMap = uriVars;<z>
String name) {<z>
!= null, "No BeanFactory configured");<z>
class);<z>
(BeansException ex) {<z>
DestinationResolutionException(<z>
+ name + "'", ex);<z>
> entrySet() {<z>
if (this.entrySet == null) {<z>
);<z>
return this.entrySet;<z>
@Nullable String... locations) {<z>
) {<z>
(locations, "Config locations must not be null");<z>
.length];<z>
< locations.length; i++) {<z>
locations[i]).trim();<z>
null;<z>
(<z>
{<z>
) : null);<z>
);<z>
>();<z>
propertyAccessors) {<z>
= resolver.getSpecificTargetClasses();<z>
) {<z>
;<z>
!= null) {<z>
clazz : targets) {<z>
if (clazz == targetType) {<z>
);<z>
(clazz.isAssignableFrom(targetType)) {<z>
resolver);<z>
resolvers = new ArrayList<>(specificAccessors);<z>
removeAll(specificAccessors);<z>
(generalAccessors);<z>
resolvers;<z>
closeInternal(CloseStatus status) throws IOException {<z>
(this.state == null) {<z>
warn("Ignoring close since connect() was never invoked");<z>
)) {<z>
)) {<z>
);<z>
CLOSING;<z>
.closeStatus = status;<z>
(status);<z>
{<z>
(this.body != null) {<z>
IllegalStateException("Multiple calls to writeWith() not supported"));<z>
.concatWith(body);<z>
);<z>
> resolveArgument(<z>
, ServerWebExchange exchange) {<z>
ResolvableType.forMethodParameter(parameter);<z>
> resolvedType = type.resolve();<z>
getAdapter(resolvedType) : null);<z>
? type.getGeneric() : type);<z>
(),<z>
.getSimpleName() + " does not support multi-value reactive type wrapper: " +<z>
.getGenericParameterType());<z>
(parameter);<z>
exchange);<z>
.one();<z>
);<z>
+ name, bindingResultSink.asMono());<z>
(value -> {<z>
.createDataBinder(exchange, value, name);<z>
binder, exchange))<z>
.doOnError(bindingResultSink::tryEmitError)<z>
-> {<z>
);<z>
.getBindingResult();<z>
bindingResult);<z>
, value);<z>
;<z>
then(Mono.fromCallable(() -> {<z>
BindingResult errors = binder.getBindingResult();<z>
(adapter != null) {<z>
?<z>
, errors)) : valueMono);<z>
parameter)) {<z>
new WebExchangeBindException(parameter, errors);<z>
return value;<z>
);<z>
});<z>
{<z>
, "Field must not be null");<z>
getDeclaringClass());<z>
)).getNested(nestingLevel);<z>
protected boolean destinationEquals(DestinationCacheKey otherKey) {<z>
&&<z>
) ||<z>
;<z>
protected ClassLoader getDefaultClassLoader() {<z>
) {<z>
getClassLoader();<z>
interfaces != null) {<z>
[0].getClassLoader();<z>
return null;<z>
request, ServerHttpResponse response,<z>
WebSessionManager sessionManager, ServerCodecConfigurer codecConfigurer,<z>
) {<z>
.notNull(request, "'request' is required");<z>
(response, "'response' is required");<z>
sessionManager, "'sessionManager' is required");<z>
Assert.notNull(codecConfigurer, "'codecConfigurer' is required");<z>
;<z>
;<z>
;<z>
.response = response;<z>
);<z>
= localeContextResolver;<z>
getLogPrefix());<z>
));<z>
.applicationContext = applicationContext;<z>
) {<z>
String foundName = null;<z>
{<z>
beanName;<z>
) {<z>
usedNames, aliases);<z>
foundName != null) {<z>
, beanElement);<z>
.add(beanName);<z>
this.usedNames.addAll(aliases);<z>
[] getStreamingMediaTypeSeparator(@Nullable MimeType mimeType) {<z>
this.streamingMediaTypes) {<z>
isCompatibleWith(mimeType)) {<z>
return NEWLINE_SEPARATOR;<z>
;<z>
cancel(WriteResultPublisher publisher) {<z>
(this, COMPLETED)) {<z>
.cancelTask.run();<z>
cancel(publisher);<z>
public ResultMatcher doesNotExist(String name) {<z>
{<z>
getResponse().getCookie(name);<z>
);<z>
CharSequence> messageSupplier) {<z>
)) {<z>
messageSupplier), cause);<z>
,<z>
{<z>
repeatableContainers = repeatableContainers;<z>
;<z>
= new ArrayList<>();<z>
annotationType);<z>
forEach(AnnotationTypeMapping::afterAllMappingsSet);<z>
@Nullable List<TransactionSynchronization> synchronizations,<z>
) {<z>
synchronizations != null) {<z>
{<z>
(completionStatus);<z>
(Throwable ex) {<z>
ex);<z>
<TransactionSynchronization> synchronizations) {<z>
.fromIterable(synchronizations)<z>
(TransactionSynchronization::afterCommit)<z>
);<z>
) {<z>
== null) {<z>
new IllegalArgumentException(message);<z>
(AnnotationAttributes attributes) {<z>
= new RuleBasedTransactionAttribute();<z>
getEnum("propagation");<z>
;<z>
= attributes.getEnum("isolation");<z>
.value());<z>
getNumber("timeout").intValue());<z>
getString("timeoutString");<z>
rbta.getTimeout() < 0,<z>
;<z>
;<z>
);<z>
getString("value"));<z>
getStringArray("label")));<z>
>();<z>
: attributes.getClassArray("rollbackFor")) {<z>
);<z>
getStringArray("rollbackForClassName")) {<z>
add(new RollbackRuleAttribute(rbRule));<z>
: attributes.getClassArray("noRollbackFor")) {<z>
.add(new NoRollbackRuleAttribute(rbRule));<z>
getStringArray("noRollbackForClassName")) {<z>
add(new NoRollbackRuleAttribute(rbRule));<z>
rbta.setRollbackRules(rollbackRules);<z>
rbta;<z>
<?> clazz, final StringBuilder stringBuilder) {<z>
> currentClass = clazz;<z>
{<z>
('[');<z>
= currentClass.getComponentType();<z>
currentClass.isPrimitive()) {<z>
descriptor;<z>
(currentClass == Integer.TYPE) {<z>
= 'I';<z>
Void.TYPE) {<z>
= 'V';<z>
{<z>
descriptor = 'Z';<z>
{<z>
descriptor = 'B';<z>
Character.TYPE) {<z>
'C';<z>
else if (currentClass == Short.TYPE) {<z>
;<z>
else if (currentClass == Double.TYPE) {<z>
;<z>
{<z>
descriptor = 'F';<z>
TYPE) {<z>
'J';<z>
else {<z>
new AssertionError();<z>
.append(descriptor);<z>
{<z>
)).append(';');<z>
DeferredResultProcessingInterceptor getInterceptor() {<z>
() {<z>
deferredResult) {<z>
true;<z>
null) {<z>
run();<z>
();<z>
value != RESULT_NONE) {<z>
continueProcessing = false;<z>
setResultInternal(value);<z>
(Throwable ex) {<z>
("Failed to handle timeout result", ex);<z>
return continueProcessing;<z>
deferredResult, Throwable t) {<z>
(errorCallback != null) {<z>
accept(t);<z>
;<z>
Throwable ex) {<z>
"Failed to handle error result", ex);<z>
return false;<z>
DeferredResult<S> deferredResult) {<z>
;<z>
) {<z>
;<z>
throws JMException {<z>
getName();<z>
{<z>
"Proxy for " + targetClassName;<z>
targetClassName;<z>
throws IllegalAccessException {<z>
fieldObject == null) {<z>
new FactoryBeanNotInitializedException();<z>
this.fieldObject);<z>
.targetObject != null) {<z>
.fieldObject.get(this.targetObject);<z>
(null);<z>
String requestPath, String version) {<z>
stripFilenameExtension(requestPath);<z>
);<z>
;<z>
)<z>
{<z>
).getHeaders();<z>
;<z>
);<z>
if (mediaType != null) {<z>
(mediaType);<z>
resource instanceof HttpResource httpResource) {<z>
());<z>
) {<z>
.getFirst(headerName);<z>
assertWithDiagnostics(() -><z>
+ "'", actual != null));<z>
));<z>
(<z>
) {<z>
metadata.getScopedProxyMode();<z>
NO)) {<z>
;<z>
ScopedProxyMode.TARGET_CLASS);<z>
definition, registry, proxyTargetClass);<z>
) {<z>
) {<z>
(task);<z>
RuntimeException ex) {<z>
;<z>
task);<z>
return true;<z>
if (this.active) {<z>
);<z>
return true;<z>
false;<z>
request, String attributeName) {<z>
;<z>
(attributeName, "Attribute name must not be null");<z>
, attributeName);<z>
SCOPE_SESSION);<z>
setTransactionData(@Nullable Object transactionData) {<z>
transactionData = transactionData;<z>
;<z>
if (transactionData instanceof SavepointManager) {<z>
setSavepointManager((SavepointManager) transactionData);<z>
) {<z>
= null;<z>
());<z>
{<z>
()) {<z>
());<z>
.setStatusCode(400);<z>
);<z>
HEAD) {<z>
(response);<z>
);<z>
resultSubscriber);<z>
<T>rowMapper)<z>
DataAccessException {<z>
MapSqlParameterSource(paramMap), rowMapper);<z>
message, String sessionId,<z>
Nullable Principal user) {<z>
(source, message, user);<z>
notNull(sessionId, "Session id must not be null");<z>
;<z>
;<z>
String name, DependencyDescriptor descriptor) {<z>
= ConstructorResolver.setCurrentInjectionPoint(descriptor);<z>
());<z>
);<z>
property, Object newValue) {<z>
Map) {<z>
currentBeanDefinition.getBeanName() + '.' + property,<z>
currentBeanDefinition, property, newValue));<z>
true;<z>
return false;<z>
<?> getParameterType() {<z>
paramType = this.parameterType;<z>
if (paramType != null) {<z>
;<z>
getDeclaringClass()) {<z>
null, 1).resolve();<z>
== null) {<z>
= computeParameterType();<z>
this.parameterType = paramType;<z>
return paramType;<z>
Object obj) {<z>
obj : obj.getClass());<z>
element, SearchStrategy.TYPE_HIERARCHY);<z>
getOrderFromAnnotations(element, annotations);<z>
&& obj instanceof DecoratingProxy) {<z>
obj).getDecoratedClass());<z>
order;<z>
(WebSocketHandler handler,<z>
sessionFactory) {<z>
Assert.notNull(handler, "WebSocketHandler is required");<z>
sessionFactory, "'sessionFactory' is required");<z>
= handler;<z>
sessionFactory;<z>
dataBufferFactory,<z>
{<z>
.dataBufferFactory = dataBufferFactory;<z>
.message = message;<z>
this.context = context;<z>
());<z>
.readOnlyHttpHeaders(adapter);<z>
JMSException {<z>
deliveryDelay >= 0) {<z>
;<z>
)) {<z>
));<z>
(message);<z>
ServerHttpRequest request, ServerHttpResponse response,<z>
Exception {<z>
);<z>
(session != null) {<z>
)) {<z>
;<z>
();<z>
) {<z>
nextElement();<z>
name)) {<z>
.getAttribute(name));<z>
return true;<z>
{<z>
{<z>
hierarchyMode);<z>
String fromHeaderName(String headerName) {<z>
headerName;<z>
) {<z>
;<z>
;<z>
) {<z>
(Profiles candidate : this.parsed) {<z>
(activeProfiles)) {<z>
return true;<z>
false;<z>
Object transaction, TransactionDefinition definition) {<z>
JpaTransactionObject) transaction;<z>
) {<z>
(<z>
"on a single DataSource, no matter whether JPA or JDBC access.");<z>
txObject.hasEntityManagerHolder() ||<z>
) {<z>
createEntityManagerForTransaction();<z>
logger.isDebugEnabled()) {<z>
+ newEm + "] for JPA transaction");<z>
EntityManagerHolder(newEm), true);<z>
.getEntityManager();<z>
(definition);<z>
().beginTransaction(em,<z>
()));<z>
txObject.setTransactionData(transactionData);<z>
());<z>
timeoutToUse != TransactionDefinition.TIMEOUT_DEFAULT) {<z>
setTimeoutInSeconds(timeoutToUse);<z>
() != null) {<z>
.isReadOnly());<z>
!= null) {<z>
conHolder = new ConnectionHolder(conHandle);<z>
TIMEOUT_DEFAULT) {<z>
conHolder.setTimeoutInSeconds(timeoutToUse);<z>
) {<z>
+ "]");<z>
;<z>
;<z>
isDebugEnabled()) {<z>
+ em + "] as JDBC transaction because " +<z>
+ getJpaDialect() + "] does not support JDBC Connection retrieval");<z>
isNewEntityManagerHolder()) {<z>
.bindResource(<z>
(), txObject.getEntityManagerHolder());<z>
.setSynchronizedWithTransaction(true);<z>
{<z>
(txObject);<z>
;<z>
(Throwable ex) {<z>
txObject);<z>
CannotCreateTransactionException("Could not open JPA EntityManager for transaction", ex);<z>
) {<z>
{<z>
return null;<z>
() > 1) {<z>
throw new IllegalArgumentException(<z>
());<z>
0);<z>
RequestBuilder requestBuilder) throws IOException {<z>
resultActions;<z>
.perform(requestBuilder);<z>
) {<z>
IOException(ex);<z>
.andReturn().getResponse();<z>
getResourceLocation(String path) {<z>
) {<z>
;<z>
path;<z>
namespaces, Object... args)<z>
XPathExpressionException {<z>
);<z>
Object payload) {<z>
);<z>
) {<z>
getSubscriptionId() + appendSession();<z>
UNSUBSCRIBE.equals(command)) {<z>
) + appendSession();<z>
equals(command)) {<z>
);<z>
(command)) {<z>
();<z>
"") + appendSession();<z>
command)) {<z>
getUser();<z>
"") + appendSession();<z>
.CONNECTED.equals(command)) {<z>
;<z>
StompCommand.DISCONNECT.equals(command)) {<z>
= getReceipt();<z>
: "") + appendSession();<z>
return getDetailedLogMessage(payload);<z>
{<z>
condition) {<z>
(message);<z>
route) {<z>
) {<z>
return null;<z>
;<z>
public boolean equals(Object other) {<z>
if (this == other) {<z>
;<z>
() != other.getClass()) {<z>
return false;<z>
) other;<z>
.beanFactory, otherTargetSource.beanFactory) &&<z>
otherTargetSource.targetBeanName));<z>
LifecycleGroup(<z>
, boolean autoStartupOnly) {<z>
;<z>
this.timeout = timeout;<z>
.lifecycleBeans = lifecycleBeans;<z>
autoStartupOnly = autoStartupOnly;<z>
(<z>
HttpServletRequest request, HttpServletResponse response, String targetUrl) {<z>
(this.statusCode != null) {<z>
.statusCode;<z>
) request.getAttribute(View.RESPONSE_STATUS_ATTRIBUTE);<z>
attributeStatusCode != null) {<z>
return attributeStatusCode;<z>
;<z>
{<z>
boolean match = matchMediaType(exchange);<z>
!this.isNegated == match);<z>
ex) {<z>
return false;<z>
ResolvableType elementType, @Nullable MediaType mediaType) {<z>
isAssignableFrom(elementType.toClass())) {<z>
false;<z>
(mediaType)) {<z>
;<z>
mediaType == null) {<z>
return MULTIVALUE_TYPE.isAssignableFrom(elementType);<z>
false;<z>
{<z>
() != null) {<z>
().getPropertyAccessor();<z>
;<z>
?> values) {<z>
values);<z>
!= null) {<z>
return kh.getKey();<z>
(<z>
;<z>
public Object echo(Throwable t) throws Throwable {<z>
t != null) {<z>
throw t;<z>
;<z>
default "";<z>
("value")<z>
default "";<z>
String[] label() default {};<z>
... arguments) {<z>
, endPos, arguments);<z>
true;<z>
= dimensions;<z>
) {<z>
= this.uri;<z>
uri != null, "No initial request yet");<z>
return uri;<z>
String name) throws NamingException {<z>
if (logger.isDebugEnabled()) {<z>
+ name + "]");<z>
execute(ctx -> {<z>
name);<z>
return null;<z>
;<z>
{<z>
alias, name)) {<z>
+ alias +<z>
+ name + "': Circular reference - '" +<z>
+ alias + "' already");<z>
, ResourceTransformerChain transformerChain)<z>
IOException {<z>
resource, Resource.class);<z>
!= null) {<z>
("Resource resolved from cache");<z>
transformed;<z>
transformerChain.transform(request, resource);<z>
cache.put(resource, transformed);<z>
return transformed;<z>
databaseMetaData) throws SQLException {<z>
{<z>
logger.debug("GetGeneratedKeys is supported");<z>
;<z>
logger.debug("GetGeneratedKeys is not supported");<z>
false);<z>
{<z>
if (logger.isWarnEnabled()) {<z>
);<z>
String databaseProductName = databaseMetaData.getDatabaseProductName();<z>
) {<z>
)) {<z>
+ databaseProductName);<z>
(false);<z>
if (isGetGeneratedKeysSupported()) {<z>
) {<z>
databaseProductName);<z>
;<z>
);<z>
{<z>
.isWarnEnabled()) {<z>
("Error retrieving 'DatabaseMetaData.getDatabaseProductName': " + ex.getMessage());<z>
databaseVersion = databaseMetaData.getDatabaseProductVersion();<z>
) {<z>
logger.isWarnEnabled()) {<z>
.getMessage());<z>
storesUpperCaseIdentifiers());<z>
catch (SQLException ex) {<z>
)) {<z>
());<z>
());<z>
ex) {<z>
{<z>
;<z>
alreadySeen) {<z>
.contains(beanName)) {<z>
;<z>
beanName);<z>
.get(canonicalName);<z>
== null) {<z>
false;<z>
contains(dependentBeanName)) {<z>
;<z>
dependentBeans) {<z>
null) {<z>
= new HashSet<>();<z>
beanName);<z>
dependentBeanName, alreadySeen)) {<z>
true;<z>
return false;<z>
Label end, int index) {<z>
this.hasLvtInfo = true;<z>
.length; i++) {<z>
== index) {<z>
this.parameterNames[i] = name;<z>
ConfigurableListableBeanFactory bf,<z>
servletConfig) {<z>
)) {<z>
.registerSingleton(WebApplicationContext.SERVLET_CONTEXT_BEAN_NAME, servletContext);<z>
containsBean(ConfigurableWebApplicationContext.SERVLET_CONFIG_BEAN_NAME)) {<z>
(ConfigurableWebApplicationContext.SERVLET_CONFIG_BEAN_NAME, servletConfig);<z>
.containsBean(WebApplicationContext.CONTEXT_PARAMETERS_BEAN_NAME)) {<z>
();<z>
null) {<z>
);<z>
{<z>
nextElement();<z>
, servletContext.getInitParameter(paramName));<z>
(servletConfig != null) {<z>
getInitParameterNames();<z>
)) {<z>
;<z>
);<z>
.registerSingleton(WebApplicationContext.CONTEXT_PARAMETERS_BEAN_NAME,<z>
parameterMap));<z>
WebApplicationContext.CONTEXT_ATTRIBUTES_BEAN_NAME)) {<z>
HashMap<>();<z>
(servletContext != null) {<z>
= servletContext.getAttributeNames();<z>
()) {<z>
(String) attrNameEnum.nextElement();<z>
));<z>
.CONTEXT_ATTRIBUTES_BEAN_NAME,<z>
));<z>
DataBuffer> collection) {<z>
);<z>
.readableByteCount()));<z>
return result;<z>
, String name) throws AccessException {<z>
member instanceof Method method) {<z>
makeAccessible(method);<z>
(target);<z>
));<z>
) {<z>
"Unable to access property '" + name + "' through getter method", ex);<z>
Field) this.member;<z>
ReflectionUtils.makeAccessible(field);<z>
);<z>
.typeDescriptor.narrow(value));<z>
catch (Exception ex) {<z>
, ex);<z>
Exception ex) throws Throwable {<z>
) {<z>
msg = "Could not connect to JMX server - retrying";<z>
(logger.isDebugEnabled()) {<z>
, ex);<z>
()) {<z>
;<z>
();<z>
);<z>
;<z>
) {<z>
.isLoggable(level)) {<z>
;<z>
(message instanceof LogRecord) {<z>
LogRecord) message;<z>
));<z>
);<z>
(this.logger.getResourceBundleName());<z>
());<z>
.setThrown(exception);<z>
.log(rec);<z>
Object other) {<z>
(this == other) {<z>
true;<z>
instanceof MatchAlwaysTransactionAttributeSource otherTas)) {<z>
return false;<z>
, otherTas.transactionAttribute);<z>
PathContainer pathRemaining,<z>
) {<z>
pathRemaining = pathRemaining;<z>
this.pathMatched = pathMatched;<z>
pathMatchInfo;<z>
validateMergedContextConfiguration(WebMergedContextConfiguration webMergedConfig) {<z>
{<z>
= String.format(<z>
().getName(),<z>
);<z>
logger.error(msg);<z>
IllegalStateException(msg);<z>
public TransferSimpSubscription(SimpSubscription subscription) {<z>
.getId();<z>
new TransferSimpSession();<z>
subscription.getDestination();<z>
(HttpServletRequest request) {<z>
);<z>
(uri == null) {<z>
;<z>
, uri);<z>
... packagesToScan) throws JAXBException {<z>
.isDebugEnabled()) {<z>
.debug("Creating JAXBContext by scanning packages [" +<z>
packagesToScan) + "]");<z>
beanClassLoader, packagesToScan);<z>
.scanPackages();<z>
(logger.isDebugEnabled()) {<z>
arrayToCommaDelimitedString(jaxb2Classes) + "]");<z>
classesToBeBound = jaxb2Classes;<z>
null) {<z>
.newInstance(jaxb2Classes, this.jaxbContextProperties);<z>
);<z>
, @Nullable BeanDefinition beanDefinition) {<z>
this.beanExpressionResolver == null) {<z>
;<z>
= null;<z>
) {<z>
getScope();<z>
{<z>
scopeName);<z>
;<z>
) throws IOException {<z>
) {<z>
;<z>
.file.exists()) {<z>
() +<z>
;<z>
length;<z>
(this.filePath);<z>
{<z>
);<z>
private Object resolveEmbeddedValuesAndExpressions(String value) {<z>
|| this.expressionContext == null) {<z>
value;<z>
configurableBeanFactory.resolveEmbeddedValue(value);<z>
);<z>
== null) {<z>
value;<z>
.expressionContext);<z>
int indexOf(Method attribute) {<z>
.length; i++) {<z>
[i].equals(attribute)) {<z>
i;<z>
return -1;<z>
(HttpServletRequest request) {<z>
: FORWARDED_HEADER_NAMES) {<z>
null) {<z>
false;<z>
;<z>
NoSuchMethodException {<z>
bean, "Bean is required");<z>
methodName, "Method name is required");<z>
.bean = bean;<z>
this.beanFactory = null;<z>
.messageSource = null;<z>
bean);<z>
(methodName, parameterTypes);<z>
= BridgeMethodResolver.findBridgedMethod(this.method);<z>
;<z>
= initMethodParameters();<z>
);<z>
.method);<z>
{<z>
.wsSession.initializeNativeSession(session);<z>
handler.supportsPartialMessages()) {<z>
String>() {<z>
boolean isLast) {<z>
handleTextMessage(session, message, isLast);<z>
;<z>
() {<z>
boolean isLast) {<z>
session, message, isLast);<z>
);<z>
>() {<z>
onMessage(String message) {<z>
message, true);<z>
});<z>
<ByteBuffer>() {<z>
public void onMessage(ByteBuffer message) {<z>
);<z>
);<z>
PongMessage>() {<z>
{<z>
, message.getApplicationData());<z>
});<z>
this.wsSession);<z>
(Exception ex) {<z>
.wsSession, ex, logger);<z>
o2) {<z>
.convert(o1);<z>
this.converter.convert(o2);<z>
);<z>
setAsText(String text) throws IllegalArgumentException {<z>
!StringUtils.hasText(text)) {<z>
null);<z>
this.numberFormat != null) {<z>
this.numberClass, this.numberFormat));<z>
parseNumber(text, this.numberClass));<z>
void initialize(<z>
ServletResponse response,<z>
) {<z>
UnsupportedOperationException("Use appropriate constructor");<z>
(URI url, DefaultConfigurator configurator) {<z>
.getResponseHeaders();<z>
"Sec-WebSocket-Protocol");<z>
Mono.empty(), protocol);<z>
<String, Object> headers,<z>
@Nullable MessagePostProcessor postProcessor) {<z>
MessageHeaders messageHeaders = null;<z>
);<z>
Object> headersToUse = processHeadersToSend(headers);<z>
) {<z>
) {<z>
messageHeaders = (MessageHeaders) headersToUse;<z>
new MessageHeaders(headersToUse);<z>
converter = getMessageConverter();<z>
instanceof SmartMessageConverter ?<z>
payload, messageHeaders, conversionHint) :<z>
messageHeaders));<z>
) {<z>
.getName();<z>
MessageHeaders.CONTENT_TYPE) : null);<z>
+ payloadType +<z>
() + "]");<z>
null) {<z>
message);<z>
return message;<z>
, Object... args) throws BeansException {<z>
)) {<z>
throw new UnsupportedOperationException(<z>
;<z>
);<z>
,<z>
, ServerRequest, T> errorHandler) {<z>
Assert.notNull(predicate, "Predicate must not be null");<z>
Assert.notNull(errorHandler, "ErrorHandler must not be null");<z>
, errorHandler));<z>
WebSocketHttpRequestHandler(WebSocketHandler wsHandler, HandshakeHandler handshakeHandler) {<z>
notNull(wsHandler, "wsHandler must not be null");<z>
handshakeHandler, "handshakeHandler must not be null");<z>
);<z>
;<z>
) {<z>
!= null) {<z>
;<z>
this;<z>
public static MultiValueMap<String, Object> getAllAnnotationAttributes(<z>
annotationName) {<z>
annotationName, false, false);<z>
, Annotation[] annotations,<z>
annotationFilter) {<z>
source = source;<z>
= null;<z>
searchStrategy = null;<z>
= annotations;<z>
= repeatableContainers;<z>
annotationFilter;<z>
?>> converters,<z>
{<z>
);<z>
= converters;<z>
advice = new RequestResponseBodyAdviceChain(requestResponseBodyAdvice);<z>
)<z>
{<z>
resourcesHolder != null) {<z>
.suspendedResources;<z>
{<z>
);<z>
> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations;<z>
null) {<z>
TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive);<z>
TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel);<z>
readOnly);<z>
.setCurrentTransactionName(resourcesHolder.name);<z>
(suspendedSynchronizations);<z>
FrameworkMethod frameworkMethod, Object testInstance, Statement statement) {<z>
, testInstance, statement);<z>
;<z>
) result;<z>
(<z>
<AsyncUncaughtExceptionHandler> exceptionHandler) {<z>
asyncAnnotationTypes = new LinkedHashSet<>(2);<z>
;<z>
Class<? extends Annotation>)<z>
getClassLoader()));<z>
ex) {<z>
;<z>
(asyncAnnotationTypes);<z>
MediaType defaultContentType) {<z>
!= null) {<z>
());<z>
)) {<z>
IllegalArgumentException(<z>
);<z>
this.defaultContentType = defaultContentType;<z>
) {<z>
(element.hasAttribute(WEAVER_CLASS_ATTRIBUTE)) {<z>
);<z>
return DEFAULT_LOAD_TIME_WEAVER_CLASS_NAME;<z>
(Endpoint endpointInstance, ClientEndpointConfig cec, URI path)<z>
IOException {<z>
throw new UnsupportedOperationException(<z>
"MockServerContainer does not support connectToServer(Endpoint, ClientEndpointConfig, URI)");<z>
() {<z>
getTypeName();<z>
this.typeArguments.length > 0) {<z>
"<", ">");<z>
typeArguments) {<z>
.add(argument.getTypeName());<z>
return typeName + stringJoiner;<z>
;<z>
{<z>
()) {<z>
!other.hasConstructorArgumentValues();<z>
this.constructorArgumentValues, other.constructorArgumentValues);<z>
HttpSession getSession(boolean allowCreate) {<z>
isRequestActive()) {<z>
this.request.getSession(allowCreate);<z>
.session = session;<z>
return session;<z>
;<z>
session == null) {<z>
allowCreate) {<z>
IllegalStateException(<z>
;<z>
= this.request.getSession(false);<z>
.session = session;<z>
;<z>
) {<z>
t instanceof DOMSource) {<z>
);<z>
));<z>
os.count;<z>
(TransformerException ex) {<z>
;<z>
String comments) throws IOException {<z>
ByteArrayOutputStream baos = new ByteArrayOutputStream();<z>
: comments));<z>
toString(StandardCharsets.ISO_8859_1);<z>
line : contents.split(EOL)) {<z>
startsWith("#"))) {<z>
);<z>
String annotationName) {<z>
getAnnotations()) {<z>
getName().equals(annotationName)) {<z>
, annotation);<z>
return Collections.emptySet();<z>
) {<z>
.brokerAvailable.compareAndSet(true, false);<z>
this.eventPublisher != null && shouldPublish) {<z>
) {<z>
.notAvailableEvent);<z>
);<z>
Builder clearBlah() {<z>
= (bitField0_ & ~0x00000001);<z>
= 0;<z>
);<z>
;<z>
HttpServletResponse response, Object handler,<z>
Exception ex) throws Exception {<z>
response, handler, ex);<z>
() throws IOException {<z>
return this.path.toFile();<z>
ex) {<z>
FileNotFoundException(this.path + " cannot be resolved to absolute file path");<z>
{<z>
"Source for field copy cannot be null");<z>
);<z>
))) {<z>
dest.getClass().getName() +<z>
() + "]");<z>
{<z>
;<z>
src);<z>
set(dest, srcValue);<z>
, COPYABLE_FIELDS);<z>
T> requiredType) throws BeansException {<z>
;<z>
);<z>
null) {<z>
namedBean;<z>
= getParentBeanFactory();<z>
{<z>
parent).resolveNamedBean(requiredType);<z>
(requiredType);<z>
Class<?>... parameterTypes)<z>
NoSuchMethodException {<z>
super(bean, methodName, parameterTypes);<z>
(String name, String... values) {<z>
for (String value : values) {<z>
.build());<z>
;<z>
> computeMatchingSubscriptions(String destination) {<z>
LinkedMultiValueMap<>();<z>
forEachSubscription((sessionId, subscription) -> {<z>
(subscription.isPattern()) {<z>
), destination)) {<z>
sessionId, subscription.getId());<z>
.getDestination())) {<z>
);<z>
);<z>
;<z>
String name) {<z>
this.caches.get(name);<z>
) {<z>
);<z>
cacheNames) {<z>
this.cacheNames.add(name);<z>
get(name);<z>
throws DataAccessException {<z>
= getParticipateAttributeName();<z>
;<z>
applySessionBindingInterceptor(asyncManager, key)) {<z>
(obtainSessionFactory())) {<z>
, WebRequest.SCOPE_REQUEST);<z>
!= null ? count + 1 : 1);<z>
(), newCount, WebRequest.SCOPE_REQUEST);<z>
debug("Opening Hibernate Session in OpenSessionInViewInterceptor");<z>
;<z>
session);<z>
);<z>
asyncRequestInterceptor =<z>
);<z>
asyncRequestInterceptor);<z>
registerDeferredResultInterceptor(key, asyncRequestInterceptor);<z>
public BeanFactoryAspectJAdvisorsBuilderAdapter(<z>
AspectJAdvisorFactory advisorFactory) {<z>
);<z>
{<z>
if (test) {<z>
result.add(value);<z>
public Mono<Void> changeSessionId() {<z>
();<z>
(currentId);<z>
idGenerator.generateId());<z>
.id.set(newId);<z>
getId(), this);<z>
Mono.empty();<z>
requestResponseBodyAdvice, Class<T> adviceType) {<z>
(requestResponseBodyAdvice != null) {<z>
= new ArrayList<>();<z>
requestResponseBodyAdvice) {<z>
advice instanceof ControllerAdviceBean adviceBean ?<z>
() : advice.getClass());<z>
)) {<z>
add((T) advice);<z>
;<z>
Collections.emptyList();<z>
void readModuleAttributes(<z>
classVisitor,<z>
Context context,<z>
final int moduleOffset,<z>
final int modulePackagesOffset,<z>
) {<z>
.charBuffer;<z>
= moduleOffset;<z>
buffer);<z>
2);<z>
);<z>
6;<z>
visitModule(moduleName, moduleFlags, moduleVersion);<z>
(moduleVisitor == null) {<z>
if (moduleMainClass != null) {<z>
(moduleMainClass);<z>
0) {<z>
;<z>
currentPackageOffset = modulePackagesOffset + 2;<z>
0) {<z>
, buffer));<z>
+= 2;<z>
currentOffset);<z>
2;<z>
> 0) {<z>
= readModule(currentOffset, buffer);<z>
(currentOffset + 2);<z>
= readUTF8(currentOffset + 4, buffer);<z>
6;<z>
, requiresVersion);<z>
;<z>
currentOffset += 2;<z>
while (exportsCount-- > 0) {<z>
;<z>
);<z>
currentOffset + 4);<z>
currentOffset += 6;<z>
String[] exportsTo = null;<z>
exportsToCount != 0) {<z>
[exportsToCount];<z>
++i) {<z>
, buffer);<z>
;<z>
(exports, exportsFlags, exportsTo);<z>
int opensCount = readUnsignedShort(currentOffset);<z>
;<z>
opensCount-- > 0) {<z>
);<z>
);<z>
= readUnsignedShort(currentOffset + 4);<z>
6;<z>
opensTo = null;<z>
!= 0) {<z>
;<z>
) {<z>
] = readModule(currentOffset, buffer);<z>
2;<z>
opensFlags, opensTo);<z>
;<z>
+= 2;<z>
usesCount-- > 0) {<z>
currentOffset, buffer));<z>
;<z>
int providesCount = readUnsignedShort(currentOffset);<z>
2;<z>
{<z>
);<z>
(currentOffset + 2);<z>
currentOffset += 4;<z>
;<z>
) {<z>
] = readClass(currentOffset, buffer);<z>
2;<z>
moduleVisitor.visitProvide(provides, providesWith);<z>
);<z>
{<z>
?<z>
map(NettyDataBufferFactory::toByteBuf) :<z>
dataBuffers).map(NettyDataBufferFactory::toByteBuf);<z>
public void method() {<z>
this.selfReference),<z>
);<z>
.dependency.method();<z>
Object returnValue, MethodParameter returnType,<z>
) throws Exception {<z>
mavContainer.setRequestHandled(true);<z>
null) {<z>
;<z>
);<z>
class, returnValue);<z>
= (HttpEntity<?>) returnValue;<z>
outputHeaders = outputMessage.getHeaders();<z>
getHeaders();<z>
isEmpty()) {<z>
) -> {<z>
VARY)) {<z>
getVaryRequestHeadersToAdd(outputHeaders, entityHeaders);<z>
) {<z>
.setVary(values);<z>
, value);<z>
);<z>
(httpEntity instanceof ResponseEntity<?> responseEntity) {<z>
= responseEntity.getStatusCodeValue();<z>
.getServletResponse().setStatus(returnStatus);<z>
{<z>
();<z>
HEAD.equals(method))<z>
(inputMessage, outputMessage)) {<z>
();<z>
100 == 3) {<z>
("location");<z>
) {<z>
webRequest, location);<z>
, inputMessage, outputMessage);<z>
);<z>
) {<z>
= 0;<z>
{<z>
) {<z>
count++;<z>
count;<z>
headerName) {<z>
> map = getNativeHeaders();<z>
!= null) {<z>
values = map.get(headerName);<z>
!CollectionUtils.isEmpty(values)) {<z>
return values.get(0);<z>
return null;<z>
HandlerExceptionResolver> exceptionResolvers) {<z>
.delegates) {<z>
;<z>
(HttpServletRequest request, AsyncContext asyncContext)<z>
URISyntaxException {<z>
(getServletPath(), "Servlet path is not initialized");<z>
return new TomcatServerHttpRequest(<z>
, getBufferSize());<z>
{<z>
;<z>
previous != null) {<z>
;<z>
void clearClassLoader(@Nullable ClassLoader classLoader) {<z>
acceptedClassLoaders.removeIf(registeredLoader -><z>
);<z>
().removeIf(beanClass -><z>
;<z>
.removeIf(beanClass -><z>
), classLoader));<z>
{<z>
notNull(ex, "JMSException must not be null");<z>
jms.IllegalStateException) {<z>
);<z>
ex instanceof jakarta.jms.InvalidClientIDException) {<z>
InvalidClientIDException) ex);<z>
) {<z>
;<z>
instanceof jakarta.jms.InvalidSelectorException) {<z>
.InvalidSelectorException) ex);<z>
(ex instanceof jakarta.jms.JMSSecurityException) {<z>
JMSSecurityException) ex);<z>
.MessageEOFException) {<z>
);<z>
) {<z>
) ex);<z>
{<z>
.MessageNotReadableException) ex);<z>
(ex instanceof jakarta.jms.MessageNotWriteableException) {<z>
) ex);<z>
.ResourceAllocationException) {<z>
;<z>
jms.TransactionInProgressException) {<z>
);<z>
.jms.TransactionRolledBackException) {<z>
ex);<z>
);<z>
compileInternal() {<z>
dataSource = getJdbcTemplate().getDataSource();<z>
(dataSource != null, "No DataSource set");<z>
.initializeMetaData(dataSource);<z>
, value)));<z>
.declaredParameters);<z>
this.callMetaDataContext.createCallString();<z>
logger.isDebugEnabled()) {<z>
;<z>
callableStatementFactory = new CallableStatementCreatorFactory(<z>
));<z>
();<z>
) {<z>
this.sseDecoder != null ? this.sseDecoder :<z>
() :<z>
:<z>
;<z>
));<z>
() {<z>
this.objectReaders.clear();<z>
{<z>
if (kotlinSerializationJsonPresent) {<z>
<>(getKotlinSerializationJsonDecoder()));<z>
(jackson2Present) {<z>
<>(getJackson2JsonDecoder()));<z>
(jackson2SmilePresent) {<z>
<>(this.jackson2SmileDecoder != null ?<z>
Jackson2SmileDecoder()));<z>
&& !shouldIgnoreXml) {<z>
?<z>
.jaxb2Decoder : new Jaxb2XmlDecoder()));<z>
);<z>
private void onSinkCancel() {<z>
INSTANCE);<z>
dispose();<z>
;<z>
Advice buildAdvice(<z>
AsyncUncaughtExceptionHandler> exceptionHandler) {<z>
;<z>
);<z>
return interceptor;<z>
<A extends Annotation> A findAnnotationOnBean(<z>
> annotationType, boolean allowFactoryBeanInit)<z>
{<z>
();<z>
.findAnnotationOnBean(beanName, annotationType, allowFactoryBeanInit);<z>
<String, String> pathVariables() {<z>
pathVariables = (Map<String, String>)<z>
URI_TEMPLATE_VARIABLES_ATTRIBUTE);<z>
{<z>
pathVariables;<z>
();<z>
, boolean isFloat) {<z>
(isFloat) {<z>
float value = Float.parseFloat(numberToken);<z>
(numberToken, startPos, endPos, value);<z>
Double.parseDouble(numberToken);<z>
value);<z>
catch (NumberFormatException ex) {<z>
);<z>
public void setAsText(String text) {<z>
StringUtils.hasText(text)) {<z>
.trim();<z>
(locationToUse));<z>
setValue(null);<z>
Template getTemplate(String viewUrl) throws Exception {<z>
;<z>
;<z>
catch (ClassNotFoundException ex) {<z>
() : ex);<z>
(<z>
) + "'", cause);<z>
convertHibernateAccessException(HibernateException ex) {<z>
instanceof JDBCException jdbcEx) {<z>
dae = this.jdbcExceptionTranslator.translate(<z>
(), jdbcEx.getSQLException());<z>
(dae != null) {<z>
;<z>
return SessionFactoryUtils.convertHibernateAccessException(ex);<z>
Object value) {<z>
ValueWrapper existingValue = get(key);<z>
existingValue == null) {<z>
put(key, value);<z>
;<z>
, @Nullable RootBeanDefinition mbd)<z>
Throwable {<z>
= (bean instanceof InitializingBean);<z>
"afterPropertiesSet"))) {<z>
(logger.isTraceEnabled()) {<z>
"'");<z>
InitializingBean) bean).afterPropertiesSet();<z>
) != NullBean.class) {<z>
);<z>
(StringUtils.hasLength(initMethodName) &&<z>
)) &&<z>
) {<z>
, bean, mbd);<z>
result) {<z>
.getReturnType();<z>
if (result instanceof Message) {<z>
result)<z>
();<z>
withPayload(result).setHeader(<z>
;<z>
DataBuffer buffer, DataBufferFactory bufferFactory,<z>
hints) {<z>
.isLoggingSuppressed(hints)) {<z>
logValue(buffer, hints);<z>
;<z>
@Nullable Object returnValue, MethodParameter returnType,<z>
ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {<z>
{<z>
);<z>
ModelAndView mav = (ModelAndView) returnValue;<z>
mav.isReference()) {<z>
getViewName();<z>
mavContainer.setViewName(viewName);<z>
viewName != null && isRedirectViewName(viewName)) {<z>
.setRedirectModelScenario(true);<z>
View view = mav.getView();<z>
.setView(view);<z>
SmartView) view).isRedirectView()) {<z>
true);<z>
));<z>
));<z>
String requestUri, String mapping, boolean ignoreCase) {<z>
;<z>
0;<z>
++, index2++) {<z>
.charAt(index1);<z>
index2);<z>
) {<z>
indexOf('/', index1);<z>
(index1 == -1) {<z>
;<z>
(index1);<z>
(c2)))) {<z>
null;<z>
!= mapping.length()) {<z>
;<z>
)) {<z>
;<z>
requestUri.charAt(index1) == ';') {<z>
index1);<z>
requestUri.substring(index1) : "");<z>
newThread(Runnable runnable) {<z>
this.threadFactory != null) {<z>
threadFactory.newThread(runnable);<z>
);<z>
public void afterPropertiesSet() {<z>
(isSingleton()) {<z>
;<z>
public void init() {<z>
new AnnotationDrivenBeanDefinitionParser());<z>
, new ExecutorBeanDefinitionParser());<z>
));<z>
("scheduler", new SchedulerBeanDefinitionParser());<z>
Nullable Object returnValue, MethodParameter returnType,<z>
) throws Exception {<z>
null) {<z>
true);<z>
returnValue;<z>
.startCallableProcessing(callable, mavContainer);<z>
(<z>
, boolean synchronizedWithTransaction) {<z>
.targetFactory = target;<z>
properties = properties;<z>
synchronizedWithTransaction;<z>
();<z>
throws InvalidResultSetAccessException {<z>
cal);<z>
se) {<z>
);<z>
renderMergedOutputModel(<z>
HttpServletRequest request, HttpServletResponse response) throws Exception {<z>
);<z>
();<z>
newWriter(document, baos);<z>
(model, writer, request);<z>
document, request);<z>
);<z>
, writer, request, response);<z>
);<z>
baos);<z>
requiredType) {<z>
>() {<z>
) throws BeansException {<z>
;<z>
args) throws BeansException {<z>
requiredType, args);<z>
() throws BeansException {<z>
(requiredType);<z>
NoUniqueBeanDefinitionException ex) {<z>
;<z>
{<z>
return null;<z>
T getIfUnique() throws BeansException {<z>
requiredType);<z>
{<z>
null;<z>
logPrefix) {<z>
this::cancelAndSetCompleted);<z>
;<z>
(PathContainer path) {<z>
;<z>
) {<z>
) {<z>
new TreeSet<>());<z>
.add(pattern);<z>
;<z>
@Nullable JsonFactory factory) {<z>
JacksonXmlModule();<z>
.setDefaultUseWrapper(defaultUseWrapper);<z>
) {<z>
) factory, module);<z>
.createDefensiveInputFactory()), module);<z>
>> violations, Errors errors) {<z>
> violation : violations) {<z>
= determineField(violation);<z>
= errors.getFieldError(field);<z>
|| !fieldError.isBindingFailure()) {<z>
;<z>
);<z>
, cd);<z>
BindingResult bindingResult) {<z>
field;<z>
isEmpty()) {<z>
] errorCodes = bindingResult.resolveMessageCodes(errorCode);<z>
ObjectError error = new ViolationObjectError(<z>
errorCodes, errorArgs, violation, this);<z>
(error);<z>
);<z>
.resolveMessageCodes(errorCode, field);<z>
nestedField,<z>
errorCodes, errorArgs, violation, this);<z>
;<z>
violation.getMessage());<z>
NotReadablePropertyException ex) {<z>
field +<z>
, ex);<z>
Nullable Object value, MethodParameter returnType) {<z>
(HandlerMethodReturnValueHandler handler : this.returnValueHandlers) {<z>
instanceof AsyncHandlerMethodReturnValueHandler &&<z>
returnType)) {<z>
return true;<z>
;<z>
index,<z>
,<z>
owner,<z>
final String name,<z>
String value,<z>
{<z>
index;<z>
= tag;<z>
owner = owner;<z>
.name = name;<z>
;<z>
;<z>
void registerAdapters(ReactiveAdapterRegistry registry) {<z>
.registerReactiveType(<z>
(Mono.class, Mono::empty),<z>
<?>) source,<z>
::from);<z>
.registerReactiveType(<z>
class, Flux::empty),<z>
source -> (Flux<?>) source,<z>
Flux::from);<z>
registerReactiveType(<z>
,<z>
Publisher<?>) source,<z>
-> source);<z>
(<z>
, EmptyCompletableFuture::new),<z>
),<z>
(source).toFuture());<z>
registerReactiveType(<z>
, () -> EMPTY_FLOW),<z>
<?>) source),<z>
);<z>
(ClassEmitter ce) {<z>
ACC_STATIC,<z>
);<z>
);<z>
putfield(STATIC_CALLBACKS_FIELD);<z>
e.return_value();<z>
);<z>
?> factory) {<z>
"Endpoint must not be null");<z>
"Endpoint id must be set");<z>
(endpoint, factory);<z>
{<z>
startImmediately) {<z>
(this.endpointRegistry != null, "No JmsListenerEndpointRegistry set");<z>
.registerListenerContainer(descriptor.endpoint,<z>
;<z>
descriptor);<z>
) {<z>
timeout != null) {<z>
), TimeUnit.MILLISECONDS);<z>
this.futureResponse.get();<z>
) {<z>
("Failed to get future response", ex);<z>
String defaultMessage) {<z>
? args.toArray() : null),<z>
());<z>
msg : "");<z>
(E event) {<z>
() &&<z>
isActualTransactionActive()) {<z>
TransactionSynchronizationManager.registerSynchronization(<z>
.callbacks));<z>
protected void cancelRemainingTask(Runnable task) {<z>
(task instanceof Future) {<z>
).cancel(true);<z>
@Nullable Object targetObject) {<z>
targetObject;<z>
targetObject != null) {<z>
;<z>
{<z>
();<z>
{<z>
close();<z>
public String getPITarget() {<z>
(this.event.isProcessingInstruction()) {<z>
;<z>
throw new IllegalStateException();<z>
{<z>
getValue(state);<z>
) {<z>
(getChild(0).getStartPosition(),<z>
SpelMessage.TYPE_NAME_EXPECTED_FOR_ARRAY_CONSTRUCTION,<z>
(<z>
) : null));<z>
;<z>
TypeCode arrayTypeCode = TypeCode.forName(type);<z>
TypeCode.OBJECT) {<z>
findType(type);<z>
componentType = arrayTypeCode.getType();<z>
newArray = null;<z>
(!hasInitializer()) {<z>
null) {<z>
this.dimensions) {<z>
dimension == null) {<z>
.MISSING_ARRAY_DIMENSION);<z>
state.getEvaluationContext().getTypeConverter();<z>
.dimensions.length == 1) {<z>
(state);<z>
;<z>
);<z>
];<z>
dimensions.length; d++) {<z>
dimensions[d].getTypedValue(state);<z>
;<z>
dims);<z>
) {<z>
throw new SpelEvaluationException(getStartPosition(),<z>
MULTIDIM_ARRAY_INITIALIZER_NOT_SUPPORTED);<z>
().getTypeConverter();<z>
(InlineList) getChild(1);<z>
) {<z>
state);<z>
toInt(typeConverter, dValue);<z>
getChildCount()) {<z>
);<z>
);<z>
, arraySize);<z>
== TypeCode.OBJECT) {<z>
, typeConverter, initializer, componentType);<z>
(arrayTypeCode == TypeCode.BOOLEAN) {<z>
;<z>
if (arrayTypeCode == TypeCode.BYTE) {<z>
state, newArray, typeConverter, initializer);<z>
(arrayTypeCode == TypeCode.CHAR) {<z>
newArray, typeConverter, initializer);<z>
== TypeCode.DOUBLE) {<z>
, newArray, typeConverter, initializer);<z>
== TypeCode.FLOAT) {<z>
);<z>
if (arrayTypeCode == TypeCode.INT) {<z>
typeConverter, initializer);<z>
(arrayTypeCode == TypeCode.LONG) {<z>
);<z>
TypeCode.SHORT) {<z>
initializer);<z>
));<z>
return new TypedValue(newArray);<z>
, Object handler, Method method) {<z>
.lock();<z>
handlerMethod = createHandlerMethod(handler, method);<z>
, mapping);<z>
(mapping);<z>
: directPaths) {<z>
pathLookup.add(path, mapping);<z>
name = null;<z>
getNamingStrategy() != null) {<z>
, mapping);<z>
handlerMethod);<z>
mapping);<z>
null) {<z>
validateAllowCredentials();<z>
, corsConfig);<z>
(mapping,<z>
directPaths, name, corsConfig != null));<z>
).unlock();<z>
public MetadataSources getMetadataSources() {<z>
metadataSourcesAccessed = true;<z>
(this.metadataSources == null) {<z>
();<z>
if (this.resourcePatternResolver != null) {<z>
;<z>
{<z>
for (Integrator integrator : this.hibernateIntegrators) {<z>
integrator);<z>
.build());<z>
return this.metadataSources;<z>
(int pos, Advisor advisor) throws AopConfigException {<z>
IntroductionAdvisor) {<z>
;<z>
pos, advisor);<z>
> decode(WebSocketMessage<?> webSocketMessage) {<z>
> result = Collections.emptyList();<z>
;<z>
{<z>
;<z>
if (webSocketMessage instanceof BinaryMessage) {<z>
webSocketMessage).getPayload();<z>
;<z>
.bufferingDecoder.decode(byteBuffer);<z>
if (result.isEmpty()) {<z>
{<z>
logger.trace("Incomplete STOMP frame content received, bufferSize=" +<z>
+ ", bufferSizeLimit=" +<z>
;<z>
return result;<z>
Object targetObject) {<z>
this.delegateMap) {<z>
{<z>
.delegateMap.get(targetObject);<z>
();<z>
.put(targetObject, delegate);<z>
return delegate;<z>
) {<z>
;<z>
, "value");<z>
.context = new StandardEvaluationContext(map);<z>
ExpressionParser spelExpressionParser = new SpelExpressionParser();<z>
expression = spelExpressionParser.parseExpression("#root['key']");<z>
() {<z>
;<z>
bytes);<z>
content.tryEmitValue(bytes);<z>
(<z>
) {<z>
this.urlDecode) {<z>
return vars;<z>
>(vars.size());<z>
.forEach((key, values) -> {<z>
String value : values) {<z>
));<z>
);<z>
;<z>
private Source getSource() {<z>
Source source = this.source;<z>
(source == null) {<z>
className);<z>
source;<z>
;<z>
session, Message message) throws JMSException {<z>
();<z>
{<z>
session, message);<z>
listener instanceof MessageListener) {<z>
, message);<z>
if (listener != null) {<z>
new IllegalArgumentException(<z>
+ listener);<z>
new IllegalStateException("No message listener specified - see property 'messageListener'");<z>
text, @Nullable DataUnit defaultUnit) {<z>
(text, "Text must not be null");<z>
(text);<z>
.matches(), "Does not match data size pattern");<z>
, defaultUnit);<z>
parseLong(matcher.group(1));<z>
amount, unit);<z>
Exception ex) {<z>
;<z>
, int numberOfBeansFound, String message) {<z>
;<z>
;<z>
= null;<z>
final int elements) {<z>
if (outputStackTop >= elements) {<z>
;<z>
} else {<z>
-= elements - outputStackTop;<z>
= 0;<z>
,<z>
, boolean growCollection, int maximumSize) {<z>
;<z>
this.index = index;<z>
collectionEntryDescriptor = collectionEntryDescriptor;<z>
= typeConverter;<z>
= growCollection;<z>
;<z>
{<z>
.connectionFactory, "ConnectionFactory must not be null");<z>
BindMarkersFactory bindMarkers = this.bindMarkers;<z>
if (bindMarkers == null) {<z>
namedParameters) {<z>
this.connectionFactory);<z>
.anonymous("?");<z>
(<z>
, this.executeFunction, this.namedParameters);<z>
{<z>
= (HibernateTransactionObject) status.getTransaction();<z>
)) {<z>
"Setting Hibernate transaction on Session [" +<z>
) + "] rollback-only");<z>
.setRollbackOnly();<z>
void scheduleSessionTask() {<z>
(this.sessions) {<z>
!= null) {<z>
().scheduleAtFixedRate(() -> {<z>
= new ArrayList<>();<z>
{<z>
getTimeSinceLastActive() > getDisconnectDelay()) {<z>
;<z>
getId());<z>
);<z>
) {<z>
("Failed to close " + session, ex);<z>
) && !removedIds.isEmpty()) {<z>
);<z>
}, getDisconnectDelay());<z>
<? extends Resource> locations,<z>
) {<z>
hasText(path)) {<z>
;<z>
();<z>
) {<z>
.externallyManaged) {<z>
jettyClient.start();<z>
(Exception ex) {<z>
("Failed to start Jetty WebSocketClient", ex);<z>
getPathMatchConfigurer() {<z>
if (this.pathMatchConfigurer == null) {<z>
();<z>
configurePathMatching(this.pathMatchConfigurer);<z>
return this.pathMatchConfigurer;<z>
checkFieldMarkers(MutablePropertyValues mpvs) {<z>
fieldMarkerPrefix = getFieldMarkerPrefix();<z>
(fieldMarkerPrefix != null) {<z>
[] pvArray = mpvs.getPropertyValues();<z>
pv : pvArray) {<z>
startsWith(fieldMarkerPrefix)) {<z>
.length());<z>
!mpvs.contains(field)) {<z>
getPropertyType(field);<z>
, getEmptyValue(field, fieldType));<z>
;<z>
outbound) {<z>
;<z>
.uri = uri;<z>
request = request;<z>
.outbound = outbound;<z>
(outbound.alloc());<z>
) {<z>
SpringPersistenceUnitInfo();<z>
if (this.defaultPersistenceUnitName != null) {<z>
defaultPersistenceUnitName);<z>
setExcludeUnlistedClasses(true);<z>
(this.packagesToScan != null) {<z>
) {<z>
(scannedUnit, pkg);<z>
.mappingResources != null) {<z>
) {<z>
.addMappingFileName(mappingFileName);<z>
ormXml = getOrmXmlForDefaultPersistenceUnit();<z>
null) {<z>
addMappingFileName(DEFAULT_ORM_XML_RESOURCE);<z>
null) {<z>
scannedUnit.setPersistenceUnitRootUrl(<z>
ormXml));<z>
catch (IOException ex) {<z>
"Failed to determine persistence unit root URL from orm.xml location", ex);<z>
scannedUnit;<z>
) {<z>
messageMap.get(code);<z>
== null) {<z>
;<z>
);<z>
null) {<z>
null;<z>
);<z>
Method method, Object[] arguments,<z>
) {<z>
rootObject, method, arguments, parameterNameDiscoverer);<z>
private static int calculateHashCode(<z>
RequestMethodsRequestCondition methods,<z>
params, HeadersRequestCondition headers,<z>
produces,<z>
RequestConditionHolder custom) {<z>
) + params.hashCode() +<z>
+ custom.hashCode();<z>
,<z>
{<z>
= getNamedValueInfo(parameter);<z>
);<z>
resolveEmbeddedValuesAndExpressions(namedValueInfo.name);<z>
== null) {<z>
throw new IllegalArgumentException(<z>
.name + "]");<z>
webRequest);<z>
(arg == null) {<z>
if (namedValueInfo.defaultValue != null) {<z>
);<z>
isOptional()) {<z>
.name, nestedParameter, webRequest);<z>
);<z>
&& namedValueInfo.defaultValue != null) {<z>
.defaultValue);<z>
(binderFactory != null) {<z>
namedValueInfo.name);<z>
), parameter);<z>
) {<z>
getRequiredType(),<z>
, parameter, ex.getCause());<z>
TypeMismatchException ex) {<z>
, ex.getRequiredType(),<z>
.getCause());<z>
&& namedValueInfo.defaultValue == null &&<z>
) {<z>
, webRequest);<z>
, parameter, mavContainer, webRequest);<z>
;<z>
boolean storeByValue) {<z>
.storeByValue) {<z>
= storeByValue;<z>
;<z>
{<z>
.pos;<z>
boolean terminated = false;<z>
!terminated) {<z>
;<z>
];<z>
ch == '"') {<z>
{<z>
;<z>
true;<z>
)) {<z>
;<z>
;<z>
start, this.pos));<z>
<Void> filter(ServerWebExchange exchange) {<z>
.defer(() -><z>
!= null && this.chain != null ?<z>
) :<z>
);<z>
HttpServletRequest request,<z>
<? extends Resource> locations) {<z>
: locations) {<z>
(resourcePath, request, location);<z>
Resource resource = getResource(pathToUse, location);<z>
!= null) {<z>
resource;<z>
) {<z>
()) {<z>
"] due to error";<z>
if (logger.isTraceEnabled()) {<z>
.trace(error, ex);<z>
));<z>
;<z>
public Object lookupVariable(String name) {<z>
name)) {<z>
name);<z>
super.lookupVariable(name);<z>
Integer, Integer> typeIndexesPerLevel) {<z>
;<z>
i <= nestingLevel; i++) {<z>
.isArray()) {<z>
result.getComponentType();<z>
{<z>
.getSuperType();<z>
: null);<z>
- 1 : index);<z>
.getGeneric(index);<z>
return result;<z>
public final MimeMultipart getMimeMultipart() throws IllegalStateException {<z>
mimeMultipart == null) {<z>
new IllegalStateException("Not in multipart mode - " +<z>
;<z>
.mimeMultipart;<z>
{<z>
);<z>
;<z>
if (targetWriter instanceof PrintWriter) {<z>
PrintWriter) targetWriter;<z>
else if (targetWriter != null) {<z>
);<z>
, @Nullable Object target, Method method,<z>
, @Nullable Class<?> targetClass,<z>
MethodProxy methodProxy) {<z>
, interceptorsAndDynamicMethodMatchers);<z>
) ? methodProxy : null);<z>
> rowMapper)<z>
throws DataAccessException {<z>
, rowMapper);<z>
boolean adviceIncluded(@Nullable Advice advice) {<z>
null) {<z>
.advisors) {<z>
== advice) {<z>
;<z>
false;<z>
(<z>
DefaultCacheConfig defaultConfig, Cacheable cacheable) {<z>
.Builder();<z>
(ae.toString());<z>
cacheable.cacheNames());<z>
(cacheable.condition());<z>
unless());<z>
;<z>
(cacheable.keyGenerator());<z>
));<z>
);<z>
cacheable.sync());<z>
applyDefault(builder);<z>
op = builder.build();<z>
, op);<z>
op;<z>
) {<z>
;<z>
))) {<z>
new InvalidDataAccessApiUsageException(<z>
"\"");<z>
.declaredParameters.add(parameter);<z>
if (logger.isDebugEnabled()) {<z>
+ "]: " + parameter.getName());<z>
(AbstractListenerWriteProcessor<T> processor) {<z>
processor.sourceCompleted = true;<z>
) {<z>
);<z>
IOException {<z>
.ASYNC == request.getDispatcherType()) {<z>
(Throwable) request.getAttribute(WRITE_ERROR_ATTRIBUTE_NAME);<z>
ex);<z>
request.startAsync();<z>
setTimeout(-1);<z>
;<z>
AsyncListener requestListener;<z>
logPrefix;<z>
asyncContext);<z>
);<z>
getLogPrefix();<z>
{<z>
) {<z>
());<z>
(400);<z>
;<z>
response), asyncContext, httpRequest);<z>
ServletServerHttpResponse) httpResponse).getAsyncListener();<z>
) {<z>
(httpResponse);<z>
completionFlag = new AtomicBoolean();<z>
);<z>
asyncContext.addListener(new HttpHandlerAsyncListener(<z>
logPrefix));<z>
subscriber);<z>
Object bean, @Nullable RootBeanDefinition mbd) {<z>
invokeAwareMethods(beanName, bean);<z>
;<z>
()) {<z>
;<z>
beanName, wrappedBean, mbd);<z>
catch (Throwable ex) {<z>
BeanCreationException(<z>
() : null),<z>
"Invocation of init method failed", ex);<z>
null || !mbd.isSynthetic()) {<z>
applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<z>
return wrappedBean;<z>
{<z>
this();<z>
(dataSource);<z>
;<z>
(NativeWebRequest webRequest) {<z>
class);<z>
== null) {<z>
null;<z>
getLookupPathForRequest(request);<z>
String extension = UriUtils.extractFileExtension(path);<z>
Locale.ENGLISH) : null);<z>
Class<?> getParameterType() {<z>
.returnValue != null) {<z>
);<z>
.equals(this.returnType)) {<z>
returnType.toClass();<z>
getParameterType();<z>
int read() throws IOException {<z>
;<z>
) {<z>
&& cachedContent.size() == contentCacheLimit) {<z>
.overflow = true;<z>
(contentCacheLimit);<z>
write(ch);<z>
;<z>
IllegalArgumentException {<z>
hasLength(text)) {<z>
);<z>
RuleBasedTransactionAttribute attr = new RuleBasedTransactionAttribute();<z>
token : tokens) {<z>
();<z>
StringUtils.containsWhitespace(trimmedToken)) {<z>
new IllegalArgumentException(<z>
"]");<z>
)) {<z>
trimmedToken);<z>
startsWith(RuleBasedTransactionAttribute.PREFIX_ISOLATION)) {<z>
;<z>
PREFIX_TIMEOUT)) {<z>
.PREFIX_TIMEOUT.length());<z>
);<z>
RuleBasedTransactionAttribute.READ_ONLY_MARKER)) {<z>
;<z>
(RuleBasedTransactionAttribute.PREFIX_COMMIT_RULE)) {<z>
(1)));<z>
.PREFIX_ROLLBACK_RULE)) {<z>
(1)));<z>
"]");<z>
attr.resolveAttributeStrings(null);<z>
(attr);<z>
setValue(null);<z>
<WebSocketExtension> extensions) {<z>
);<z>
: extensions) {<z>
add(new WebSocketToStandardExtensionAdapter(extension));<z>
result;<z>
(RequestConditionHolder other, HttpServletRequest request) {<z>
{<z>
return 0;<z>
if (this.condition == null) {<z>
;<z>
{<z>
-1;<z>
(this.condition, other.condition);<z>
compareTo(other.condition, request);<z>
(Object key) {<z>
(key instanceof String) {<z>
));<z>
{<z>
this.targetMap.get(caseInsensitiveKey);<z>
null;<z>
isExcludedFromDependencyCheck(PropertyDescriptor pd) {<z>
.getWriteMethod();<z>
if (wm == null) {<z>
false;<z>
)) {<z>
false;<z>
.getDeclaringClass().getSuperclass();<z>
);<z>
(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,<z>
providedArgs) throws Exception {<z>
(request, mavContainer, providedArgs);<z>
) {<z>
);<z>
args);<z>
]> getParameterMap() {<z>
)) {<z>
);<z>
);<z>
> protocols, HttpHeaders requestHeaders,<z>
ConnectionBuilder connectionBuilder) {<z>
Collections.emptyList());<z>
requestHeaders = requestHeaders;<z>
connectionBuilder.getClientNegotiation();<z>
(Method setter) {<z>
).replaceFirst("set", "get");<z>
().getMethod(getterName);<z>
NoSuchMethodException ex) {<z>
return null;<z>
] errorArgs,<z>
defaultMessage) {<z>
.hasLength(field)) {<z>
, defaultMessage);<z>
);<z>
;<z>
), fixedField, newVal, false,<z>
, field), errorArgs, defaultMessage);<z>
);<z>
{<z>
handler;<z>
: this.factories) {<z>
;<z>
return result;<z>
Exception {<z>
== null) {<z>
generate(cg);<z>
= Thread.currentThread();<z>
;<z>
= currentThread.getContextClassLoader();<z>
ex) {<z>
.generate(cg);<z>
classLoader.equals(threadContextClassLoader);<z>
overrideClassLoader) {<z>
.classLoader);<z>
.generate(cg);<z>
(overrideClassLoader) {<z>
setContextClassLoader(threadContextClassLoader);<z>
Object obj) {<z>
) {<z>
return EMPTY_STRING;<z>
);<z>
ServerWebExchange exchange, HandlerResult result) {<z>
<Object> valueMono;<z>
;<z>
adapter = getAdapter(result);<z>
!= null) {<z>
adapter.isMultiValue()) {<z>
(<z>
));<z>
.getReturnValue() != null ?<z>
());<z>
ResolvableType.forClass(Void.class) :<z>
).getGeneric());<z>
());<z>
result.getReturnType();<z>
.empty() : NO_VALUE_MONO)<z>
flatMap(returnValue -> {<z>
<List<View>> viewsMono;<z>
();<z>
);<z>
getLocale(exchange.getLocaleContext());<z>
.toClass();<z>
Object.class) {<z>
clazz = returnValue.getClass();<z>
clazz == Void.class) {<z>
resolveViews(getDefaultViewName(exchange), locale);<z>
hasModelAnnotation(parameter)) {<z>
(), locale);<z>
) {<z>
) returnValue;<z>
status();<z>
status != null) {<z>
;<z>
(render.headers());<z>
);<z>
.view();<z>
view == null) {<z>
);<z>
((String) view, locale) :<z>
)));<z>
isAssignableFrom(clazz)) {<z>
).asMap());<z>
getDefaultViewName(exchange), locale);<z>
hasModelAnnotation(parameter)) {<z>
, ?>) returnValue);<z>
getDefaultViewName(exchange), locale);<z>
.isAssignableFrom(clazz)) {<z>
) returnValue));<z>
);<z>
name, returnValue);<z>
(exchange), locale);<z>
;<z>
(bindingContext, exchange);<z>
, exchange));<z>
});<z>
boolean enabled) {<z>
instanceof JsonParser.Feature) {<z>
;<z>
JsonGenerator.Feature) {<z>
enabled);<z>
if (feature instanceof SerializationFeature) {<z>
;<z>
if (feature instanceof DeserializationFeature) {<z>
feature, enabled);<z>
) {<z>
enabled);<z>
));<z>
, Object endpoint) {<z>
unRegisterMethod.invoke(engine, endpoint);<z>
ex) {<z>
"Failed to unregister " + endpoint, ex);<z>
, @Nullable byte[] content)<z>
SQLException {<z>
streamAsLob) {<z>
) {<z>
, content.length);<z>
paramIndex, (Blob) null);<z>
wrapAsLob) {<z>
) {<z>
);<z>
) null);<z>
ps.setBytes(paramIndex, content);<z>
.isDebugEnabled()) {<z>
:<z>
);<z>
classLoader) &&<z>
, classLoader);<z>
classLoader);<z>
"jakarta.json.bind.Jsonb", classLoader);<z>
, classLoader);<z>
private ApplicationContext applicationContext;<z>
;<z>
ChannelRegistration clientOutboundChannelRegistration;<z>
brokerRegistry;<z>
{<z>
reader, int length, LobHandler lobHandler) {<z>
;<z>
this.length = length;<z>
.getLobCreator();<z>
> original, @Nullable String propertyName,<z>
> requiredType, @Nullable TypeDescriptor typeDescriptor) {<z>
{<z>
;<z>
approximable = CollectionFactory.isApproximableCollectionType(requiredType);<z>
canCreateCopy(requiredType)) {<z>
()) {<z>
) +<z>
);<z>
return original;<z>
(original);<z>
typeDescriptor.getElementTypeDescriptor() : null);<z>
== null && originalAllowed &&<z>
null, propertyName)) {<z>
original;<z>
it;<z>
.iterator();<z>
) {<z>
logger.isDebugEnabled()) {<z>
.getName() +<z>
ex);<z>
return original;<z>
Object> convertedCopy;<z>
{<z>
());<z>
Object>)<z>
accessibleConstructor(requiredType).newInstance();<z>
ex) {<z>
(logger.isDebugEnabled()) {<z>
getName() +<z>
"] - injecting original Collection as-is: " + ex);<z>
;<z>
++) {<z>
element = it.next();<z>
= buildIndexedPropertyName(propertyName, i);<z>
= convertIfNecessary(indexedPropertyName, null, element,<z>
;<z>
;<z>
Throwable ex) {<z>
()) {<z>
getClass().getName() +<z>
;<z>
original;<z>
element == convertedElement);<z>
convertedCopy);<z>
getStereotypes(Element element) {<z>
;<z>
element.getKind();<z>
) {<z>
stereotypes;<z>
.typeHelper.getAllAnnotationMirrors(element)) {<z>
);<z>
startsWith("jakarta.")) {<z>
;<z>
stereotypes;<z>
public MissingServletRequestParameterException(<z>
boolean missingAfterConversion) {<z>
"", missingAfterConversion);<z>
.parameterName = parameterName;<z>
;<z>
getAdvicesAndAdvisorsForBean(<z>
, String beanName, @Nullable TargetSource targetSource) {<z>
);<z>
(advisors.isEmpty()) {<z>
;<z>
return advisors.toArray();<z>
expectedKind) {<z>
();<z>
t == null) {<z>
= this.expressionString.length();<z>
);<z>
kind != expectedKind) {<z>
NOT_EXPECTED_TOKEN,<z>
());<z>
;<z>
configurer) {<z>
this.delegates) {<z>
delegate.configureContentNegotiation(configurer);<z>
{<z>
) {<z>
throw new IllegalStateException(<z>
);<z>
(this.sharedConnectionMonitor) {<z>
) {<z>
new SharedConnectionNotInitializedException(<z>
"This listener container's shared Connection has not been initialized yet");<z>
return this.sharedConnection;<z>
, DataBufferFactory bufferFactory,<z>
<String, Object> hints) {<z>
bytes);<z>
hints)) {<z>
= Hints.getLogPrefix(hints);<z>
.readableByteCount() + " bytes");<z>
;<z>
KeyHolder generatedKeyHolder) throws DataAccessException {<z>
&& getGeneratedKeysColumnNames() == null) {<z>
new InvalidDataAccessApiUsageException(<z>
);<z>
;<z>
(params), generatedKeyHolder);<z>
rowsAffected);<z>
return rowsAffected;<z>
, @Nullable byte[] content) {<z>
;<z>
this.name = name;<z>
;<z>
);<z>
, filename);<z>
(Object message) {<z>
)) {<z>
(message), null, null);<z>
{<z>
setSubject(subject);<z>
) {<z>
);<z>
Nullable Object conversionHint) {<z>
: getConverters()) {<z>
= (converter instanceof SmartMessageConverter ?<z>
) :<z>
);<z>
{<z>
result;<z>
;<z>
{<z>
(parameterValues.length);<z>
0;<z>
) {<z>
{<z>
parameter.getName();<z>
);<z>
return matchedParameters;<z>
, IOException {<z>
);<z>
());<z>
);<z>
));<z>
;<z>
beanDefinitionReader);<z>
messageSupplier) {<z>
.log.isTraceEnabled()) {<z>
), cause);<z>
{<z>
this.uriBuilderFactory != null) {<z>
uriBuilderFactory;<z>
?<z>
.baseUrl) : new DefaultUriBuilderFactory());<z>
(this.defaultUriVariables);<z>
factory;<z>
handleError(Throwable ex) {<z>
);<z>
receivePublisher.onError(ex);<z>
.sendProcessor;<z>
sendProcessor != null) {<z>
cancel();<z>
onError(ex);<z>
Method method, Class<?> exceptionType) {<z>
Assert.notNull(method, "Method must not be null");<z>
[] declaredExceptions = method.getExceptionTypes();<z>
: declaredExceptions) {<z>
exceptionType)) {<z>
;<z>
return false;<z>
Throwable cause) {<z>
if (cause == null) {<z>
isDebugEnabled()) {<z>
: "") +<z>
+ "]";<z>
.debug(msg, cause);<z>
actualKey) {<z>
);<z>
(map == null) {<z>
;<z>
map.get(actualKey);<z>
isVoid()) {<z>
actualKey);<z>
)) {<z>
();<z>
= null;<z>
return value;<z>
protected DataAccessException convertHibernateAccessException(HibernateException ex) {<z>
JDBCException jdbcEx) {<z>
(<z>
;<z>
(dae != null) {<z>
dae;<z>
JDBCConnectionException) {<z>
ex.getMessage(), ex);<z>
) {<z>
.getSQL() + "]", ex);<z>
ex instanceof QueryTimeoutException jdbcEx) {<z>
+ "]", ex);<z>
LockAcquisitionException jdbcEx) {<z>
ex);<z>
PessimisticLockException jdbcEx) {<z>
+ "]", ex);<z>
{<z>
) + "; SQL [" + jdbcEx.getSQL() +<z>
+ "]", ex);<z>
{<z>
"]", ex);<z>
QueryException) {<z>
);<z>
) {<z>
, ex);<z>
if (ex instanceof NonUniqueObjectException) {<z>
(), ex);<z>
ex instanceof PropertyValueException) {<z>
.getMessage(), ex);<z>
if (ex instanceof PersistentObjectException) {<z>
getMessage(), ex);<z>
if (ex instanceof TransientObjectException) {<z>
.getMessage(), ex);<z>
(ex instanceof ObjectDeletedException) {<z>
getMessage(), ex);<z>
{<z>
);<z>
(ex instanceof WrongClassException hibEx) {<z>
), ex);<z>
ex instanceof StaleObjectStateException hibEx) {<z>
, ex);<z>
{<z>
ex.getMessage(), ex);<z>
ex instanceof OptimisticEntityLockException) {<z>
ex.getMessage(), ex);<z>
instanceof PessimisticEntityLockException) {<z>
) {<z>
getCause());<z>
ex.getMessage(), ex);<z>
new JpaSystemException(ex);<z>
) {<z>
{<z>
return true;<z>
instanceof ResolvableType otherType)) {<z>
false;<z>
type)) {<z>
return false;<z>
&&<z>
.typeProvider == null ||<z>
) {<z>
return false;<z>
variableResolver != otherType.variableResolver &&<z>
|| otherType.variableResolver == null ||<z>
))) {<z>
return false;<z>
componentType, otherType.componentType)) {<z>
;<z>
return true;<z>
,<z>
super MergedAnnotation<A>> predicate,<z>
A> selector) {<z>
(selector == null) {<z>
nearest();<z>
null;<z>
.annotations.length; i++) {<z>
= this.annotations[i];<z>
AnnotationTypeMappings mappings = this.mappings[i];<z>
; mappingIndex++) {<z>
AnnotationTypeMapping mapping = mappings.get(mappingIndex);<z>
, requiredType)) {<z>
0 ? (MergedAnnotation<A>) root :<z>
, root, IntrospectionFailureLogger.INFO));<z>
test(candidate))) {<z>
{<z>
return candidate;<z>
, candidate) : candidate);<z>
result;<z>
boolean closeResources)<z>
throws DataAccessException {<z>
notNull(psc, "PreparedStatementCreator must not be null");<z>
(action, "Callback object must not be null");<z>
()) {<z>
(psc);<z>
+ sql + "]" : ""));<z>
));<z>
= null;<z>
= psc.createPreparedStatement(con);<z>
;<z>
ps);<z>
ps);<z>
;<z>
SQLException ex) {<z>
{<z>
.cleanupParameters();<z>
sql = getSql(psc);<z>
= null;<z>
;<z>
= null;<z>
));<z>
null;<z>
ex);<z>
closeResources) {<z>
if (psc instanceof ParameterDisposer) {<z>
psc).cleanupParameters();<z>
closeStatement(ps);<z>
(con, getDataSource());<z>
getNamespaceCount() {<z>
Iterator namespaces;<z>
)) {<z>
.getNamespaces();<z>
this.event.isEndElement()) {<z>
asEndElement().getNamespaces();<z>
IllegalStateException();<z>
countIterator(namespaces);<z>
task) {<z>
, task);<z>
(RejectedExecutionException ex) {<z>
throw new TaskRejectedException(<z>
.concurrentExecutor + "] did not accept task: " + task, ex);<z>
(String[] to) throws MessagingException {<z>
);<z>
InternetAddress[to.length];<z>
< to.length; i++) {<z>
= parseAddress(to[i]);<z>
addresses);<z>
getMessage() {<z>
new StringBuilder("Validation failed for argument [")<z>
)).append("] in ")<z>
).toGenericString());<z>
getBindingResult();<z>
() > 1) {<z>
" errors");<z>
;<z>
{<z>
append(error).append("] ");<z>
return sb.toString();<z>
handler) {<z>
handler;<z>
&& this.modelInitializer != null, "Not initialized");<z>
(<z>
);<z>
= this.methodResolver.getRequestMappingMethod(handlerMethod);<z>
exceptionHandler =<z>
exchange);<z>
this.modelInitializer<z>
bindingContext, exchange)<z>
bindingContext)))<z>
exceptionHandler))<z>
bindingContext.saveModel())<z>
;<z>
) {<z>
contentLength;<z>
;<z>
(NumberFormatException ex) {<z>
isDebugEnabled()) {<z>
("Ignoring invalid content-length: '" + headerAccessor);<z>
= null;<z>
(contentLength != null && contentLength >= 0) {<z>
) {<z>
new byte[contentLength];<z>
;<z>
(byteBuffer.get() != 0) {<z>
"Frame must be terminated with a null octet");<z>
;<z>
return null;<z>
ByteArrayOutputStream(256);<z>
(byteBuffer.remaining() > 0) {<z>
.get();<z>
) {<z>
toByteArray();<z>
(b);<z>
return null;<z>
objectName) {<z>
!= null, "No MBeanServer set");<z>
boolean actuallyUnregistered = false;<z>
.registeredBeans) {<z>
)) {<z>
server.isRegistered(objectName)) {<z>
objectName);<z>
= true;<z>
{<z>
+ objectName + "] as said MBean " +<z>
"is not registered (perhaps already unregistered by an external process)");<z>
(JMException ex) {<z>
(logger.isInfoEnabled()) {<z>
);<z>
) {<z>
objectName);<z>
) {<z>
new ArrayList<>(modules);<z>
= false;<z>
this.findWellKnownModules = false;<z>
return this;<z>
private void printFieldSeparatorIfNecessary() {<z>
.styledFirstField) {<z>
styleFieldSeparator(this.buffer);<z>
= true;<z>
) {<z>
this.postProcessingLock) {<z>
) {<z>
1);<z>
destroyMethod);<z>
void handleRequest(ServerHttpRequest request, ServerHttpResponse response,<z>
) throws SockJsException {<z>
;<z>
(), wsHandler, sockJsSession);<z>
sockJsSession.getAttributes());<z>
ex) {<z>
(ex, CloseStatus.SERVER_ERROR);<z>
, ex);<z>
() throws BeansException {<z>
.beanOfTypeIncludingAncestors(<z>
, ScriptTemplateConfig.class, true, false);<z>
{<z>
new ApplicationContextException("Expected a single ScriptTemplateConfig bean in the current " +<z>
"the usual implementation. This bean may have any name.", ex);<z>
(ServerHttpRequest request, ServerHttpResponse response,<z>
, Endpoint endpoint)<z>
HandshakeFailureException {<z>
= getHttpServletRequest(request);<z>
;<z>
getRequestURL();<z>
String path = servletRequest.getRequestURI();<z>
.<String, String> emptyMap();<z>
endpointConfig = new ServerEndpointRegistration(path, endpoint);<z>
;<z>
selectedExtensions);<z>
endpointConfig, pathParams);<z>
{<z>
throw new HandshakeFailureException(<z>
;<z>
) {<z>
HandshakeFailureException(<z>
, ex);<z>
) {<z>
"; ", "Failed properties: ", "");<z>
(PropertyAccessException exception : this.propertyAccessExceptions) {<z>
getMessage());<z>
stringJoiner.toString();<z>
) {<z>
.callbacks = callbacks;<z>
>[callbacks.length];<z>
++) {<z>
].getClass();<z>
T> type, boolean includeNonSingletons, boolean allowEagerInit)<z>
throws BeansException {<z>
FactoryBean.class.isAssignableFrom(type));<z>
);<z>
)) {<z>
= entry.getKey();<z>
beanInstance = entry.getValue();<z>
beanInstance instanceof FactoryBean && !isFactoryType) {<z>
<?>) beanInstance;<z>
= factory.getObjectType();<z>
()) &&<z>
type.isAssignableFrom(objectType))) {<z>
getBean(beanName, type));<z>
) {<z>
{<z>
= FACTORY_BEAN_PREFIX + beanName;<z>
T) beanInstance);<z>
;<z>
) {<z>
);<z>
otherClazz = cond2.getClass();<z>
equals(otherClazz)) {<z>
+ otherClazz);<z>
{<z>
MockServletContext servletContext = new MockServletContext();<z>
(servletContext);<z>
;<z>
, wac);<z>
return wac;<z>
) {<z>
.length == 0)) {<z>
(), this.parameterNames);<z>
{<z>
;<z>
prev = 0;<z>
length(); i++) {<z>
);<z>
) {<z>
sb == null) {<z>
path.substring(0, i));<z>
!= null) {<z>
charAt(i));<z>
;<z>
path);<z>
public ServletServerHttpRequest(HttpServletRequest request, AsyncContext asyncContext,<z>
String servletPath, DataBufferFactory bufferFactory, int bufferSize)<z>
URISyntaxException {<z>
bufferSize);<z>
>[] classes,<z>
> contextInitializerClasses,<z>
, @Nullable String[] propertySourceProperties,<z>
contextLoader,<z>
CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate, @Nullable MergedContextConfiguration parent) {<z>
, classes, contextInitializerClasses, activeProfiles, propertySourceLocations,<z>
);<z>
request(long n) {<z>
()) {<z>
.MAX_VALUE ? n : "Long.MAX_VALUE"));<z>
.this, n);<z>
targetType) {<z>
.contains(targetType)) {<z>
null;<z>
();<z>
) {<z>
;<z>
null) {<z>
;<z>
{<z>
;<z>
= targetType.getName();<z>
= targetTypeName + "Editor";<z>
(editorName);<z>
) {<z>
PropertyEditor.class.isAssignableFrom(editorClass)) {<z>
);<z>
;<z>
return (PropertyEditor) instantiateClass(editorClass);<z>
{<z>
);<z>
;<z>
public void closeSource() {<z>
source.close();<z>
ignore) {<z>
() {<z>
.propertyValues == null) {<z>
this.propertyValues = new MutablePropertyValues();<z>
propertyValues;<z>
Nullable MediaType mediaType) {<z>
(mediaType)) {<z>
return false;<z>
getJavaType(type, contextClass);<z>
mediaType);<z>
if (objectMapper == null) {<z>
;<z>
causeRef = new AtomicReference<>();<z>
)) {<z>
;<z>
.get());<z>
;<z>
public void destroy() {<z>
null && getDataSource() != null) {<z>
(this.databaseCleaner, getDataSource());<z>
();<z>
org.springframework.protobuf.Msg parseFrom(<z>
com.google.protobuf.CodedInputStream input)<z>
java.io.IOException {<z>
);<z>
T apply(MockMvcConfigurer configurer) {<z>
);<z>
.configurers.add(configurer);<z>
self();<z>
String viewName) {<z>
AbstractUrlBasedView view = instantiateView();<z>
setSupportedMediaTypes(getSupportedMediaTypes());<z>
;<z>
viewName + getSuffix());<z>
();<z>
(requestContextAttribute != null) {<z>
view.setRequestContextAttribute(requestContextAttribute);<z>
;<z>
, ParserContext context) {<z>
Object source = context.extractSource(element);<z>
);<z>
;<z>
element.getAttribute("order");<z>
orderAttribute);<z>
);<z>
handlerMappingDef.setSource(source);<z>
.ROLE_INFRASTRUCTURE);<z>
;<z>
.getReaderContext().registerWithGeneratedName(handlerMappingDef);<z>
= WebSocketNamespaceUtils.registerSockJsService(<z>
, SOCK_JS_SCHEDULER_NAME, context, source);<z>
strategy;<z>
if (sockJsService != null) {<z>
strategy = new SockJsHandlerMappingStrategy(sockJsService);<z>
(element, context, source);<z>
DomUtils.getChildElementByTagName(element, "handshake-interceptors");<z>
(interceptElem, context);<z>
.getAttribute("allowed-origins");<z>
tokenizeToStringArray(allowedOrigins, ","));<z>
allowedOriginPatterns = element.getAttribute("allowed-origin-patterns");<z>
);<z>
= new OriginHandshakeInterceptor(origins);<z>
{<z>
setAllowedOriginPatterns(originPatterns);<z>
interceptor);<z>
new WebSocketHandlerMappingStrategy(handler, interceptors);<z>
<>();<z>
(source);<z>
DomUtils.getChildElementsByTagName(element, "mapping")) {<z>
context);<z>
"urlMap", urlMap);<z>
;<z>
context.popAndRegisterContainingComponent();<z>
null;<z>
int off, int len) {<z>
;<z>
flush();<z>
setCommittedIfBufferSizeExceeded();<z>
) {<z>
) {<z>
size() > HEADER_KEY_CACHE_LIMIT) {<z>
));<z>
true;<z>
return false;<z>
(@Nullable Object other) {<z>
if (this == other) {<z>
true;<z>
(other instanceof AnnotationTransactionAttributeSource otherTas)) {<z>
return false;<z>
) &&<z>
== otherTas.publicMethodsOnly);<z>
{<z>
String keepAliveSeconds = element.getAttribute("keep-alive");<z>
hasText(keepAliveSeconds)) {<z>
.addPropertyValue("keepAliveSeconds", keepAliveSeconds);<z>
String queueCapacity = element.getAttribute("queue-capacity");<z>
.hasText(queueCapacity)) {<z>
("queueCapacity", queueCapacity);<z>
;<z>
);<z>
StringUtils.hasText(poolSize)) {<z>
, poolSize);<z>
HttpRequest EMPTY_REQUEST = new HttpRequest() {<z>
URI.create("");<z>
public HttpMethod getMethod() {<z>
valueOf("UNKNOWN");<z>
getMethodValue() {<z>
return "UNKNOWN";<z>
) {<z>
;<z>
getHeaders() {<z>
HttpHeaders.EMPTY;<z>
String, String> pathVariables() {<z>
(<z>
.URI_TEMPLATE_VARIABLES_ATTRIBUTE, Collections.emptyMap());<z>
void sendInternal(Message<?> message) {<z>
getHeaders());<z>
Assert.notNull(destination, "Destination header required");<z>
;<z>
));<z>
{<z>
MessageDeliveryException(message,<z>
);<z>
{<z>
this.targetDataSources == null) {<z>
new IllegalArgumentException("Property 'targetDataSources' is required");<z>
(this.targetDataSources.size());<z>
((key, value) -> {<z>
= resolveSpecifiedLookupKey(key);<z>
);<z>
resolvedDataSources.put(lookupKey, dataSource);<z>
});<z>
) {<z>
;<z>
{<z>
this.lifecycleMonitor) {<z>
subscribe(this);<z>
true;<z>
(String name, Object value) {<z>
, value);<z>
(this.explicitAttributes == null) {<z>
<>(8);<z>
.explicitAttributes.add(name);<z>
MethodVisitor mv, CodeFlow cf) {<z>
();<z>
;<z>
, cf);<z>
String lastDesc = cf.lastDescriptor();<z>
!= null, "No last descriptor");<z>
.charAt(0));<z>
);<z>
Label();<z>
();<z>
;<z>
, elseTarget);<z>
visitInsn(DUP);<z>
.visitLdcInsn("");<z>
visitInsn(SWAP);<z>
, "java/lang/String", "equals", "(Ljava/lang/Object;)Z",false);<z>
IFEQ, endOfIf);<z>
.visitLabel(elseTarget);<z>
(POP);<z>
cf.enterCompilationScope();<z>
;<z>
(this.exitTypeDescriptor)) {<z>
();<z>
.state(lastDesc != null, "No last descriptor");<z>
;<z>
);<z>
(endOfIf);<z>
exitTypeDescriptor);<z>
Builder builder) {<z>
"org.springframework.http.MediaTypeFactory", "<clinit>");<z>
);<z>
(MergedContextConfiguration mergedContextConfiguration) {<z>
synchronized (this.contextCache) {<z>
= this.contextCache.get(mergedContextConfiguration);<z>
if (context == null) {<z>
loadContextInternal(mergedContextConfiguration);<z>
()) {<z>
(String.format("Storing ApplicationContext [%s] in cache under key [%s]",<z>
(context), mergedContextConfiguration));<z>
context);<z>
) {<z>
, ex);<z>
logger.isDebugEnabled()) {<z>
("Retrieved ApplicationContext [%s] from cache with key [%s]",<z>
.identityHashCode(context), mergedContextConfiguration));<z>
.logStatistics();<z>
;<z>
(@Nullable ServerWebExchange exchange, String requestPath) {<z>
exchange != null) {<z>
codingKey = getContentCodingKey(exchange);<z>
{<z>
+ "+encoding=" + codingKey;<z>
return RESOLVED_RESOURCE_CACHE_KEY_PREFIX + requestPath;<z>
Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter parameter,<z>
HttpMediaTypeNotSupportedException, HttpMessageNotReadableException {<z>
;<z>
boolean noContentType = false;<z>
);<z>
) {<z>
HttpMediaTypeNotSupportedException(ex.getMessage());<z>
(contentType == null) {<z>
noContentType = true;<z>
APPLICATION_OCTET_STREAM;<z>
= parameter.getContainingClass();<z>
T>) targetType : null);<z>
targetClass == null) {<z>
ResolvableType.forMethodParameter(parameter);<z>
);<z>
);<z>
= NO_VALUE;<z>
EmptyBodyCheckingHttpInputMessage message;<z>
;<z>
converter : this.messageConverters) {<z>
);<z>
=<z>
);<z>
:<z>
(targetClass, contentType))) {<z>
.hasBody()) {<z>
HttpInputMessage msgToUse =<z>
(message, parameter, targetType, converterType);<z>
) :<z>
read(targetClass, msgToUse));<z>
targetType, converterType);<z>
, targetType, converterType);<z>
ex) {<z>
;<z>
body == NO_VALUE) {<z>
!SUPPORTED_METHODS.contains(httpMethod) ||<z>
hasBody())) {<z>
;<z>
contentType,<z>
Object.class));<z>
= contentType;<z>
;<z>
-> {<z>
(theBody, !traceOn);<z>
"Read \"" + selectedContentType + "\" to [" + formatted + "]";<z>
;<z>
;<z>
access, final String... modules) {<z>
mv != null) {<z>
);<z>
) {<z>
) this.body;<z>
(publisher != null, "Publisher must not be null");<z>
;<z>
public WebSocketHandler getLastHandler() {<z>
this.delegate;<z>
while (result instanceof WebSocketHandlerDecorator) {<z>
).getDelegate();<z>
return result;<z>
> resolveArgument(<z>
{<z>
NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);<z>
nestedParameter = parameter.nestedIfOptional();<z>
resolveEmbeddedValuesAndExpressions(namedValueInfo.name);<z>
) {<z>
(<z>
.name + "]"));<z>
bindingContext.getModel();<z>
.toString(), nestedParameter, exchange)<z>
{<z>
!= null) {<z>
defaultValue);<z>
, namedValueInfo, parameter, bindingContext, exchange);<z>
name, parameter, model, exchange);<z>
.justOrEmpty(arg);<z>
getDefaultValue(<z>
, model, exchange));<z>
String expectedViewName) {<z>
-> {<z>
;<z>
(mav == null) {<z>
;<z>
;<z>
) {<z>
.notNull(byteBuf, "ByteBuf must not be null");<z>
(dataBufferFactory, "NettyDataBufferFactory must not be null");<z>
.byteBuf = byteBuf;<z>
dataBufferFactory = dataBufferFactory;<z>
) {<z>
return OuterSample.internal_static_Msg_fieldAccessorTable<z>
.ensureFieldAccessorsInitialized(<z>
class, Msg.Builder.class);<z>
AbstractBeanDefinition other) {<z>
()) {<z>
.hasPropertyValues();<z>
this.propertyValues, other.propertyValues);<z>
, String sql) {<z>
;<z>
(ds);<z>
setSql(sql);<z>
private HandlerMethod(HandlerMethod handlerMethod, Object handler) {<z>
"HandlerMethod is required");<z>
handler, "Handler object is required");<z>
= handler;<z>
;<z>
handlerMethod.beanType;<z>
method;<z>
.bridgedMethod = handlerMethod.bridgedMethod;<z>
.parameters = handlerMethod.parameters;<z>
.resolvedFromHandlerMethod = handlerMethod;<z>
noLocal,<z>
{<z>
);<z>
;<z>
.noLocal = noLocal;<z>
.subscription = subscription;<z>
this.durable = durable;<z>
) {<z>
();<z>
[] cookies;<z>
cookieLock) {<z>
this.request.getCookies();<z>
if (cookies != null) {<z>
for (Cookie cookie : cookies) {<z>
);<z>
(name, cookie.getValue());<z>
.add(name, httpCookie);<z>
return httpCookies;<z>
TagWriter tagWriter) throws JspException {<z>
);<z>
{<z>
;<z>
isAllocated() {<z>
dataBuffer();<z>
&&<z>
).isAllocated();<z>
tb, int num, String name) {<z>
) {<z>
throw new IllegalStateException("Should never be called with null value");<z>
FactoryMethods(tb, name, num);<z>
TaskScheduler messageBrokerTaskScheduler() {<z>
new ThreadPoolTaskScheduler();<z>
scheduler.setThreadNamePrefix("MessageBroker-");<z>
availableProcessors());<z>
.setRemoveOnCancelPolicy(true);<z>
return scheduler;<z>
{<z>
|| this.targetObject == null) {<z>
);<z>
targetObject;<z>
classVisitor) {<z>
api != Opcodes.ASM9<z>
ASM8<z>
&& api != Opcodes.ASM7<z>
!= Opcodes.ASM6<z>
!= Opcodes.ASM5<z>
&& api != Opcodes.ASM4<z>
&& api != Opcodes.ASM10_EXPERIMENTAL) {<z>
IllegalArgumentException("Unsupported api " + api);<z>
.api = api;<z>
.cv = classVisitor;<z>
String name, String... values) {<z>
{<z>
(name, value);<z>
this;<z>
static boolean isMultipartArgument(MethodParameter parameter) {<z>
= parameter.getNestedParameterType();<z>
paramType ||<z>
||<z>
)));<z>
(ThreadPoolTaskExecutor executor) {<z>
StringUtils.hasText(this.poolSize)) {<z>
int corePoolSize;<z>
int maxPoolSize;<z>
indexOf('-');<z>
1) {<z>
.poolSize, 0, separatorIndex, 10);<z>
;<z>
maxPoolSize) {<z>
throw new IllegalArgumentException(<z>
);<z>
null) {<z>
0) {<z>
(true);<z>
corePoolSize = maxPoolSize;<z>
(<z>
"A non-zero lower bound for the size range requires a queue-capacity value");<z>
.parseInt(this.poolSize);<z>
value;<z>
maxPoolSize = value;<z>
);<z>
(maxPoolSize);<z>
(NumberFormatException ex) {<z>
poolSize + "]: only single " +<z>
;<z>
InputStream getBody() throws IOException {<z>
== null) {<z>
.response.getBody());<z>
);<z>
void addConstantMemberReference(<z>
int index,<z>
tag,<z>
String owner,<z>
String name,<z>
descriptor) {<z>
;<z>
{<z>
(type.resolve() == null) {<z>
;<z>
source.getAnnotations());<z>
Method getInterfaceMethodIfPossible(Method method) {<z>
{<z>
;<z>
-> {<z>
> current = key.getDeclaringClass();<z>
null && current != Object.class) {<z>
[] ifcs = current.getInterfaces();<z>
> ifc : ifcs) {<z>
());<z>
catch (NoSuchMethodException ex) {<z>
= current.getSuperclass();<z>
return key;<z>
;<z>
(@Nullable Object other) {<z>
) {<z>
;<z>
(!(other instanceof AnnotationCacheOperationSource otherCos)) {<z>
false;<z>
.equals(otherCos.annotationParsers) &&<z>
.publicMethodsOnly);<z>
roundEnv) {<z>
getRootElements()) {<z>
markAsProcessed(element);<z>
exchange) {<z>
);<z>
handlerMethod;<z>
= lookupHandlerMethod(exchange);<z>
ex) {<z>
;<z>
null) {<z>
handlerMethod = handlerMethod.createWithResolvedBean();<z>
return Mono.justOrEmpty(handlerMethod);<z>
);<z>
wrapCachedClass(Class klass) {<z>
;<z>
(argumentTypes == null) {<z>
Constants.EMPTY_CLASS_ARRAY;<z>
new EnhancerFactoryData(klass, argumentTypes, classOnly);<z>
factoryDataField = null;<z>
= klass.getField(FACTORY_DATA_FIELD);<z>
;<z>
= klass.getDeclaredField(CALLBACK_FILTER_FIELD);<z>
true);<z>
(null, this.filter);<z>
e) {<z>
throw new CodeGenerationException(e);<z>
catch (IllegalAccessException e) {<z>
e);<z>
factoryData);<z>
, String beanName) {<z>
|| bean instanceof AopInfrastructureBean) {<z>
bean;<z>
(bean instanceof Advised advised) {<z>
bean))) {<z>
if (this.beforeExistingAdvisors) {<z>
advisor);<z>
(this.advisor);<z>
;<z>
beanName)) {<z>
proxyFactory = prepareProxyFactory(bean, beanName);<z>
{<z>
(), proxyFactory);<z>
);<z>
proxyFactory);<z>
ClassLoader classLoader = getProxyClassLoader();<z>
().getClassLoader()) {<z>
SmartClassLoader) classLoader).getOriginalClassLoader();<z>
;<z>
return bean;<z>
(BeanFactory beanFactory) {<z>
beanFactory = beanFactory;<z>
!= null) {<z>
;<z>
.targetBeanName == null) {<z>
propertyPath != null) {<z>
(<z>
"Specify 'targetObject' or 'targetBeanName' in combination with 'propertyPath'");<z>
'.') : -1);<z>
== -1) {<z>
IllegalArgumentException(<z>
;<z>
substring(0, dotIndex);<z>
1);<z>
== null) {<z>
new IllegalArgumentException("'propertyPath' is required");<z>
isSingleton(this.targetBeanName)) {<z>
.getBean(this.targetBeanName);<z>
.forBeanPropertyAccess(bean);<z>
(this.propertyPath);<z>
protected AbstractServerResponse(<z>
MultiValueMap<String, Cookie> cookies) {<z>
this.statusCode = statusCode;<z>
;<z>
=<z>
(cookies));<z>
String, Object>> attributesConsumer) {<z>
);<z>
attributes = new LinkedHashMap<>();<z>
accept(attributes);<z>
.AttributesRouterFunction<>(this, attributes);<z>
) throws IOException {<z>
(in);<z>
close();<z>
? extends Annotation> annotationType,<z>
annotationFilter) {<z>
{<z>
annotationFilter,<z>
)).get(annotationType);<z>
{<z>
return noRepeatablesCache.computeIfAbsent(annotationFilter,<z>
get(annotationType);<z>
);<z>
setWebAppRootSystemProperty(ServletContext servletContext) throws IllegalStateException {<z>
.notNull(servletContext, "ServletContext must not be null");<z>
"/");<z>
(root == null) {<z>
(<z>
;<z>
WEB_APP_ROOT_KEY_PARAM);<z>
: DEFAULT_WEB_APP_ROOT_KEY);<z>
key);<z>
StringUtils.pathEquals(oldValue, root)) {<z>
IllegalStateException("Web app root system property already set to different value: '" +<z>
+<z>
;<z>
key, root);<z>
+ "' = [" + root + "]");<z>
validate() {<z>
{<z>
if (classOnly) {<z>
IllegalStateException("createClass does not accept callbacks");<z>
new IllegalStateException("Callbacks are required");<z>
callbackTypes == null)) {<z>
;<z>
{<z>
= null;<z>
null && callbackTypes != null) {<z>
) {<z>
("Lengths of callback and callback types array must be the same");<z>
determineTypes(callbacks);<z>
; i++) {<z>
i])) {<z>
[i]);<z>
callbacks != null) {<z>
;<z>
(interfaces != null) {<z>
; i++) {<z>
] == null) {<z>
"Interfaces cannot be null");<z>
.isInterface()) {<z>
[i] + " is not an interface");<z>
> ml, Class<?> elementType) {<z>
size());<z>
{<z>
));<z>
resolved;<z>
MethodParameter parameter, Object value, UriComponentsBuilder builder,<z>
> uriVariables) {<z>
;<z>
HttpMethod method) {<z>
);<z>
== 205 ||<z>
;<z>
{<z>
) -> String.format(<z>
valueToBind, toQuery()));<z>
);<z>
FastByteArrayOutputStream fastByteArrayOutputStream) {<z>
this.fastByteArrayOutputStream = fastByteArrayOutputStream;<z>
= fastByteArrayOutputStream.buffers.iterator();<z>
(this.buffersIterator.hasNext()) {<z>
;<z>
getLast()) {<z>
fastByteArrayOutputStream.index;<z>
.length : 0);<z>
TimeZone getTimeZone(@Nullable LocaleContext localeContext) {<z>
(localeContext instanceof TimeZoneAwareLocaleContext) {<z>
;<z>
(timeZone != null) {<z>
timeZone;<z>
));<z>
scopeName, Scope scope) {<z>
(this.scopes == null) {<z>
= new LinkedHashMap<>(1);<z>
);<z>
{<z>
;<z>
.append("]; ");<z>
).append("]; ");<z>
;<z>
("]; ");<z>
getDescription());<z>
);<z>
TransactionException {<z>
{<z>
.isDebug()) {<z>
;<z>
);<z>
{<z>
)) {<z>
("Marking existing transaction as rollback-only after commit exception", ex);<z>
(status);<z>
Error rbex) {<z>
("Commit exception overridden by rollback exception", ex);<z>
TransactionSynchronization.STATUS_UNKNOWN);<z>
rbex;<z>
(status, TransactionSynchronization.STATUS_ROLLED_BACK);<z>
resolveResourceInternal(@Nullable ServerWebExchange exchange,<z>
Resource> locations, ResourceResolverChain chain) {<z>
(exchange, requestPath);<z>
.class);<z>
!= null) {<z>
.getLogPrefix() : "";<z>
+ "Resource resolved from cache");<z>
Mono.just(cachedResource);<z>
.resolveResource(exchange, requestPath, locations)<z>
key, resource));<z>
(<z>
) {<z>
super(methodDetails, cacheResolver, keyGenerator);<z>
.getCacheAnnotation();<z>
), ann.noEvictFor());<z>
{<z>
AbstractServerHttpRequest) {<z>
) request).getNativeRequest();<z>
else if (request instanceof ServerHttpRequestDecorator) {<z>
.getDelegate());<z>
(<z>
getClass().getName());<z>
name) {<z>
>();<z>
(this.aliasMap) {<z>
, result);<z>
StringUtils.toStringArray(result);<z>
(<z>
RejectedExecutionHandler rejectedExecutionHandler) {<z>
(this.queueCapacity);<z>
,<z>
, queue, threadFactory, rejectedExecutionHandler);<z>
if (this.allowCoreThreadTimeOut) {<z>
.allowCoreThreadTimeOut(true);<z>
{<z>
.prestartAllCoreThreads();<z>
exposeUnconfigurableExecutor ?<z>
executor);<z>
return executor;<z>
boolean isFormPost() {<z>
String contentType = getContentType();<z>
) &&<z>
(getMethod()));<z>
(Properties props, EncodedResource resource, PropertiesPersister persister)<z>
IOException {<z>
= null;<z>
= null;<z>
).getFilename();<z>
null && filename.endsWith(XML_FILE_EXTENSION)) {<z>
) {<z>
("XML support disabled");<z>
;<z>
props, stream);<z>
.requiresReader()) {<z>
);<z>
persister.load(props, reader);<z>
getInputStream();<z>
);<z>
if (stream != null) {<z>
close();<z>
null) {<z>
;<z>
initialBlockSize) {<z>
(initialBlockSize > 0, "Initial block size must be greater than 0");<z>
initialBlockSize = initialBlockSize;<z>
initialBlockSize;<z>
{<z>
String contextPath = element.getAttribute("context-path");<z>
if (StringUtils.hasText(contextPath)) {<z>
beanDefinitionBuilder.addPropertyValue("contextPath", contextPath);<z>
DomUtils.getChildElementsByTagName(element, "class-to-be-bound");<z>
) {<z>
(classes.size());<z>
for (Element classToBeBound : classes) {<z>
.getAttribute("name");<z>
add(className);<z>
);<z>
, @Nullable String falseString, boolean allowEmpty) {<z>
trueString;<z>
falseString;<z>
this.allowEmpty = allowEmpty;<z>
ResultMatcher number(Double expectedValue) {<z>
result -> {<z>
MockHttpServletResponse response = result.getResponse();<z>
getDefinedEncoding(response), expectedValue);<z>
ResourceWebHandler> handlerMap) {<z>
();<z>
forEach((rawPattern, resourceWebHandler) -> {<z>
(rawPattern);<z>
);<z>
handlerMap.put(pattern, resourceWebHandler);<z>
;<z>
{<z>
{<z>
debug(String.valueOf(message));<z>
TemplateLoader getTemplateLoaderForPath(String templateLoaderPath) {<z>
)) {<z>
;<z>
;<z>
()) {<z>
.debug(<z>
"]");<z>
FileTemplateLoader(file);<z>
ex) {<z>
{<z>
+ templateLoaderPath +<z>
, ex);<z>
(getResourceLoader(), templateLoaderPath);<z>
"File system access not preferred: using SpringTemplateLoader");<z>
getResourceLoader(), templateLoaderPath);<z>
> callable) {<z>
create(sink -> {<z>
.call();<z>
.success();<z>
{<z>
);<z>
this.scheduler);<z>
createListenerConsumer(final Session session) throws JMSException {<z>
= getDestination();<z>
(destination == null) {<z>
String destinationName = getDestinationName();<z>
destinationName != null, "No destination set");<z>
resolveDestinationName(session, destinationName);<z>
= createConsumer(session, destination);<z>
{<z>
)));<z>
message -> processMessage(message, session));<z>
;<z>
(@Nullable Object returnValue) {<z>
+ "]" +<z>
().getName() : "") +<z>
" in " + toString();<z>
... buffers) {<z>
ObjectUtils.isEmpty(buffers)) {<z>
[]::new));<z>
return this;<z>
, String expression) {<z>
"AnnotatedElementKey must not be null");<z>
;<z>
= element;<z>
this.expression = expression;<z>
, WebSocketHandler handler,<z>
<WebSocketSession> connectFuture) {<z>
super(request, handler, connectFuture);<z>
enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) {<z>
);<z>
();<z>
()) {<z>
BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);<z>
.CONFIGURATION_CLASS_ATTRIBUTE);<z>
annotationMetadata = null;<z>
= null;<z>
{<z>
();<z>
;<z>
|| methodMetadata != null) &&<z>
{<z>
liteConfigurationCandidateWithoutBeanMethods =<z>
) &&<z>
.hasBeanMethods(annotationMetadata));<z>
liteConfigurationCandidateWithoutBeanMethods) {<z>
beanClassLoader);<z>
{<z>
new IllegalStateException(<z>
), ex);<z>
{<z>
(beanDef instanceof AbstractBeanDefinition abd)) {<z>
BeanDefinitionStoreException("Cannot enhance @Configuration bean definition '" +<z>
;<z>
&& beanFactory.containsSingleton(beanName)) {<z>
info("Cannot enhance @Configuration bean definition '" + beanName +<z>
;<z>
.put(beanName, abd);<z>
NativeDetector.inNativeImage()) {<z>
enhanceConfigClasses.end();<z>
ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();<z>
{<z>
beanDef = entry.getValue();<z>
Boolean.TRUE);<z>
;<z>
configClass, this.beanClassLoader);<z>
enhancedClass) {<z>
(logger.isTraceEnabled()) {<z>
.trace(String.format("Replacing bean definition '%s' existing class '%s' with " +<z>
enhancedClass.getName()));<z>
setBeanClass(enhancedClass);<z>
);<z>
Nullable LocaleContext localeContext, boolean inheritable) {<z>
{<z>
);<z>
{<z>
(localeContext);<z>
localeContextHolder.remove();<z>
localeContext);<z>
inheritableLocaleContextHolder.remove();<z>
copyDefaultEditorsTo(PropertyEditorRegistrySupport target) {<z>
;<z>
this.configValueEditorsActive;<z>
.defaultEditors;<z>
.overriddenDefaultEditors;<z>
birth_date, List<BigDecimal> balance) {<z>
.name = name;<z>
.age = age;<z>
;<z>
.balance = balance;<z>
{<z>
.toString());<z>
) {<z>
.sourceType == null) {<z>
-1);<z>
== null) {<z>
1;<z>
other.sourceType.getName());<z>
;<z>
(String headerName, String... headerValues) {<z>
(String headerValue : headerValues) {<z>
, headerValue);<z>
;<z>
(ServletContext servletContext) {<z>
"ServletContext must not be null");<z>
;<z>
(param != null ? param : DEFAULT_WEB_APP_ROOT_KEY);<z>
).remove(key);<z>
List<KParameter> parameters) {<z>
KParameter> filteredParameters = parameters<z>
()<z>
()))<z>
toList());<z>
size()];<z>
filteredParameters.size(); i++) {<z>
KParameter parameter = filteredParameters.get(i);<z>
parameter.getName();<z>
if (name == null) {<z>
;<z>
parameterNames[i] = name;<z>
return parameterNames;<z>
(@Nullable Object value, MethodParameter returnType) {<z>
(value, returnType);<z>
this.returnValueHandlers) {<z>
AsyncHandlerMethodReturnValueHandler)) {<z>
.supportsReturnType(returnType)) {<z>
return handler;<z>
null;<z>
typesToMatch) {<z>
> targetType = mbd.getTargetType();<z>
) {<z>
return targetType;<z>
(mbd.getFactoryMethodName() != null) {<z>
;<z>
resolveBeanClass(mbd, beanName, typesToMatch);<z>
equals(@Nullable Object other) {<z>
(other)) {<z>
false;<z>
otherErc = (ExplicitRepeatableContainer) other;<z>
equals(otherErc.repeatable));<z>
Object other) {<z>
this == other) {<z>
return true;<z>
otherSettings)) {<z>
;<z>
== otherSettings.deliveryMode &&<z>
priority &&<z>
.timeToLive == otherSettings.timeToLive);<z>
) {<z>
this.clazz != null) {<z>
getResource(this.path);<z>
(this.classLoader != null) {<z>
.path);<z>
;<z>
(IllegalArgumentException ex) {<z>
null;<z>
methodInvocation) throws Throwable {<z>
beforeAccess();<z>
.proceed();<z>
;<z>
ServerHttpResponse response) {<z>
asyncRequestControl == null) {<z>
(!(response instanceof ServletServerHttpResponse servletServerResponse)) {<z>
(<z>
"Response must be a ServletServerHttpResponse: " + response.getClass());<z>
= new ServletServerHttpAsyncRequestControl(this, servletServerResponse);<z>
asyncRequestControl;<z>
Nullable String value, BeanExpressionContext evalContext) throws BeansException {<z>
{<z>
return value;<z>
value);<z>
expr == null) {<z>
value, this.beanExpressionParserContext);<z>
.expressionCache.put(value, expr);<z>
= this.evaluationCache.get(evalContext);<z>
== null) {<z>
);<z>
sec.addPropertyAccessor(new BeanExpressionContextAccessor());<z>
BeanFactoryAccessor());<z>
;<z>
sec.addPropertyAccessor(new EnvironmentAccessor());<z>
(evalContext.getBeanFactory()));<z>
getBeanClassLoader()));<z>
.setTypeConverter(new StandardTypeConverter(() -> {<z>
);<z>
cs : DefaultConversionService.getSharedInstance());<z>
}));<z>
(sec);<z>
;<z>
expr.getValue(sec);<z>
catch (Throwable ex) {<z>
ex);<z>
matcher) {<z>
getCookie(name).getPath();<z>
this.exchangeResult.assertWithDiagnostics(() -> {<z>
getMessage(name) + " path";<z>
(message, path, matcher);<z>
);<z>
;<z>
Cookie cookie) {<z>
, "Cookie must not be null");<z>
.cookies.add(cookie);<z>
;<z>
boolean isOverrideFor(Method candidate) {<z>
method.getName()) ||<z>
this.method.getParameterCount()) {<z>
false;<z>
;<z>
getParameterTypes(), paramTypes)) {<z>
true;<z>
{<z>
paramTypes[i] !=<z>
()) {<z>
;<z>
return true;<z>
final Method method) {<z>
new StringBuilder();<z>
;<z>
= method.getParameterTypes();<z>
) {<z>
);<z>
append(')');<z>
;<z>
stringBuilder.toString();<z>
WebApplicationContext webAppContext) {<z>
notNull(webAppContext, "WebApplicationContext is required");<z>
, "WebApplicationContext must have a ServletContext");<z>
= webAppContext;<z>
void scanPackage(SpringPersistenceUnitInfo scannedUnit, String pkg) {<z>
(this.componentsIndex != null) {<z>
candidates = new HashSet<>();<z>
filter : entityTypeFilters) {<z>
()));<z>
forEach(scannedUnit::addManagedClassName);<z>
(pkg, "package-info");<z>
scannedUnit::addManagedPackage);<z>
CLASSPATH_ALL_URL_PREFIX +<z>
convertClassNameToResourcePath(pkg) + CLASS_RESOURCE_PATTERN;<z>
this.resourcePatternResolver.getResources(pattern);<z>
resourcePatternResolver);<z>
(Resource resource : resources) {<z>
resource);<z>
().getClassName();<z>
(reader, readerFactory)) {<z>
className);<z>
null) {<z>
getURL();<z>
isJarURL(url)) {<z>
.extractJarFileURL(url));<z>
(PACKAGE_INFO_SUFFIX)) {<z>
(<z>
);<z>
(FileNotFoundException ex) {<z>
ex) {<z>
new PersistenceException("Failed to scan classpath for unlisted entity classes", ex);<z>
run() {<z>
synchronized (lifecycleMonitor) {<z>
++;<z>
;<z>
;<z>
;<z>
idleReceivesPerTaskLimit;<z>
0 && idleLimit < 0) {<z>
;<z>
;<z>
;<z>
0 || messageCount < messageLimit) &&<z>
< 0 || idleCount < idleLimit)) {<z>
currentReceived = invokeListener();<z>
currentReceived;<z>
messageCount++;<z>
currentReceived ? 0 : idleCount + 1);<z>
ex) {<z>
();<z>
) {<z>
waitBeforeRecoveryAttempt();<z>
= false;<z>
false;<z>
{<z>
.lastRecoveryMarker == currentRecoveryMarker) {<z>
, false);<z>
recoverAfterListenerSetupFailure();<z>
currentRecoveryMarker = new Object();<z>
alreadyRecovered = true;<z>
{<z>
handleListenerSetupFailure(ex, true);<z>
(lifecycleMonitor) {<z>
);<z>
;<z>
messageReceived) {<z>
;<z>
.idleTaskExecutionCount = 0;<z>
(lifecycleMonitor) {<z>
) || !rescheduleTaskIfNecessary(this)) {<z>
;<z>
logger.isDebugEnabled()) {<z>
);<z>
);<z>
);<z>
isRunning()) {<z>
- getPausedTaskCount();<z>
1) {<z>
"All scheduled consumers have been paused, probably due to tasks having been rejected. " +<z>
"Check your thread pool configuration! Manual recovery necessary through a start() call.");<z>
{<z>
"Number of scheduled consumers has dropped below concurrentConsumers limit, probably " +<z>
);<z>
MethodProxy methodProxy) {<z>
= args[0];<z>
(proxy == other) {<z>
true;<z>
if (other instanceof Factory) {<z>
.getCallback(INVOKE_EQUALS);<z>
{<z>
false;<z>
EqualsInterceptor) callback).advised;<z>
;<z>
return false;<z>
void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {<z>
;<z>
.beanPostProcessors.remove(beanPostProcessor);<z>
;<z>
initHeaders(SimpMessageHeaderAccessor simpAccessor) {<z>
getHeaderInitializer() != null) {<z>
).initHeaders(simpAccessor);<z>
Locale locale) {<z>
()) {<z>
;<z>
= getCacheKey(viewName, locale);<z>
cachedView;<z>
synchronized (this.viewCreationCache) {<z>
cacheKey);<z>
.viewCreationCache.remove(cacheKey);<z>
isDebugEnabled()) {<z>
(cacheKey) +<z>
: "not found in the cache"));<z>
> attributesForRepeatable(AnnotationMetadata metadata,<z>
{<z>
getName());<z>
{<z>
;<z>
null) {<z>
shadowMatchCache) {<z>
null;<z>
);<z>
) {<z>
;<z>
;<z>
{<z>
.getDeclaringClass());<z>
null) {<z>
);<z>
catch (ReflectionWorldException ex2) {<z>
;<z>
!= originalMethod && (shadowMatch == null ||<z>
) {<z>
= originalMethod;<z>
;<z>
ex) {<z>
;<z>
null) {<z>
matchesMethodExecution(methodToMatch);<z>
ReflectionWorldException ex2) {<z>
= null;<z>
ex) {<z>
("PointcutExpression matching rejected target method", ex);<z>
null;<z>
{<z>
, null, null);<z>
{<z>
shadowMatch = new DefensiveShadowMatch(shadowMatch,<z>
(methodToMatch));<z>
put(targetMethod, shadowMatch);<z>
;<z>
) {<z>
"Cookie must not be null");<z>
(), cookie);<z>
return this;<z>
{<z>
)) {<z>
message);<z>
{<z>
;<z>
this.defaultProtocolHandler != null) {<z>
.resolveSessionId(message);<z>
sessionId != null) {<z>
sessionId;<z>
return null;<z>
throws SQLException {<z>
!= null) {<z>
getResultSetValue(rs, index, requiredType);<z>
, index);<z>
(@Nullable String domain) {<z>
{<z>
.charAt(0);<z>
) - 1);<z>
== '-') {<z>
domain);<z>
(); i++) {<z>
= c;<z>
charAt(i);<z>
'-' && c == '.')) {<z>
(domain + ": invalid cookie domain char '" + c + "'");<z>
FlashMap> allMaps, HttpServletRequest request) {<z>
<>();<z>
) {<z>
)) {<z>
result.add(flashMap);<z>
result.isEmpty()) {<z>
result);<z>
()) {<z>
.get(0));<z>
return result.get(0);<z>
return null;<z>
filter, Object cacheKey, Throwable ex) {<z>
== null) {<z>
())) {<z>
doPut(exceptionCache, cacheKey, ex);<z>
request) {<z>
if (request instanceof RequestFacade facade) {<z>
;<z>
{<z>
;<z>
(wrappedRequest);<z>
+<z>
;<z>
Object> doExecute(Object... args) {<z>
checkCompiled();<z>
params = matchInParameterValuesWithCallParameters(args);<z>
;<z>
) {<z>
context.containsLocalBean(THEME_SOURCE_BEAN_NAME)) {<z>
.class);<z>
&& themeSource instanceof HierarchicalThemeSource hts) {<z>
hts.getParentThemeSource() == null) {<z>
ThemeSource) context.getParent());<z>
{<z>
themeSource + "]");<z>
themeSource;<z>
themeSource = null;<z>
context.getParent() instanceof ThemeSource) {<z>
;<z>
;<z>
();<z>
if (logger.isDebugEnabled()) {<z>
logger.debug("Unable to locate ThemeSource with name '" + THEME_SOURCE_BEAN_NAME +<z>
;<z>
themeSource;<z>
sqlType, boolean nullable) {<z>
= columnName;<z>
.sqlType = sqlType;<z>
;<z>
Nullable Object candidate,<z>
) {<z>
getDisplayString(candidate, editor, false);<z>
{<z>
<?>) boundValue;<z>
;<z>
if (enumCodeAsString.equals(candidateDisplayString)) {<z>
;<z>
;<z>
) {<z>
;<z>
candidateDisplayString)) {<z>
return true;<z>
!= null && candidate instanceof String candidateAsString) {<z>
;<z>
.containsKey(editor)) {<z>
editor);<z>
editor.setAsText(candidateAsString);<z>
candidateAsValue = editor.getValue();<z>
{<z>
.put(editor, candidateAsValue);<z>
nullSafeEquals(boundValue, candidateAsValue)) {<z>
true;<z>
;<z>
)<z>
throws JMSException, IOException, XmlMappingException {<z>
bos = new ByteArrayOutputStream(1024);<z>
bos);<z>
.marshal(object, streamResult);<z>
BytesMessage message = session.createBytesMessage();<z>
));<z>
return message;<z>
) {<z>
if (this == o) {<z>
return true;<z>
QuartzCronField other)) {<z>
return false;<z>
() &&<z>
other.value);<z>
, Class<?> expectedType) {<z>
isInstance(attributeValue)) {<z>
String.format(<z>
getSimpleName(), expectedType.getSimpleName(),<z>
.displayName));<z>
{<z>
);<z>
XMLStreamException ex) {<z>
);<z>
<Object> resolveArgument(<z>
BindingContext context, ServerWebExchange exchange) {<z>
;<z>
)) {<z>
(Object.class);<z>
.getClass())) {<z>
;<z>
());<z>
getValueInternal(ExpressionState state) throws EvaluationException {<z>
leftOp = getLeftOperand();<z>
();<z>
();<z>
.getValueInternal(state).getValue();<z>
instanceof Number leftNumber && rightOperand instanceof Number rightNumber) {<z>
instanceof BigDecimal) {<z>
);<z>
));<z>
{<z>
;<z>
()));<z>
{<z>
doubleValue()));<z>
{<z>
, rightNumber.floatValue()));<z>
;<z>
) {<z>
;<z>
d);<z>
);<z>
, PlatformTransactionManager transactionManager,<z>
boolean defaultRollback) {<z>
.testContext = testContext;<z>
.transactionManager = transactionManager;<z>
this.transactionDefinition = transactionDefinition;<z>
this.defaultRollback = defaultRollback;<z>
this.flaggedForRollback = defaultRollback;<z>
(DataBuffer dataBuffer) {<z>
) {<z>
;<z>
) {<z>
();<z>
;<z>
requestToken();<z>
Mono<Void> invokeAfterCompletion(TransactionSynchronizationManager synchronizationManager,<z>
<TransactionSynchronization> synchronizations, int completionStatus) {<z>
;<z>
MethodVisitor methodVisitor) {<z>
!= Opcodes.ASM9<z>
&& api != Opcodes.ASM8<z>
api != Opcodes.ASM7<z>
&& api != Opcodes.ASM6<z>
!= Opcodes.ASM5<z>
ASM4<z>
) {<z>
throw new IllegalArgumentException("Unsupported api " + api);<z>
api;<z>
mv = methodVisitor;<z>
ServletUriComponentsBuilder fromRequestUri(HttpServletRequest request) {<z>
request);<z>
.getRequestURI());<z>
;<z>
webSocketMessageBrokerStats(<z>
@Nullable AbstractBrokerMessageHandler stompBrokerRelayMessageHandler,<z>
TaskExecutor clientInboundChannelExecutor,<z>
{<z>
stats = new WebSocketMessageBrokerStats();<z>
((SubProtocolWebSocketHandler) subProtocolWebSocketHandler);<z>
(stompBrokerRelayMessageHandler instanceof StompBrokerRelayMessageHandler) {<z>
(StompBrokerRelayMessageHandler) stompBrokerRelayMessageHandler);<z>
setInboundChannelExecutor(clientInboundChannelExecutor);<z>
.setOutboundChannelExecutor(clientOutboundChannelExecutor);<z>
;<z>
stats;<z>
? extends T> clazz, HttpInputMessage inputMessage)<z>
IOException, HttpMessageNotReadableException {<z>
();<z>
();<z>
null && contentType.getCharset() != null ?<z>
) : DEFAULT_CHARSET);<z>
charset);<z>
reader);<z>
) {<z>
.getMessage(), ex, inputMessage);<z>
) {<z>
constructor.getDeclaringClass();<z>
= ClassUtils.getUserClass(declaringClass);<z>
) {<z>
(constructor.getParameterTypes());<z>
{<z>
constructor;<z>
int startPos, int endPos, long value) {<z>
startPos, endPos);<z>
);<z>
"J";<z>
, MultipartFile> getMultipartFiles() {<z>
multipartFiles == null) {<z>
;<z>
.multipartFiles;<z>
(ExchangeFilterFunction afterFilter) {<z>
.notNull(afterFilter, "ExchangeFilterFunction must not be null");<z>
-><z>
(afterRequest, next));<z>
boolean equals(@Nullable Object other) {<z>
if (this == other) {<z>
true;<z>
other instanceof AdviceExcludingMethodMatcher otherMm)) {<z>
;<z>
.equals(otherMm.adviceMethod);<z>
scope) {<z>
== SCOPE_REQUEST) {<z>
, callback);<z>
;<z>
? extends Encoder<?>> encoders) {<z>
encoders.clear();<z>
);<z>
strategies = this.strategies.mutate()<z>
encoders(list -> {<z>
clear();<z>
addAll(encoders);<z>
();<z>
> handleTypeMismatch(<z>
, WebRequest request) {<z>
);<z>
(Object... args) throws Exception {<z>
= getBridgedMethod();<z>
{<z>
method, getBean(), args);<z>
), args);<z>
IllegalArgumentException ex) {<z>
(method, getBean(), args);<z>
.getMessage() : "Illegal argument");<z>
, args), ex);<z>
) {<z>
targetException = ex.getTargetException();<z>
(targetException instanceof RuntimeException) {<z>
(RuntimeException) targetException;<z>
(targetException instanceof Error) {<z>
Error) targetException;<z>
{<z>
targetException;<z>
);<z>
Nullable String nestedProperty) {<z>
String actualPropertyName =<z>
;<z>
.customEditors != null) {<z>
::registerCustomEditor);<z>
!= null) {<z>
editorHolder) -> {<z>
if (nestedProperty != null) {<z>
PropertyAccessorUtils.getFirstNestedPropertySeparatorIndex(editorPath);<z>
{<z>
(0, pos);<z>
= editorPath.substring(pos + 1);<z>
|| editorNestedProperty.equals(actualPropertyName)) {<z>
.registerCustomEditor(<z>
editorHolder.getPropertyEditor());<z>
.registerCustomEditor(<z>
));<z>
;<z>
TypedValue contextObject, EvaluationContext evalContext, String name)<z>
{<z>
getValue();<z>
nullSafe) {<z>
;<z>
PropertyAccessor accessorToUse = this.cachedReadAccessor;<z>
null) {<z>
contains(accessorToUse)) {<z>
contextObject.getValue(), name);<z>
Exception ex) {<z>
= null;<z>
=<z>
));<z>
) {<z>
.getValue(), name)) {<z>
if (accessor instanceof ReflectivePropertyAccessor reflectivePropertyAccessor) {<z>
= reflectivePropertyAccessor.createOptimalAccessor(<z>
getValue(), name);<z>
this.cachedReadAccessor = accessor;<z>
getValue(), name);<z>
ex) {<z>
));<z>
() == null) {<z>
;<z>
, name,<z>
)));<z>
void addConstantDynamicOrInvokeDynamicReference(<z>
int tag,<z>
int index,<z>
String name,<z>
String descriptor,<z>
) {<z>
, name, descriptor, bootstrapMethodIndex);<z>
;<z>
DateTimeFormatter formatter, @Nullable Locale locale) {<z>
(locale) : formatter);<z>
);<z>
;<z>
int typeAnnotationOffset) {<z>
currentOffset = typeAnnotationOffset;<z>
typeAnnotationOffset);<z>
targetType >>> 24) {<z>
TypeReference.CLASS_TYPE_PARAMETER:<z>
TypeReference.METHOD_TYPE_PARAMETER:<z>
.METHOD_FORMAL_PARAMETER:<z>
&= 0xFFFF0000;<z>
2;<z>
:<z>
:<z>
.METHOD_RECEIVER:<z>
&= 0xFF000000;<z>
;<z>
.LOCAL_VARIABLE:<z>
:<z>
targetType &= 0xFF000000;<z>
tableLength = readUnsignedShort(currentOffset + 1);<z>
+= 3;<z>
currentLocalVariableAnnotationRangeStarts = new Label[tableLength];<z>
Label[tableLength];<z>
int[tableLength];<z>
< tableLength; ++i) {<z>
currentOffset);<z>
length = readUnsignedShort(currentOffset + 2);<z>
);<z>
+= 6;<z>
.currentLocalVariableAnnotationRangeStarts[i] =<z>
createLabel(startPc, context.currentMethodLabels);<z>
.currentLocalVariableAnnotationRangeEnds[i] =<z>
, context.currentMethodLabels);<z>
] = index;<z>
:<z>
TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:<z>
TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:<z>
:<z>
.METHOD_REFERENCE_TYPE_ARGUMENT:<z>
targetType &= 0xFF0000FF;<z>
currentOffset += 4;<z>
:<z>
.CLASS_TYPE_PARAMETER_BOUND:<z>
.METHOD_TYPE_PARAMETER_BOUND:<z>
.THROWS:<z>
case TypeReference.EXCEPTION_PARAMETER:<z>
;<z>
+= 3;<z>
INSTANCEOF:<z>
case TypeReference.NEW:<z>
TypeReference.CONSTRUCTOR_REFERENCE:<z>
.METHOD_REFERENCE:<z>
;<z>
currentOffset += 3;<z>
new IllegalArgumentException();<z>
= targetType;<z>
= readByte(currentOffset);<z>
currentTypeAnnotationTargetPath =<z>
: new TypePath(classFileBuffer, currentOffset);<z>
* pathLength;<z>
argName, Set<?> ms) {<z>
));<z>
int i = 0;<z>
(Object m : ms) {<z>
(argName, i), m));<z>
++;<z>
return resolved;<z>
(String beanName, Object beanInstance) {<z>
transformedBeanName = transformedBeanName(beanName);<z>
transformedBeanName)) {<z>
isPrimary();<z>
();<z>
&&<z>
beanInstance));<z>
public boolean containsKey(Object key) {<z>
(key instanceof String headerName) {<z>
, 0) != -1);<z>
;<z>
Method method) {<z>
);<z>
getParameterTypes()) {<z>
));<z>
();<z>
Object other) {<z>
) {<z>
true;<z>
instanceof BeanMetadataAttribute otherMa)) {<z>
;<z>
(otherMa.name) &&<z>
, otherMa.value) &&<z>
, otherMa.source));<z>
state) throws EvaluationException {<z>
) {<z>
state);<z>
createNewInstance(state);<z>
void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {<z>
.isDefaultNamespace(root)) {<z>
getChildNodes();<z>
) {<z>
item(i);<z>
instanceof Element ele) {<z>
(delegate.isDefaultNamespace(ele)) {<z>
parseDefaultElement(ele, delegate);<z>
;<z>
parseCustomElement(root);<z>
int bufferSize) {<z>
, MimeTypeUtils.ALL);<z>
isTrue(bufferSize > 0, "'bufferSize' must be larger than 0");<z>
= bufferSize;<z>
ParameterNameDiscoverer createParameterNameDiscoverer() {<z>
;<z>
AspectJAdviceParameterNameDiscoverer adviceParameterNameDiscoverer =<z>
getExpression());<z>
setReturningName(this.returningName);<z>
;<z>
(true);<z>
;<z>
discoverer;<z>
) throws MBeanExportException {<z>
null) {<z>
.server != null, "No MBeanServer available");<z>
) {<z>
);<z>
{<z>
;<z>
put(bean, mappedObjectNames) == null) {<z>
(ObjectName mappedObjectName : mappedObjectNames) {<z>
mappedObjectName, bean.getNotificationListener(),<z>
(), bean.getHandback());<z>
catch (Throwable ex) {<z>
MBeanExportException("Unable to register NotificationListener", ex);<z>
PhaseEvent event) {<z>
.getFacesContext())) {<z>
;<z>
InvalidResultSetAccessException {<z>
(column);<z>
catch (SQLException se) {<z>
InvalidResultSetAccessException(se);<z>
UriComponentsBuilder fromPath(String path) {<z>
new UriComponentsBuilder();<z>
path(path);<z>
return builder;<z>
reference) throws SAXException {<z>
!= null) {<z>
reference.getName());<z>
{<z>
;<z>
getContainer(HttpServletRequest request) {<z>
request.getServletContext();<z>
= "jakarta.websocket.server.ServerContainer";<z>
getAttribute(attrName);<z>
.notNull(container, "No 'jakarta.websocket.server.ServerContainer' ServletContext attribute. " +<z>
"Are you running in a Servlet container that supports JSR-356?");<z>
;<z>
{<z>
.requestResponse(getPayloadMono());<z>
isVoid(elementType)) {<z>
);<z>
);<z>
.map(this::retainDataAndReleasePayload)<z>
dataBuffer, elementType, dataMimeType, EMPTY_HINTS));<z>
String selectProtocol(HttpHeaders headers, WebSocketHandler handler) {<z>
String protocolHeader = headers.getFirst(SEC_WEBSOCKET_PROTOCOL);<z>
!= null) {<z>
.getSubProtocols();<z>
{<z>
contains(protocol)) {<z>
protocol;<z>
return null;<z>
) {<z>
public Msg parsePartialFrom(<z>
google.protobuf.CodedInputStream input,<z>
extensionRegistry)<z>
.InvalidProtocolBufferException {<z>
;<z>
, Object target, String name) {<z>
);<z>
name.equals("length")) {<z>
.valueOf(Integer.TYPE);<z>
);<z>
.get(cacheKey);<z>
) {<z>
) {<z>
(cacheKey);<z>
(AccessException ex) {<z>
typeDescriptor;<z>
void putAttributes(final ByteVector output) {<z>
moduleAttributeLength =<z>
+ usesIndex.length + provides.length;<z>
addConstantUtf8(Constants.MODULE))<z>
moduleAttributeLength)<z>
moduleNameIndex)<z>
moduleFlags)<z>
)<z>
putShort(requiresCount)<z>
length)<z>
putShort(exportsCount)<z>
0, exports.length)<z>
opensCount)<z>
, 0, opens.length)<z>
usesCount)<z>
, usesIndex.length)<z>
(providesCount)<z>
, provides.length);<z>
(packageCount > 0) {<z>
.addConstantUtf8(Constants.MODULE_PACKAGES))<z>
(2 + packageIndex.length)<z>
packageCount)<z>
data, 0, packageIndex.length);<z>
if (mainClassIndex > 0) {<z>
.MODULE_MAIN_CLASS))<z>
.putInt(2)<z>
putShort(mainClassIndex);<z>
throws Exception {<z>
{<z>
;<z>
preProcessIndex++;<z>
(<z>
headers, HttpStatus status, WebRequest request) {<z>
status, request);<z>
readParameterAnnotations(<z>
final MethodVisitor methodVisitor,<z>
final Context context,<z>
int runtimeParameterAnnotationsOffset,<z>
) {<z>
;<z>
= classFileBuffer[currentOffset++] & 0xFF;<z>
numParameters, visible);<z>
context.charBuffer;<z>
; ++i) {<z>
currentOffset);<z>
+= 2;<z>
while (numAnnotations-- > 0) {<z>
, charBuffer);<z>
;<z>
, annotationDescriptor, visible),<z>
;<z>
Type getThisType(CodeEmitter e) {<z>
) {<z>
);<z>
;<z>
public void shutdown() {<z>
()) {<z>
this.beanName + "'" : ""));<z>
.executor != null) {<z>
{<z>
);<z>
.executor.shutdownNow()) {<z>
;<z>
;<z>
, HttpInputMessage inputMessage) throws IOException {<z>
newInstance();<z>
true);<z>
!isSupportDtd());<z>
.setFeature("http://xml.org/sax/features/external-general-entities", isProcessExternalEntities());<z>
);<z>
();<z>
{<z>
(NO_OP_ENTITY_RESOLVER);<z>
;<z>
)));<z>
SAXException | ParserConfigurationException ex) {<z>
throw new HttpMessageNotReadableException(<z>
, ex, inputMessage);<z>
?> message) {<z>
(logger.isDebugEnabled()) {<z>
(message, SimpMessageHeaderAccessor.class);<z>
accessor : SimpMessageHeaderAccessor.wrap(message));<z>
));<z>
{<z>
{<z>
) this.requestUpgradeStrategy).stop();<z>
Object value) throws BeansException {<z>
;<z>
propertyName);<z>
(NotReadablePropertyException ex) {<z>
propertyName,<z>
"' does not exist", ex);<z>
));<z>
value));<z>
, String value) throws IllegalArgumentException {<z>
HashSet<>();<z>
",")) {<z>
;<z>
{<z>
format(<z>
), originalValue,<z>
values())));<z>
groups;<z>
sql, int[] types) {<z>
);<z>
);<z>
(sql);<z>
;<z>
getValueTypeDescriptor(@Nullable Object rootObject) throws EvaluationException {<z>
=<z>
(rootObject), this.configuration);<z>
);<z>
maybeBindAnnotationsFromPointcutExpression() {<z>
> varNames = new ArrayList<>();<z>
pointcutExpression, " ");<z>
< tokens.length; i++) {<z>
toMatch = tokens[i];<z>
'(');<z>
if (firstParenIndex != -1) {<z>
;<z>
)) {<z>
);<z>
body.numTokensConsumed;<z>
text);<z>
null) {<z>
);<z>
("@args")) {<z>
tokens, i);<z>
body.numTokensConsumed;<z>
);<z>
;<z>
servletContext) {<z>
().values()) {<z>
ServletContextAware) {<z>
.setServletContext(servletContext);<z>
{<z>
.name = name.toUpperCase();<z>
;<z>
birth_date = birth_date;<z>
this.balance = balance;<z>
{<z>
headerAccessor.isModified()) {<z>
;<z>
this.headerAccessor.toMessageHeaders();<z>
instanceof Throwable) {<z>
!= null && this.providedMessage instanceof ErrorMessage) {<z>
this.providedMessage).getOriginalMessage();<z>
(message != null) {<z>
, message);<z>
payload, headersToUse);<z>
<>(this.payload, headersToUse);<z>
{<z>
bodySpec.returnResult())<z>
)<z>
(HttpHeaders::getContentType)<z>
)<z>
.orElse(StandardCharsets.UTF_8)<z>
();<z>
context) {<z>
context.getStore(AUTOWIRED_VALIDATION_NAMESPACE);<z>
testClass -> {<z>
methodsWithErrors =<z>
getUniqueDeclaredMethods(testClass, autowiredTestOrLifecycleMethodFilter);<z>
== 0 ? NO_AUTOWIRED_VIOLATIONS_DETECTED :<z>
.format(<z>
(methodsWithErrors)));<z>
;<z>
) {<z>
;<z>
(<z>
boolean registerDefaultFormatters) {<z>
embeddedValueResolver != null) {<z>
embeddedValueResolver);<z>
this);<z>
if (registerDefaultFormatters) {<z>
this);<z>
protected void renderMergedOutputModel(<z>
throws Exception {<z>
model, request);<z>
);<z>
);<z>
= getRequestDispatcher(request, dispatcherPath);<z>
) {<z>
) +<z>
);<z>
request, response)) {<z>
(getContentType());<z>
isDebugEnabled()) {<z>
+ "]");<z>
);<z>
()) {<z>
);<z>
response);<z>
byte getByte(int columnIndex) throws InvalidResultSetAccessException {<z>
.getByte(columnIndex);<z>
catch (SQLException se) {<z>
;<z>
() {<z>
Validator selected = null;<z>
for (WebMvcConfigurer configurer : this.delegates) {<z>
);<z>
if (validator != null) {<z>
{<z>
("No unique Validator found: {" +<z>
validator + "}");<z>
;<z>
selected;<z>
private void putFrameType(final Object type) {<z>
if (type instanceof Integer) {<z>
type).intValue());<z>
type instanceof String) {<z>
.putByte(Frame.ITEM_OBJECT)<z>
;<z>
{<z>
(Frame.ITEM_UNINITIALIZED)<z>
(Label) type).bytecodeOffset);<z>
private Object instantiateUserDefinedStrategy(<z>
Nullable ClassLoader classLoader) {<z>
Object result;<z>
className, classLoader)).newInstance();<z>
ClassNotFoundException ex) {<z>
+ "] for strategy [" +<z>
;<z>
) {<z>
IllegalArgumentException("Unable to instantiate class [" + className + "] for strategy [" +<z>
) + "]: a zero-argument constructor is required", ex);<z>
)) {<z>
"Provided class name must be an implementation of " + strategyType);<z>
return result;<z>
) {<z>
;<z>
domain);<z>
path);<z>
return result;<z>
String field) {<z>
= getFieldError(field);<z>
null) {<z>
fieldError.getRejectedValue();<z>
formatFieldValue(field, value));<z>
) != null) {<z>
(fixedField(field));<z>
field, value);<z>
.fieldValues.get(field);<z>
createMessagingErrorMessage(String description) {<z>
handlerMethod = getHandlerMethod();<z>
StringBuilder(description).append('\n')<z>
"Endpoint handler details:\n")<z>
.append("]\n")<z>
getBean()).append("]\n");<z>
();<z>
) {<z>
("Accept: %s",<z>
.mediaTypes.size() == 1) ?<z>
).next().toString() :<z>
mediaTypes.toString());<z>
void activate() {<z>
.active = true;<z>
.listeners) {<z>
);<z>
{<z>
makeAccessible(this.field);<z>
());<z>
IllegalAccessException ex) {<z>
throw new InvalidPropertyException(getWrappedClass(),<z>
getName(), "Field is not accessible", ex);<z>
<?> requiredType) {<z>
bean)) {<z>
convertIfNecessary(bean, requiredType);<z>
if (convertedBean == null) {<z>
);<z>
;<z>
ex) {<z>
logger.isTraceEnabled()) {<z>
+ "' to required type '" +<z>
;<z>
));<z>
(T) bean;<z>
.ManagedAttribute getManagedAttribute(Method method) throws InvalidMetadataException {<z>
.TYPE_HIERARCHY)<z>
withNonMergedAttributes();<z>
!ann.isPresent()) {<z>
null;<z>
jmx.export.metadata.ManagedAttribute();<z>
.asMap();<z>
MutablePropertyValues pvs = new MutablePropertyValues(map);<z>
("defaultValue");<z>
);<z>
.get("defaultValue");<z>
.length() > 0) {<z>
(defaultValue);<z>
;<z>
) {<z>
{<z>
cacheNames) {<z>
name, createConcurrentMapCache(name));<z>
.dynamic = false;<z>
;<z>
{<z>
) {<z>
, null).getClass();<z>
synchronized (this.resourceTypes) {<z>
;<z>
type == null) {<z>
(name, null).getClass();<z>
resourceTypes.put(name, type);<z>
type;<z>
> getApplicationListeners(<z>
ResolvableType eventType) {<z>
;<z>
source.getClass() : null);<z>
);<z>
CachedListenerRetriever newRetriever = null;<z>
get(cacheKey);<z>
null) {<z>
this.beanClassLoader == null ||<z>
(), this.beanClassLoader) &&<z>
)) {<z>
;<z>
.retrieverCache.putIfAbsent(cacheKey, newRetriever);<z>
if (existingRetriever != null) {<z>
= null;<z>
) {<z>
();<z>
{<z>
result;<z>
sourceType, newRetriever);<z>
signaler) throws SchedulerConfigException {<z>
();<z>
.dataSource == null) {<z>
+<z>
);<z>
));<z>
true);<z>
DBConnectionManager.getInstance().addConnectionProvider(<z>
,<z>
) {<z>
getConnection() throws SQLException {<z>
DataSourceUtils.doGetConnection(dataSource);<z>
shutdown() {<z>
public void initialize() {<z>
SchedulerFactoryBean.getConfigTimeNonTransactionalDataSource();<z>
dataSource);<z>
));<z>
).addConnectionProvider(<z>
),<z>
new ConnectionProvider() {<z>
Connection getConnection() throws SQLException {<z>
);<z>
shutdown() {<z>
public void initialize() {<z>
extractDatabaseMetaData(this.dataSource,<z>
;<z>
productName = JdbcUtils.commonDatabaseName(productName);<z>
contains("hsql")) {<z>
;<z>
());<z>
MetaDataAccessException ex) {<z>
, "Could not detect database type. Assuming locks can be taken.");<z>
initialize(loadHelper, signaler);<z>
PathMatcher pathMatcher) {<z>
pattern, "'matchingPattern' is required");<z>
lookupPath, "'lookupPath' is required");<z>
notNull(pathMatcher, "PathMatcher is required");<z>
= pattern;<z>
.lookupPath = lookupPath;<z>
= pathMatcher;<z>
;<z>
this.lookupPathContainer = null;<z>
> message) {<z>
getHeaders().get(LOOKUP_DESTINATION_HEADER);<z>
{<z>
return 0;<z>
getPatternComparator(destination);<z>
this.patterns.iterator();<z>
);<z>
&& iteratorOther.hasNext()) {<z>
);<z>
if (result != 0) {<z>
;<z>
.hasNext()) {<z>
;<z>
else if (iteratorOther.hasNext()) {<z>
1;<z>
return 0;<z>
rootObject, SpelParserConfiguration configuration) {<z>
;<z>
notNull(configuration, "SpelParserConfiguration must not be null");<z>
;<z>
;<z>
;<z>
) {<z>
constantPoolEntryIndex];<z>
(value != null) {<z>
return value;<z>
constantPoolEntryIndex];<z>
] =<z>
;<z>
AbstractBeanDefinition parseAdvice(<z>
, Element aspectElement, Element adviceElement, ParserContext parserContext,<z>
> beanReferences) {<z>
().getLocalName(adviceElement)));<z>
.class);<z>
).add("targetBeanName", aspectName);<z>
;<z>
;<z>
RootBeanDefinition aspectFactoryDef =<z>
(SimpleBeanFactoryAwareAspectInstanceFactory.class);<z>
aspectName);<z>
(true);<z>
adviceDef = createAdviceDefinition(<z>
, aspectName, order, methodDefinition, aspectFactoryDef,<z>
);<z>
);<z>
.extractSource(adviceElement));<z>
).addGenericArgumentValue(adviceDef);<z>
ORDER_PROPERTY)) {<z>
(<z>
);<z>
).registerWithGeneratedName(advisorDefinition);<z>
;<z>
;<z>
T> supplier,<z>
{<z>
, name, null, supplier, customizers);<z>
) {<z>
.JTA_TRANSACTION_ASPECT_BEAN_NAME;<z>
JTA_TRANSACTION_ASPECT_CLASS_NAME;<z>
().containsBeanDefinition(txAspectBeanName)) {<z>
new RootBeanDefinition();<z>
setBeanClassName(txAspectClassName);<z>
.setFactoryMethodName("aspectOf");<z>
element, def);<z>
;<z>
private Document parseXmlString(String xml) throws Exception {<z>
;<z>
;<z>
documentBuilder = factory.newDocumentBuilder();<z>
));<z>
return documentBuilder.parse(inputSource);<z>
private SessionFactory obtainSessionFactory() {<z>
;<z>
sf != null, "No SessionFactory set");<z>
;<z>
(ServerResponse other) {<z>
notNull(other, "ServerResponse must not be null");<z>
);<z>
.addAll(other.cookies());<z>
) {<z>
abstractOther.statusCode;<z>
);<z>
.value();<z>
doHandshake(ServerHttpRequest request, ServerHttpResponse response,<z>
<String, Object> attributes) throws HandshakeFailureException {<z>
handler, attributes);<z>
List<?> postProcessors, ConfigurableListableBeanFactory beanFactory) {<z>
1) {<z>
Object> comparatorToUse = null;<z>
if (beanFactory instanceof DefaultListableBeanFactory) {<z>
getDependencyComparator();<z>
== null) {<z>
;<z>
.sort(comparatorToUse);<z>
{<z>
;<z>
;<z>
;<z>
) {<z>
, status);<z>
hasAttribute("context-relative")) {<z>
element.getAttribute("context-relative"));<z>
, true);<z>
("keep-query-params")) {<z>
"keep-query-params"));<z>
;<z>
ObjectName[] getRegisteredObjectNames() {<z>
{<z>
;<z>
ExpressionException(String message) {<z>
;<z>
;<z>
this.position = 0;<z>
) {<z>
{<z>
|| retrieveLastModifiedTime() > this.lastModified);<z>
@Nullable Object storeValue) {<z>
.serialization != null) {<z>
[]) storeValue));<z>
) {<z>
, ex);<z>
fromStoreValue(storeValue);<z>
private static Method findGenericDeclaration(Method bridgeMethod) {<z>
getDeclaringClass().getSuperclass();<z>
!= null && Object.class != superclass) {<z>
superclass, bridgeMethod);<z>
&& !method.isBridge()) {<z>
method;<z>
;<z>
.getDeclaringClass());<z>
, bridgeMethod);<z>
, @Nullable String reason) {<z>
), "Invalid status code");<z>
= code;<z>
reason = reason;<z>
void onComplete() {<z>
.READY_TO_WRITE) {<z>
().onComplete();<z>
{<z>
State.READY_TO_WRITE) {<z>
).onComplete();<z>
this.state == State.NEW) {<z>
;<z>
.state = State.FIRST_SIGNAL_RECEIVED;<z>
Void> result;<z>
writeFunction.apply(this);<z>
catch (Throwable ex) {<z>
this.writeCompletionBarrier.onError(ex);<z>
(this.writeCompletionBarrier);<z>
this.completed = true;<z>
(Object connectionFactory)<z>
{<z>
if (connectionFactory instanceof ConnectionFactory) {<z>
return (ConnectionFactory) connectionFactory;<z>
{<z>
) connectionFactory);<z>
+<z>
connectionFactory);<z>
visitTryCatchBlock(<z>
handler, final String type) {<z>
mv != null) {<z>
);<z>
(<z>
definition, BeanDefinitionRegistry registry)<z>
BeanDefinitionStoreException {<z>
, false);<z>
definition);<z>
;<z>
Throwable {<z>
getName()) {<z>
:<z>
0];<z>
:<z>
System.identityHashCode(proxy);<z>
:<z>
;<z>
"close":<z>
error(<z>
new UnsupportedOperationException("Close is not supported!"));<z>
(this.target, args);<z>
) {<z>
.getTargetException();<z>
{<z>
) {<z>
case START_OBJECT:<z>
++;<z>
:<z>
this.objectDepth--;<z>
START_ARRAY:<z>
this.arrayDepth++;<z>
:<z>
this.arrayDepth--;<z>
@Nullable ConnectionFactory cf, boolean started) {<z>
if (con == null) {<z>
) {<z>
();<z>
Throwable ex) {<z>
"Could not stop JMS Connection before closing it", ex);<z>
close();<z>
(Throwable ex) {<z>
, ex);<z>
) {<z>
instance = get();<z>
state(instance != null, "No instance from Supplier");<z>
return instance;<z>
getCaches(<z>
CacheOperation> context, CacheResolver cacheResolver) {<z>
= cacheResolver.resolveCaches(context);<z>
()) {<z>
new IllegalStateException("No cache could be resolved for '" +<z>
"' using resolver '" + cacheResolver +<z>
;<z>
return caches;<z>
Jackson2CodecSupport(ObjectMapper objectMapper, MimeType... mimeTypes) {<z>
objectMapper, "ObjectMapper must not be null");<z>
.defaultObjectMapper = objectMapper;<z>
isEmpty(mimeTypes) ?<z>
) : DEFAULT_MIME_TYPES;<z>
] removeDuplicateStrings(String[] array) {<z>
) {<z>
array;<z>
array));<z>
set);<z>
, MatchingContext matchingContext) {<z>
matchingContext.isSeparator(pathIndex)) {<z>
) {<z>
matchingContext.determineRemainingPath) {<z>
1;<z>
return true;<z>
matchingContext.pathLength);<z>
pathIndex++;<z>
(pathIndex, matchingContext));<z>
return false;<z>
getDisplayValue() {<z>
instanceof String) {<z>
) this.value;<z>
{<z>
?<z>
value.toString());<z>
return "";<z>
Advisor anAdvisor) {<z>
= getAspectJPrecedenceInformationFor(anAdvisor);<z>
null) {<z>
);<z>
getAdvice() instanceof BeforeAdvice);<z>
Class<?> argumentType, String varName) {<z>
{<z>
, i)) {<z>
;<z>
("Expected to find an unbound argument of type '" +<z>
getName() + "'");<z>
) {<z>
0,<z>
);<z>
) - 1;<z>
(), index);<z>
());<z>
, "An @ModelAttribute and an Errors/BindingResult argument " +<z>
;<z>
.getParameterAnnotation(ModelAttribute.class);<z>
) ?<z>
: Conventions.getVariableNameForParameter(attributeParam));<z>
.MODEL_KEY_PREFIX + name);<z>
!= null, () -> "An Errors/BindingResult argument is expected " +<z>
));<z>
errors;<z>
private String getDisconnectReceipt(SimpMessageHeaderAccessor simpHeaders) {<z>
DISCONNECT_MESSAGE_HEADER;<z>
simpHeaders.getHeader(name);<z>
null) {<z>
getAccessor(message, StompHeaderAccessor.class);<z>
{<z>
);<z>
;<z>
request) {<z>
.warnLogger.isWarnEnabled()) {<z>
);<z>
objectMapper, String contentType) {<z>
.objectMapper = objectMapper;<z>
configurePrettyPrint();<z>
(contentType);<z>
setExposePathVariables(false);<z>
public String metaDataSchemaNameToUse(@Nullable String schemaName) {<z>
) {<z>
getDefaultSchema());<z>
schemaNameToUse(schemaName);<z>
) {<z>
== null) {<z>
;<z>
: array) {<z>
) {<z>
return true;<z>
;<z>
> clazz, boolean useCache) {<z>
!useCache) {<z>
();<z>
clazz).newInstance();<z>
getPropertyType() {<z>
Method method) {<z>
method.getReturnType();<z>
.member).getType();<z>
createProxy(EntityManager rawEntityManager,<z>
, boolean synchronizedWithTransaction) {<z>
notNull(emfInfo, "EntityManagerFactoryInfo must not be null");<z>
();<z>
pui = emfInfo.getPersistenceUnitInfo();<z>
) == PersistenceUnitTransactionType.JTA : null);<z>
rawEntityManager, emfInfo.getEntityManagerInterface(),<z>
jpaDialect, jta, containerManaged, synchronizedWithTransaction);<z>
NativeWebRequest request, ModelAndViewContainer container, HandlerMethod handlerMethod)<z>
Exception {<z>
.retrieveAttributes(request);<z>
sessionAttributes);<z>
container);<z>
name : findSessionAttributeArguments(handlerMethod)) {<z>
) {<z>
, name);<z>
value == null) {<z>
);<z>
, value);<z>
HttpServletRequest request) {<z>
Object path = resolvePath(request);<z>
path instanceof PathContainer);<z>
{<z>
())) {<z>
getValue();<z>
;<z>
values) {<z>
;<z>
for (CacheParameterDetail keyParameterDetail : this.keyParameterDetails) {<z>
getParameterPosition();<z>
) {<z>
IllegalStateException("Values mismatch, key parameter at position "<z>
+ values.length + " value(s)");<z>
.toCacheInvocationParameter(values[parameterPosition]));<z>
]);<z>
destinationName, Object request,<z>
headers, Class<T> targetClass) {<z>
(destinationName);<z>
(destination, request, headers, targetClass);<z>
) {<z>
getHeaderNames();<z>
>(headerNames.size());<z>
(String headerName : headerNames) {<z>
(headerName);<z>
) {<z>
(value)));<z>
response.getRedirectedUrl();<z>
(location != null) {<z>
new NameValuePair("Location", location));<z>
;<z>
public void visitLdcInsn(final Object value) {<z>
if (api < Opcodes.ASM5<z>
value instanceof Handle<z>
) == Type.METHOD))) {<z>
throw new UnsupportedOperationException(REQUIRES_ASM5);<z>
) {<z>
;<z>
if (mv != null) {<z>
value);<z>
) {<z>
() {<z>
();<z>
public final int getConcurrentConsumers() {<z>
lifecycleMonitor) {<z>
concurrentConsumers;<z>
List<ResponseBodyAdvice<?>> responseBodyAdvice) {<z>
(responseBodyAdvice != null) {<z>
.responseBodyAdvice.addAll(responseBodyAdvice);<z>
calculateHashCode() {<z>
ObjectUtils.nullSafeHashCode(this.type);<z>
if (this.typeProvider != null) {<z>
.getType());<z>
) {<z>
getSource());<z>
{<z>
nullSafeHashCode(this.componentType);<z>
hashCode;<z>
MessageChannel outboundChannel,<z>
{<z>
;<z>
user = user;<z>
;<z>
!= null && serverHeartbeat != null) {<z>
0 && serverHeartbeat[1] > 0 ?<z>
: 0);<z>
0] > 0 ?<z>
;<z>
;<z>
this.writeInterval = 0;<z>
);<z>
File getFile() throws IOException {<z>
;<z>
) {<z>
();<z>
));<z>
String resolveRequiredPlaceholders(String text) throws IllegalArgumentException {<z>
this.strictHelper == null) {<z>
.strictHelper = createPlaceholderHelper(false);<z>
doResolvePlaceholders(text, this.strictHelper);<z>
) {<z>
key, Restructure.WHEN_NECESSARY);<z>
: null);<z>
.getKey(), key));<z>
, Map<Integer, Parameter> byIndex) {<z>
(i, parameter) -> {<z>
.getValue();<z>
!= null) {<z>
statement.bind(i, value);<z>
);<z>
});<z>
() {<z>
ThreadPoolTaskExecutor();<z>
determinePoolSizeRange(executor);<z>
) {<z>
);<z>
) {<z>
setKeepAliveSeconds(this.keepAliveSeconds);<z>
null) {<z>
(this.rejectedExecutionHandler);<z>
!= null) {<z>
+ "-");<z>
.afterPropertiesSet();<z>
;<z>
, String payload, boolean isLast) {<z>
);<z>
this.wsSession, textMessage);<z>
catch (Exception ex) {<z>
);<z>
GlassFishLoadTimeWeaver(@Nullable ClassLoader classLoader) {<z>
(classLoader, "ClassLoader must not be null");<z>
<?> instrumentableLoaderClass;<z>
classLoader.loadClass(INSTRUMENTABLE_LOADER_CLASS_NAME);<z>
;<z>
.copyMethod = instrumentableLoaderClass.getMethod("copy");<z>
catch (Throwable ex) {<z>
throw new IllegalStateException(<z>
);<z>
= null;<z>
)) {<z>
)) {<z>
= cl;<z>
{<z>
(classLoader + " and its parents are not suitable ClassLoaders: A [" +<z>
() + "] implementation is required.");<z>
;<z>
TaskExecutor executor, ContentNegotiationManager manager) {<z>
notNull(registry, "ReactiveAdapterRegistry is required");<z>
"TaskExecutor is required");<z>
;<z>
registry;<z>
taskExecutor = executor;<z>
= manager;<z>
this.taskExecutorWarning =<z>
;<z>
Connection> doGetConnection(ConnectionFactory connectionFactory) {<z>
(connectionFactory, "ConnectionFactory must not be null");<z>
{<z>
) synchronizationManager.getResource(connectionFactory);<z>
) {<z>
;<z>
conHolder.hasConnection()) {<z>
.doOnNext(conHolder::setConnection);<z>
conHolder.getConnection());<z>
Connection> con = fetchConnection(connectionFactory);<z>
.isSynchronizationActive()) {<z>
doOnNext(conn -> {<z>
conHolder;<z>
null) {<z>
ConnectionHolder(conn);<z>
(conn);<z>
requested();<z>
holderToUse, connectionFactory));<z>
holderToUse.setSynchronizedWithTransaction(true);<z>
!= conHolder) {<z>
connectionFactory, holderToUse);<z>
(e))));<z>
con;<z>
;<z>
) {<z>
=<z>
&&<z>
.toClass());<z>
) &&<z>
APPLICATION_FORM_URLENCODED.isCompatibleWith(mediaType)));<z>
String... resourceNames) {<z>
Resource[resourceNames.length];<z>
; i++) {<z>
resourceNames[i], relativeClass);<z>
.load(resources);<z>
public ReadableByteChannel readableChannel() throws IOException {<z>
(this.path, StandardOpenOption.READ);<z>
(NoSuchFileException ex) {<z>
;<z>
{<z>
3);<z>
;<z>
{<z>
;<z>
{<z>
.add(TopicConnection.class);<z>
Connection.class.getClassLoader(),<z>
());<z>
locations) {<z>
(locations, "Locations list must not be null");<z>
);<z>
.addAll(locations);<z>
void afterPropertiesSet() {<z>
.targetConnectionFactory == null) {<z>
"Property 'targetConnectionFactory' is required");<z>
, @Nullable Operator operator) {<z>
elements.isEmpty());<z>
elements.size() == 1) {<z>
return elements.get(0);<z>
new Profiles[0]);<z>
);<z>
{<z>
!= null) {<z>
(this.userAttributes == null) {<z>
();<z>
put(key, value);<z>
(this.userAttributes != null) {<z>
);<z>
public boolean isStandalone() {<z>
()) {<z>
();<z>
new IllegalStateException();<z>
writeTagContent(TagWriter tagWriter) throws JspException {<z>
();<z>
();<z>
;<z>
) {<z>
"items", items) : items);<z>
();<z>
selectTagBoundType.isEnum()) {<z>
);<z>
) {<z>
;<z>
getItemValue();<z>
getItemLabel();<z>
valueProperty =<z>
, itemValue)) : null);<z>
labelProperty =<z>
, itemLabel)) : null);<z>
;<z>
writeOptions(tagWriter);<z>
;<z>
length) throws IOException {<z>
.length || length < 0) {<z>
new IndexOutOfBoundsException();<z>
this.closed) {<z>
throw new IOException("Stream closed");<z>
length == this.index) {<z>
(length);<z>
).length) {<z>
= offset;<z>
length) {<z>
(length);<z>
length - this.index;<z>
copyLength) {<z>
;<z>
this.index, copyLength);<z>
pos += copyLength;<z>
.index += copyLength;<z>
copyLength;<z>
(length > 0);<z>
, this.index, length);<z>
;<z>
public Object parseIdRefElement(Element ele) {<z>
;<z>
StringUtils.hasLength(refName)) {<z>
);<z>
return null;<z>
(refName)) {<z>
error("<idref> element contains empty target attribute", ele);<z>
return null;<z>
(refName);<z>
extractSource(ele));<z>
;<z>
Class<?> clazz, boolean checkForXmlRootElement) {<z>
) {<z>
false;<z>
.contextPath)) {<z>
packageName = ClassUtils.getPackageName(clazz);<z>
(this.contextPath, ":");<z>
contextPaths) {<z>
packageName)) {<z>
true;<z>
return false;<z>
isEmpty(this.classesToBeBound)) {<z>
(clazz);<z>
;<z>
ConversionFailedException(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType,<z>
@Nullable Object value, Throwable cause) {<z>
"] to type [" + targetType +<z>
, cause);<z>
.sourceType = sourceType;<z>
targetType;<z>
value;<z>
tagWriter)<z>
{<z>
displayValue = convertToDisplayString(value);<z>
getInputType()));<z>
!= item && isOptionSelected(item))) {<z>
"checked", "checked");<z>
{<z>
this.httpClient = client;<z>
.httpRequest = request;<z>
httpContext = context;<z>
clazz, boolean mustBeStatic) {<z>
);<z>
Field field : fields) {<z>
field.getModifiers()))) {<z>
return field;<z>
clazz.getSuperclass() != null) {<z>
.getSuperclass(), mustBeStatic);<z>
field != null) {<z>
field;<z>
> implementedInterface : clazz.getInterfaces()) {<z>
);<z>
if (field != null) {<z>
;<z>
null;<z>
TypeDescriptor targetType) {<z>
) {<z>
, sourceType, targetType);<z>
(targetType.isAssignableTo(STREAM_TYPE)) {<z>
targetType);<z>
new IllegalStateException("Unexpected source/target types");<z>
(CallableStatement cs, List<SqlParameter> parameters)<z>
throws SQLException {<z>
parameters.size());<z>
= 1;<z>
: parameters) {<z>
SqlOutParameter outParam) {<z>
null, "Anonymous parameters not allowed");<z>
outParam.getSqlReturnType();<z>
) {<z>
.getTypeName());<z>
), out);<z>
cs.getObject(sqlColIndex);<z>
) {<z>
{<z>
, outParam));<z>
String rsName = outParam.getName();<z>
);<z>
((ResultSet) out, rsParam));<z>
) {<z>
);<z>
outParam.getName(), out);<z>
) {<z>
;<z>
results;<z>
throws JmsException {<z>
);<z>
{<z>
;<z>
, postProcessor);<z>
() {<z>
(this.bindingResult == null,<z>
"DataBinder is already initialized - call initBeanPropertyAccess before other configuration methods");<z>
.directFieldAccess = false;<z>
) {<z>
) {<z>
);<z>
{<z>
.get();<z>
.state(ex != null, "No exception in cache");<z>
(), "invoke");<z>
) {<z>
?> requiredTypeToUse = requiredType;<z>
null) {<z>
this.customEditorsForPath != null) {<z>
);<z>
editor == null) {<z>
<>();<z>
(strippedPaths, "", propertyPath);<z>
hasNext() && editor == null;) {<z>
it.next();<z>
strippedPath, requiredType);<z>
null) {<z>
;<z>
(requiredType == null) {<z>
propertyPath);<z>
);<z>
<?> type) {<z>
(clazz, "Class must not be null");<z>
;<z>
Class<?> searchType = clazz;<z>
searchType && searchType != null) {<z>
searchType);<z>
{<z>
())) &&<z>
()))) {<z>
;<z>
);<z>
null;<z>
) {<z>
methods.size() == 1) {<z>
).next());<z>
);<z>
other) {<z>
),<z>
requestConditions) + " and " +<z>
.nullSafeToString(other.requestConditions));<z>
@Nullable TypeDescriptor sourceType, Object value) {<z>
{<z>
value;<z>
if (cs != null) {<z>
;<z>
toString();<z>
remoteAddress) {<z>
, "'remoteAddress' must not be null");<z>
remoteAddress = remoteAddress;<z>
this;<z>
descriptor, final boolean visible) {<z>
mv != null) {<z>
descriptor, visible);<z>
null;<z>
Nullable ModelAndViewContainer mavContainer,<z>
@Nullable WebDataBinderFactory binderFactory) throws Exception {<z>
getParameterType();<z>
;<z>
) {<z>
new IllegalStateException(<z>
) + "] in method " + parameter.getMethod() +<z>
? result.getClass() : null) +<z>
;<z>
result;<z>
parser, DeserializationContext deserializationContext,<z>
boolean tokenizeArrayElements, boolean forceUseOfBigDecimal, int maxInMemorySize) {<z>
.parser = parser;<z>
deserializationContext;<z>
;<z>
forceUseOfBigDecimal;<z>
) this.parser.getNonBlockingInputFeeder();<z>
maxInMemorySize;<z>
();<z>
t, String indent) {<z>
) {<z>
);<z>
);<z>
toStringAST());<z>
));<z>
.println(sb.toString());<z>
(); i++) {<z>
getChild(i), indent + " ");<z>
getObject() {<z>
();<z>
if (response == null) {<z>
new IllegalStateException("Current servlet response not available - " +<z>
;<z>
;<z>
public void setParent(@Nullable ApplicationContext parent) {<z>
= parent;<z>
) {<z>
);<z>
ConfigurableEnvironment) {<z>
ConfigurableEnvironment) parentEnvironment);<z>
String statusText,<z>
body, @Nullable Charset charset) {<z>
;<z>
{<z>
(annotationType)) {<z>
false;<z>
annotationType,<z>
true)));<z>
tokens) {<z>
);<z>
pv);<z>
;<z>
!= null, "Default value must not be null");<z>
;<z>
initApplicationEventMulticaster() {<z>
= getBeanFactory();<z>
(beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {<z>
.applicationEventMulticaster =<z>
.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);<z>
if (logger.isTraceEnabled()) {<z>
+ "]");<z>
applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);<z>
);<z>
{<z>
+ "' bean, using " +<z>
().getSimpleName() + "]");<z>
) {<z>
"@EnableAsync annotation metadata was not injected");<z>
= new AsyncAnnotationBeanPostProcessor();<z>
;<z>
"annotation");<z>
getDefaultValue(EnableAsync.class, "annotation")) {<z>
(customAsyncAnnotation);<z>
("proxyTargetClass"));<z>
"order"));<z>
return bpp;<z>
DataBuffer buf, int idx) {<z>
pos = buf.readPosition();<z>
int len = idx - pos + 1;<z>
retainedSlice(pos, len);<z>
] filters, MockServletConfig servletConfig,<z>
webAppContext, @Nullable RequestBuilder defaultRequestBuilder,<z>
Nullable Charset defaultResponseCharacterEncoding,<z>
<ResultHandler> globalResultHandlers,<z>
> dispatcherServletCustomizers) {<z>
globalResultHandlers, dispatcherServletCustomizers);<z>
setDefaultResponseCharacterEncoding(defaultResponseCharacterEncoding);<z>
mockMvc;<z>
@Nullable Class<? extends Annotation> classAnnotationType,<z>
) {<z>
methodAnnotationType != null),<z>
"Either Class annotation type or Method annotation type needs to be specified (or both)");<z>
classAnnotationType != null) {<z>
AnnotationClassFilter(classAnnotationType, checkInherited);<z>
.classFilter = new AnnotationCandidateClassFilter(methodAnnotationType);<z>
null) {<z>
new AnnotationMethodMatcher(methodAnnotationType, checkInherited);<z>
.TRUE;<z>
) {<z>
;<z>
)) {<z>
);<z>
{<z>
add(childElement.getAttribute("location"));<z>
toStringArray(locations));<z>
.getAttribute("engine-name"));<z>
hasAttribute("render-object")) {<z>
, element.getAttribute("render-object"));<z>
{<z>
);<z>
)) {<z>
);<z>
(element.hasAttribute("charset")) {<z>
)));<z>
("resource-loader-path")) {<z>
;<z>
hasAttribute("shared-engine")) {<z>
, element.getAttribute("shared-engine"));<z>
autoStartupOnly) {<z>
= getLifecycleBeans();<z>
= new TreeMap<>();<z>
, bean) -> {<z>
) {<z>
phase = getPhase(bean);<z>
.computeIfAbsent(<z>
lifecycleBeans, autoStartupOnly)<z>
(beanName, bean);<z>
);<z>
.isEmpty()) {<z>
);<z>
final int access) {<z>
parameters == null) {<z>
new ByteVector();<z>
++parametersCount;<z>
);<z>
o2) {<z>
) {<z>
0;<z>
o1 == null) {<z>
-1 : 1);<z>
if (o2 == null) {<z>
.nullsLow ? 1 : -1);<z>
(o1, o2);<z>
isMethodProxyCompatible(Method method) {<z>
) &&<z>
.isEqualsMethod(method) &&<z>
method));<z>
{<z>
.getTransactionStatus() != null) {<z>
if (logger.isTraceEnabled()) {<z>
trace("Completing transaction for [" + txInfo.getJoinpointIdentification() +<z>
"] after exception: " + ex);<z>
(ex)) {<z>
.rollback(txInfo.getTransactionStatus());<z>
catch (TransactionSystemException ex2) {<z>
.error("Application exception overridden by rollback exception", ex);<z>
(ex);<z>
throw ex2;<z>
| Error ex2) {<z>
ex);<z>
throw ex2;<z>
.commit(txInfo.getTransactionStatus());<z>
) {<z>
"Application exception overridden by commit exception", ex);<z>
(ex);<z>
ex2;<z>
Error ex2) {<z>
);<z>
throw ex2;<z>
void init() {<z>
AnnotationDrivenBeanDefinitionParser());<z>
DefaultServletHandlerBeanDefinitionParser());<z>
new InterceptorsBeanDefinitionParser());<z>
ResourcesBeanDefinitionParser());<z>
new ViewControllerBeanDefinitionParser());<z>
("redirect-view-controller", new ViewControllerBeanDefinitionParser());<z>
));<z>
;<z>
registerBeanDefinitionParser("freemarker-configurer", new FreeMarkerConfigurerBeanDefinitionParser());<z>
new GroovyMarkupConfigurerBeanDefinitionParser());<z>
ScriptTemplateConfigurerBeanDefinitionParser());<z>
;<z>
T o1, T o2) {<z>
;<z>
o2);<z>
));<z>
@Nullable ClassLoader classLoader, String... packagesToScan) {<z>
;<z>
;<z>
packagesToScan = packagesToScan;<z>
DefaultTransactionStatus status) {<z>
status.getTransaction();<z>
).getConnection();<z>
if (status.isDebug()) {<z>
"]");<z>
();<z>
{<z>
);<z>
AnnotationVisitor visitParameterAnnotation(<z>
) {<z>
if (mv != null) {<z>
, descriptor, visible);<z>
return null;<z>
name) {<z>
getParameter(name);<z>
= this.formParams.getFirst(name);<z>
);<z>
MultipartCodecs multipartCodecs() {<z>
multipartCodecs == null) {<z>
= new DefaultMultipartCodecs();<z>
;<z>
void addMatchedSubscriptionId(<z>
<String, String> sessionIdToSubscriptionIds,<z>
{<z>
sessionId, (_sessionId, subscriptionIds) -> {<z>
subscriptionIds == null) {<z>
;<z>
+ 1);<z>
);<z>
.add(subscriptionId);<z>
result;<z>
;<z>
public AbstractListenerWebSocketSession(<z>
{<z>
Sinks.Empty<Void>) null);<z>
() {<z>
new CustomScopeConfigurer();<z>
());<z>
;<z>
Nullable Class<?> targetType) {<z>
.getAnnotation(CacheDefaults.class);<z>
(annotation != null) {<z>
annotation;<z>
getAnnotation(CacheDefaults.class) : null);<z>
getMultipartHeaders(String paramOrFileName) {<z>
String contentType = getMultipartContentType(paramOrFileName);<z>
null) {<z>
= new HttpHeaders();<z>
(CONTENT_TYPE, contentType);<z>
headers;<z>
null;<z>
) {<z>
CGLIB_CLASS_SEPARATOR)) {<z>
();<z>
{<z>
superclass;<z>
;<z>
SpelNodeImpl eatRelationalExpression() {<z>
SpelNodeImpl expr = eatSumExpression();<z>
;<z>
{<z>
);<z>
SpelNodeImpl rhExpr = eatSumExpression();<z>
checkOperands(t, expr, rhExpr);<z>
relationalOperatorToken.kind;<z>
()) {<z>
== TokenKind.GT) {<z>
expr, rhExpr);<z>
{<z>
, rhExpr);<z>
{<z>
rhExpr);<z>
TokenKind.GE) {<z>
t.endPos, expr, rhExpr);<z>
(tk == TokenKind.EQ) {<z>
expr, rhExpr);<z>
TokenKind.NE, "Not-equals token expected");<z>
rhExpr);<z>
if (tk == TokenKind.INSTANCEOF) {<z>
;<z>
{<z>
.endPos, expr, rhExpr);<z>
tk == TokenKind.BETWEEN, "Between token expected");<z>
);<z>
return expr;<z>
classFilter, MethodMatcher methodMatcher) {<z>
(classFilter, "ClassFilter must not be null");<z>
, "MethodMatcher must not be null");<z>
classFilter;<z>
.methodMatcher = methodMatcher;<z>
Set<String> keySet() {<z>
new LinkedHashSet<>(size());<z>
this.response.getHeaders()) {<z>
));<z>
return keys;<z>
Attributes attributes,<z>
String, String> namespaceMapping) throws XMLStreamException {<z>
name.getNamespaceURI());<z>
entrySet()) {<z>
getKey();<z>
.getValue();<z>
namespaceUri);<z>
)) {<z>
(namespaceUri);<z>
streamWriter.setPrefix(prefix, namespaceUri);<z>
(); i++) {<z>
);<z>
{<z>
(),<z>
.getValue(i));<z>
ConfigurationClass> configurationModel) {<z>
TrackedConditionEvaluator();<z>
configurationModel) {<z>
configClass, trackedConditionEvaluator);<z>
supportsParameter(MethodParameter parameter) {<z>
;<z>
)) ||<z>
.class.isAssignableFrom(paramType));<z>
length) {<z>
!= null) {<z>
;<z>
.BINARY, buffer);<z>
.getType(), webSocketMessage);<z>
session, ObjectWriter objectWriter)<z>
IOException {<z>
;<z>
object);<z>
.toString());<z>
> body) {<z>
getRawStatusCode();<z>
200);<z>
.putAll(response.getHeaders());<z>
);<z>
clientResponse.setBody(body);<z>
return clientResponse;<z>
T> type) {<z>
);<z>
)) {<z>
new IllegalStateException(<z>
) + "]: " + value);<z>
) value;<z>
> locations) {<z>
.fromIterable(locations)<z>
location))<z>
next();<z>
retrieveServletPart() {<z>
multipartRequest.getPart(this.requestPartName);<z>
{<z>
this.requestPartName + "'", ex);<z>
) {<z>
HibernateException) {<z>
(HibernateException) ex);<z>
{<z>
ex.getCause());<z>
.convertJpaAccessExceptionIfPossible(ex);<z>
AnnotationAttributes> attributesForRepeatable(<z>
{<z>
= new LinkedHashSet<>();<z>
getAnnotationAttributes(annotationClassName));<z>
;<z>
) {<z>
]) container.get("value")) {<z>
, containedAttributes);<z>
.unmodifiableSet(result);<z>
parentId) {<z>
;<z>
eventId = eventId;<z>
parentId;<z>
Subscriber<? super T> writeSubscriber) {<z>
synchronized (this) {<z>
null, "Only one write subscriber supported");<z>
writeSubscriber;<z>
!= null || this.completed) {<z>
));<z>
emitCachedSignals();<z>
(this);<z>
Exception {<z>
!= null) {<z>
= transactionFactory.createTransaction(transactionName, transactionTimeout);<z>
);<z>
getValue() throws EvaluationException {<z>
);<z>
for (Expression expression : this.expressions) {<z>
.class);<z>
value != null) {<z>
value);<z>
.toString();<z>
void onWritePossible() {<z>
bodyProcessor;<z>
if (processor != null) {<z>
.onWritePossible();<z>
ResponseBodyFlushProcessor flushProcessor = bodyFlushProcessor;<z>
flushProcessor != null) {<z>
);<z>
() {<z>
);<z>
(InvocationTargetException ex) {<z>
;<z>
) {<z>
(getInvocationFailureMessage(), ex);<z>
) {<z>
= cf.lastDescriptor();<z>
) {<z>
) {<z>
;<z>
insertCheckCast(mv, "Ljava/util/Map");<z>
.visitLdcInsn(propertyName);<z>
);<z>
, String name, long parentId,<z>
<FlightRecorderStartupStep> recordingCallback) {<z>
new FlightRecorderStartupEvent(id, name, parentId);<z>
begin();<z>
= recordingCallback;<z>
CorsProcessor processor) {<z>
configSource, "CorsConfigurationSource must not be null");<z>
;<z>
.configSource = configSource;<z>
.processor = processor;<z>
) {<z>
new CommandLineArgs();<z>
: args) {<z>
)) {<z>
substring(2);<z>
optionName;<z>
null;<z>
= optionText.indexOf('=');<z>
indexOfEqualsSign > -1) {<z>
optionText.substring(0, indexOfEqualsSign);<z>
= optionText.substring(indexOfEqualsSign + 1);<z>
optionText;<z>
optionName.isEmpty()) {<z>
;<z>
, optionValue);<z>
.addNonOptionArg(arg);<z>
commandLineArgs;<z>
public void afterPropertiesSet() throws Exception {<z>
Integer.toHexString(hashCode());<z>
{<z>
new QueuedThreadPool();<z>
(name);<z>
;<z>
if (this.byteBufferPool == null) {<z>
,<z>
ThreadPool.SizedThreadPool<z>
.getMaxThreads() / 2<z>
: ProcessorUtils.availableProcessors() * 2);<z>
) {<z>
);<z>
.executor instanceof LifeCycle) {<z>
executor).start();<z>
.start();<z>
) {<z>
{<z>
getSession();<z>
, "No HttpSession");<z>
String name : names) {<z>
.getAttribute(name));<z>
XhrClientSockJsSession sockJsSession,<z>
connectFuture) {<z>
url;<z>
this.receiveHeaders = headers;<z>
;<z>
;<z>
{<z>
(this == o) return true;<z>
)) return false;<z>
that = (IdentifiableApplicationEvent) o;<z>
equals(that.id);<z>
List<HttpMethod> getAccessControlAllowMethods() {<z>
;<z>
if (value != null) {<z>
);<z>
);<z>
) {<z>
;<z>
.add(method);<z>
;<z>
.emptyList();<z>
String cookieValue) {<z>
new Cookie(getCookieName(), cookieValue);<z>
{<z>
;<z>
setPath(getCookiePath());<z>
cookie;<z>
, Predicate<String> filter) throws IOException {<z>
getMetadata();<z>
StandardAnnotationMetadata) {<z>
), filter);<z>
), filter);<z>
throws Exception {<z>
.class : superclass;<z>
.isFinal(sc.getModifiers()))<z>
.getName());<z>
;<z>
);<z>
= new ArrayList();<z>
();<z>
();<z>
, actualMethods, interfaceMethods, forcePublic);<z>
) {<z>
(Object value) {<z>
Method method = (Method) value;<z>
.ACC_FINAL<z>
)<z>
& ~Constants.ACC_ABSTRACT<z>
ACC_NATIVE<z>
.ACC_SYNCHRONIZED);<z>
(method))) {<z>
;<z>
.getMethodInfo(method, modifiers);<z>
;<z>
e = new ClassEmitter(v);<z>
if (currentData == null) {<z>
.V1_8,<z>
Constants.ACC_PUBLIC,<z>
getClassName(),<z>
),<z>
(useFactory ?<z>
) :<z>
getTypes(interfaces)),<z>
;<z>
Constants.V1_8,<z>
ACC_PUBLIC,<z>
,<z>
new Type[]{FACTORY},<z>
.SOURCE_FILE);<z>
));<z>
, null);<z>
OBJECT_TYPE, null);<z>
!interceptDuringConstruction) {<z>
BOOLEAN_TYPE, null);<z>
.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null);<z>
.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, null);<z>
{<z>
);<z>
{<z>
);<z>
, null);<z>
{<z>
, methods, actualMethods);<z>
emitConstructors(e, constructorInfo);<z>
(e);<z>
emitSetThreadCallbacks(e);<z>
);<z>
(e);<z>
!= null) {<z>
();<z>
);<z>
e);<z>
emitNewInstanceMultiarg(e, constructorInfo);<z>
);<z>
);<z>
(e);<z>
e);<z>
);<z>
> getDefaultReturnValueHandlers() {<z>
(20);<z>
(new ModelAndViewMethodReturnValueHandler());<z>
;<z>
add(new ViewMethodReturnValueHandler());<z>
(getMessageConverters(),<z>
taskExecutor, this.contentNegotiationManager));<z>
());<z>
.add(new HttpEntityMethodProcessor(getMessageConverters(),<z>
this.contentNegotiationManager, this.requestResponseBodyAdvice));<z>
(new HttpHeadersReturnValueHandler());<z>
CallableMethodReturnValueHandler());<z>
.add(new DeferredResultMethodReturnValueHandler());<z>
this.beanFactory));<z>
ServletModelAttributeMethodProcessor(false));<z>
(getMessageConverters(),<z>
contentNegotiationManager, this.requestResponseBodyAdvice));<z>
);<z>
new MapMethodProcessor());<z>
) != null) {<z>
(getCustomReturnValueHandlers());<z>
{<z>
()));<z>
(true));<z>
handlers;<z>
simpleBrokerMessageHandler(<z>
AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,<z>
brokerChannel, UserDestinationResolver userDestinationResolver) {<z>
registry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);<z>
getSimpleBroker(brokerChannel);<z>
if (handler == null) {<z>
return null;<z>
userDestinationResolver, registry.getUserDestinationPrefix());<z>
;<z>
(String beanName) {<z>
.get(beanName);<z>
) {<z>
true;<z>
{<z>
bd = new GenericBeanDefinition();<z>
clazz);<z>
);<z>
EncodingHint hint) {<z>
result;<z>
) {<z>
this.ssp, this.fragment);<z>
;<z>
this.fragment,<z>
.pathBuilder.build(), queryParams,<z>
);<z>
;<z>
.isEmpty()) {<z>
UriTemplateVariables.SKIP_VALUE));<z>
return result;<z>
) {<z>
));<z>
instanceof Closeable) {<z>
) this.httpResponse).close();<z>
) {<z>
) {<z>
)) {<z>
()) {<z>
+ this.phase);<z>
.reverseOrder());<z>
.smartMemberCount);<z>
synchronizedSet(new LinkedHashSet<>());<z>
());<z>
member : this.members) {<z>
{<z>
member.name, latch, countDownBeanNames);<z>
bean instanceof SmartLifecycle) {<z>
();<z>
.MILLISECONDS);<z>
) {<z>
() + " bean" +<z>
+ " with phase value " +<z>
;<z>
ex) {<z>
();<z>
, boolean eager) {<z>
field);<z>
declaringClass = field.getDeclaringClass();<z>
;<z>
= required;<z>
;<z>
reason) {<z>
!= null) {<z>
, reason));<z>
(@Nullable ConnectionFactory cf) {<z>
cf instanceof TransactionAwareConnectionFactoryProxy) {<z>
(TransactionAwareConnectionFactoryProxy) cf).getTargetConnectionFactory();<z>
.connectionFactory = cf;<z>
{<z>
(message, cause);<z>
;<z>
= position;<z>
addAttribute(Object attributeValue) {<z>
;<z>
()) {<z>
return this;<z>
getVariableName(attributeValue), attributeValue);<z>
) {<z>
(av != null) {<z>
return av.visitArray(name);<z>
return null;<z>
)<z>
{<z>
.notNull(criteria, "DetachedCriteria must not be null");<z>
{<z>
.getExecutableCriteria(session);<z>
);<z>
{<z>
firstResult);<z>
> 0) {<z>
;<z>
();<z>
;<z>
payload, @Nullable MessagePostProcessor postProcessor) throws MessagingException {<z>
getDefaultDestination();<z>
{<z>
);<z>
), payload, postProcessor);<z>
) {<z>
);<z>
);<z>
) != 0) {<z>
= charset.newEncoder()<z>
.REPLACE)<z>
.onUnmappableCharacter(CodingErrorAction.REPLACE);<z>
;<z>
));<z>
estimatedSize)<z>
;<z>
) {<z>
CoderResult cr = (inBuffer.hasRemaining() ?<z>
);<z>
)) {<z>
);<z>
isUnderflow()) {<z>
if (cr.isOverflow()) {<z>
());<z>
());<z>
(maximumSize);<z>
(), writableByteCount());<z>
());<z>
;<z>
@Nullable String targetBeanName) {<z>
-> "bean name '" +<z>
"' does not refer to the target of a scoped proxy");<z>
return targetBeanName.substring(TARGET_NAME_PREFIX_LENGTH);<z>
(String baseLineVersion, Project project) {<z>
,<z>
"reports", "api-diff",<z>
);<z>
toString());<z>
() {<z>
this.registrations.size());<z>
registration : this.registrations) {<z>
getCorsConfiguration());<z>
return configs;<z>
() {<z>
this.argumentResolvers == null) {<z>
>();<z>
.argumentResolvers);<z>
return this.argumentResolvers;<z>
) throws EvaluationException {<z>
1];<z>
- 1);<z>
i++) {<z>
getValueInternal(state);<z>
Object value = childValue.getValue();<z>
[i] = value;<z>
forObject(value));<z>
this.cachedExecutor;<z>
) {<z>
.getEvaluationContext(), arguments);<z>
catch (AccessException ex) {<z>
(ex.getCause() instanceof InvocationTargetException) {<z>
getCause().getCause();<z>
if (rootCause instanceof RuntimeException runtimeException) {<z>
runtimeException;<z>
(state).getValue();<z>
rootCause,<z>
CONSTRUCTOR_INVOCATION_PROBLEM, typeName,<z>
("", argumentTypes));<z>
null;<z>
);<z>
!= null, "No type name");<z>
typeName, argumentTypes, state);<z>
.cachedExecutor = executorToUse;<z>
) {<z>
exitTypeDescriptor = CodeFlow.toDescriptor(<z>
getDeclaringClass());<z>
.getEvaluationContext(), arguments);<z>
catch (AccessException ex) {<z>
ex,<z>
, typeName,<z>
"", argumentTypes));<z>
(String name, @Nullable String filename) {<z>
notNull(name, "Name must not be null");<z>
formData().name(name);<z>
{<z>
.filename(filename);<z>
);<z>
targetType,<z>
accumulator) {<z>
decoder;<z>
this.mimeType = mimeType;<z>
.targetType = targetType;<z>
= accumulator;<z>
MergedContextConfiguration mergedConfig) throws Exception {<z>
) {<z>
String.format("Loading ApplicationContext for merged context configuration [%s].",<z>
);<z>
);<z>
= createContext();<z>
.getParentApplicationContext();<z>
) {<z>
context.setParent(parent);<z>
prepareContext(context);<z>
(context, mergedConfig);<z>
context.getDefaultListableBeanFactory());<z>
;<z>
;<z>
(context);<z>
(context, mergedConfig);<z>
refresh();<z>
.registerShutdownHook();<z>
;<z>
resourceUrl, String description) throws FileNotFoundException {<z>
;<z>
) {<z>
FileNotFoundException(<z>
" cannot be resolved to absolute file path " +<z>
);<z>
resourceUrl).getSchemeSpecificPart());<z>
) {<z>
());<z>
> remove(Object key) {<z>
String headerName) {<z>
oldValues = get(key);<z>
.response.removeHeaders(headerName);<z>
return oldValues;<z>
;<z>
parserContext) {<z>
getLocalName(adviceElement);<z>
if (BEFORE.equals(elementName)) {<z>
AspectJMethodBeforeAdvice.class;<z>
)) {<z>
return AspectJAfterAdvice.class;<z>
(AFTER_RETURNING_ELEMENT.equals(elementName)) {<z>
AspectJAfterReturningAdvice.class;<z>
AFTER_THROWING_ELEMENT.equals(elementName)) {<z>
return AspectJAfterThrowingAdvice.class;<z>
(AROUND.equals(elementName)) {<z>
.class;<z>
+ elementName + "].");<z>
CodedOutputStream output)<z>
io.IOException {<z>
getSerializedSize();<z>
)) {<z>
(1, getFooBytes());<z>
(bitField0_ & 0x00000002) == 0x00000002)) {<z>
2, blah_);<z>
.writeTo(output);<z>
MediaType> producibleMediaTypes(<z>
List<HttpMessageConverter<?>> messageConverters,<z>
> entityClass) {<z>
stream()<z>
entityClass, null))<z>
(entityClass).stream())<z>
));<z>
Throwable cause) {<z>
;<z>
beanName = null;<z>
= null;<z>
Object message) {<z>
()) {<z>
);<z>
private TransportHandlingSockJsService createSockJsService() {<z>
scheduler != null, "No TaskScheduler available");<z>
transportHandlerOverrides.isEmpty(),<z>
"Specify either TransportHandlers or TransportHandler overrides, not both");<z>
?<z>
:<z>
, this.transportHandlerOverrides));<z>
(HttpRequest request) {<z>
notNull(request, "Request must not be null");<z>
request = request;<z>
this;<z>
{<z>
) {<z>
.sockJsSession.isDisconnected()) {<z>
;<z>
handleTransportError(failure);<z>
);<z>
] classes,<z>
? extends ApplicationContextInitializer<?>>> contextInitializerClasses,<z>
, @Nullable String[] propertySourceLocations,<z>
> contextCustomizers,<z>
ContextLoader contextLoader, @Nullable CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,<z>
) {<z>
= testClass;<z>
= processStrings(locations);<z>
this.classes = processClasses(classes);<z>
.contextInitializerClasses = processContextInitializerClasses(contextInitializerClasses);<z>
.activeProfiles = processActiveProfiles(activeProfiles);<z>
propertySourceLocations);<z>
(propertySourceProperties);<z>
= processContextCustomizers(contextCustomizers);<z>
;<z>
;<z>
parent;<z>
{<z>
StringBuilder("ExponentialBackOff{");<z>
"n/a" : this.currentInterval + "ms");<z>
getMultiplier());<z>
append('}');<z>
);<z>
(ClassLoader classLoader) {<z>
if (classLoader == null) {<z>
"classLoader == null is not yet supported");<z>
= new WeakReference<ClassLoader>(classLoader);<z>
Object> load =<z>
new Function<AbstractClassGenerator, Object>() {<z>
apply(AbstractClassGenerator gen) {<z>
this);<z>
wrapCachedClass(klass);<z>
, load);<z>
afterPropertiesSet() {<z>
null) {<z>
systemTreePath);<z>
!= null) {<z>
.userTreePath);<z>
argumentResolvers) {<z>
delegate : this.delegates) {<z>
);<z>
doWithMatchingMapping(<z>
request, boolean ignoreException,<z>
) throws Exception {<z>
handlerMappings, "Handler mappings not initialized");<z>
isEmpty();<z>
= null;<z>
(parseRequestPath) {<z>
;<z>
);<z>
handlerMapping : this.handlerMappings) {<z>
= null;<z>
chain = handlerMapping.getHandler(request);<z>
catch (Exception ex) {<z>
(!ignoreException) {<z>
throw ex;<z>
{<z>
.apply(handlerMapping, chain);<z>
{<z>
previousPath, request);<z>
return null;<z>
> task) {<z>
>(task);<z>
TIMEOUT_INDEFINITE);<z>
future;<z>
>> route(ServerRequest request) {<z>
)) {<z>
()) {<z>
;<z>
);<z>
Mono.just(this.handlerFunction);<z>
;<z>
basename) {<z>
);<z>
);<z>
(this.defaultEncoding != null) {<z>
);<z>
.fallbackToSystemLocale != null) {<z>
fallbackToSystemLocale);<z>
beanClassLoader != null) {<z>
messageSource.setBeanClassLoader(this.beanClassLoader);<z>
;<z>
void protectPasscode() {<z>
= getFirstNativeHeader(STOMP_PASSCODE_HEADER);<z>
(value)) {<z>
;<z>
;<z>
) {<z>
null) {<z>
this.reference.getNext();<z>
references != null) {<z>
references.length) {<z>
;<z>
.referenceIndex = 0;<z>
.references[this.referenceIndex];<z>
.referenceIndex++;<z>
Msg parseDelimitedFrom(<z>
.InputStream input,<z>
.ExtensionRegistryLite extensionRegistry)<z>
java.io.IOException {<z>
, extensionRegistry);<z>
checkAllowedFields(MutablePropertyValues mpvs) {<z>
] pvs = mpvs.getPropertyValues();<z>
pv : pvs) {<z>
());<z>
(field)) {<z>
removePropertyValue(pv);<z>
getBindingResult().recordSuppressedField(field);<z>
) {<z>
"Field [" + field + "] has been removed from PropertyValues " +<z>
;<z>
{<z>
.resourceResolvers.clear();<z>
) {<z>
resourceResolvers.addAll(resourceResolvers);<z>
{<z>
();<z>
Exception ex) {<z>
logger.debug("Connection stop failed - relying on listeners to perform recovery after restart", ex);<z>
int columnIndex) throws SQLException {<z>
"Returning CLOB as ASCII stream");<z>
if (this.wrapAsLob) {<z>
rs.getClob(columnIndex);<z>
);<z>
.getAsciiStream(columnIndex);<z>
) {<z>
if (isRunning()) {<z>
false;<z>
getWebSocketClient() instanceof Lifecycle) {<z>
getWebSocketClient()).stop();<z>
cacheNames) {<z>
new LinkedHashSet<>(cacheNames.length);<z>
{<z>
;<z>
this.cacheNames.add(cacheName);<z>
int columnIndex) throws InvalidResultSetAccessException {<z>
.resultSet.getTime(columnIndex);<z>
(SQLException se) {<z>
(se);<z>
private static CompositeUriComponentsContributor getUriComponentsContributor() {<z>
;<z>
null) {<z>
);<z>
) {<z>
defaultUriComponentsContributor;<z>
) {<z>
{<z>
true;<z>
(now)) {<z>
(State.EXPIRED);<z>
true;<z>
return false;<z>
(String attributeName, MethodParameter parameter,<z>
NativeWebRequest request) throws Exception {<z>
request);<z>
null) {<z>
Object attribute = createAttributeFromRequestValue(<z>
, request);<z>
if (attribute != null) {<z>
;<z>
, binderFactory, request);<z>
parseDelimitedFrom(<z>
input,<z>
)<z>
.io.IOException {<z>
parseDelimitedFrom(input, extensionRegistry);<z>
{<z>
instanceof GString) {<z>
value.toString();<z>
{<z>
else if (value instanceof Closure) {<z>
currentBeanDefinition;<z>
Closure<?>) value;<z>
)[0];<z>
if (Object.class == parameterType) {<z>
"");<z>
(this.currentBeanDefinition);<z>
(null, parameterType);<z>
((Object) null);<z>
.currentBeanDefinition.getBeanDefinition();<z>
;<z>
;<z>
(ContextConfigurationAttributes configAttributes) {<z>
] processedLocations =<z>
getLocations());<z>
);<z>
protected void startSharedConnection() {<z>
startSharedConnection();<z>
{<z>
("Connection start failed - relying on listeners to perform recovery", ex);<z>
() {<z>
0] = 42;<z>
0] = 42L;<z>
= 42.0d;<z>
0] = 42;<z>
42;<z>
;<z>
= true;<z>
] = 42.0f;<z>
void remove() {<z>
);<z>
) {<z>
());<z>
last = null;<z>
?> type, boolean asArray,<z>
visited) {<z>
type.getInterfaces()) {<z>
hierarchy, visited);<z>
, T data) {<z>
(processor.isDataEmpty(data)) {<z>
.subscription != null, "No subscription");<z>
(1);<z>
.dataReceived(data);<z>
(this);<z>
{<z>
+ "]" +<z>
() + "]" +<z>
+ getStompBrokerRelayStatsInfo() + "]" +<z>
getClientInboundExecutorStatsInfo() + "]" +<z>
getClientOutboundExecutorStatsInfo() + "]" +<z>
;<z>
throws MessagingException {<z>
?> messageToUse = message;<z>
(this.broadcastHandler != null) {<z>
this.broadcastHandler.preHandle(message);<z>
if (messageToUse == null) {<z>
);<z>
) {<z>
.getTargetDestinations().isEmpty()) {<z>
) {<z>
"No active sessions for user destination: " + result.getSourceDestination());<z>
(this.broadcastHandler != null) {<z>
);<z>
);<z>
(accessor);<z>
getSubscribeDestination());<z>
;<z>
accessor.getMessageHeaders());<z>
()) {<z>
getTargetDestinations());<z>
)) {<z>
(target, messageToUse);<z>
(DateFormat dateFormat, boolean allowEmpty) {<z>
;<z>
allowEmpty;<z>
-1;<z>
void prepare() {<z>
server == null) {<z>
, this.environment, this.agentId);<z>
();<z>
this.actualObjectNames != null) {<z>
isDebugEnabled()) {<z>
));<z>
) {<z>
.server.addNotificationListener(<z>
);<z>
{<z>
MBeanServerNotFoundException(<z>
.serviceUrl + "]", ex);<z>
Exception ex) {<z>
new JmxException("Unable to register NotificationListener", ex);<z>
, @Nullable MessageHeaders headers,<z>
) {<z>
this.marshaller, "Property 'marshaller' is required");<z>
()) {<z>
new ByteArrayOutputStream(1024);<z>
);<z>
.marshal(payload, result);<z>
;<z>
);<z>
);<z>
marshaller.marshal(payload, result);<z>
toString();<z>
{<z>
, ex);<z>
payload;<z>
get(RepeatableContainers repeatableContainers,<z>
annotationFilter, boolean directOnly) {<z>
(annotationFilter == AnnotationFilter.PLAIN) {<z>
)) {<z>
];<z>
)) {<z>
];<z>
repeatableContainers, annotationFilter, directOnly);<z>
(InternetAddress to) throws MessagingException {<z>
Assert.notNull(to, "To address must not be null");<z>
);<z>
(Message.RecipientType.TO, to);<z>
) {<z>
(event.isBrokerAvailable()) {<z>
delay = getRegistryExpirationPeriod() / 2;<z>
.scheduleWithFixedDelay(this.schedulerTask, delay);<z>
<?> future = this.scheduledFuture;<z>
null ){<z>
true);<z>
scheduledFuture = null;<z>
(<z>
{<z>
("", missingAfterConversion);<z>
;<z>
= parameter;<z>
{<z>
"MetadataReader must not be null");<z>
.getAnnotationMetadata();<z>
);<z>
getResource());<z>
statusCodePredicate,<z>
> exceptionFunction) {<z>
statusCodePredicate, "IntPredicate must not be null");<z>
, "Function must not be null");<z>
- 1;<z>
new StatusHandler(statusCodePredicate, exceptionFunction));<z>
this;<z>
Nullable LockMode lockMode)<z>
DataAccessException {<z>
executeWithNativeSession(session -> {<z>
(lockMode != null) {<z>
LockOptions(lockMode));<z>
.load(entityClass, id);<z>
);<z>
) {<z>
== null) {<z>
"] ";<z>
return this.logPrefix;<z>
countNonNull(Object... instances) {<z>
int result = 0;<z>
: instances) {<z>
) {<z>
1;<z>
result;<z>
) {<z>
{<z>
Object candidate : collection) {<z>
(candidate == element) {<z>
true;<z>
return false;<z>
> doConnect(<z>
) {<z>
Sinks.unsafe().empty();<z>
.empty();<z>
[] savedResponse = new ClientHttpResponse[1];<z>
new MockClientHttpRequest(httpMethod, uri);<z>
MockServerHttpResponse mockServerResponse = new MockServerHttpResponse();<z>
{<z>
log("Invoking HttpHandler for ", httpMethod, uri);<z>
;<z>
= prepareResponse(mockServerResponse, mockServerRequest);<z>
subscribe(<z>
,<z>
tryEmitError,<z>
tryEmitEmpty);<z>
();<z>
;<z>
-><z>
-> {<z>
"Creating client response for ", httpMethod, uri);<z>
(mockServerResponse, responseBody);<z>
);<z>
("Writing client request for ", httpMethod, uri);<z>
.apply(mockClientRequest).subscribe(<z>
-> {},<z>
tryEmitError,<z>
;<z>
.asMono())<z>
-> {<z>
;<z>
(response, ex) : ex;<z>
null ?<z>
empty())));<z>
beanName, Object singletonObject) {<z>
.singletonObjects) {<z>
);<z>
.remove(beanName);<z>
this.earlySingletonObjects.remove(beanName);<z>
;<z>
> iterator() {<z>
();<z>
<>() {<z>
) {<z>
;<z>
<V>> next() {<z>
(iterator.next());<z>
{<z>
CompositePathComponentBuilder compositeBuilder = new CompositePathComponentBuilder();<z>
(PathComponentBuilder builder : this.builders) {<z>
(builder.cloneBuilder());<z>
return compositeBuilder;<z>
invoke(<z>
) {<z>
();<z>
operation.isEarlyRemove();<z>
{<z>
removeValue(context);<z>
invoker.invoke();<z>
if (!earlyRemove) {<z>
;<z>
return result;<z>
ThrowableWrapper wrapperException) {<z>
wrapperException.getOriginal();<z>
ex.getClass())) {<z>
);<z>
;<z>
public void setCc(String cc) throws MailParseException {<z>
.helper.setCc(cc);<z>
catch (MessagingException ex) {<z>
;<z>
{<z>
.internal_static_SecondMsg_fieldAccessorTable<z>
(<z>
protobuf.SecondMsg.Builder.class);<z>
() {<z>
if (this.scheduledExecutor == null) {<z>
this.removeOnCancelPolicy;<z>
;<z>
BeanPostProcessor element) {<z>
(index, element);<z>
beanPostProcessorCache = null;<z>
return result;<z>
String pathPattern) {<z>
);<z>
(registration);<z>
;<z>
DisposableBean bean) {<z>
;<z>
.dependentBeanMap) {<z>
(beanName);<z>
) {<z>
isTraceEnabled()) {<z>
+ "': " + dependencies);<z>
dependentBeanName : dependencies) {<z>
);<z>
{<z>
bean.destroy();<z>
ex) {<z>
)) {<z>
+ "' threw an exception", ex);<z>
> containedBeans;<z>
{<z>
beanName);<z>
{<z>
: containedBeans) {<z>
(containedBeanName);<z>
dependentBeanMap) {<z>
;) {<z>
> entry = it.next();<z>
> dependenciesToClean = entry.getValue();<z>
(beanName);<z>
()) {<z>
remove();<z>
(beanName);<z>
<?>> converters) {<z>
WebMvcConfigurer delegate : this.delegates) {<z>
.extendMessageConverters(converters);<z>
password) throws JMSException {<z>
;<z>
instanceof TopicConnectionFactory) {<z>
target).createTopicConnection(username, password);<z>
);<z>
) {<z>
jakarta.jms.IllegalStateException("'targetConnectionFactory' is not a TopicConnectionFactory");<z>
return (TopicConnection) con;<z>
) {<z>
)) {<z>
().matches(path)) {<z>
);<z>
null;<z>
void writeMetadata(CandidateComponentsMetadata metadata) throws IOException {<z>
.isEmpty()) {<z>
) {<z>
metadata, outputStream);<z>
{<z>
.value = value;<z>
this.valueToMatch = valueToMatch;<z>
= params;<z>
<?> requiredType) {<z>
= null;<z>
)) {<z>
entry.getKey();<z>
beanInstance = entry.getValue();<z>
(isPrimary(candidateBeanName, beanInstance)) {<z>
{<z>
);<z>
= containsBeanDefinition(primaryBeanName);<z>
{<z>
.size(),<z>
"more than one 'primary' bean found among candidates: " + candidates.keySet());<z>
) {<z>
;<z>
= candidateBeanName;<z>
return primaryBeanName;<z>
T dataBuffer, Object hint) {<z>
{<z>
;<z>
;<z>
> after) {<z>
, "HandlerFilterFunction must not be null");<z>
request, next) -> {<z>
;<z>
request, nextHandler);<z>
boolean checkQualifier(<z>
BeanDefinitionHolder bdHolder, Annotation annotation, TypeConverter typeConverter) {<z>
annotationType();<z>
) bdHolder.getBeanDefinition();<z>
;<z>
== null) {<z>
));<z>
null) {<z>
= getQualifiedElementAnnotation(bd, type);<z>
) {<z>
targetAnnotation = getFactoryMethodAnnotation(bd, type);<z>
{<z>
getResolvedDecoratedDefinition(bd);<z>
) {<z>
;<z>
if (targetAnnotation == null) {<z>
{<z>
getBeanName());<z>
{<z>
getUserClass(beanType), type);<z>
{<z>
== null && bd.hasBeanClass()) {<z>
bd.getBeanClass()), type);<z>
&& targetAnnotation.equals(annotation)) {<z>
true;<z>
);<z>
) && qualifier == null) {<z>
false;<z>
) {<z>
();<z>
;<z>
Object actualValue = null;<z>
null) {<z>
.getAttribute(attributeName);<z>
(actualValue == null) {<z>
(attributeName);<z>
AutowireCandidateQualifier.VALUE_KEY) &&<z>
.matchesName((String) expectedValue)) {<z>
null) {<z>
attributeName);<z>
if (actualValue != null) {<z>
(actualValue, expectedValue.getClass());<z>
actualValue)) {<z>
return false;<z>
true;<z>
>> partWriters,<z>
formWriter) {<z>
(initMediaTypes(formWriter));<z>
partWriters = partWriters;<z>
this.formWriter = formWriter;<z>
, CodeFlow cf) {<z>
type != null, "No type available");<z>
(this.type.isPrimitive()) {<z>
TYPE) {<z>
GETSTATIC, "java/lang/Boolean", "TYPE", "Ljava/lang/Class;");<z>
.type == Byte.TYPE) {<z>
, "java/lang/Byte", "TYPE", "Ljava/lang/Class;");<z>
== Character.TYPE) {<z>
"java/lang/Character", "TYPE", "Ljava/lang/Class;");<z>
== Double.TYPE) {<z>
"java/lang/Double", "TYPE", "Ljava/lang/Class;");<z>
type == Float.TYPE) {<z>
"Ljava/lang/Class;");<z>
type == Integer.TYPE) {<z>
);<z>
Long.TYPE) {<z>
"TYPE", "Ljava/lang/Class;");<z>
Short.TYPE) {<z>
(GETSTATIC, "java/lang/Short", "TYPE", "Ljava/lang/Class;");<z>
Type.getType(this.type));<z>
cf.pushDescriptor(this.exitTypeDescriptor);<z>
, AbstractBeanDefinition definition, ParserContext parserContext) {<z>
;<z>
(!StringUtils.hasText(id)) {<z>
getAttribute("static-field");<z>
;<z>
expression) {<z>
(expression);<z>
);<z>
: WebUtils.SUBMIT_IMAGE_SUFFIXES) {<z>
);<z>
InvocableHandlerMethod getExceptionHandlerMethod(HandlerMethod handlerMethod, Exception exception) {<z>
(logger.isDebugEnabled()) {<z>
.getSimpleName());<z>
;<z>
;<z>
{<z>
;<z>
put(beanType, resolver);<z>
resolver.resolveMethod(exception);<z>
null) {<z>
);<z>
this.exceptionHandlerAdviceCache.entrySet()) {<z>
;<z>
beanType)) {<z>
.getValue();<z>
resolveMethod(exception);<z>
!= null) {<z>
(), method);<z>
return null;<z>
?> targetClass, Method method) {<z>
.beanName = beanName;<z>
= BridgeMethodResolver.findBridgedMethod(method);<z>
= (!Proxy.isProxyClass(targetClass) ?<z>
;<z>
new AnnotatedElementKey(this.targetMethod, targetClass);<z>
);<z>
= resolveDeclaredEventTypes(method, ann);<z>
ann.condition() : null);<z>
);<z>
? ann.id() : "");<z>
isEmpty() ? id : null);<z>
{<z>
) {<z>
();<z>
.running;<z>
getLineNumber() {<z>
getCause();<z>
cause instanceof SAXParseException) {<z>
.getLineNumber();<z>
-1;<z>
>> firstRunOf(<z>
>, ?> valueExtractor) {<z>
valueExtractor);<z>
> processor, Subscription subscription) {<z>
;<z>
{<z>
subscription = subscription;<z>
request(1);<z>
onSubscribe(processor, subscription);<z>
String url) {<z>
.resolveUrlPath(url);<z>
{<z>
);<z>
);<z>
] methods, String methodName)<z>
throws IllegalArgumentException {<z>
= null;<z>
;<z>
Method method : methods) {<z>
().equals(methodName)) {<z>
method.getParameterCount();<z>
{<z>
= method;<z>
;<z>
.getParameterCount() == numParams) {<z>
()) {<z>
;<z>
numMethodsFoundWithCurrentMinimumArgs++;<z>
numMethodsFoundWithCurrentMinimumArgs > 1) {<z>
+ methodName +<z>
);<z>
targetMethod;<z>
NamedValueInfo createNamedValueInfo(MethodParameter parameter) {<z>
= parameter.getParameterAnnotation(SessionAttribute.class);<z>
);<z>
.required(), ValueConstants.DEFAULT_NONE);<z>
{<z>
"clientLogin must not be empty");<z>
clientLogin = login;<z>
this;<z>
read() {<z>
if (this.currentBuffer == null) {<z>
return -1;<z>
this.currentBufferLength) {<z>
.totalBytesRead++;<z>
& 0xFF;<z>
{<z>
currentBuffer = this.buffersIterator.next();<z>
);<z>
;<z>
.currentBuffer = null;<z>
read();<z>
private String readCommand(ByteBuffer byteBuffer) {<z>
ByteArrayOutputStream(256);<z>
{<z>
());<z>
StandardCharsets.UTF_8);<z>
Collection<DataBuffer> processDataBuffer(<z>
matcher, LimitedDataBufferList chunks) {<z>
List<DataBuffer> result = null;<z>
(buffer);<z>
) {<z>
.add(buffer);<z>
(buffer);<z>
readPosition();<z>
length = (endIndex - startIndex + 1);<z>
);<z>
new ArrayList<>());<z>
()) {<z>
stripDelimiter) {<z>
);<z>
);<z>
.add(slice);<z>
.join(chunks);<z>
(this.stripDelimiter) {<z>
delimiter().length);<z>
(joined);<z>
.clear();<z>
+ 1);<z>
) > 0);<z>
.emptyList());<z>
;<z>
{<z>
headers == null) {<z>
);<z>
;<z>
{<z>
JtaTransactionObject) transaction;<z>
txObject.resetTransactionTimeout) {<z>
(0);<z>
) {<z>
("Failed to reset transaction timeout after JTA completion", ex);<z>
(<z>
root, @Nullable BeanDefinitionParserDelegate parentDelegate) {<z>
readerContext);<z>
root, parentDelegate);<z>
;<z>
{<z>
;<z>
(subProjectsCount);<z>
< subProjectsCount; i++) {<z>
));<z>
) {<z>
;<z>
) {<z>
new IllegalStateException("No 'defaultDestination' or 'defaultDestinationName' specified. " +<z>
"Check configuration of JmsMessagingTemplate.");<z>
;<z>
{<z>
;<z>
SQLException se) {<z>
(se);<z>
void enableFilters(Session session) {<z>
filterNames = getFilterNames();<z>
) {<z>
) {<z>
;<z>
, @Nullable Object source) {<z>
registerBeanNameUrlHandlerMapping(context, source);<z>
(context, source);<z>
registerSimpleControllerHandlerAdapter(context, source);<z>
, source);<z>
);<z>
;<z>
;<z>
);<z>
public UUID getId() {<z>
value = getHeader(MessageHeaders.ID);<z>
(value == null) {<z>
;<z>
()));<z>
initSslInfo() {<z>
request).channel();<z>
.class);<z>
parent() != null) {<z>
.class);<z>
null) {<z>
sslHandler.engine().getSession();<z>
DefaultSslInfo(session);<z>
return null;<z>
ServerRequest.Builder uri(URI uri) {<z>
.notNull(uri, "URI must not be null");<z>
;<z>
this;<z>
) {<z>
if (!(beanFactory instanceof ConfigurableBeanFactory)) {<z>
throw new IllegalStateException("Not running in a ConfigurableBeanFactory: " + beanFactory);<z>
this.beanFactory = (ConfigurableBeanFactory) beanFactory;<z>
beanClassLoader == null) {<z>
);<z>
Nullable String propString) throws IllegalArgumentException {<z>
) {<z>
);<z>
()) {<z>
= st.nextToken();<z>
.indexOf('=');<z>
) {<z>
IllegalArgumentException(<z>
;<z>
) - 2) {<z>
IllegalArgumentException(<z>
+ "'");<z>
eqIdx);<z>
+ 2;<z>
- 1;<z>
substring(beginIndex, endIndex);<z>
;<z>
aspectInstanceFactory) {<z>
getAspectMetadata().getAspectClass();<z>
.getAspectMetadata().getAspectName();<z>
validate(aspectClass);<z>
MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =<z>
aspectInstanceFactory);<z>
new ArrayList<>();<z>
: getAdvisorMethods(aspectClass)) {<z>
aspectName);<z>
(advisor != null) {<z>
;<z>
)) {<z>
);<z>
.add(0, instantiationAdvisor);<z>
Field field : aspectClass.getDeclaredFields()) {<z>
getDeclareParentsAdvisor(field);<z>
null) {<z>
);<z>
return advisors;<z>
> ctor) {<z>
for (ParameterNameDiscoverer pnd : this.parameterNameDiscoverers) {<z>
.getParameterNames(ctor);<z>
result != null) {<z>
;<z>
return null;<z>
, Object suspendedResources) {<z>
sessionFactory = obtainSessionFactory();<z>
= (SuspendedResourcesHolder) suspendedResources;<z>
hasResource(sessionFactory)) {<z>
);<z>
sessionFactory, resourcesHolder.getSessionHolder());<z>
&& resourcesHolder.getConnectionHolder() != null) {<z>
));<z>
constructor, int parameterIndex,<z>
) {<z>
constructor, "Constructor must not be null");<z>
, parameterIndex, implementationClass);<z>
return forMethodParameter(methodParameter);<z>
<T, HandlerMethod> handlerMethods) {<z>
int total = handlerMethods.size();<z>
) {<z>
(total + " mappings in " + formatMappingName());<z>
registerAspectJAnnotationAutoProxyCreatorIfNecessary(<z>
) {<z>
beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(<z>
parserContext.extractSource(sourceElement));<z>
getRegistry(), sourceElement);<z>
parserContext);<z>
, HttpServletResponse response,<z>
, boolean http10Compatible) throws IOException {<z>
: response.encodeRedirectURL(targetUrl));<z>
) {<z>
RESPONSE_STATUS_ATTRIBUTE);<z>
.statusCode != null) {<z>
;<z>
setHeader("Location", encodedURL);<z>
{<z>
);<z>
.setHeader("Location", encodedURL);<z>
sendRedirect(encodedURL);<z>
= getHttp11StatusCode(request, response, targetUrl);<z>
setStatus(statusCode.value());<z>
response.setHeader("Location", encodedURL);<z>
, int sqlType, @Nullable String typeName)<z>
{<z>
{<z>
= false;<z>
Integer sqlTypeToUse = null;<z>
(!shouldIgnoreGetParameterType) {<z>
);<z>
) {<z>
)) {<z>
);<z>
) {<z>
= Types.NULL;<z>
();<z>
();<z>
.getDatabaseProductName();<z>
("Informix") ||<z>
&& jdbcDriverName.contains("SQL Server"))) {<z>
= true;<z>
) ||<z>
jdbcDriverName.startsWith("jConnect") ||<z>
||<z>
) {<z>
;<z>
{<z>
setObject(paramIndex, null);<z>
sqlTypeToUse);<z>
null) {<z>
setNull(paramIndex, sqlType, typeName);<z>
ps.setNull(paramIndex, sqlType);<z>
{<z>
null) {<z>
).getMetaData().supportsSavepoints();<z>
.savepointsSupported;<z>
element, final @Nullable String requestingBeanName) {<z>
= new TargetSource() {<z>
<?> getTargetClass() {<z>
;<z>
boolean isStatic() {<z>
return false;<z>
() {<z>
requestingBeanName);<z>
Object target) {<z>
);<z>
.setTargetSource(ts);<z>
.lookupType.isInterface()) {<z>
(element.lookupType);<z>
?<z>
) : null);<z>
classLoader);<z>
RootBeanDefinition mbd,<z>
resolver) {<z>
beanName);<z>
;<z>
isFactoryMethodUnique && mbd.factoryMethodToIntrospect == null) {<z>
resolveFactoryMethodIfPossible(mbd);<z>
) ?<z>
computeIfAbsent(beanName,<z>
beanName, getAliases(bdName))) :<z>
)));<z>
(holder, descriptor);<z>
public AnnotationVisitor visitTypeAnnotation(<z>
String descriptor, final boolean visible) {<z>
{<z>
new UnsupportedOperationException("TypeAnnotation requires ASM5");<z>
!= null) {<z>
);<z>
null;<z>
args, MethodProxy methodProxy) throws Throwable {<z>
;<z>
getTarget();<z>
.setCurrentProxy(proxy);<z>
;<z>
);<z>
oldProxy);<z>
if (target != null) {<z>
target);<z>
(<z>
request, HttpServletResponse response)<z>
Exception {<z>
= this.cachedTemplates;<z>
{<z>
;<z>
);<z>
);<z>
response, transformer);<z>
Source source = null;<z>
(model);<z>
source == null) {<z>
);<z>
response));<z>
(source);<z>
String beanName) {<z>
Object instance;<z>
;<z>
this.currentlyCreatedBean.set(beanName);<z>
instanceSupplier.get();<z>
outerBean != null) {<z>
;<z>
remove();<z>
{<z>
;<z>
(instance);<z>
(bw);<z>
;<z>
indent() {<z>
++) {<z>
append(' ');<z>
String descriptor) {<z>
{<z>
descriptor);<z>
return null;<z>
) {<z>
notNull(delegate, "A delegate Filter is required");<z>
delegate = delegate;<z>
urlPattern : urlPatterns) {<z>
urlPattern);<z>
Context> getOrCreateContext() {<z>
context -> {<z>
= context.get(TransactionContextHolder.class);<z>
holder.hasContext()) {<z>
currentContext());<z>
;<z>
(ServerRequest other) {<z>
;<z>
();<z>
));<z>
);<z>
.uri = other.uri();<z>
)));<z>
other.cookies()));<z>
)));<z>
addAll(other.params()));<z>
null);<z>
attribute)<z>
, InvalidAttributeValueException, MBeanException, ReflectionException {<z>
;<z>
;<z>
setAttribute(attribute);<z>
).setContextClassLoader(currentClassLoader);<z>
T[] values) {<z>
(name, "'name' must not be empty");<z>
);<z>
value : values) {<z>
, value);<z>
(<z>
, Annotation annotation,<z>
) {<z>
= Adapt.values(classValuesAsString, nestedAnnotationsAsMap);<z>
MergedAnnotation.from(annotatedElement, annotation)<z>
withNonMergedAttributes()<z>
(mergedAnnotation -><z>
;<z>
) {<z>
);<z>
{<z>
{<z>
);<z>
(formatClassNameForMessage(null));<z>
sj.toString();<z>
) {<z>
() != null) {<z>
scheme(getScheme());<z>
getSchemeSpecificPart() != null) {<z>
));<z>
if (getFragment() != null) {<z>
(getFragment());<z>
[] args) {<z>
> methodDeclaringClass = method.getDeclaringClass();<z>
getClass();<z>
(targetBeanClass)) {<z>
.getName() +<z>
targetBeanClass.getName() + "'. If the bean requires proxying " +<z>
, args));<z>
) {<z>
();<z>
right = desc2.getName();<z>
getBytes();<z>
rightBytes = right.getBytes();<z>
(); i++) {<z>
.length() == i) {<z>
return 1;<z>
[i];<z>
0) {<z>
return result;<z>
() - right.length();<z>
(Object managedBean, String beanKey) {<z>
);<z>
<>();<z>
: methods) {<z>
if (method.isSynthetic()) {<z>
()) {<z>
null;<z>
BeanUtils.findPropertyForMethod(method);<z>
) ||<z>
includeWriteAttribute(method, beanKey)))) {<z>
, pd.getName(), beanKey);<z>
);<z>
getReadMethod())) {<z>
desc.setField(FIELD_ROLE, ROLE_GETTER);<z>
;<z>
;<z>
isExposeClassDescriptor()) {<z>
managedBean).getName());<z>
desc);<z>
beanKey)) {<z>
;<z>
= info.getDescriptor();<z>
FIELD_ROLE, ROLE_OPERATION);<z>
{<z>
);<z>
populateOperationDescriptor(desc, method, beanKey);<z>
setDescriptor(desc);<z>
info != null) {<z>
;<z>
new ModelMBeanOperationInfo[0]);<z>
) {<z>
!= byte[].class) {<z>
IllegalStateException(<z>
.getClass()));<z>
payload;<z>
mimeType = getContentType();<z>
.toString() : "");<z>
== null || !isReadableContentType()) {<z>
contentType;<z>
.getCharset();<z>
StandardCharsets.UTF_8);<z>
80) ?<z>
String(bytes, charset) :<z>
80), charset) + "...(truncated)";<z>
] getClasses(Object[] objects) {<z>
.length];<z>
++) {<z>
i].getClass();<z>
return classes;<z>
@Nullable String path) {<z>
((key, value) -> {<z>
.hasText(path)) {<z>
(key.startsWith("[")) {<z>
;<z>
'.' + key;<z>
if (value instanceof String) {<z>
result.put(key, value);<z>
value instanceof Map) {<z>
SuppressWarnings("unchecked")<z>
, Object>) value;<z>
map, key);<z>
Collection) {<z>
)<z>
= (Collection<Object>) value;<z>
if (collection.isEmpty()) {<z>
result.put(key, "");<z>
0;<z>
) {<z>
result, Collections.singletonMap(<z>
object), key);<z>
value != null ? value : ""));<z>
;<z>
initResolvers(ArgumentResolverConfigurer customResolvers,<z>
ReactiveAdapterRegistry adapterRegistry, ConfigurableApplicationContext context,<z>
List<HttpMessageReader<?>> readers) {<z>
context.getBeanFactory();<z>
) && supportDataBinding;<z>
(30);<z>
, false));<z>
));<z>
PathVariableMethodArgumentResolver(beanFactory, adapterRegistry));<z>
adapterRegistry));<z>
));<z>
(new MatrixVariableMapMethodArgumentResolver(adapterRegistry));<z>
isEmpty()) {<z>
readers, adapterRegistry));<z>
adapterRegistry));<z>
) {<z>
(adapterRegistry, false));<z>
);<z>
RequestHeaderMapMethodArgumentResolver(adapterRegistry));<z>
;<z>
new ExpressionValueMethodArgumentResolver(beanFactory, adapterRegistry));<z>
beanFactory, adapterRegistry));<z>
RequestAttributeMethodArgumentResolver(beanFactory, adapterRegistry));<z>
!readers.isEmpty()) {<z>
;<z>
new ModelMethodArgumentResolver(adapterRegistry));<z>
if (supportDataBinding) {<z>
(adapterRegistry));<z>
ServerWebExchangeMethodArgumentResolver(adapterRegistry));<z>
));<z>
(requestMappingMethod) {<z>
());<z>
(new WebSessionMethodArgumentResolver(adapterRegistry));<z>
isKotlinPresent()) {<z>
());<z>
customResolvers.getCustomResolvers());<z>
, true));<z>
) {<z>
, true));<z>
result;<z>
onComplete(AbstractListenerWriteFlushProcessor<T> processor) {<z>
COMPLETED)) {<z>
publishComplete();<z>
);<z>
getPropertyHandler(String propertyName) throws BeansException {<z>
;<z>
getPropertyAccessorForPropertyPath(propertyName);<z>
);<z>
>... componentClasses) {<z>
componentClasses) {<z>
);<z>
Mono<T> applyStatusHandlers(ClientResponse response) {<z>
int statusCode = response.rawStatusCode();<z>
statusHandlers) {<z>
) {<z>
Mono<? extends Throwable> exMono;<z>
handler.apply(response);<z>
-> releaseIfNotConsumed(response, ex));<z>
ex -> releaseIfNotConsumed(response, ex));<z>
ex2) {<z>
= releaseIfNotConsumed(response, ex2);<z>
exMono.flatMap(Mono::error);<z>
);<z>
(result, statusCode, request);<z>
null;<z>
@Nullable Class<T> requiredType,<z>
TypeMismatchException {<z>
("TypeDescriptor resolution not supported");<z>
public HeadersRequestCondition combine(HeadersRequestCondition other) {<z>
() && other.isEmpty()) {<z>
this;<z>
()) {<z>
this;<z>
)) {<z>
;<z>
this.expressions);<z>
other.expressions);<z>
return new HeadersRequestCondition(set);<z>
JspException {<z>
processor = getRequestContext().getRequestDataValueProcessor();<z>
getRequest();<z>
processor != null && request instanceof HttpServletRequest) {<z>
getExtraHiddenFields((HttpServletRequest) request));<z>
"No TagWriter set");<z>
endTag();<z>
EVAL_PAGE;<z>
<DataBuffer> writeResourceRegion(<z>
String, Object> hints) {<z>
= region.getResource();<z>
long position = region.getPosition();<z>
);<z>
(hints)) {<z>
(Hints.getLogPrefix(hints) +<z>
) + " of [" + resource + "]");<z>
bufferSize);<z>
) {<z>
logger));<z>
count);<z>
ctor) {<z>
= ctor;<z>
if (ctor.isVarArgs()) {<z>
.getParameterCount() - 1;<z>
= null;<z>
) throws PersistenceException {<z>
!= null, "PersistenceUnitInfo not initialized");<z>
getPersistenceProvider();<z>
{<z>
.getPersistenceProviderClassName();<z>
null) {<z>
new IllegalArgumentException(<z>
);<z>
));<z>
) BeanUtils.instantiateClass(providerClass);<z>
isDebugEnabled()) {<z>
.debug("Building JPA container EntityManagerFactory for persistence unit '" +<z>
"'");<z>
emf =<z>
));<z>
.persistenceUnitInfo);<z>
return emf;<z>
final int doStartTagInternal() throws Exception {<z>
);<z>
)) {<z>
.pageContext.getAttribute(<z>
NestedPathTag.NESTED_PATH_VARIABLE_NAME, PageContext.REQUEST_SCOPE);<z>
&&<z>
() - 1))) {<z>
nestedPath + resolvedPath;<z>
;<z>
) {<z>
());<z>
.PAGE_SCOPE);<z>
.REQUEST_SCOPE);<z>
removeAttribute(STATUS_VARIABLE_NAME, PageContext.PAGE_SCOPE);<z>
, this.status, PageContext.REQUEST_SCOPE);<z>
EVAL_BODY_INCLUDE;<z>
getInvocationDescription(MethodInvocation invocation) {<z>
invocation.getThis();<z>
.state(target != null, "Target must not be null");<z>
();<z>
+ className + "]";<z>
Properties props) {<z>
this.helper = new PropertyPlaceholderHelper(<z>
valueSeparator, ignoreUnresolvablePlaceholders);<z>
new PropertyPlaceholderConfigurerResolver(props);<z>
name) {<z>
(target == null) {<z>
return this;<z>
));<z>
type.isArray()) {<z>
this;<z>
Class);<z>
);<z>
{<z>
null);<z>
null) {<z>
= findGetterForProperty(name, type, target);<z>
{<z>
(method, -1));<z>
= ClassUtils.getInterfaceMethodIfPossible(method);<z>
invocationTarget = new InvokerPair(method, typeDescriptor);<z>
ReflectionUtils.makeAccessible(method);<z>
readerCache.put(cacheKey, invocationTarget);<z>
method != null) {<z>
new OptimalPropertyAccessor(invocationTarget);<z>
Field) {<z>
null);<z>
field == null) {<z>
);<z>
null) {<z>
);<z>
;<z>
put(cacheKey, invocationTarget);<z>
(field != null) {<z>
);<z>
return this;<z>
void stop() {<z>
if (isRunning()) {<z>
;<z>
Lifecycle) {<z>
);<z>
void doClose() {<z>
, true)) {<z>
)) {<z>
+ this);<z>
publishEvent(new ContextClosedEvent(this));<z>
ex) {<z>
logger.warn("Exception thrown from ApplicationListener handling ContextClosedEvent", ex);<z>
lifecycleProcessor != null) {<z>
this.lifecycleProcessor.onClose();<z>
ex) {<z>
;<z>
();<z>
;<z>
onClose();<z>
earlyApplicationListeners != null) {<z>
applicationListeners.clear();<z>
(this.earlyApplicationListeners);<z>
set(false);<z>
isBeforeFirst() throws InvalidResultSetAccessException {<z>
);<z>
(SQLException se) {<z>
InvalidResultSetAccessException(se);<z>
) {<z>
, values);<z>
;<z>
this;<z>
args) throws Throwable {<z>
);<z>
) {<z>
[0]);<z>
"hashCode")) {<z>
;<z>
.equals("toString")) {<z>
return "Cached JMS Session: " + this.target;<z>
if (methodName.equals("close")) {<z>
{<z>
sessionList) {<z>
getSessionCacheSize()) {<z>
proxy);<z>
;<z>
catch (JMSException ex) {<z>
ex);<z>
);<z>
return null;<z>
{<z>
target;<z>
equals("rollback")) {<z>
.transactionOpen = false;<z>
{<z>
true;<z>
) && (methodName.equals("createProducer") ||<z>
))) {<z>
[0];<z>
)) {<z>
getCachedProducer(dest);<z>
(isCacheConsumers()) {<z>
) ||<z>
methodName.equals("createSubscriber"))) {<z>
[0];<z>
TemporaryQueue || dest instanceof TemporaryTopic)) {<z>
(dest,<z>
null),<z>
&& (Boolean) args[2]),<z>
;<z>
) || methodName.equals("createDurableSubscriber")) {<z>
args[0];<z>
{<z>
return getCachedConsumer(dest,<z>
),<z>
Boolean) args[3]),<z>
1],<z>
true);<z>
if (methodName.equals("createSharedConsumer")) {<z>
0];<z>
!= null) {<z>
return getCachedConsumer(dest,<z>
] : null),<z>
args[1],<z>
false);<z>
) {<z>
dest = (Destination) args[0];<z>
!= null) {<z>
(dest,<z>
2] : null),<z>
[1],<z>
);<z>
);<z>
InvocationTargetException ex) {<z>
;<z>
{<z>
!= null) {<z>
();<z>
{<z>
return this.servletContext;<z>
new IllegalStateException("No ServletContext");<z>
)<z>
ServletException {<z>
);<z>
getCachedPath(request);<z>
!= defaultPathMatcher) {<z>
;<z>
cacheControlMappings)) {<z>
PathContainer pathContainer ?<z>
(String) path));<z>
(control != null) {<z>
{<z>
.trace("Applying " + control);<z>
);<z>
true;<z>
this.cacheMappings)) {<z>
PathContainer pathContainer ?<z>
lookupCacheSeconds((String) path));<z>
null) {<z>
isTraceEnabled()) {<z>
);<z>
cacheSeconds);<z>
true;<z>
prepareResponse(response);<z>
;<z>
String> encoder) {<z>
<String> pathSegments = getPathSegments();<z>
>(pathSegments.size());<z>
: pathSegments) {<z>
apply(pathSegment, Type.PATH_SEGMENT);<z>
add(encodedPathSegment);<z>
);<z>
text, boolean ignoreUnresolvablePlaceholders) {<z>
{<z>
text;<z>
strictHelper);<z>
(text));<z>
) throws IOException {<z>
connectorServer != null) {<z>
) {<z>
("Stopping JMX connector server: " + this.connectorServer);<z>
this.connectorServer.stop();<z>
();<z>
private static ServletRequestAttributes currentRequestAttributes() {<z>
RequestAttributes requestAttr = RequestContextHolder.currentRequestAttributes();<z>
instanceof ServletRequestAttributes)) {<z>
new IllegalStateException("Current request is not a servlet request");<z>
return (ServletRequestAttributes) requestAttr;<z>
(GenericConverter converter, @Nullable Object source,<z>
TypeDescriptor sourceType, TypeDescriptor targetType) {<z>
, targetType);<z>
{<z>
;<z>
) {<z>
;<z>
defaultMessage, boolean htmlEscape) {<z>
, defaultMessage, this.locale);<z>
) {<z>
return "";<z>
msg) : msg);<z>
Builder paths(String... paths) {<z>
options.getPatternParser() != null ?<z>
: PathPatternParser.defaultInstance);<z>
.isEmpty(paths) ?<z>
;<z>
this;<z>
{<z>
{<z>
>> iterator() {<z>
);<z>
public int size() {<z>
();<z>
extends NotificationListener> listeners) {<z>
;<z>
NotificationListenerBean> notificationListeners =<z>
;<z>
.forEach((key, listener) -> {<z>
NotificationListenerBean(listener);<z>
(key)) {<z>
key);<z>
.add(bean);<z>
);<z>
NotificationListenerBean[0]);<z>
UnsupportedEncodingException {<z>
, "Writer access not allowed");<z>
.writer == null) {<z>
, getCharacterEncoding());<z>
;<z>
return this.writer;<z>
{<z>
null) {<z>
headerName) ||<z>
)) {<z>
String)) {<z>
throw new IllegalArgumentException(<z>
);<z>
{<z>
++;<z>
beanThatBroadcasts != null) {<z>
++;<z>
(String annotationType) {<z>
(annotationType)) {<z>
;<z>
Boolean.TRUE.equals(scan(annotationType,<z>
annotationFilter, true)));<z>
Throwable exception) {<z>
this.delegateSession != null) {<z>
exception);<z>
mpvs) {<z>
getFieldDefaultPrefix();<z>
fieldDefaultPrefix != null) {<z>
pvArray = mpvs.getPropertyValues();<z>
(PropertyValue pv : pvArray) {<z>
.startsWith(fieldDefaultPrefix)) {<z>
());<z>
(field)) {<z>
);<z>
(pv);<z>
boolean isCglibRenamedMethod(Method renamedMethod) {<z>
renamedMethod.getName();<z>
.startsWith(CGLIB_RENAMED_METHOD_PREFIX)) {<z>
i = name.length() - 1;<z>
i))) {<z>
;<z>
(i) == '$');<z>
false;<z>
] b, ClassLoader loader,<z>
?> contextClass) throws Exception {<z>
c = null;<z>
THROWABLE;<z>
== loader) {<z>
;<z>
c = lookup.defineClass(b);<z>
IllegalArgumentException ex) {<z>
;<z>
(Throwable ex) {<z>
ex);<z>
(c == null) {<z>
(protectionDomain == null) {<z>
;<z>
= loader.getClass().getMethod(<z>
, ProtectionDomain.class);<z>
(loader, className, b, protectionDomain);<z>
InvocationTargetException ex) {<z>
instanceof UnsupportedOperationException)) {<z>
;<z>
();<z>
(Throwable ex) {<z>
;<z>
classLoaderDefineClassMethod != null) {<z>
0, b.length, protectionDomain};<z>
{<z>
setAccessible(true);<z>
(loader, args);<z>
{<z>
CodeGenerationException(ex.getTargetException());<z>
{<z>
.endsWith("InaccessibleObjectException")) {<z>
);<z>
;<z>
) != loader) {<z>
lookup());<z>
.defineClass(b);<z>
(Throwable ex) {<z>
CodeGenerationException(ex);<z>
(c == null) {<z>
;<z>
.forName(className, true, loader);<z>
return c;<z>
public void onResult(SendResult result) {<z>
{<z>
;<z>
);<z>
;<z>
onError(result.getException());<z>
(<z>
, BeanDefinitionRegistry registry)<z>
throws BeanDefinitionStoreException {<z>
getBeanName();<z>
.getBeanDefinition());<z>
getAliases();<z>
null) {<z>
(String alias : aliases) {<z>
beanName, alias);<z>
(Marshaller marshaller) {<z>
);<z>
);<z>
this.marshaller = marshaller;<z>
beanClassName) {<z>
());<z>
beanClassName);<z>
return builder;<z>
ParserContext() {<z>
isTemplate() {<z>
true;<z>
getExpressionPrefix() {<z>
"#{";<z>
String getExpressionSuffix() {<z>
return "}";<z>
Object handler, @Nullable HandlerInterceptor[] interceptors)<z>
throws Exception {<z>
null) {<z>
null);<z>
(handler instanceof HandlerMethod handlerMethod) {<z>
());<z>
.printValue("Method", handlerMethod);<z>
);<z>
(JsonDeserializer<?>... deserializers) {<z>
?> deserializer : deserializers) {<z>
);<z>
Object.class) {<z>
.getClass().getName());<z>
, deserializer);<z>
return this;<z>
allocateBuffer(int initialCapacity) {<z>
= (this.preferDirect ?<z>
initialCapacity) :<z>
allocate(initialCapacity));<z>
;<z>
{<z>
cookies.length];<z>
cookies.length; i++) {<z>
i];<z>
cookieStrings[i] = new ToStringCreator(cookie)<z>
))<z>
("value", cookie.getValue())<z>
cookie.getComment())<z>
))<z>
getMaxAge())<z>
)<z>
)<z>
"version", cookie.getVersion())<z>
append("httpOnly", cookie.isHttpOnly())<z>
;<z>
);<z>
boolean loadContext,<z>
Class<A> annotationType, ExtensionContext context) {<z>
(), "No AnnotatedElement");<z>
).get();<z>
GenericApplicationContext gac = null;<z>
;<z>
if (loadContext) {<z>
.getApplicationContext(context);<z>
;<z>
;<z>
= gac;<z>
(applicationContext instanceof ConfigurableApplicationContext)) {<z>
()) {<z>
getClass().getName();<z>
.warn(String.format("@%s(\"%s\") could not be evaluated on [%s] since the test " +<z>
contextType));<z>
return false;<z>
;<z>
= configurableBeanFactory.getBeanExpressionResolver();<z>
expressionResolver != null, "No BeanExpressionResolver");<z>
null);<z>
result = expressionResolver.evaluate(<z>
beanExpressionContext);<z>
{<z>
close();<z>
(result instanceof Boolean) {<z>
;<z>
{<z>
();<z>
"true".equals(str)) {<z>
return true;<z>
.state("false".equals(str),<z>
.format("@%s(\"%s\") on %s must evaluate to \"true\" or \"false\", not \"%s\"",<z>
element, result));<z>
;<z>
String.format("@%s(\"%s\") on %s must evaluate to a String or a Boolean, not %s",<z>
getSimpleName(), expression, element,<z>
) : "null"));<z>
throw new IllegalStateException(message);<z>
Object event, @Nullable ResolvableType eventType) {<z>
.notNull(event, "Event must not be null");<z>
ApplicationEvent applicationEvent;<z>
ApplicationEvent) {<z>
ApplicationEvent) event;<z>
>(this, event, eventType);<z>
== null) {<z>
).getResolvableType();<z>
earlyApplicationEvents != null) {<z>
add(applicationEvent);<z>
);<z>
!= null) {<z>
) {<z>
(event, eventType);<z>
.publishEvent(event);<z>
entity) throws DataAccessException {<z>
executeWithNativeSession(session -> {<z>
;<z>
persist(entityName, entity);<z>
;<z>
);<z>
) {<z>
name;<z>
color;<z>
= colorName;<z>
{<z>
(this == other) {<z>
return true;<z>
other instanceof EncodedResource otherResource)) {<z>
return false;<z>
resource) &&<z>
, otherResource.charset) &&<z>
.encoding));<z>
private void configurePathMatchingProperties(<z>
ParserContext context) {<z>
"path-matching");<z>
!= null) {<z>
.extractSource(element);<z>
pathMatchingElement.hasAttribute("suffix-pattern")) {<z>
getAttribute("suffix-pattern"));<z>
"useSuffixPatternMatch", useSuffixPatternMatch);<z>
) {<z>
));<z>
add("useTrailingSlashMatch", useTrailingSlashMatch);<z>
("registered-suffixes-only")) {<z>
pathMatchingElement.getAttribute("registered-suffixes-only"));<z>
).add("useRegisteredSuffixPatternMatch", useRegisteredSuffixPatternMatch);<z>
pathHelperRef = null;<z>
"path-helper")) {<z>
("path-helper"));<z>
, source);<z>
"urlPathHelper", pathHelperRef);<z>
RuntimeBeanReference pathMatcherRef = null;<z>
) {<z>
getAttribute("path-matcher"));<z>
(pathMatcherRef, context, source);<z>
("pathMatcher", pathMatcherRef);<z>
protected int determineTimeout(TransactionDefinition definition) {<z>
getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {<z>
;<z>
;<z>
reset() {<z>
.clear();<z>
this.initialBlockSize;<z>
= false;<z>
0;<z>
;<z>
JMSException {<z>
];<z>
message.readBytes(bytes);<z>
return bytes;<z>
<T> action)<z>
JmsException {<z>
, "Callback object must not be null");<z>
{<z>
.resolveDestinationName(session, queueName, false);<z>
session, queue, messageSelector);<z>
browser);<z>
browser);<z>
, true);<z>
(String line) {<z>
(getMaxInMemorySize() < 0) {<z>
if (line.isEmpty()) {<z>
;<z>
Integer.MAX_VALUE - this.accumulated) {<z>
);<z>
);<z>
)) {<z>
);<z>
def) {<z>
("key-generator");<z>
name)) {<z>
RuntimeBeanReference(name.trim()));<z>
;<z>
{<z>
);<z>
) {<z>
return result;<z>
fallback = this.defaultMediaType;<z>
fallback : mediaType);<z>
null) {<z>
(result, fallback);<z>
).setContentType(result);<z>
return result;<z>
registerDispatcherServlet(ServletContext servletContext) {<z>
= getServletName();<z>
(servletName, "getServletName() must not return null or empty");<z>
();<z>
;<z>
= createDispatcherServlet(servletAppContext);<z>
"createDispatcherServlet(WebApplicationContext) must not return null");<z>
));<z>
);<z>
(registration == null) {<z>
servletName + "'. " +<z>
);<z>
setLoadOnStartup(1);<z>
));<z>
isAsyncSupported());<z>
] filters = getServletFilters();<z>
) {<z>
(Filter filter : filters) {<z>
servletContext, filter);<z>
registration);<z>
throws NoSuchMessageException {<z>
locale);<z>
if (msg != null) {<z>
;<z>
getDefaultMessage(code);<z>
fallback != null) {<z>
fallback;<z>
);<z>
{<z>
;<z>
(), Locale.ENGLISH);<z>
map);<z>
rawHeaders);<z>
.readOnlyHttpHeaders(multiValueMap);<z>
) {<z>
{<z>
;<z>
domain;<z>
;<z>
private boolean secure;<z>
;<z>
private String sameSite;<z>
ResponseCookieBuilder maxAge(Duration maxAge) {<z>
this.maxAge = maxAge;<z>
return this;<z>
long maxAgeSeconds) {<z>
);<z>
return this;<z>
domain(String domain) {<z>
(domain);<z>
this;<z>
(String domain) {<z>
(domain)) {<z>
domain.trim();<z>
&& str.endsWith("\"")) {<z>
()) {<z>
return null;<z>
domain;<z>
{<z>
= path;<z>
return this;<z>
(boolean secure) {<z>
secure;<z>
return this;<z>
boolean httpOnly) {<z>
.httpOnly = httpOnly;<z>
return this;<z>
sameSite) {<z>
sameSite = sameSite;<z>
this;<z>
ResponseCookie build() {<z>
,<z>
);<z>
(ResourceRegion region, ReactiveHttpOutputMessage message,<z>
String, Object> hints) {<z>
message, hints)<z>
) -> {<z>
Mono.just(region);<z>
.getContentType();<z>
, mediaType, message, hints);<z>
;<z>
name) {<z>
resourceTypes.containsKey(name)) {<z>
;<z>
;<z>
true;<z>
ex) {<z>
;<z>
pathMatcher) {<z>
Assert.notNull(pathMatcher, "PathMatcher must not be null");<z>
this.pathMatcher = pathMatcher;<z>
equals("a/a");<z>
String toString() {<z>
{<z>
) + "[]";<z>
null) {<z>
return "?";<z>
.type instanceof TypeVariable<?> variable) {<z>
{<z>
return "?";<z>
()) {<z>
, ", ") + '>';<z>
return this.resolved.getName();<z>
annotation) {<z>
(annotation.annotationType());<z>
) {<z>
annotation);<z>
findRepeatedAnnotations(annotation);<z>
nextToken() {<z>
{<z>
;<z>
.get(this.tokenStreamPointer++);<z>
] convert(Object source) {<z>
.serializer.serializeToByteArray(source);<z>
Throwable ex) {<z>
throw new SerializationFailedException("Failed to serialize object using " +<z>
().getSimpleName(), ex);<z>
) {<z>
);<z>
sseConsumer = sseConsumer;<z>
.timeout = timeout;<z>
void invokeApplicationContextInitializers(ConfigurableApplicationContext context,<z>
{<z>
initializerClasses =<z>
.getContextInitializerClasses();<z>
)) {<z>
>();<z>
getClass();<z>
initializerClass : initializerClasses) {<z>
> initializerContextClass =<z>
;<z>
context)) {<z>
(String.format(<z>
), initializerContextClass.getName(),<z>
;<z>
BeanUtils.instantiateClass(initializerClass));<z>
.sort(initializerInstances);<z>
: initializerInstances) {<z>
initializer.initialize(context);<z>
, MethodCallback mc) {<z>
getDeclaredMethods(clazz, false);<z>
Method method : methods) {<z>
mc.doWith(method);<z>
IllegalAccessException ex) {<z>
);<z>
getPath() {<z>
= PATH_DELIMITER_STRING;<z>
new StringJoiner(delimiter, delimiter, "");<z>
.pathSegments) {<z>
);<z>
return pathBuilder.toString();<z>
ModelMBean createAndConfigureMBean(Object managedResource, String beanKey)<z>
{<z>
ModelMBean mbean = createModelMBean();<z>
getMBeanInfo(managedResource, beanKey));<z>
;<z>
;<z>
ex) {<z>
new MBeanExportException("Could not create ModelMBean for managed resource [" +<z>
"'", ex);<z>
ResolvableType getElementType(ReactiveAdapter adapter, ResolvableType genericType) {<z>
adapter.isNoValue()) {<z>
.class);<z>
else if (genericType != ResolvableType.NONE) {<z>
return genericType;<z>
class);<z>
{<z>
createBeanDefinitionDocumentReader();<z>
= getRegistry().getBeanDefinitionCount();<z>
, createReaderContext(resource));<z>
- countBefore;<z>
extends MimeType> mimeTypes) {<z>
: mimeTypes) {<z>
) {<z>
return true;<z>
false;<z>
{<z>
();<z>
) {<z>
.getConnection() +<z>
"] rollback-only");<z>
();<z>
parameter, NativeWebRequest request)<z>
{<z>
);<z>
) {<z>
pathPatterns);<z>
add(registration);<z>
registration;<z>
Nullable Class<?> clazz) {<z>
{<z>
;<z>
);<z>
> iface : implementedInterfaces) {<z>
) {<z>
;<z>
;<z>
{<z>
flush();<z>
;<z>
setCommitted(true);<z>
double[] array) {<z>
(array == null) {<z>
return 0;<z>
;<z>
array) {<z>
* hash + Double.hashCode(element);<z>
hash;<z>
{<z>
?<z>
.getClass(), name) :<z>
));<z>
@Nullable Map<?, ?> context)<z>
{<z>
return mapRow(rs, rowNum);<z>
) {<z>
if (type == null) {<z>
.NONE;<z>
).getGeneric();<z>
SqlParameter param,<z>
throws SQLException {<z>
), inValue);<z>
RuntimeBeanReference(String beanName, boolean toParent) {<z>
hasText(beanName, "'beanName' must not be empty");<z>
;<z>
.beanType = null;<z>
;<z>
public void onApplicationEvent(ContextRefreshedEvent event) {<z>
isEmpty()) {<z>
.applicationContext);<z>
{<z>
(<z>
));<z>
addAll(this.applicationListeners);<z>
{<z>
BeanFactory beanFactory = getBeanFactory();<z>
.applicationListenerBeans) {<z>
?> listener =<z>
;<z>
{<z>
);<z>
{<z>
);<z>
allListeners;<z>
default ExecutionPhase.BEFORE_TEST_METHOD;<z>
SqlConfig config() default @SqlConfig;<z>
{<z>
String... headerValues) {<z>
headerValues) {<z>
).add(headerName, headerValue);<z>
return this;<z>
,<z>
,<z>
serverTransportType, SockJsMessageCodec codec) {<z>
);<z>
;<z>
Assert.notNull(serverTransportType, "TransportType is required");<z>
notNull(codec, "SockJsMessageCodec is required");<z>
;<z>
));<z>
);<z>
.transport = transport;<z>
this.serverTransportType = serverTransportType;<z>
this.codec = codec;<z>
visitFrameEnd() {<z>
previousFrame != null) {<z>
(stackMapTableEntries == null) {<z>
new ByteVector();<z>
;<z>
stackMapTableNumberOfEntries;<z>
currentFrame;<z>
null;<z>
beanFactory) {<z>
(!(beanFactory instanceof ConfigurableBeanFactory cbf)) {<z>
beanFactory);<z>
.scopedTargetSource.setBeanFactory(beanFactory);<z>
new ProxyFactory();<z>
pf.copyFrom(this);<z>
.setTargetSource(this.scopedTargetSource);<z>
notNull(this.targetBeanName, "Property 'targetBeanName' is required");<z>
this.targetBeanName);<z>
) {<z>
new IllegalStateException("Cannot create scoped proxy for bean '" + this.targetBeanName +<z>
"': Target type could not be determined at the time of proxy creation.");<z>
))) {<z>
getBeanClassLoader()));<z>
scopedTargetSource.getTargetBeanName());<z>
(scopedObject));<z>
(AopInfrastructureBean.class);<z>
;<z>
() {<z>
) ||<z>
introspectedClass.getDeclaringClass() != null &&<z>
))));<z>
,<z>
Object... providedArgs) throws Exception {<z>
= invokeForRequest(webRequest, mavContainer, providedArgs);<z>
setResponseStatus(webRequest);<z>
returnValue == null) {<z>
null || mavContainer.isRequestHandled()) {<z>
);<z>
true);<z>
(getResponseStatusReason())) {<z>
.setRequestHandled(true);<z>
setRequestHandled(false);<z>
(this.returnValueHandlers != null, "No return value handlers");<z>
(<z>
returnValue), mavContainer, webRequest);<z>
) {<z>
logger.isTraceEnabled()) {<z>
(returnValue), ex);<z>
;<z>
) {<z>
{<z>
return null;<z>
lastIndexOf(EXTENSION_SEPARATOR);<z>
-1) {<z>
;<z>
int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);<z>
(folderIndex > extIndex) {<z>
null;<z>
.substring(extIndex + 1);<z>
int chunkSize, boolean outputStreaming) {<z>
this.connection = connection;<z>
this.chunkSize = chunkSize;<z>
this.outputStreaming = outputStreaming;<z>
, HttpInputMessage inputMessage)<z>
HttpMessageNotReadableException {<z>
parameterizedType = (ParameterizedType) type;<z>
) parameterizedType.getRawType());<z>
0];<z>
createUnmarshaller(elementClass);<z>
.getBody());<z>
);<z>
XMLStreamReader.END_DOCUMENT) {<z>
XmlRootElement.class)) {<z>
(streamReader));<z>
(XmlType.class)) {<z>
streamReader, elementClass).getValue());<z>
throw new HttpMessageNotReadableException(<z>
, inputMessage);<z>
= moveToNextElement(streamReader);<z>
result;<z>
ex) {<z>
HttpMessageNotReadableException(<z>
(), ex, inputMessage);<z>
ex) {<z>
new HttpMessageNotReadableException(<z>
ex, inputMessage);<z>
ex) {<z>
ex);<z>
{<z>
getOperation().getExceptionCacheResolver();<z>
) {<z>
));<z>
;<z>
message, HttpMethod httpMethod, URI uri) {<z>
isDebugEnabled()) {<z>
uri));<z>
) {<z>
> 0) {<z>
outputStack[--outputStackTop];<z>
{<z>
return STACK_KIND | -(--outputStackStart);<z>
) {<z>
type);<z>
if (formatter != null) {<z>
formatter;<z>
(type);<z>
type).createDateTimeFormatter(fallbackFormatter);<z>
release() {<z>
!= null) {<z>
;<z>
;<z>
) {<z>
logger.warn("Could not complete unfinished transaction on endpoint release", ex);<z>
() {<z>
while (true) {<z>
.pendingMessages.poll();<z>
== null) {<z>
release();<z>
ServerHttpResponse response,<z>
{<z>
);<z>
(AbstractHttpSockJsSession) wsSession;<z>
;<z>
(String message) throws SockJsTransportFailureException {<z>
.responseLock) {<z>
add(message);<z>
(logger.isTraceEnabled()) {<z>
+ getId());<z>
() && this.readyToSend) {<z>
if (logger.isTraceEnabled()) {<z>
.trace("Session is active, ready to flush.");<z>
;<z>
);<z>
{<z>
);<z>
(<z>
, ConstructorArgumentValues cargs, MutablePropertyValues pvs) {<z>
cargs, pvs);<z>
this.parentName = parentName;<z>
) {<z>
) {<z>
null);<z>
, @Nullable Object right) throws SpelEvaluationException {<z>
== null) {<z>
? 0 : -1);<z>
null) {<z>
;<z>
instanceof Number leftNumber && right instanceof Number rightNumber) {<z>
BigDecimal || rightNumber instanceof BigDecimal) {<z>
class);<z>
(rightNumber, BigDecimal.class);<z>
compareTo(rightBigDecimal);<z>
instanceof Double || rightNumber instanceof Double) {<z>
));<z>
) {<z>
floatValue());<z>
) {<z>
, BigInteger.class);<z>
, BigInteger.class);<z>
;<z>
Long) {<z>
, rightNumber.longValue());<z>
rightNumber instanceof Integer) {<z>
(), rightNumber.intValue());<z>
(leftNumber instanceof Short || rightNumber instanceof Short) {<z>
.shortValue());<z>
|| rightNumber instanceof Byte) {<z>
byteValue());<z>
), rightNumber.doubleValue());<z>
Comparable) {<z>
) left).compareTo(right);<z>
(ClassCastException ex) {<z>
, right.getClass());<z>
.getClass());<z>
void destroy() {<z>
target != null) {<z>
destroy();<z>
PathMatchConfigurer configurer) {<z>
);<z>
);<z>
if (useTrailingSlashMatch != null) {<z>
(useTrailingSlashMatch);<z>
configurer.isUseCaseSensitiveMatch();<z>
null) {<z>
);<z>
private static RequestUpgradeStrategy initUpgradeStrategy() {<z>
String className;<z>
if (tomcatPresent) {<z>
;<z>
(jettyPresent) {<z>
"JettyRequestUpgradeStrategy";<z>
if (undertowPresent) {<z>
className = "UndertowRequestUpgradeStrategy";<z>
else if (reactorNettyPresent) {<z>
= "ReactorNettyRequestUpgradeStrategy";<z>
;<z>
= "org.springframework.web.reactive.socket.server.upgrade." + className;<z>
());<z>
).newInstance();<z>
) {<z>
new IllegalStateException(<z>
"Failed to instantiate RequestUpgradeStrategy: " + className, ex);<z>
) {<z>
);<z>
{<z>
&&<z>
instanceof TypeElement) {<z>
.add((TypeElement) element);<z>
list;<z>
void destroy() throws BeansException {<z>
.cachedFactory != null) {<z>
this.cachedFactory.close();<z>
@Nullable Object value) {<z>
if (name != null) {<z>
) {<z>
.put(name, value);<z>
.variables.remove(name);<z>
public Object resolveArgumentValue(<z>
) {<z>
.getParameterType());<z>
();<z>
? headers : headers.toSingleValueMap());<z>
parameter) {<z>
getNestedParameterType().getSimpleName();<z>
"' of type " + type;<z>
reason, parameter);<z>
AnnotatedElement EMPTY_ANNOTATED_ELEMENT = new AnnotatedElement() {<z>
) {<z>
null;<z>
) {<z>
return new Annotation[0];<z>
public Annotation[] getDeclaredAnnotations() {<z>
0];<z>
int hashCode() {<z>
(this.from);<z>
(this.replyTo);<z>
.nullSafeHashCode(this.to);<z>
ObjectUtils.nullSafeHashCode(this.cc);<z>
.bcc);<z>
.nullSafeHashCode(this.sentDate);<z>
nullSafeHashCode(this.subject);<z>
return hashCode;<z>
neededCapacity) {<z>
, "'neededCapacity' must >= 0");<z>
neededCapacity == CAPACITY_THRESHOLD) {<z>
CAPACITY_THRESHOLD;<z>
(neededCapacity > CAPACITY_THRESHOLD) {<z>
neededCapacity / CAPACITY_THRESHOLD * CAPACITY_THRESHOLD;<z>
CAPACITY_THRESHOLD) {<z>
MAX_CAPACITY;<z>
CAPACITY_THRESHOLD;<z>
newCapacity;<z>
int newCapacity = 64;<z>
(newCapacity < neededCapacity) {<z>
newCapacity <<= 1;<z>
Math.min(newCapacity, MAX_CAPACITY);<z>
createScheduler(SchedulerFactory schedulerFactory, @Nullable String schedulerName)<z>
{<z>
= Thread.currentThread();<z>
);<z>
!= null &&<z>
getClassLoader() != threadContextClassLoader);<z>
overrideClassLoader) {<z>
getClassLoader());<z>
repository = SchedulerRepository.getInstance();<z>
synchronized (repository) {<z>
lookup(schedulerName) : null);<z>
Scheduler newScheduler = schedulerFactory.getScheduler();<z>
newScheduler == existingScheduler) {<z>
("Active Scheduler of name '" + schedulerName + "' already registered " +<z>
;<z>
exposeSchedulerInRepository) {<z>
));<z>
;<z>
{<z>
currentThread.setContextClassLoader(threadContextClassLoader);<z>
locale) {<z>
();<z>
locale != null) {<z>
.locales.add(locale);<z>
return this;<z>
, int capacity) {<z>
.notNull(collectionType, "Collection type must not be null");<z>
.isInterface()) {<z>
|| Collection.class == collectionType) {<z>
>(capacity);<z>
List.class == collectionType) {<z>
(capacity);<z>
class == collectionType) {<z>
>();<z>
.getName());<z>
.isAssignableFrom(collectionType)) {<z>
, "Cannot create EnumSet for unknown element type");<z>
elementType));<z>
)) {<z>
+ collectionType.getName());<z>
collectionType).newInstance();<z>
(Throwable ex) {<z>
(<z>
), ex);<z>
Annotation> select(<z>
<Annotation> candidate) {<z>
() == 0) {<z>
;<z>
;<z>
{<z>
(databaseName);<z>
logger.isDebugEnabled()) {<z>
"Caching SQL error codes for DataSource [" + identify(dataSource) +<z>
);<z>
dataSource, sec);<z>
;<z>
(List<Method> aliases) {<z>
= this;<z>
!= null) {<z>
= aliases.size();<z>
0; j < size; j++) {<z>
aliases.get(j));<z>
{<z>
(additional);<z>
mapping.source;<z>
, Method method) {<z>
handlerMethod;<z>
handler instanceof String) {<z>
context = getApplicationContext();<z>
(context != null, "ApplicationContext is required for resolving handler bean names");<z>
= (String) handler;<z>
);<z>
;<z>
;<z>
Class<?> source,<z>
, AnnotationsProcessor<C, R> processor) {<z>
switch (searchStrategy) {<z>
:<z>
context, source, processor);<z>
case INHERITED_ANNOTATIONS:<z>
source, searchStrategy, processor);<z>
case SUPERCLASS:<z>
);<z>
TYPE_HIERARCHY:<z>
, false);<z>
TYPE_HIERARCHY_AND_ENCLOSING_CLASSES:<z>
, processor, true, true);<z>
searchStrategy);<z>
startInternal() {<z>
.bind().block();<z>
getPort());<z>
;<z>
String name, Object value, int age) {<z>
this.name = name;<z>
value = value;<z>
.age = age;<z>
visit(<z>
final int version,<z>
int access,<z>
name,<z>
,<z>
,<z>
interfaces) {<z>
Opcodes.ACC_RECORD) != 0) {<z>
);<z>
) {<z>
);<z>
addBootstrapMethod(<z>
Object... bootstrapMethodArguments) {<z>
bootstrapMethods;<z>
) {<z>
);<z>
.length;<z>
];<z>
{<z>
index;<z>
.length;<z>
.putShort(<z>
getTag(),<z>
bootstrapMethodHandle.getOwner(),<z>
.getName(),<z>
,<z>
bootstrapMethodHandle.isInterface())<z>
index);<z>
bootstrapMethodsAttribute.putShort(numBootstrapArguments);<z>
; i++) {<z>
.putShort(bootstrapMethodArgumentIndexes[i]);<z>
length - bootstrapMethodOffset;<z>
();<z>
{<z>
.hashCode();<z>
;<z>
;<z>
clientInboundChannel, MessageChannel clientOutboundChannel) {<z>
);<z>
;<z>
clientInboundChannel;<z>
clientOutboundChannel = clientOutboundChannel;<z>
boolean equals(@Nullable Object other) {<z>
{<z>
;<z>
instanceof ByteRange otherRange)) {<z>
return false;<z>
otherRange.firstPos &&<z>
otherRange.lastPos));<z>
() {<z>
reactorPresent) {<z>
().registerAdapters(this);<z>
(rxjava3Present) {<z>
RxJava3Registrar().registerAdapters(this);<z>
) {<z>
CoroutinesRegistrar().registerAdapters(this);<z>
mutinyPresent) {<z>
;<z>
supportedMediaTypes) {<z>
.notNull(supportedMediaTypes, "'supportedMediaTypes' must not be null");<z>
.noNullElements(supportedMediaTypes, "'supportedMediaTypes' must not contain null elements");<z>
.supportedMediaTypes, supportedMediaTypes);<z>
) {<z>
Assert.notNull(transformer, "The provided ResourceTransformer should not be null");<z>
this.transformers.add(transformer);<z>
instanceof CssLinkResourceTransformer) {<z>
true;<z>
this;<z>
classLoader) throws IOException {<z>
SimpleAnnotationMetadataReadingVisitor(classLoader);<z>
visitor, PARSING_OPTIONS);<z>
;<z>
visitor.getMetadata();<z>
> resolveInitializerClasses(<z>
{<z>
);<z>
<>();<z>
ContextConfigurationAttributes configAttributes : configAttributesList) {<z>
.isTraceEnabled()) {<z>
logger.trace("Processing context initializers for configuration attributes " + configAttributes);<z>
, configAttributes.getInitializers());<z>
configAttributes.isInheritInitializers()) {<z>
return initializerClasses;<z>
{<z>
this.logger.isInfoEnabled()) {<z>
exception);<z>
(<z>
CacheEvictOperation operation, @Nullable Object result) {<z>
Object key = null;<z>
cache : context.getCaches()) {<z>
operation.isCacheWide()) {<z>
null);<z>
);<z>
) {<z>
result);<z>
logInvalidating(context, operation, key);<z>
());<z>
registerHttpHandler(String contextPath, HttpHandler handler) {<z>
(this.handlerMap == null) {<z>
<>();<z>
);<z>
rbd) {<z>
getDecoratedDefinition();<z>
ConfigurableListableBeanFactory clbf) {<z>
.getBeanName())) {<z>
decDef.getBeanName());<z>
if (dbd instanceof RootBeanDefinition) {<z>
;<z>
return null;<z>
ex,<z>
Object handler) throws IOException {<z>
);<z>
);<z>
text) throws IllegalArgumentException {<z>
.hasText(text)) {<z>
setValue(null);<z>
.length() != this.exactDateLength) {<z>
throw new IllegalArgumentException(<z>
+ "characters long");<z>
dateFormat.parse(text));<z>
catch (ParseException ex) {<z>
.getMessage(), ex);<z>
parseMergeAttribute(Element collectionElement) {<z>
);<z>
)) {<z>
.defaults.getMerge();<z>
TRUE_VALUE.equals(value);<z>
OutputStream getBodyInternal(HttpHeaders headers) throws IOException {<z>
== null) {<z>
{<z>
);<z>
{<z>
(contentLength);<z>
this.chunkSize);<z>
.connection, headers);<z>
connect();<z>
.connection.getOutputStream();<z>
;<z>
protected NumberFormat getNumberFormat(Locale locale) {<z>
getCurrencyInstance(locale);<z>
;<z>
.fractionDigits);<z>
.setMinimumFractionDigits(this.fractionDigits);<z>
(this.roundingMode != null) {<z>
(this.roundingMode);<z>
currency != null) {<z>
setCurrency(this.currency);<z>
!= null) {<z>
.pattern);<z>
return format;<z>
) {<z>
servletInstance != null) {<z>
.destroy();<z>
[] parentResult, HierarchicalBeanFactory hbf) {<z>
parentResult.length == 0) {<z>
result;<z>
.length + parentResult.length);<z>
(Arrays.asList(result));<z>
for (String beanName : parentResult) {<z>
{<z>
;<z>
toStringArray(merged);<z>
classLoader) {<z>
.getName()));<z>
ex) {<z>
false;<z>
private Deque<VariableScope> initVariableScopes() {<z>
{<z>
);<z>
;<z>
;<z>
startInternal() {<z>
lifecycle.isRunning()) {<z>
.start();<z>
.startInternal();<z>
?> getObjectType() {<z>
{<z>
this.singletonInstance != null) {<z>
singletonInstance.getClass();<z>
[] ifcs = getProxiedInterfaces();<z>
.length == 1) {<z>
0];<z>
> 1) {<z>
ifcs);<z>
.beanFactory != null) {<z>
);<z>
getTargetClass();<z>
handlerType) {<z>
(handlerType,<z>
MethodIntrospector.MetadataLookup<MessageExceptionHandler>) method -><z>
(method, MessageExceptionHandler.class));<z>
new HashMap<>();<z>
()) {<z>
.getKey();<z>
.value()));<z>
)) {<z>
addAll(getExceptionsFromMethodSignature(method));<z>
> exceptionType : exceptionTypes) {<z>
method);<z>
oldMethod.equals(method)) {<z>
new IllegalStateException("Ambiguous @ExceptionHandler method mapped for [" +<z>
;<z>
return result;<z>
response,<z>
sockJsSession) throws SockJsException {<z>
.isNew()) {<z>
)) {<z>
());<z>
request));<z>
) {<z>
()) {<z>
;<z>
frame = SockJsFrame.closeFrameGoAway();<z>
));<z>
(IOException ex) {<z>
, ex);<z>
{<z>
.isTraceEnabled()) {<z>
+ getTransportType() + " async request.");<z>
response, getFrameFormat(request));<z>
(logger.isDebugEnabled()) {<z>
+ getTransportType() + " connection still open for " + sockJsSession);<z>
);<z>
SockJsFrame.CHARSET));<z>
) {<z>
sockJsSession.getId(), ex);<z>
[] parameterInfoToTypes(<z>
ClassLoader classLoader)<z>
ClassNotFoundException {<z>
;<z>
&& paramInfo.length > 0) {<z>
];<z>
x < paramInfo.length; x++) {<z>
getType(), classLoader);<z>
return types;<z>
{<z>
Throwable endpointEx = null;<z>
;<z>
) {<z>
(null);<z>
ex) {<z>
);<z>
);<z>
| Error ex) {<z>
;<z>
ex);<z>
ex;<z>
) {<z>
);<z>
ResourceException ex) {<z>
endpointEx == null) {<z>
new JmsResourceException(ex);<z>
Object... values) throws DataAccessException {<z>
session -> {<z>
session.createQuery(queryString);<z>
);<z>
values != null) {<z>
length; i++) {<z>
]);<z>
;<z>
);<z>
(@Nullable Object other) {<z>
this == other) {<z>
return true;<z>
that)) {<z>
false;<z>
.mm2));<z>
public HandlerMethodArgumentResolverComposite addResolvers(<z>
... resolvers) {<z>
resolvers != null) {<z>
argumentResolvers, resolvers);<z>
return this;<z>
) {<z>
, "Left RequestPredicate must not be null");<z>
.notNull(right, "Right RequestPredicate must not be null");<z>
.left = left;<z>
right;<z>
void afterPropertiesSet() {<z>
getCacheOperationSource();<z>
CacheResultInterceptor(getErrorHandler());<z>
getErrorHandler());<z>
);<z>
;<z>
initialized = true;<z>
transactionManager,<z>
) {<z>
transactionManager = transactionManager;<z>
.transactionAttribute = transactionAttribute;<z>
joinpointIdentification = joinpointIdentification;<z>
paramName, Object value)<z>
{<z>
{value});<z>
() {<z>
;<z>
!= null) {<z>
;<z>
code;<z>
handler) {<z>
;<z>
subProtocols = null;<z>
(handlerToCheck instanceof SubProtocolCapable) {<z>
handlerToCheck).getSubProtocols();<z>
);<z>
() throws IllegalStateException {<z>
.scheduledExecutor instanceof ScheduledThreadPoolExecutor,<z>
"No ScheduledThreadPoolExecutor available");<z>
this.scheduledExecutor;<z>
() {<z>
if (this.server == null) {<z>
this.server = JmxUtils.locateMBeanServer();<z>
ClassUtils.isPresent("com.fasterxml.jackson.databind.ObjectMapper", classLoader) &&<z>
;<z>
ClassUtils.isPresent("com.google.gson.Gson", classLoader);<z>
"jakarta.json.bind.Jsonb", classLoader);<z>
= ClassUtils.isPresent("jakarta.validation.Validator", classLoader);<z>
(Element element, ParserContext context) {<z>
(element);<z>
);<z>
(compDefinition);<z>
getChildElementByTagName(element, "client-inbound-channel");<z>
context, source);<z>
= DomUtils.getChildElementByTagName(element, "client-outbound-channel");<z>
("clientOutboundChannel", channelElem, context, source);<z>
(element, "broker-channel");<z>
("brokerChannel", channelElem, context, source);<z>
source);<z>
source);<z>
= registerMessageConverter(element, context, source);<z>
;<z>
, source);<z>
, brokerChannel,<z>
context, source);<z>
;<z>
context, source);<z>
(element, "stomp-endpoint")) {<z>
, stompHandler, context, source);<z>
= endpointElem.getAttribute("path");<z>
(pathAttribute, "Invalid <stomp-endpoint> (no path mapping)");<z>
(pathAttribute, ",")) {<z>
= path.trim();<z>
);<z>
"sockjs") != null) {<z>
? path + "**" : path + "/**");<z>
);<z>
new SimpSessionScope());<z>
);<z>
add("scopes", scopeMap);<z>
source);<z>
;<z>
context.popAndRegisterContainingComponent();<z>
return null;<z>
createSession(<z>
, Object> attributes) {<z>
;<z>
String name) {<z>
request, name);<z>
{<z>
int[0];<z>
{<z>
class == clazz ||<z>
Byte.class == clazz ||<z>
||<z>
class == clazz ||<z>
class == clazz ||<z>
Float.class == clazz ||<z>
clazz);<z>
, HttpServletRequest request,<z>
throws Exception {<z>
getEngine();<z>
String url = getUrl();<z>
;<z>
(url);<z>
<String, String> templateLoader = path -> {<z>
getTemplate(path);<z>
(IOException ex) {<z>
(ex);<z>
getLocale(request);<z>
), locale, templateLoader, url);<z>
html;<z>
) {<z>
();<z>
;<z>
model.put("renderingContext", context);<z>
= engine.eval(template, bindings);<z>
(this.renderObject != null) {<z>
);<z>
);<z>
);<z>
);<z>
) {<z>
ex));<z>
String attrName)<z>
throws AttributeNotFoundException, MBeanException, ReflectionException {<z>
.getContextClassLoader();<z>
().setContextClassLoader(this.managedResourceClassLoader);<z>
;<z>
.setContextClassLoader(currentClassLoader);<z>
String defaultMessage, Locale locale) {<z>
if (this.parentMessageSource != null) {<z>
defaultMessage, locale);<z>
(defaultMessage != null) {<z>
locale);<z>
;<z>
{<z>
-> {<z>
;<z>
;<z>
(<z>
{<z>
);<z>
) {<z>
) {<z>
return true;<z>
(!(other instanceof SimpSubscription otherSubscription)) {<z>
;<z>
.equals(otherSubscription.getId()) &&<z>
.getId()));<z>
{<z>
> snapshot;<z>
registeredBeans) {<z>
registeredBeans);<z>
isEmpty()) {<z>
.debug("Unregistering JMX-exposed beans");<z>
) {<z>
);<z>
public DummyFactory() {<z>
TestBean();<z>
SINGLETON_NAME);<z>
.testBean.setAge(25);<z>
(DataBuffer delegateBuffer) {<z>
= new LeakAwareDataBuffer(delegateBuffer, this);<z>
this.trackCreated.get()) {<z>
);<z>
return dataBuffer;<z>
(final Entry entry) {<z>
) {<z>
= entries.length;<z>
int newCapacity = currentCapacity * 2 + 1;<z>
;<z>
>= 0; --i) {<z>
i];<z>
currentEntry != null) {<z>
;<z>
.next;<z>
currentEntry.next = newEntries[newCurrentEntryIndex];<z>
] = currentEntry;<z>
nextEntry;<z>
= newEntries;<z>
;<z>
.hashCode % entries.length;<z>
entry.next = entries[index];<z>
;<z>
Method method) {<z>
function = ReflectJvmMapping.getKotlinFunction(method);<z>
) {<z>
.getReturnType());<z>
) {<z>
return method.getGenericReturnType();<z>
? extends Annotation> annotationType) {<z>
||<z>
{<z>
.isAnnotationPresent(annotationType);<z>
.isPresent(annotationType);<z>
(int queueCapacity) {<z>
if (queueCapacity > 0) {<z>
new LinkedBlockingQueue<>(queueCapacity);<z>
<>();<z>
) {<z>
new CallCountingTransactionManager();<z>
;<z>
tm;<z>
getRequestUri(HttpServletRequest request) {<z>
INCLUDE_REQUEST_URI_ATTRIBUTE);<z>
{<z>
.getRequestURI();<z>
return uri;<z>
AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) {<z>
BeanDefinitionBuilder.genericBeanDefinition();<z>
;<z>
{<z>
(parentName);<z>
> beanClass = getBeanClass(element);<z>
{<z>
.setBeanClass(beanClass);<z>
element);<z>
(beanClassName != null) {<z>
);<z>
extractSource(element));<z>
getContainingBeanDefinition();<z>
(containingBd != null) {<z>
containingBd.getScope());<z>
if (parserContext.isDefaultLazyInit()) {<z>
);<z>
builder);<z>
.getBeanDefinition();<z>
<?> annotation,<z>
) {<z>
isPresent()) {<z>
return null;<z>
return annotation.asAnnotationAttributes(<z>
values(classValuesAsString, nestedAnnotationsAsMap));<z>
) {<z>
if (this == other) {<z>
true;<z>
otherComp)) {<z>
return false;<z>
getScheme()) &&<z>
ssp, otherComp.ssp) &&<z>
);<z>
(final Label subroutineCaller) {<z>
= EMPTY_LIST;<z>
= this;<z>
= EMPTY_LIST;<z>
(listOfBlocksToProcess != EMPTY_LIST) {<z>
Label basicBlock = listOfBlocksToProcess;<z>
;<z>
listOfProcessedBlocks;<z>
basicBlock;<z>
((basicBlock.flags & FLAG_SUBROUTINE_END) != 0<z>
!= subroutineCaller.subroutineId) {<z>
basicBlock.outgoingEdges =<z>
(<z>
.outputStackSize,<z>
,<z>
basicBlock.outgoingEdges);<z>
listOfBlocksToProcess);<z>
EMPTY_LIST) {<z>
= listOfProcessedBlocks.nextListElement;<z>
= null;<z>
;<z>
processSource(Source source) {<z>
(source) || source instanceof DOMSource) {<z>
return source;<z>
null;<z>
= null;<z>
if (source instanceof SAXSource saxSource) {<z>
.getXMLReader();<z>
inputSource = saxSource.getInputSource();<z>
instanceof StreamSource streamSource) {<z>
) {<z>
getInputStream());<z>
) {<z>
getReader());<z>
streamSource.getSystemId());<z>
(xmlReader == null) {<z>
();<z>
(true);<z>
));<z>
String name = "http://xml.org/sax/features/external-general-entities";<z>
.setFeature(name, isProcessExternalEntities());<z>
= saxParserFactory.newSAXParser();<z>
.getXMLReader();<z>
()) {<z>
NO_OP_ENTITY_RESOLVER);<z>
);<z>
) {<z>
, ex);<z>
source;<z>
?>> assignableTypes,<z>
annotations) {<z>
unmodifiableSet(basePackages);<z>
.assignableTypes = Collections.unmodifiableList(assignableTypes);<z>
.annotations = Collections.unmodifiableList(annotations);<z>
{<z>
=<z>
;<z>
aspectJAnnotation == null) {<z>
= false;<z>
isAfterAdvice = false;<z>
.getAnnotationType()) {<z>
:<z>
case AtAround:<z>
this.isBeforeAdvice = false;<z>
isAfterAdvice = false;<z>
case AtBefore:<z>
isBeforeAdvice = true;<z>
isAfterAdvice = false;<z>
AtAfter:<z>
AtAfterReturning:<z>
:<z>
= false;<z>
this.isAfterAdvice = true;<z>
super T> action) {<z>
.rs.next()) {<z>
;<z>
return true;<z>
false;<z>
SQLException ex) {<z>
new InvalidResultSetAccessException(ex);<z>
String targetUrl,<z>
String> uriVariables) {<z>
);<z>
);<z>
(!found) {<z>
new StringBuilder(targetUrl);<z>
StringBuilder();<z>
endLastMatch = 0;<z>
(found) {<z>
.group(1);<z>
(name));<z>
;<z>
());<z>
));<z>
();<z>
;<z>
);<z>
result;<z>
) {<z>
= type.getName();<z>
()) {<z>
) {<z>
:<z>
return "I";<z>
:<z>
) {<z>
"B";<z>
{<z>
return "C";<z>
(name.equals("long")) {<z>
;<z>
{<z>
;<z>
:<z>
(name.equals("float")) {<z>
return "F";<z>
name.equals("short")) {<z>
return "S";<z>
case 6:<z>
.equals("double")) {<z>
"D";<z>
case 7:<z>
if (name.equals("boolean")) {<z>
return "Z";<z>
'[') {<z>
);<z>
.endsWith(";")) {<z>
, '/');<z>
;<z>
return "";<z>
wac) {<z>
).getInitParameter(ContextLoader.GLOBAL_INITIALIZER_CLASSES_PARAM);<z>
null) {<z>
(globalClassNames, INIT_PARAM_DELIMITERS)) {<z>
className, wac));<z>
) {<z>
) {<z>
className, wac));<z>
(this.contextInitializers);<z>
{<z>
);<z>
{<z>
StringBuilder(input.length());<z>
(); i++) {<z>
ch = input.charAt(i);<z>
) {<z>
(ch);<z>
{<z>
;<z>
();<z>
context) {<z>
.currentMethodDescriptor;<z>
[] locals = context.currentFrameLocalTypes;<z>
int numLocal = 0;<z>
== 0) {<z>
context.currentMethodName)) {<z>
locals[numLocal++] = Opcodes.UNINITIALIZED_THIS;<z>
} else {<z>
.charBuffer);<z>
int currentMethodDescritorOffset = 1;<z>
(true) {<z>
currentArgumentDescriptorStartOffset = currentMethodDescritorOffset;<z>
(methodDescriptor.charAt(currentMethodDescritorOffset++)) {<z>
:<z>
'C':<z>
case 'B':<z>
'S':<z>
:<z>
numLocal++] = Opcodes.INTEGER;<z>
:<z>
Opcodes.FLOAT;<z>
'J':<z>
.LONG;<z>
case 'D':<z>
DOUBLE;<z>
'[':<z>
charAt(currentMethodDescritorOffset) == '[') {<z>
++currentMethodDescritorOffset;<z>
.charAt(currentMethodDescritorOffset) == 'L') {<z>
++currentMethodDescritorOffset;<z>
) != ';') {<z>
currentMethodDescritorOffset;<z>
++] =<z>
(<z>
;<z>
:<z>
currentMethodDescritorOffset) != ';') {<z>
++currentMethodDescritorOffset;<z>
[numLocal++] =<z>
(<z>
);<z>
;<z>
public Builder mergeFrom(<z>
input,<z>
google.protobuf.ExtensionRegistryLite extensionRegistry)<z>
throws java.io.IOException {<z>
SecondMsg parsedMessage = null;<z>
, extensionRegistry);<z>
com.google.protobuf.InvalidProtocolBufferException e) {<z>
) e.getUnfinishedMessage();<z>
throw e;<z>
{<z>
{<z>
);<z>
this;<z>
of(String type,<z>
{<z>
(metadata -> {<z>
().stream()<z>
))<z>
.orElse(null);<z>
== stereotypes.size()<z>
(stereotypes);<z>
"Candidates with type %s and stereotypes %s", type, stereotypes);<z>
void setConfigurers(List<WebSocketConfigurer> configurers) {<z>
.isEmpty(configurers)) {<z>
.configurers.addAll(configurers);<z>
> getDirectPaths() {<z>
) {<z>
;<z>
String> result = Collections.emptySet();<z>
.patterns) {<z>
pattern.hasPatternSyntax()) {<z>
>(1) : result);<z>
());<z>
result;<z>
args) throws Throwable {<z>
actualArgs = args;<z>
getParameterCount() == 0) {<z>
actualArgs = null;<z>
makeAccessible(this.aspectJAdviceMethod);<z>
);<z>
ex) {<z>
new AopInvocationException("Mismatch on arguments to advice method [" +<z>
.aspectJAdviceMethod + "]; pointcut expression [" +<z>
+ "]", ex);<z>
) {<z>
);<z>
getEntityName(Class<?> entityClass) {<z>
= ClassUtils.getShortName(entityClass);<z>
lastIndexOf('.');<z>
1) {<z>
lastDot + 1);<z>
return shortName;<z>
) throws JspException {<z>
;<z>
;<z>
)));<z>
getBindStatus().getErrorMessages();<z>
.length; i++) {<z>
];<z>
{<z>
delimiter);<z>
getDisplayString(errorMessage));<z>
endTag();<z>
> action)<z>
throws DataAccessException {<z>
csc, "CallableStatementCreator must not be null");<z>
);<z>
logger.isDebugEnabled()) {<z>
getSql(csc);<z>
);<z>
.getConnection(obtainDataSource());<z>
= null;<z>
;<z>
);<z>
= action.doInCallableStatement(cs);<z>
cs);<z>
result;<z>
SQLException ex) {<z>
instanceof ParameterDisposer) {<z>
).cleanupParameters();<z>
csc);<z>
csc = null;<z>
);<z>
;<z>
());<z>
null;<z>
);<z>
(csc instanceof ParameterDisposer) {<z>
cleanupParameters();<z>
(cs);<z>
.releaseConnection(con, getDataSource());<z>
boolean peekIdentifierToken(String identifierString) {<z>
;<z>
null) {<z>
return false;<z>
)));<z>
) throws IOException {<z>
);<z>
) {<z>
("Failed to obtain URL for file " + this.resource, ex);<z>
) {<z>
headers instanceof HttpFields.Mutable mutableHttpFields)) {<z>
"Immutable headers");<z>
key);<z>
value);<z>
oldValues;<z>
method) {<z>
method.getDeclaringClass();<z>
clazz.isInterface()) {<z>
class || clazz == SmartFactoryBean.class) &&<z>
("getObject"));<z>
factoryBeanType = null;<z>
{<z>
= SmartFactoryBean.class;<z>
isAssignableFrom(clazz)) {<z>
;<z>
).equals("getObject") &&<z>
);<z>
Object convertToInternal(<z>
headers, @Nullable Object conversionHint) {<z>
)) {<z>
));<z>
String) payload).getBytes(charset);<z>
payload;<z>
<?> beanClass) {<z>
) || beanName.length() !=<z>
{<z>
;<z>
beanClass.getName()) &&<z>
endsWith(AutowireCapableBeanFactory.ORIGINAL_INSTANCE_SUFFIX));<z>
) throws JMSException {<z>
;<z>
) {<z>
);<z>
(TopicConnectionFactory) target).createTopicConnection();<z>
;<z>
) {<z>
<ExceptionListener> copy;<z>
synchronized (connectionMonitor) {<z>
this.delegates);<z>
: copy) {<z>
ex);<z>
static DefaultUriBuilderFactory initUriTemplateHandler() {<z>
uriFactory = new DefaultUriBuilderFactory();<z>
;<z>
uriFactory;<z>
throws IOException {<z>
= dataBuffer.asByteBuffer();<z>
input.remaining();<z>
= getNativeResponse();<z>
getOutputStream()).write(input);<z>
;<z>
maximumValue) {<z>
= 0;<z>
= 1;<z>
< maximumValue) {<z>
<<= 1;<z>
++;<z>
shift;<z>
doInvokeListener(ApplicationListener listener, ApplicationEvent event) {<z>
(event);<z>
ex) {<z>
= ex.getMessage();<z>
()) ||<z>
event instanceof PayloadApplicationEvent &&<z>
.getClass()))) {<z>
= this.lazyLogger;<z>
{<z>
getClass());<z>
= loggerToUse;<z>
{<z>
);<z>
throw ex;<z>
ListenableFuture<WebSocketSession> doHandshake(WebSocketHandler webSocketHandler,<z>
uriVars) {<z>
, "'uriTemplate' must not be null");<z>
.toUri();<z>
, null, uri);<z>
) {<z>
result -> {<z>
.getResponse().getContentAsString();<z>
xmlHelper.assertXmlEqual(xmlContent, content);<z>
() {<z>
this.numberOfRemainingUnboundArguments > 1) {<z>
numberOfRemainingUnboundArguments<z>
;<z>
<>();<z>
pointcutExpression, " ");<z>
< tokens.length; i++) {<z>
].equals("this") ||<z>
("this(") ||<z>
"target") ||<z>
) {<z>
tokens, i);<z>
body.numTokensConsumed;<z>
maybeExtractVariableName(body.text);<z>
null) {<z>
.add(varName);<z>
) {<z>
;<z>
i += body.numTokensConsumed;<z>
<>();<z>
candidateVarNames);<z>
{<z>
(varName)) {<z>
);<z>
varNames.size() > 1) {<z>
varNames.size() +<z>
" candidate this(), target() or args() variables but only one unbound argument slot");<z>
{<z>
{<z>
{<z>
(0));<z>
{<z>
();<z>
(this.engine == null) {<z>
());<z>
supports(Type genericType) {<z>
if (genericType instanceof ParameterizedType parameterizedType) {<z>
&&<z>
) {<z>
= parameterizedType.getActualTypeArguments()[0];<z>
instanceof Class<?> classArgument) {<z>
||<z>
(classArgument) ||<z>
);<z>
else if (typeArgument instanceof GenericArrayType arrayType) {<z>
.TYPE == arrayType.getGenericComponentType());<z>
{<z>
);<z>
false;<z>
static EntityManager getTransactionalEntityManager(EntityManagerFactory emf)<z>
throws DataAccessResourceFailureException {<z>
, null);<z>
(InputSource inputSource, Resource resource)<z>
{<z>
Document doc = doLoadDocument(inputSource, resource);<z>
count = registerBeanDefinitions(doc, resource);<z>
.isDebugEnabled()) {<z>
"Loaded " + count + " bean definitions from " + resource);<z>
count;<z>
(BeanDefinitionStoreException ex) {<z>
throw ex;<z>
) {<z>
,<z>
+ " in XML document from " + resource + " is invalid", ex);<z>
SAXException ex) {<z>
),<z>
;<z>
) {<z>
throw new BeanDefinitionStoreException(resource.getDescription(),<z>
resource, ex);<z>
ex) {<z>
getDescription(),<z>
ex);<z>
Throwable ex) {<z>
,<z>
+ resource, ex);<z>
) {<z>
!Hints.isLoggingSuppressed(hints)) {<z>
traceDebug(logger, traceOn -> {<z>
;<z>
+ formatted + "]";<z>
;<z>
Principal principal) {<z>
, "'principal' must not be null");<z>
principal;<z>
;<z>
String, MediaType> getMediaTypeMappings() {<z>
<String, MediaType> result = null;<z>
) {<z>
MappingMediaTypeFileExtensionResolver) {<z>
;<z>
map)) {<z>
;<z>
;<z>
));<z>
,<z>
Map<String, Object> attributes) {<z>
request.getURI();<z>
HttpHeaders();<z>
.getHeaders());<z>
request.getCookies();<z>
getPrincipal();<z>
.getLogPrefix();<z>
;<z>
protocol, remoteAddress, attributes, logPrefix);<z>
create(<z>
symbolTable,<z>
,<z>
AnnotationWriter previousAnnotation) {<z>
;<z>
putShort(0);<z>
new AnnotationWriter(<z>
annotation, previousAnnotation);<z>
, Object[] args) {<z>
)) {<z>
args;<z>
]);<z>
varArgs.length];<z>
.length - 1);<z>
, varArgs.length);<z>
combinedArgs;<z>
Nullable String sql, SQLException ex) {<z>
, "Cannot translate a null SQLException");<z>
, sql, ex);<z>
{<z>
return dae;<z>
getFallbackTranslator();<z>
null) {<z>
task, sql, ex);<z>
;<z>
extends RestClientException>> seriesMapping) {<z>
CollectionUtils.isEmpty(seriesMapping)) {<z>
this.seriesMapping.putAll(seriesMapping);<z>
> entityType, ServerHttpRequest request) {<z>
.equals(entityType) ?<z>
(), request.getURI()) :<z>
));<z>
columnIndex) throws InvalidResultSetAccessException {<z>
getInt(columnIndex);<z>
(SQLException se) {<z>
throw new InvalidResultSetAccessException(se);<z>
{<z>
= getHttpClient();<z>
if (httpClient instanceof Closeable) {<z>
) httpClient).close();<z>
String body) {<z>
(body, "Body must not be null");<z>
);<z>
.<z>
s -> {<z>
);<z>
;<z>
});<z>
;<z>
throws NoSuchBeanDefinitionException {<z>
beanName = transformedBeanName(name);<z>
();<z>
)) {<z>
isPrototype(originalBeanName(name));<z>
(beanName);<z>
(mbd.isPrototype()) {<z>
, mbd));<z>
name)) {<z>
;<z>
(isFactoryBean(beanName, mbd)) {<z>
>) getBean(FACTORY_BEAN_PREFIX + beanName);<z>
) ||<z>
isSingleton());<z>
false;<z>
connect(HttpMethod method, URI uri,<z>
Mono<Void>> requestCallback) {<z>
new AtomicReference<>();<z>
this.delegate<z>
(method, uri, request -> {<z>
wrapped = new WiretapClientHttpRequest(request);<z>
;<z>
wrapped);<z>
map(response -> {<z>
;<z>
String header = WebTestClient.WEBTESTCLIENT_REQUEST_ID;<z>
getHeaders().getFirst(header);<z>
);<z>
;<z>
wrappedResponse));<z>
;<z>
;<z>
factory) {<z>
);<z>
) {<z>
ConverterFactory.class);<z>
(typeInfo == null) {<z>
"Unable to determine source type <S> and target type <T> for your " +<z>
+ "]; does the class parameterize those types?");<z>
addConverter(new ConverterFactoryAdapter(factory,<z>
1].toClass())));<z>
] classFile, final boolean hasFrames) {<z>
final Attribute[] attributes = getAttributePrototypes();<z>
= null;<z>
null;<z>
null;<z>
lastMethod = null;<z>
;<z>
null;<z>
null;<z>
= null;<z>
= null;<z>
0;<z>
;<z>
nestMemberClasses = null;<z>
;<z>
;<z>
null;<z>
null;<z>
firstAttribute = null;<z>
COMPUTE_NOTHING;<z>
0, false)<z>
(<z>
EXPAND_FRAMES : 0) | ClassReader.EXPAND_ASM_INSNS);<z>
toByteArray();<z>
initForwardedPrefix(HttpServletRequest request) {<z>
= null;<z>
= request.getHeaderNames();<z>
{<z>
;<z>
) {<z>
(name);<z>
if (result != null) {<z>
.length());<z>
;<z>
) {<z>
rawPrefix.length();<z>
1) == '/') {<z>
--;<z>
));<z>
.toString();<z>
return null;<z>
MergedAnnotations getRepeatableAnnotations(AnnotatedElement element,<z>
) {<z>
(annotationType, containerType);<z>
);<z>
{<z>
(url, "URL must not be null");<z>
null;<z>
url = url;<z>
Exception ex, HttpServletRequest request) {<z>
= null;<z>
excludedExceptions != null) {<z>
) {<z>
())) {<z>
;<z>
exceptionMappings != null) {<z>
, ex);<z>
{<z>
logger.isDebugEnabled()) {<z>
+ this.defaultErrorView + "'");<z>
this.defaultErrorView;<z>
;<z>
getLocations() {<z>
(this.locationsToUse.isEmpty()) {<z>
locationResources;<z>
.locationsToUse;<z>
void clear() {<z>
synchronizations = null;<z>
this.currentTransactionName = null;<z>
currentTransactionReadOnly = false;<z>
null;<z>
actualTransactionActive = false;<z>
{<z>
.proxy != null) {<z>
();<z>
this.proxyInterfaces.length == 1) {<z>
0];<z>
.target instanceof TargetSource) {<z>
();<z>
null) {<z>
;<z>
null;<z>
boolean shouldBeMerged(ItemMetadata itemMetadata) {<z>
;<z>
)<z>
;<z>
(String httpUrl) {<z>
.notNull(httpUrl, "HTTP URL must not be null");<z>
= HTTP_URL_PATTERN.matcher(httpUrl);<z>
()) {<z>
();<z>
group(1);<z>
);<z>
;<z>
= matcher.group(5);<z>
StringUtils.hasLength(host)) {<z>
"] is not a valid HTTP URL");<z>
.host(host);<z>
;<z>
)) {<z>
(port);<z>
(8));<z>
10));<z>
fragment = matcher.group(12);<z>
(StringUtils.hasText(fragment)) {<z>
;<z>
return builder;<z>
;<z>
, MethodParameter returnType,<z>
NativeWebRequest webRequest) throws Exception {<z>
){<z>
.addAllAttributes((Map) returnValue);<z>
) {<z>
new UnsupportedOperationException("Unexpected return type [" +<z>
getMethod());<z>
protected int writeTagContent(TagWriter tagWriter) throws JspException {<z>
;<z>
writeDefaultAttributes(tagWriter);<z>
));<z>
, getCols());<z>
, getOnselect());<z>
);<z>
, value, "textarea"));<z>
endTag();<z>
SKIP_BODY;<z>
actualCount) {<z>
(msg);<z>
= expectedCount;<z>
actualCount = actualCount;<z>
protected TimeZone getFallbackTimeZone() {<z>
{<z>
));<z>
timeZone != null) {<z>
timeZone;<z>
return null;<z>
<Cache> loadCaches() {<z>
getCacheManager();<z>
);<z>
>();<z>
: cacheManager.getCacheNames()) {<z>
(cacheName);<z>
isAllowNullValues()));<z>
;<z>
PropertyValues pvs) {<z>
MutablePropertyValues ?<z>
));<z>
doBind(mpvs);<z>
resource, String script,<z>
, String blockCommentStartDelimiter,<z>
throws ScriptException {<z>
"'script' must not be null or empty");<z>
notNull(separator, "'separator' must not be null");<z>
;<z>
{<z>
;<z>
.hasText(blockCommentStartDelimiter, "'blockCommentStartDelimiter' must not be null or empty");<z>
);<z>
();<z>
;<z>
;<z>
boolean inDoubleQuote = false;<z>
false;<z>
); i++) {<z>
.charAt(i);<z>
{<z>
inEscape = false;<z>
;<z>
c == '\\') {<z>
true;<z>
c);<z>
{<z>
;<z>
inSingleQuote && (c == '"')) {<z>
inDoubleQuote = !inDoubleQuote;<z>
) {<z>
(separator, i)) {<z>
0) {<z>
);<z>
= new StringBuilder();<z>
separator.length() - 1;<z>
startsWithAny(script, commentPrefixes, i)) {<z>
;<z>
i) {<z>
= indexOfNextNewline;<z>
, i)) {<z>
blockCommentEndDelimiter, i);<z>
(indexOfCommentEnd > i) {<z>
1;<z>
throw new ScriptParseException(<z>
, resource);<z>
c == '\n' || c == '\t') {<z>
{<z>
;<z>
(c);<z>
{<z>
;<z>
;<z>
Msg parseFrom(<z>
com.google.protobuf.ByteString data)<z>
throws com.google.protobuf.InvalidProtocolBufferException {<z>
.parseFrom(data);<z>
{<z>
ref = foo_;<z>
instanceof java.lang.String)) {<z>
ref)<z>
toStringUtf8();<z>
foo_ = s;<z>
s;<z>
} else {<z>
ref;<z>
{<z>
{<z>
requestEncoding = getCharacterEncoding();<z>
= super.getParameterMap();<z>
); nameIterator.hasNext(); ) {<z>
next();<z>
.get(name));<z>
valueIterator.hasNext(); ) {<z>
;<z>
).getBytes());<z>
value != null) {<z>
;<z>
value, requestEncoding).getBytes());<z>
)) {<z>
write('&');<z>
()) {<z>
this.cachedContent.write('&');<z>
{<z>
ex);<z>
Annotation> asyncAnnotationType) {<z>
;<z>
HashSet<>();<z>
asyncAnnotationTypes.add(asyncAnnotationType);<z>
.pointcut = buildPointcut(asyncAnnotationTypes);<z>
Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {<z>
source == null) {<z>
return null;<z>
;<z>
string);<z>
TypeDescriptor targetElementType = targetType.getElementTypeDescriptor();<z>
);<z>
);<z>
; i++) {<z>
= fields[i];<z>
targetElementType);<z>
);<z>
return target;<z>
name1, String name2) {<z>
();<z>
Signature(name1, desc);<z>
name2, desc);<z>
= new CreateInfo(c1, c2);<z>
return proxy;<z>
initSsePrettyPrinter() {<z>
printer = new DefaultPrettyPrinter();<z>
;<z>
printer;<z>
[] errorPayload,<z>
clientHeaderAccessor) {<z>
errorPayload, errorHeaderAccessor.getMessageHeaders());<z>
{<z>
other);<z>
getMessageConditions();<z>
.size(); i++) {<z>
message);<z>
if (result != 0) {<z>
;<z>
return 0;<z>
) {<z>
(lhsType, "Left-hand side type must not be null");<z>
, "Right-hand side type must not be null");<z>
lhsType) {<z>
return true;<z>
lhsType instanceof Class<?> lhsClass) {<z>
(rhsType instanceof Class<?> rhsClass) {<z>
.isAssignable(lhsClass, rhsClass);<z>
instanceof ParameterizedType rhsParameterizedType) {<z>
= rhsParameterizedType.getRawType();<z>
{<z>
, rhRawClass);<z>
rhsType instanceof GenericArrayType rhsGenericArrayType) {<z>
.getGenericComponentType();<z>
), rhsComponent);<z>
lhsType instanceof ParameterizedType lhsParameterizedType) {<z>
<?> rhsClass) {<z>
lhsParameterizedType.getRawType();<z>
?> lhsClass) {<z>
rhsClass);<z>
else if (rhsType instanceof ParameterizedType rhsParameterizedType) {<z>
isAssignable(lhsParameterizedType, rhsParameterizedType);<z>
{<z>
.getGenericComponentType();<z>
{<z>
lhsComponent, rhsClass.getComponentType());<z>
(rhsType instanceof GenericArrayType rhsGenericArrayType) {<z>
.getGenericComponentType();<z>
, rhsComponent);<z>
WildcardType lhsWildcardType) {<z>
, rhsType);<z>
;<z>
DataBuffer> encode() {<z>
?<z>
().map(this::encodeEntries) :<z>
(this.metadataEntries));<z>
String headerName) {<z>
(headerName)) {<z>
(headerName, null);<z>
) throws Throwable {<z>
.getName()) {<z>
case "equals":<z>
]);<z>
"hashCode":<z>
(proxy);<z>
case "close":<z>
;<z>
case "isClosed":<z>
();<z>
:<z>
this.target;<z>
:<z>
);<z>
case "isWrapperFor":<z>
;<z>
target, args);<z>
) {<z>
;<z>
expression, String[] fields) {<z>
;<z>
null;<z>
(fields);<z>
?> attributes) {<z>
!= null) {<z>
(key, attribute) -> {<z>
if (!containsKey(key)) {<z>
attribute);<z>
});<z>
this;<z>
, String name) {<z>
notNull(request, "Request must not be null");<z>
null) {<z>
return true;<z>
String suffix : SUBMIT_IMAGE_SUFFIXES) {<z>
null) {<z>
;<z>
return false;<z>
throws JMSException, MessageConversionException {<z>
message;<z>
.targetType) {<z>
TEXT:<z>
this.objectMapper.writer());<z>
:<z>
.writer());<z>
targetType);<z>
{<z>
+ "]", ex);<z>
);<z>
message;<z>
setApplicationContext(ApplicationContext applicationContext) {<z>
(applicationContext instanceof ConfigurableApplicationContext) {<z>
applicationContext;<z>
) throws MessagingException {<z>
T> match = null;<z>
message);<z>
ex) {<z>
(ex);<z>
== null) {<z>
empty();<z>
.mapping, match.handlerMethod, message);<z>
extends DataBuffer> collection) {<z>
addAll(index, collection);<z>
;<z>
result;<z>
{<z>
.annotationTypes;<z>
{<z>
));<z>
annotationTypes = annotationTypes;<z>
;<z>
{<z>
setDriver(driver);<z>
);<z>
);<z>
handlerMappingsLocation) {<z>
(handlerMappingsLocation, "Handler mappings location must not be null");<z>
());<z>
;<z>
... httpMethods) {<z>
);<z>
;<z>
;<z>
statusCode) {<z>
(body);<z>
Assert.notNull(statusCode, "HttpStatus is required");<z>
.status = statusCode;<z>
throws BeansException {<z>
);<z>
, propertyName);<z>
;<z>
);<z>
!= null) {<z>
keys != null) {<z>
) {<z>
tokens.keys.length);<z>
ph.isWritable()) {<z>
();<z>
(InvalidPropertyException ex) {<z>
;<z>
{<z>
List<Invocation> expectedInvocations =<z>
);<z>
> actualInvocations =<z>
)).getInvocations();<z>
, actualInvocations, argumentAdapters);<z>
(HttpServletRequest request, HttpServletResponse response)<z>
Exception {<z>
getMethod())) {<z>
));<z>
;<z>
request);<z>
;<z>
{<z>
session = request.getSession(false);<z>
(session != null) {<z>
Object mutex = WebUtils.getSessionMutex(session);<z>
{<z>
return handleRequestInternal(request, response);<z>
;<z>
String> getAnnotationTypes() {<z>
= this.annotationTypes;<z>
(annotationTypes == null) {<z>
unmodifiableSet(<z>
));<z>
= annotationTypes;<z>
annotationTypes;<z>
<?> declaringClass) {<z>
);<z>
.length != candidateMethod.getParameterCount()) {<z>
return false;<z>
candidateParameters = candidateMethod.getParameterTypes();<z>
< candidateParameters.length; i++) {<z>
, declaringClass);<z>
i];<z>
(candidateParameter.isArray()) {<z>
getComponentType().toClass())) {<z>
;<z>
{<z>
false;<z>
return true;<z>
throws InvalidResultSetAccessException {<z>
this.resultSet.getFloat(columnIndex);<z>
(SQLException se) {<z>
throw new InvalidResultSetAccessException(se);<z>
, final Label[] labels) {<z>
if (mv != null) {<z>
(dflt, keys, labels);<z>
) throws ExecutionException {<z>
.mutex) {<z>
{<z>
:<z>
.result;<z>
:<z>
instanceof ExecutionException, "Failure without exception");<z>
result;<z>
:<z>
= adapt(adapteeResult);<z>
result = adapted;<z>
state = State.SUCCESS;<z>
adapted;<z>
) {<z>
ex;<z>
.state = State.FAILURE;<z>
ex;<z>
ex) {<z>
= new ExecutionException(ex);<z>
result = execEx;<z>
;<z>
throw execEx;<z>
new IllegalStateException();<z>
renderDefaultContent(TagWriter tagWriter) throws JspException {<z>
(VALUE_VARIABLE_NAME);<z>
value);<z>
tagWriter);<z>
> matcher) {<z>
-> {<z>
();<z>
;<z>
{<z>
(beanDefinition, "BeanDefinition must not be null");<z>
beanName, "Bean name must not be null");<z>
.beanDefinition = beanDefinition;<z>
beanName;<z>
= aliases;<z>
) throws BeansException, IllegalStateException {<z>
;<z>
.notNull(handler, "Handler object must not be null");<z>
resolvedHandler = handler;<z>
;<z>
parse(urlPath);<z>
{<z>
pattern);<z>
null && existingHandler != resolvedHandler) {<z>
IllegalStateException(<z>
+ "]: " +<z>
+ " mapped.");<z>
handlerName) {<z>
(handlerName)) {<z>
obtainApplicationContext().getBean(handlerName);<z>
handlerMap.put(pattern, resolvedHandler);<z>
{<z>
));<z>
) {<z>
(getSessionMutex()) {<z>
.attributes.remove(DESTRUCTION_CALLBACK_NAME_PREFIX + name);<z>
char convertToCharacter(String entityReference) {<z>
= this.entityReferenceToCharacterMap.get(entityReference);<z>
!= null) {<z>
return referredCharacter;<z>
;<z>
AbstractHandlerMapping getHandlerMapping() {<z>
.isEmpty()) {<z>
return null;<z>
();<z>
registrations) {<z>
getRequestHandler(registration);<z>
()) {<z>
urlMap.put(pathPattern, handler);<z>
urlMap, this.order);<z>
Class<?> requiredType) {<z>
this.defaultEditorsActive) {<z>
null;<z>
(this.overriddenDefaultEditors != null) {<z>
.get(requiredType);<z>
{<z>
editor;<z>
this.defaultEditors == null) {<z>
;<z>
.get(requiredType);<z>
T getObject() throws Exception {<z>
()) {<z>
: getEarlySingletonInstance());<z>
return createInstance();<z>
List<Element> scripts, String execution) {<z>
.genericBeanDefinition(CompositeDatabasePopulator.class);<z>
;<z>
;<z>
delegates = new ManagedList<>();<z>
{<z>
;<z>
.hasText(executionAttr)) {<z>
"INIT";<z>
execution.equals(executionAttr)) {<z>
.genericBeanDefinition(ResourceDatabasePopulator.class);<z>
("ignoreFailedDrops", ignoreFailedDrops);<z>
delegate.addPropertyValue("continueOnError", continueOnError);<z>
= BeanDefinitionBuilder.genericBeanDefinition(SortedResourcesFactoryBean.class);<z>
(scriptElement.getAttribute("location")));<z>
, resourcesFactory.getBeanDefinition());<z>
("encoding"))) {<z>
getAttribute("encoding")));<z>
(element, scriptElement);<z>
null) {<z>
, new TypedStringValue(separator));<z>
getBeanDefinition());<z>
.addPropertyValue("populators", delegates);<z>
();<z>
(List<?> list) {<z>
= false;<z>
for (Object element : list) {<z>
) {<z>
;<z>
containsRuntimeRefs) {<z>
>();<z>
);<z>
return managedList;<z>
return list;<z>
, Object handler, Method method) {<z>
lock();<z>
createHandlerMethod(handler, method);<z>
, mapping);<z>
getDirectPaths(mapping);<z>
String path : directPaths) {<z>
.add(path, mapping);<z>
, method, mapping);<z>
!= null) {<z>
validateAllowCredentials();<z>
handlerMethod, corsConfig);<z>
.put(mapping,<z>
null));<z>
();<z>
String field) {<z>
field);<z>
{<z>
if (objectError instanceof FieldError fieldError) {<z>
fixedField, fieldError)) {<z>
fieldError;<z>
;<z>
) {<z>
(servletResponse instanceof HttpServletResponseWrapper) {<z>
HttpServletResponseWrapper) servletResponse).getResponse();<z>
class, servletResponse);<z>
) servletResponse;<z>
?> args) {<z>
;<z>
);<z>
);<z>
, Object> attributes) {<z>
.notNull(sessionId, "'sessionId' is required");<z>
.notNull(attributes, "'attributes' is required");<z>
this.sessionId = sessionId;<z>
this.attributes = attributes;<z>
other) {<z>
other) {<z>
return true;<z>
(!(other instanceof AspectJExpressionPointcut otherPc)) {<z>
false;<z>
&&<z>
.pointcutDeclarationScope, otherPc.pointcutDeclarationScope) &&<z>
, otherPc.pointcutParameterNames) &&<z>
.pointcutParameterTypes);<z>
setValue(Object value) {<z>
instanceof Map) {<z>
new Properties();<z>
value);<z>
super.setValue(props);<z>
(value);<z>
) {<z>
.isPattern()) {<z>
.getId();<z>
, sessionIdToSubscriptionIds) -> {<z>
;<z>
) {<z>
removeInternal(destination, sessionId, subscriptionId);<z>
});<z>
);<z>
Object> handleHttpMessageNotWritable(<z>
headers, HttpStatus status, WebRequest request) {<z>
, status, request);<z>
charset) {<z>
!= this.charset) {<z>
? charset : DEFAULT_CHARSET);<z>
);<z>
void renderMergedOutputModel(<z>
HttpServletResponse response) throws Exception {<z>
baos = createTemporaryOutputStream();<z>
PdfReader reader = readPdfResource();<z>
new PdfStamper(reader, baos);<z>
stamper, request, response);<z>
.close();<z>
response, baos);<z>
targetIsClass) {<z>
= clazz;<z>
.property = name;<z>
.targetIsClass = targetIsClass;<z>
(RuntimeException ex) {<z>
;<z>
:<z>
EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(ex));<z>
@Nullable byte[] array) {<z>
(array == null) {<z>
;<z>
.length;<z>
(length == 0) {<z>
EMPTY_ARRAY;<z>
StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);<z>
{<z>
.valueOf(b));<z>
);<z>
) {<z>
ServerResponse) result.getReturnValue();<z>
"No ServerResponse");<z>
() {<z>
<HttpMessageWriter<?>> messageWriters() {<z>
return messageWriters;<z>
{<z>
;<z>
);<z>
DataAccessException createCustomException(<z>
{<z>
0;<z>
.getConstructors();<z>
?> constructor : constructors) {<z>
constructor.getParameterTypes();<z>
== parameterTypes[0] &&<z>
MESSAGE_ONLY_CONSTRUCTOR) {<z>
MESSAGE_ONLY_CONSTRUCTOR;<z>
0] &&<z>
class == parameterTypes[1] &&<z>
MESSAGE_THROWABLE_CONSTRUCTOR) {<z>
;<z>
String.class == parameterTypes[0] &&<z>
SQLException.class == parameterTypes[1] &&<z>
constructorType < MESSAGE_SQLEX_CONSTRUCTOR) {<z>
;<z>
String.class == parameterTypes[0] &&<z>
&&<z>
{<z>
MESSAGE_SQL_THROWABLE_CONSTRUCTOR;<z>
parameterTypes[0] &&<z>
] &&<z>
) {<z>
;<z>
> exceptionConstructor;<z>
) {<z>
:<z>
.class};<z>
;<z>
;<z>
(messageAndSqlAndSqlExArgs);<z>
:<z>
class, Throwable.class};<z>
{task, sql, sqlEx};<z>
getConstructor(messageAndSqlAndThrowableArgsClass);<z>
;<z>
case MESSAGE_SQLEX_CONSTRUCTOR:<z>
;<z>
sqlEx};<z>
getConstructor(messageAndSqlExArgsClass);<z>
;<z>
MESSAGE_THROWABLE_CONSTRUCTOR:<z>
;<z>
(), sqlEx};<z>
;<z>
(messageAndThrowableArgs);<z>
:<z>
};<z>
+ ": " + sqlEx.getMessage()};<z>
(messageOnlyArgsClass);<z>
);<z>
if (logger.isWarnEnabled()) {<z>
logger.warn("Unable to find appropriate constructor of custom exception class [" +<z>
;<z>
null;<z>
{<z>
.isWarnEnabled()) {<z>
.getName() + "]", ex);<z>
return null;<z>
<?> propertySource) {<z>
();<z>
(relativePropertySourceName.equals(newPropertySourceName)) {<z>
IllegalArgumentException(<z>
;<z>
HttpServletResponse response) {<z>
) {<z>
jettyResponse;<z>
wrapper) {<z>
= (HttpServletResponse) wrapper.getResponse();<z>
;<z>
+ response.getClass() +<z>
);<z>
(<z>
BeanDefinition containingBd)<z>
BeanDefinitionStoreException {<z>
this.mergedBeanDefinitions) {<z>
= null;<z>
null;<z>
== null) {<z>
beanName);<z>
{<z>
mbd;<z>
{<z>
instanceof RootBeanDefinition) {<z>
);<z>
= new RootBeanDefinition(bd);<z>
;<z>
getParentName());<z>
!beanName.equals(parentBeanName)) {<z>
pbd = getMergedBeanDefinition(parentBeanName);<z>
getParentBeanFactory();<z>
parent instanceof ConfigurableBeanFactory) {<z>
parentBeanName);<z>
throw new NoSuchBeanDefinitionException(parentBeanName,<z>
+<z>
;<z>
{<z>
(), beanName,<z>
ex);<z>
);<z>
(bd);<z>
(mbd.getScope())) {<z>
;<z>
)) {<z>
containingBd.getScope());<z>
containingBd == null && isCacheBeanMetadata()) {<z>
;<z>
) {<z>
mbd);<z>
return mbd;<z>
... values) {<z>
(name, "Name must not be null");<z>
this.queryParams.remove(name);<z>
(!ObjectUtils.isEmpty(values)) {<z>
, values);<z>
();<z>
return this;<z>
String resolveThemeName(HttpServletRequest request) {<z>
);<z>
null) {<z>
;<z>
cookieName = getCookieName();<z>
if (cookieName != null) {<z>
request, cookieName);<z>
!= null) {<z>
;<z>
(StringUtils.hasText(value)) {<z>
= value;<z>
{<z>
);<z>
request.setAttribute(THEME_REQUEST_ATTRIBUTE_NAME, themeName);<z>
themeName;<z>
(WriteResultPublisher publisher, Throwable ex) {<z>
ex;<z>
)) {<z>
);<z>
] constructorArgTypes) {<z>
constructorArgTypes == null) {<z>
"Both 'constructorArgs' and 'constructorArgTypes' need to be specified");<z>
length != constructorArgTypes.length) {<z>
constructorArgs.length +<z>
);<z>
constructorArgs;<z>
= constructorArgTypes;<z>
Map<String, Object> headers) {<z>
headers.get(NATIVE_HEADERS);<z>
) {<z>
;<z>
(values)) {<z>
.get(0);<z>
;<z>
session) {<z>
addConnection(connection);<z>
connection);<z>
true;<z>
String parameter) throws ServletRequestBindingException {<z>
name, parameter);<z>
;<z>
(NumberFormatException ex) {<z>
new ServletRequestBindingException(<z>
+ name + "' with value of '" +<z>
;<z>
int min, int max) {<z>
(value, ",");<z>
field : fields) {<z>
)) {<z>
max);<z>
);<z>
= StringUtils.delimitedListToStringArray(field, "/");<z>
if (split.length > 2) {<z>
IllegalArgumentException("Incrementer has more than two fields: '" +<z>
;<z>
);<z>
].contains("-")) {<z>
- 1;<z>
parseInt(split[1]);<z>
(delta <= 0) {<z>
+<z>
"\"");<z>
+= delta) {<z>
;<z>
<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,<z>
> locations, ResourceResolverChain chain) {<z>
locations).map(resource -> {<z>
(exchange == null) {<z>
resource;<z>
(exchange);<z>
(acceptEncoding == null) {<z>
;<z>
this.contentCodings) {<z>
.contains(coding)) {<z>
(coding);<z>
;<z>
()) {<z>
encoded;<z>
catch (IOException ex) {<z>
) +<z>
+ "]", ex);<z>
return resource;<z>
);<z>
headers) {<z>
(logger.isDebugEnabled()) {<z>
;<z>
new HttpHeaders();<z>
(headers != null) {<z>
;<z>
;<z>
) != HttpStatus.OK) {<z>
.isErrorEnabled()) {<z>
);<z>
);<z>
()) {<z>
infoUrl + ") response: " + response);<z>
response.getBody();<z>
"");<z>
, @Nullable String nameSuffix) throws ConstantException {<z>
;<z>
.entrySet()) {<z>
.equals(value)) {<z>
getKey();<z>
suffixToUse, value);<z>
onComplete() {<z>
().flush();<z>
(null);<z>
) {<z>
.deferredResult.setErrorResult(ex);<z>
) {<z>
()) {<z>
(resource.contentLength());<z>
) {<z>
);<z>
() {<z>
();<z>
(routeMatcher != null, "No RouteMatcher set");<z>
return routeMatcher;<z>
throws NamingException {<z>
null) {<z>
class);<z>
;<z>
;<z>
{<z>
GenericTypeAwarePropertyDescriptor ?<z>
() :<z>
getWriteMethod());<z>
makeAccessible(writeMethod);<z>
.invoke(getWrappedInstance(), value);<z>
() {<z>
this.parameterIndex < 0) {<z>
getMethod();<z>
null) {<z>
void.class;<z>
.isKotlinType(getContainingClass())) {<z>
getReturnType(method);<z>
();<z>
.parameterIndex];<z>
, State newState, @Nullable DataBuffer remainder) {<z>
newState)) {<z>
()) {<z>
+ " -> " + newState);<z>
dispose();<z>
{<z>
) {<z>
newState.onNext(remainder);<z>
);<z>
();<z>
return true;<z>
(remainder);<z>
false;<z>
IllegalArgumentException {<z>
text, "'text' must not be empty");<z>
= text.trim();<z>
.indexOf(BASE_NAME_SEPARATOR);<z>
) {<z>
setValue(ResourceBundle.getBundle(name));<z>
);<z>
hasText(baseName)) {<z>
"'");<z>
;<z>
);<z>
: ResourceBundle.getBundle(baseName));<z>
PropertyValues pvs) {<z>
());<z>
);<z>
) {<z>
synchronized (this.injectionMetadataCache) {<z>
cacheKey);<z>
clazz)) {<z>
(metadata != null) {<z>
metadata.clear(pvs);<z>
clazz);<z>
);<z>
return metadata;<z>
@Nullable Object conversionHint) {<z>
getMimeType(message.getHeaders()));<z>
Object payload = message.getPayload();<z>
, charset));<z>
static boolean isSameOrigin(ServerHttpRequest request) {<z>
.getOrigin();<z>
) {<z>
true;<z>
getURI();<z>
);<z>
uri.getHost();<z>
);<z>
);<z>
notNull(actualHost, "Actual request host must not be null");<z>
-1, "Actual request port must not be undefined");<z>
(origin).build();<z>
(originUrl.getScheme()) &&<z>
(originUrl.getHost()) &&<z>
getPort()));<z>
applyDefaultResultActions(MvcResult mvcResult) throws Exception {<z>
handler : this.defaultResultHandlers) {<z>
(mvcResult);<z>
{<z>
.match(mvcResult);<z>
) {<z>
LoadTimeWeaver serverSpecificLoadTimeWeaver = createServerSpecificLoadTimeWeaver(classLoader);<z>
null) {<z>
)) {<z>
.debug("Determined server-specific load-time weaver: " +<z>
().getName());<z>
= serverSpecificLoadTimeWeaver;<z>
(InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) {<z>
("Found Spring's JVM agent for instrumentation");<z>
.loadTimeWeaver = new InstrumentationLoadTimeWeaver(classLoader);<z>
= new ReflectiveLoadTimeWeaver(classLoader);<z>
()) {<z>
logger.debug("Using reflective load-time weaver for class loader: " +<z>
;<z>
catch (IllegalStateException ex) {<z>
IllegalStateException(ex.getMessage() + " Specify a custom LoadTimeWeaver or start your " +<z>
"Java virtual machine with Spring's agent: -javaagent:spring-instrument-{version}.jar");<z>
(@Nullable Message message) {<z>
message != null) {<z>
).fromMessage(message);<z>
catch (JMSException ex) {<z>
(ex);<z>
;<z>
String propertyName) {<z>
= this.fieldMap.get(propertyName);<z>
== null) {<z>
(getWrappedClass(), propertyName);<z>
!= null) {<z>
(field);<z>
;<z>
;<z>
) {<z>
;<z>
.uriComponentsContributor = new CompositeUriComponentsContributor(<z>
), this.conversionService);<z>
key) {<z>
getReference(key, Restructure.WHEN_NECESSARY);<z>
? ref.get() : null);<z>
getValue() : null);<z>
beanName, Class<T> beanClass,<z>
{<z>
beanClass);<z>
) {<z>
.setInstanceSupplier(supplier);<z>
: customizers) {<z>
customize(beanDefinition);<z>
beanClass.getName());<z>
;<z>
processSource(Source source) {<z>
instanceof StreamSource streamSource) {<z>
getInputStream());<z>
SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();<z>
);<z>
, !isSupportDtd());<z>
featureName = "http://xml.org/sax/features/external-general-entities";<z>
));<z>
;<z>
;<z>
if (!isProcessExternalEntities()) {<z>
NO_OP_ENTITY_RESOLVER);<z>
(xmlReader, inputSource);<z>
| ParserConfigurationException ex) {<z>
"Processing of external entities could not be disabled", ex);<z>
source;<z>
return source;<z>
) {<z>
() != null) {<z>
));<z>
if (getUserInfo() != null) {<z>
;<z>
() != null) {<z>
.host(getHost());<z>
port != null) {<z>
);<z>
.copyToUriComponentsBuilder(builder);<z>
) {<z>
);<z>
if (getFragment() != null) {<z>
());<z>
void commit(TransactionStatus status) throws TransactionException {<z>
()) {<z>
(<z>
"Transaction is already completed - do not call commit or rollback more than once per transaction");<z>
;<z>
)) {<z>
()) {<z>
logger.debug("Transactional code has requested rollback");<z>
);<z>
.isGlobalRollbackOnly()) {<z>
defStatus.isDebug()) {<z>
;<z>
true);<z>
processCommit(defStatus);<z>
{<z>
eventType = getEventType();<z>
|| eventType == XMLStreamConstants.END_ELEMENT) {<z>
();<z>
IllegalStateException("Parser must be on START_ELEMENT or END_ELEMENT state");<z>
> comparator, boolean nullsLow) {<z>
comparator, "Non-null Comparator is required");<z>
this.nonNullComparator = comparator;<z>
;<z>
setFrom(String from) throws MailParseException {<z>
this.helper.setFrom(from);<z>
{<z>
new MailParseException(ex);<z>
SchedulerException {<z>
) {<z>
("Starting Quartz Scheduler now");<z>
scheduler.start();<z>
)) {<z>
getSchedulerName() +<z>
"] in " + startupDelay + " seconds");<z>
() {<z>
() {<z>
);<z>
InterruptedException ex) {<z>
().interrupt();<z>
) {<z>
.info("Starting Quartz Scheduler now, after delay of " + startupDelay + " seconds");<z>
);<z>
) {<z>
throw new SchedulingException("Could not start Quartz Scheduler after delay", ex);<z>
() + "]");<z>
);<z>
;<z>
value) throws IllegalArgumentException {<z>
value)) {<z>
);<z>
originalValue = value;<z>
trim();<z>
equalsIgnoreCase(value)) {<z>
(TestGroup.class);<z>
).startsWith("ALL-")) {<z>
.class);<z>
value.substring(4)));<z>
;<z>
(originalValue, value);<z>
boolean equals(@Nullable Object other) {<z>
other) {<z>
;<z>
!(other instanceof SimpleMailMessage otherMessage)) {<z>
false;<z>
(this.from, otherMessage.from) &&<z>
otherMessage.replyTo) &&<z>
to) &&<z>
.cc, otherMessage.cc) &&<z>
(this.bcc, otherMessage.bcc) &&<z>
.sentDate, otherMessage.sentDate) &&<z>
otherMessage.subject) &&<z>
.text));<z>
payload,<z>
) {<z>
;<z>
payload, headers, postProcessor);<z>
) {<z>
();<z>
;<z>
);<z>
EnvironmentAccessor());<z>
).getWebApplicationContext()));<z>
= getConversionService(pageContext);<z>
(conversionService != null) {<z>
(conversionService));<z>
context;<z>
(Session session, MessageConsumer consumer) throws JMSException {<z>
();<z>
getConnectionFactory();<z>
JmsResourceHolder resourceHolder = null;<z>
) {<z>
.getResource(connectionFactory);<z>
.hasTimeout()) {<z>
(timeout, resourceHolder.getTimeToLiveInMillis());<z>
timeout);<z>
)) {<z>
isSessionLocallyTransacted(session)) {<z>
;<z>
)) {<z>
if (message != null) {<z>
acknowledge();<z>
;<z>
.closeMessageConsumer(consumer);<z>
HandlerMethodArgumentResolver> argumentResolvers) {<z>
== null) {<z>
argumentResolvers.clear();<z>
argumentResolvers);<z>
{<z>
message);<z>
) {<z>
);<z>
public Thread createThread(Runnable runnable) {<z>
(), runnable, nextThreadName());<z>
));<z>
());<z>
return thread;<z>
getProducibleTypes(<z>
Supplier<List<MediaType>> producibleTypesSupplier) {<z>
HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);<z>
get());<z>
, FilterChain filterChain)<z>
IOException {<z>
(response instanceof HttpServletResponse httpResponse))) {<z>
;<z>
= getAlreadyFilteredAttributeName();<z>
alreadyFilteredAttributeName) != null;<z>
(httpRequest) || shouldNotFilter(httpRequest)) {<z>
);<z>
hasAlreadyFilteredAttribute) {<z>
) {<z>
;<z>
(request, response);<z>
alreadyFilteredAttributeName, Boolean.TRUE);<z>
filterChain);<z>
alreadyFilteredAttributeName);<z>
task) {<z>
task.run();<z>
Exception ex) {<z>
AssertionError("XML parsing error", ex);<z>
this.bodySpec;<z>
{<z>
if (shouldIgnoreIndex) {<z>
null;<z>
getResources(COMPONENTS_RESOURCE_LOCATION);<z>
if (!urls.hasMoreElements()) {<z>
;<z>
ArrayList<>();<z>
while (urls.hasMoreElements()) {<z>
nextElement();<z>
UrlResource(url));<z>
);<z>
logger.isDebugEnabled()) {<z>
);<z>
();<z>
CandidateComponentsIndex(result) : null);<z>
{<z>
("Unable to load indexes from location [" +<z>
COMPONENTS_RESOURCE_LOCATION + "]", ex);<z>
void destroy() {<z>
i-- > 0;) {<z>
this.filters.get(i);<z>
filter.destroy();<z>
toStoreValue(@Nullable Object userValue) {<z>
.toStoreValue(userValue);<z>
(this.serialization != null) {<z>
);<z>
Throwable ex) {<z>
throw new IllegalArgumentException("Failed to serialize cache value '" + userValue +<z>
, ex);<z>
;<z>
BeanFactory beanFactory) {<z>
ConfigurableBeanFactory) {<z>
= (ConfigurableBeanFactory) beanFactory;<z>
Session session) throws JMSException {<z>
Destination destination = getDestination();<z>
) {<z>
;<z>
, "No destination set");<z>
);<z>
;<z>
> checkNotModified(Instant lastModified, String etag) {<z>
);<z>
, "Etag must not be null");<z>
, etag);<z>
String name) {<z>
.headers.get(name);<z>
null) {<z>
return header.getStringValues();<z>
emptyList();<z>
(final int opcode, final int var) {<z>
) {<z>
);<z>
String, String> map) {<z>
{<z>
) : null);<z>
;<z>
}));<z>
{<z>
.streamDriver != null) {<z>
.createReader(inputStream), dataHolder);<z>
);<z>
Class<?> handlerType) {<z>
) {<z>
().test(handlerType)) {<z>
prefix = entry.getKey();<z>
!= null) {<z>
resolveStringValue(prefix);<z>
return prefix;<z>
return null;<z>
{<z>
headers = message.getHeaders();<z>
headers.get(DESTINATION_TEMPLATE_VARIABLES_HEADER);<z>
? vars.get(name) : null;<z>
String formatDate(long date) {<z>
Instant instant = Instant.ofEpochMilli(date);<z>
instant, GMT);<z>
return DATE_FORMATTER.format(time);<z>
logExecutorWarning() {<z>
{<z>
{<z>
this.taskExecutor;<z>
&&<z>
SimpleAsyncTaskExecutor || executor instanceof SyncTaskExecutor)) {<z>
.getSimpleName();<z>
+<z>
executorTypeName + " currently in use is not suitable under load.\n" +<z>
"'\n" +<z>
);<z>
;<z>
) {<z>
("Content-Type");<z>
{<z>
this.webRequest.getEncodingType();<z>
{<z>
getName();<z>
MediaType.ALL_VALUE);<z>
,<z>
) {<z>
registerBeanDefinitions(importingClassMetadata, registry);<z>
Object base, Object property) throws ELException {<z>
) {<z>
= property.toString();<z>
;<z>
.containsBean(beanName)) {<z>
;<z>
false;<z>
throws IOException {<z>
this.connector != null &&<z>
isInitialized())) {<z>
;<z>
> inputStream, ResolvableType elementType,<z>
, Object> hints) {<z>
throw new UnsupportedOperationException();<z>
{<z>
cache.asMap().isEmpty();<z>
invalidateAll();<z>
;<z>
@Nullable ResourceLoader resourceLoader) {<z>
);<z>
metadataReaderFactory = new CachingMetadataReaderFactory(resourceLoader);<z>
));<z>
, ServerHttpRequest> toParts() {<z>
-> {<z>
;<z>
MediaType.MULTIPART_FORM_DATA;<z>
mediaType, context);<z>
, elementType, reader);<z>
{<z>
null;<z>
(this.detectAllHandlerAdapters) {<z>
String, HandlerAdapter> matchingBeans =<z>
, false);<z>
()) {<z>
());<z>
(this.handlerAdapters);<z>
HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class);<z>
.singletonList(ha);<z>
{<z>
handlerAdapters == null) {<z>
HandlerAdapter.class);<z>
isTraceEnabled()) {<z>
+ getServletName() +<z>
);<z>
) {<z>
(properties) ?<z>
getNativeEntityManagerFactory().createEntityManager(properties) :<z>
).createEntityManager());<z>
);<z>
return rawEntityManager;<z>
Nullable MediaType mediaType) {<z>
if (!canWrite(mediaType)) {<z>
;<z>
() != null) {<z>
.getCharset();<z>
{<z>
;<z>
= selectObjectMapper(clazz, mediaType);<z>
null) {<z>
false;<z>
> causeRef = new AtomicReference<>();<z>
objectMapper.canSerialize(clazz, causeRef)) {<z>
;<z>
causeRef.get());<z>
;<z>
protected void flushBufferedBodyContent(BodyContent bodyContent) throws JspException {<z>
(bodyContent.getEnclosingWriter());<z>
(IOException ex) {<z>
);<z>
[] expectedContent) {<z>
return request -> {<z>
= (MockClientHttpRequest) request;<z>
expectedContent, mockRequest.getBodyAsBytes());<z>
request) throws IOException {<z>
getRequestMatchers()) {<z>
(request);<z>
characterEncoding) {<z>
"'characterEncoding' must not be null");<z>
characterEncoding;<z>
if (!this.characterEncodingSet) {<z>
characterEncoding;<z>
@Nullable Object other) {<z>
this == other) {<z>
true;<z>
) {<z>
false;<z>
) other;<z>
);<z>
public boolean equals(@Nullable Object other) {<z>
if (this == other) {<z>
true;<z>
other instanceof SortDefinition otherSd)) {<z>
return false;<z>
(otherSd.getProperty()) &&<z>
otherSd.isAscending() &&<z>
() == otherSd.isIgnoreCase());<z>
text, Object[] args) {<z>
(0, args.length)<z>
(args[i] != null ?<z>
+ "] [value=" + args[i] + "]" :<z>
+ i + "] [null]"))<z>
, " ", " "));<z>
+ "\n" +<z>
getName() + "]\n" +<z>
toGenericString() + "] " +<z>
formattedArgs;<z>
raiseLimitException() {<z>
new DataBufferLimitException(<z>
+ this.maxByteCount);<z>
) {<z>
;<z>
content);<z>
catch (AssertionError ex) {<z>
) {<z>
value), list.isEmpty());<z>
));<z>
public void setObjectMapper(ObjectMapper objectMapper) {<z>
.notNull(objectMapper, "ObjectMapper must not be null");<z>
;<z>
configurePrettyPrint();<z>
(<z>
final int access,<z>
String name,<z>
String descriptor,<z>
String signature,<z>
{<z>
!= null) {<z>
signature, value);<z>
;<z>
void flushCache() throws SockJsTransportFailureException {<z>
()) {<z>
getMessageCache().poll();<z>
.getMessageCodec();<z>
message);<z>
frame);<z>
().length + 1);<z>
.isTraceEnabled()) {<z>
.byteCount + " bytes written so far, " +<z>
) + " more messages not flushed");<z>
).getStreamBytesLimit()) {<z>
("Streamed bytes limit reached, recycling current request");<z>
();<z>
0;<z>
();<z>
{<z>
getValueInternal(state).getValue();<z>
);<z>
.toDescriptorFromObject(left);<z>
.rightActualDescriptor = CodeFlow.toDescriptorFromObject(right);<z>
right instanceof Number rightNumber) {<z>
instanceof BigDecimal || rightNumber instanceof BigDecimal) {<z>
(leftNumber, BigDecimal.class);<z>
);<z>
) > 0);<z>
{<z>
());<z>
instanceof Float) {<z>
rightNumber.floatValue());<z>
{<z>
(leftNumber, BigInteger.class);<z>
class);<z>
(rightBigInteger) > 0);<z>
instanceof Long || rightNumber instanceof Long) {<z>
rightNumber.longValue());<z>
{<z>
> rightNumber.intValue());<z>
leftNumber instanceof Short || rightNumber instanceof Short) {<z>
());<z>
instanceof Byte || rightNumber instanceof Byte) {<z>
);<z>
));<z>
) {<z>
left.toString();<z>
;<z>
);<z>
?> contextClass) {<z>
(contextClass != null) {<z>
) {<z>
= resolveVariable(<z>
.forClass(contextClass));<z>
if (resolvedTypeVariable != ResolvableType.NONE) {<z>
resolvedTypeVariable.resolve();<z>
) {<z>
return resolved;<z>
else if (genericType instanceof ParameterizedType) {<z>
);<z>
hasUnresolvableGenerics()) {<z>
) genericType;<z>
length];<z>
getActualTypeArguments();<z>
;<z>
++) {<z>
;<z>
{<z>
ResolvableType resolvedTypeArgument = resolveVariable(<z>
contextType);<z>
if (resolvedTypeArgument != ResolvableType.NONE) {<z>
[i] = resolvedTypeArgument.resolve();<z>
(typeArgument).resolve();<z>
;<z>
resolvedType.getRawClass();<z>
null) {<z>
.getType();<z>
;<z>
MessagingException {<z>
, "To address must not be null");<z>
validateAddress(to);<z>
;<z>
throws EvaluationException {<z>
.compiledAst;<z>
if (compiledAst != null) {<z>
rootObject, getEvaluationContext());<z>
{<z>
SpelCompilerMode.MIXED) {<z>
.compiledAst = null;<z>
.set(0);<z>
new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);<z>
expressionState =<z>
;<z>
(expressionState);<z>
(expressionState);<z>
return result;<z>
long getValueMatchCount(Set<HeaderExpression> expressions) {<z>
;<z>
expressions) {<z>
isNegated()) {<z>
;<z>
return count;<z>
JettyWebSocketSession wsSession) {<z>
, "WebSocketHandler must not be null");<z>
"WebSocketSession must not be null");<z>
= webSocketHandler;<z>
= wsSession;<z>
[] body,<z>
, @Nullable HttpRequest request) {<z>
), statusText, headers, body, charset,<z>
;<z>
RuntimeBeanReference registerScheduler(<z>
Object source) {<z>
().containsBeanDefinition(schedulerName)) {<z>
class);<z>
);<z>
(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
());<z>
.add("threadNamePrefix", schedulerName + "-");<z>
);<z>
taskSchedulerDef);<z>
, schedulerName));<z>
RuntimeBeanReference(schedulerName);<z>
(<z>
... args) {<z>
NestedDependencyDescriptor(descriptor) {<z>
boolean isRequired() {<z>
return false;<z>
{<z>
beanFactory.getBean(beanName, args) :<z>
requiredType, beanFactory));<z>
(descriptorToUse, beanName, null, null);<z>
(result));<z>
write(ByteBuffer source) {<z>
remaining();<z>
this.byteBuffer.duplicate();<z>
source.remaining();<z>
.writePosition).limit(limit);<z>
);<z>
length;<z>
TransactionAttribute attr) {<z>
name, "Name must not be null");<z>
);<z>
== -1) {<z>
"' is not a valid method name: format is FQN.methodName");<z>
name.substring(0, lastDotIndex);<z>
+ 1);<z>
, this.beanClassLoader);<z>
(clazz, methodName, attr);<z>
Synchronization synchronization) {<z>
this.transactionSynchronizationRegistry != null) {<z>
synchronization);<z>
getTransaction().registerSynchronization(synchronization);<z>
) {<z>
);<z>
@Nullable Object value) {<z>
);<z>
customEditor = getCustomEditor(fixedField);<z>
{<z>
setValue(value);<z>
customEditor.getAsText();<z>
null) {<z>
textValue;<z>
null) {<z>
.getPropertyTypeDescriptor(fixedField);<z>
TypeDescriptor.valueOf(String.class);<z>
strDesc)) {<z>
);<z>
value;<z>
SourceClass> getInterfaces() throws IOException {<z>
> result = new LinkedHashSet<>();<z>
(this.source instanceof Class) {<z>
;<z>
ifcClass : sourceClass.getInterfaces()) {<z>
, DEFAULT_EXCLUSION_FILTER));<z>
)) {<z>
(asSourceClass(className, DEFAULT_EXCLUSION_FILTER));<z>
result;<z>
containsLocalBean(String name) {<z>
String beanName = transformedBeanName(name);<z>
beanName)) &&<z>
|| isFactoryBean(beanName)));<z>
) {<z>
, "Property name must not be null");<z>
;<z>
if (resolvedName != null) {<z>
;<z>
String uppercasedName = name.toUpperCase();<z>
name.equals(uppercasedName)) {<z>
(uppercasedName);<z>
resolvedName != null) {<z>
resolvedName;<z>
;<z>
{<z>
.bufferSize);<z>
;<z>
), dataBuffer, this);<z>
) throws IOException {<z>
new InputStreamReader(inputStream))) {<z>
= false;<z>
String content;<z>
) != null) {<z>
= consumeCommentTokens(content);<z>
) {<z>
(hasDoctype(content)) {<z>
isDtdValidated = true;<z>
)) {<z>
VALIDATION_XSD);<z>
) {<z>
return VALIDATION_AUTO;<z>
String beanName, RootBeanDefinition mbd, boolean allowInit) {<z>
;<z>
ResolvableType.NONE) {<z>
;<z>
=<z>
: ResolvableType.NONE);<z>
mbd.getInstanceSupplier() != null) {<z>
getFactoryBeanGeneric(mbd.targetType);<z>
.resolve() != null) {<z>
result;<z>
result = getFactoryBeanGeneric(beanType);<z>
resolve() != null) {<z>
return result;<z>
mbd.getFactoryBeanName();<z>
String factoryMethodName = mbd.getFactoryMethodName();<z>
factoryBeanName != null) {<z>
null) {<z>
= getBeanDefinition(factoryBeanName);<z>
?> factoryBeanClass;<z>
if (factoryBeanDefinition instanceof AbstractBeanDefinition &&<z>
AbstractBeanDefinition) factoryBeanDefinition).hasBeanClass()) {<z>
AbstractBeanDefinition) factoryBeanDefinition).getBeanClass();<z>
(factoryBeanName, factoryBeanDefinition);<z>
;<z>
) {<z>
= getTypeForFactoryBeanFromMethod(factoryBeanClass, factoryMethodName);<z>
() != null) {<z>
result;<z>
)) {<z>
.NONE;<z>
) {<z>
isSingleton() ?<z>
beanName, mbd) :<z>
, mbd));<z>
!= null) {<z>
getTypeForFactoryBean(factoryBean);<z>
null) {<z>
);<z>
.getTypeForFactoryBean(beanName, mbd, true);<z>
&& factoryMethodName != null) {<z>
.getBeanClass(), factoryMethodName);<z>
beanType);<z>
!= null) {<z>
;<z>
ResolvableType.NONE;<z>
String qName) throws SAXException {<z>
qName), currentNamespaceMapping());<z>
);<z>
) {<z>
+ ex.getMessage(), ex);<z>
<ApplicationEvent> listener) {<z>
);<z>
ApplicationEvent.class)) {<z>
(listener);<z>
targetClass != listener.getClass()) {<z>
);<z>
;<z>
JdkClientHttpResponse(<z>
{<z>
response = response;<z>
bufferFactory = bufferFactory;<z>
adaptHeaders(response);<z>
<BeanDefinition> scanCandidateComponents(String basePackage) {<z>
;<z>
= ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +<z>
basePackage) + '/' + this.resourcePattern;<z>
packageSearchPath);<z>
logger.isTraceEnabled();<z>
);<z>
resources) {<z>
traceEnabled) {<z>
("Scanning " + resource);<z>
getMetadataReader(resource);<z>
isCandidateComponent(metadataReader)) {<z>
ScannedGenericBeanDefinition(metadataReader);<z>
);<z>
(isCandidateComponent(sbd)) {<z>
(debugEnabled) {<z>
"Identified candidate component class: " + resource);<z>
candidates.add(sbd);<z>
(debugEnabled) {<z>
;<z>
(traceEnabled) {<z>
logger.trace("Ignored because not matching any filter: " + resource);<z>
) {<z>
{<z>
+ ex.getMessage());<z>
Throwable ex) {<z>
BeanDefinitionStoreException(<z>
ex);<z>
catch (IOException ex) {<z>
;<z>
candidates;<z>
String> getCacheNames() {<z>
{<z>
this.cacheNames);<z>
<HttpMethod> getAllow() {<z>
);<z>
if (StringUtils.hasLength(value)) {<z>
.tokenizeToStringArray(value, ",");<z>
LinkedHashSet<>(tokens.length);<z>
) {<z>
token);<z>
;<z>
;<z>
Collections.emptySet();<z>
Map<Integer, Integer> getTypeIndexesPerLevel() {<z>
) {<z>
4);<z>
;<z>
<T> mimeTypes) {<z>
.notNull(mimeTypes, "'mimeTypes' must not be null");<z>
size() <= 50, "Too many elements");<z>
bubbleSort(mimeTypes, MimeType::isLessSpecific);<z>
ex) {<z>
() instanceof InvocationTargetException) {<z>
.getCause();<z>
(rootCause instanceof RuntimeException) {<z>
(RuntimeException) rootCause;<z>
(),<z>
+ this.name +<z>
+ "]", rootCause);<z>
determineDefaultLocale(HttpServletRequest request) {<z>
);<z>
defaultLocale == null) {<z>
getLocale();<z>
;<z>
<?> clazz, HttpInputMessage inputMessage)<z>
, HttpMessageNotReadableException {<z>
(serializer(clazz), inputMessage);<z>
Nullable Object label)<z>
{<z>
.startTag("option");<z>
);<z>
(value);<z>
String labelDisplayString = getDisplayString(label);<z>
(valueDisplayString);<z>
("value", valueDisplayString);<z>
) {<z>
"selected", "selected");<z>
{<z>
("disabled", "disabled");<z>
.appendValue(labelDisplayString);<z>
);<z>
, NativeWebRequest request)<z>
throws Exception {<z>
);<z>
) {<z>
);<z>
isEmpty()) {<z>
files.get(0) : files);<z>
if (StringUtils.startsWithIgnoreCase(<z>
) {<z>
class);<z>
.getMethod())) {<z>
paramName);<z>
if (!parts.isEmpty()) {<z>
0) : parts);<z>
return null;<z>
.classWriter = classWriter;<z>
byte[] inputBytes = classReader.classFileBuffer;<z>
= classReader.getItemCount();<z>
inputBytes, constantPoolOffset, constantPoolLength);<z>
[constantPoolCount * 2];<z>
hasBootstrapMethods = false;<z>
itemIndex < constantPoolCount) {<z>
nameAndTypeItemOffset;<z>
switch (itemTag) {<z>
.CONSTANT_FIELDREF_TAG:<z>
Symbol.CONSTANT_METHODREF_TAG:<z>
readClass(itemOffset, charBuffer),<z>
.CONSTANT_INTEGER_TAG:<z>
case Symbol.CONSTANT_FLOAT_TAG:<z>
readInt(itemOffset));<z>
case Symbol.CONSTANT_NAME_AND_TYPE_TAG:<z>
2, charBuffer));<z>
CONSTANT_LONG_TAG:<z>
.CONSTANT_DOUBLE_TAG:<z>
classReader.readLong(itemOffset));<z>
CONSTANT_METHOD_HANDLE_TAG:<z>
int memberRefItemOffset =<z>
readUnsignedShort(itemOffset + 1));<z>
(memberRefItemOffset + 2));<z>
readUTF8(nameAndTypeItemOffset, charBuffer),<z>
CONSTANT_DYNAMIC_TAG:<z>
Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:<z>
nameAndTypeItemOffset, charBuffer),<z>
.readUTF8(nameAndTypeItemOffset + 2, charBuffer),<z>
readUnsignedShort(itemOffset));<z>
.CONSTANT_STRING_TAG:<z>
.CONSTANT_CLASS_TAG:<z>
.CONSTANT_METHOD_TYPE_TAG:<z>
Symbol.CONSTANT_PACKAGE_TAG:<z>
readUTF8(itemOffset, charBuffer));<z>
hasBootstrapMethods) {<z>
) {<z>
public String toString() {<z>
"null";<z>
parserContext) {<z>
(advisorElement, parserContext);<z>
String id = advisorElement.getAttribute(ID);<z>
new AdvisorEntry(id));<z>
advisorBeanName = id;<z>
.hasText(advisorBeanName)) {<z>
;<z>
().registerWithGeneratedName(advisorDef);<z>
, parserContext);<z>
BeanDefinition) {<z>
);<z>
registerComponent(<z>
, advisorDef, (BeanDefinition) pointcut));<z>
else if (pointcut instanceof String) {<z>
pointcut));<z>
parserContext.registerComponent(<z>
;<z>
;<z>
returnValue, MethodParameter returnType,<z>
NativeWebRequest request) throws Exception {<z>
(returnValue, "Expected return value");<z>
());<z>
+ returnValue);<z>
).getGeneric();<z>
> elementClass = elementType.toClass();<z>
= getMediaTypes(request);<z>
();<z>
) {<z>
.anyMatch(MediaType.TEXT_EVENT_STREAM::includes) ||<z>
{<z>
);<z>
SseEmitter(STREAMING_TIMEOUT_VALUE);<z>
adapter, returnValue);<z>
emitter;<z>
.isAssignableFrom(elementClass)) {<z>
logExecutorWarning(returnType);<z>
;<z>
returnValue);<z>
return emitter;<z>
{<z>
{<z>
(type)) {<z>
;<z>
);<z>
.connect(adapter, returnValue);<z>
;<z>
;<z>
;<z>
mav);<z>
null;<z>
Class<? extends Set> targetSetClass) {<z>
null) {<z>
);<z>
targetSetClass)) {<z>
("'targetSetClass' must implement [java.util.Set]");<z>
targetSetClass = targetSetClass;<z>
(MethodParameter parameter, Throwable ex) {<z>
getMessage();<z>
{<z>
logger.isDebugEnabled()) {<z>
formatArgumentError(parameter, exMsg));<z>
) {<z>
int eventType = getEventType();<z>
.START_ELEMENT || eventType == XMLStreamConstants.END_ELEMENT) {<z>
;<z>
throw new IllegalStateException("Parser must be on START_ELEMENT or END_ELEMENT state");<z>
filterName) throws IllegalStateException {<z>
obtainSessionFactory().getCurrentSession();<z>
Filter filter = session.getEnabledFilter(filterName);<z>
if (filter == null) {<z>
(filterName);<z>
return filter;<z>
) throws EntryProcessorException {<z>
0];<z>
()) {<z>
) fromStoreValue(entry.getValue());<z>
;<z>
);<z>
Exception ex) {<z>
+ valueLoader + "' failed " +<z>
) + "'", ex);<z>
.setValue(toStoreValue(value));<z>
return value;<z>
parameter) {<z>
int i = parameter.getParameterIndex();<z>
;<z>
);<z>
EncodedResource resource, boolean continueOnError,<z>
, @Nullable String separator,<z>
, String blockCommentEndDelimiter) throws ScriptException {<z>
(connection, resource, continueOnError, ignoreFailedDrops,<z>
{ commentPrefix }, separator, blockCommentStartDelimiter,<z>
);<z>
{<z>
(servletContext != null) {<z>
setServletContext(servletContext);<z>
(@Nullable ClientHttpRequest request) throws IOException {<z>
();<z>
;<z>
);<z>
org.springframework.protobuf.SecondMsg parseFrom(<z>
.google.protobuf.ByteString data,<z>
com.google.protobuf.ExtensionRegistryLite extensionRegistry)<z>
.protobuf.InvalidProtocolBufferException {<z>
return PARSER.parseFrom(data, extensionRegistry);<z>
wrap(Object adviceObject) throws UnknownAdviceTypeException {<z>
instanceof Advisor) {<z>
) adviceObject;<z>
adviceObject instanceof Advice advice)) {<z>
(adviceObject);<z>
instanceof MethodInterceptor) {<z>
;<z>
for (AdvisorAdapter adapter : this.adapters) {<z>
{<z>
advice);<z>
;<z>
void refreshCommonCaches() {<z>
entrySet()) {<z>
entry.getKey())) {<z>
));<z>
XMLEvent peek() {<z>
()) {<z>
events.get(this.cursor);<z>
return null;<z>
> findSessions(String userName) {<z>
);<z>
.getUser(userName);<z>
null) {<z>
)) {<z>
), session);<z>
UserRegistrySnapshot registry : remoteRegistries.values()) {<z>
.get(userName);<z>
!= null) {<z>
map);<z>
;<z>
?> clazz) {<z>
.values();<z>
(TypeCode typeCode : allValues) {<z>
== typeCode.getType()) {<z>
;<z>
;<z>
StringBuilder getOperationDescription() {<z>
sb = super.getOperationDescription();<z>
" | unless='");<z>
;<z>
'\'');<z>
);<z>
sync);<z>
);<z>
return sb;<z>
Nullable StompHeaders headers) {<z>
= createHeaderAccessor(StompCommand.UNSUBSCRIBE);<z>
(headers != null) {<z>
);<z>
);<z>
accessor, EMPTY_PAYLOAD);<z>
execute(message);<z>
public void contributeMethodArgument(MethodParameter parameter, Object value,<z>
) {<z>
contributors) {<z>
ucc) {<z>
ucc.supportsParameter(parameter)) {<z>
builder, uriVariables, conversionService);<z>
contributor instanceof HandlerMethodArgumentResolver resolver) {<z>
supportsParameter(parameter)) {<z>
void updateCurrentBufferLength() {<z>
.fastByteArrayOutputStream.buffers.getLast()) {<z>
.fastByteArrayOutputStream.index;<z>
? this.currentBuffer.length : 0);<z>
(final int localIndex) {<z>
null || localIndex >= outputLocals.length) {<z>
return LOCAL_KIND | localIndex;<z>
else {<z>
int abstractType = outputLocals[localIndex];<z>
0) {<z>
;<z>
return abstractType;<z>
, Class<T> responseType)<z>
RestClientException {<z>
httpEntityCallback(entity, responseType);<z>
;<z>
requestCallback, responseExtractor));<z>
{<z>
> ranges = getAcceptLanguage();<z>
if (ranges.isEmpty()) {<z>
return Collections.emptyList();<z>
)<z>
)<z>
()))<z>
;<z>
] getParameterNames(Method method) {<z>
getParameterTypes();<z>
.length;<z>
.numberOfRemainingUnboundArguments];<z>
;<z>
) {<z>
;<z>
throwingName != null) {<z>
++;<z>
.numberOfRemainingUnboundArguments < minimumNumberUnboundArgs) {<z>
new IllegalStateException(<z>
);<z>
int algorithmicStep = STEP_JOIN_POINT_BINDING;<z>
< STEP_FINISHED) {<z>
algorithmicStep++) {<z>
:<z>
maybeBindThisJoinPoint()) {<z>
maybeBindThisJoinPointStaticPart();<z>
STEP_THROWING_BINDING:<z>
();<z>
:<z>
maybeBindAnnotationsFromPointcutExpression();<z>
:<z>
);<z>
:<z>
();<z>
case STEP_THIS_TARGET_ARGS_BINDING:<z>
();<z>
STEP_REFERENCE_PCUT_BINDING:<z>
);<z>
1));<z>
catch (AmbiguousBindingException | IllegalArgumentException ex) {<z>
.raiseExceptions) {<z>
ex;<z>
;<z>
== 0) {<z>
this.parameterNameBindings;<z>
) {<z>
("Failed to bind all argument names: " +<z>
numberOfRemainingUnboundArguments + " argument(s) could not be bound");<z>
null;<z>
throws NamingException {<z>
isDebugEnabled()) {<z>
+ root + "]");<z>
);<z>
getCharset(@Nullable MimeType mimeType) {<z>
null) {<z>
;<z>
;<z>
Nullable String contextPath) {<z>
);<z>
fullPath, contextPath);<z>
;<z>
public Object getProperty(String name) {<z>
{<z>
;<z>
source.lookup(name);<z>
if (logger.isDebugEnabled()) {<z>
value + "]");<z>
value;<z>
{<z>
()) {<z>
"] threw NamingException " +<z>
getMessage() + ". Returning null.");<z>
return null;<z>
public void setMaxPoolSize(int maxPoolSize) {<z>
) {<z>
this.threadPoolExecutor != null) {<z>
maxPoolSize);<z>
maxPoolSize = maxPoolSize;<z>
bean) {<z>
bean;<z>
isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {<z>
smartInstantiationAware) {<z>
bp.getEarlyBeanReference(exposedObject, beanName);<z>
exposedObject;<z>
public HandlerMethod(<z>
String beanName, BeanFactory beanFactory,<z>
@Nullable MessageSource messageSource, Method method) {<z>
hasText(beanName, "Bean name is required");<z>
, "BeanFactory is required");<z>
, "Method is required");<z>
beanName;<z>
beanFactory = beanFactory;<z>
messageSource;<z>
= beanFactory.getType(beanName);<z>
== null) {<z>
"'");<z>
= ClassUtils.getUserClass(beanType);<z>
= method;<z>
BridgeMethodResolver.findBridgedMethod(method);<z>
makeAccessible(this.bridgedMethod);<z>
= initMethodParameters();<z>
();<z>
(this.beanType, this.method);<z>
MessageSourceAccessor getMessageSourceAccessor() throws IllegalStateException {<z>
)) {<z>
new IllegalStateException(<z>
);<z>
messageSourceAccessor;<z>
(Query<?> queryObject) {<z>
isCacheQueries()) {<z>
;<z>
!= null) {<z>
;<z>
(getFetchSize() > 0) {<z>
);<z>
(getMaxResults() > 0) {<z>
(getMaxResults());<z>
=<z>
obtainSessionFactory());<z>
) {<z>
(sessionHolder.getTimeToLiveInSeconds());<z>
) {<z>
instanceof SpelExpression) {<z>
);<z>
> result) throws IOException {<z>
.parser);<z>
&& this.arrayDepth == 0) {<z>
);<z>
this.tokenBuffer = createToken();<z>
String elementName) {<z>
= DomUtils.getChildElementsByTagName(interceptor, elementName);<z>
);<z>
(Element path : paths) {<z>
.getAttribute("path"));<z>
return patterns;<z>
(Object transaction) {<z>
= (JpaTransactionObject) transaction;<z>
isNewEntityManagerHolder()) {<z>
));<z>
);<z>
()) {<z>
;<z>
.getConnectionHolder().getConnectionHandle();<z>
) {<z>
(conHandle,<z>
).getEntityManager());<z>
{<z>
ex);<z>
());<z>
{<z>
.getEntityManagerHolder().getEntityManager();<z>
) {<z>
+ "] after transaction");<z>
closeEntityManager(em);<z>
("Not closing pre-bound JPA EntityManager after transaction");<z>
protected void hookOnNext(MultipartParser.Token token) {<z>
(false);<z>
();<z>
.HeadersToken) {<z>
);<z>
tooManyParts()) {<z>
(state, token.headers());<z>
(token.buffer());<z>
HttpServletRequest request) {<z>
;<z>
!= null ? themeName : getDefaultThemeName());<z>
HttpServletRequest originalRequest) {<z>
{<z>
= getWebApplicationContext();<z>
;<z>
originalRequest, wac, this.exposedContextBeanNames);<z>
originalRequest;<z>
throws JMSException {<z>
= session.createBytesMessage();<z>
bytes);<z>
return message;<z>
enhancer) {<z>
createClass();<z>
;<z>
;<z>
(BeanFactory beanFactory) {<z>
{<z>
this.beanFactory = (ConfigurableBeanFactory) beanFactory;<z>
int targetCapacity) {<z>
), "New capacity must not be smaller than current size");<z>
) {<z>
targetCapacity - size();<z>
length == targetCapacity) {<z>
);<z>
;<z>
pos = 0;<z>
.buffers.iterator();<z>
)) {<z>
it.next();<z>
it.hasNext()) {<z>
data, pos, bytes.length);<z>
bytes.length;<z>
.index);<z>
);<z>
(data);<z>
;<z>
alreadyBufferedSize = 0;<z>
ParserContext parserContext) {<z>
{<z>
RootBeanDefinition();<z>
;<z>
;<z>
;<z>
(element));<z>
;<z>
;<z>
?> config,<z>
?> implClass) {<z>
implClass);<z>
FormattingConversionService conversionService) {<z>
!= null) {<z>
formatter : this.formatters) {<z>
{<z>
>) formatter);<z>
?>) {<z>
((AnnotationFormatterFactory<?>) formatter);<z>
throw new IllegalArgumentException(<z>
;<z>
null) {<z>
for (FormatterRegistrar registrar : this.formatterRegistrars) {<z>
registrar.registerFormatters(conversionService);<z>
() {<z>
;<z>
currentThread().getContextClassLoader();<z>
{<z>
).getClassLoader());<z>
DataBuffer> input, ResolvableType elementType,<z>
Nullable Map<String, Object> hints) {<z>
Flux.from(input);<z>
null) {<z>
flux;<z>
();<z>
equals(charset)) {<z>
return flux;<z>
);<z>
, STRING_TYPE, textMimeType, null);<z>
(StandardCharsets.UTF_8)));<z>
mergeFrom(<z>
.protobuf.CodedInputStream input,<z>
google.protobuf.ExtensionRegistryLite extensionRegistry)<z>
IOException {<z>
.Msg parsedMessage = null;<z>
parsePartialFrom(input, extensionRegistry);<z>
e) {<z>
);<z>
;<z>
{<z>
!= null) {<z>
parsedMessage);<z>
return this;<z>
newValue) {<z>
= this.typeDescriptor.getElementTypeDescriptor();<z>
"No element type");<z>
, newValue, elementType.getType());<z>
candidate) {<z>
.notNull(candidate, "Candidate object must not be null");<z>
;<z>
;<z>
) {<z>
TargetClassAware) current).getTargetClass();<z>
(current);<z>
) {<z>
);<z>
result;<z>
boolean last) {<z>
inKey = false;<z>
);<z>
last ? length - 1 : 0);<z>
< length) {<z>
charAt(i)) {<z>
:<z>
.PROPERTY_KEY_SUFFIX_CHAR:<z>
inKey;<z>
:<z>
{<z>
;<z>
last) {<z>
;<z>
++;<z>
-1;<z>
parameter) {<z>
class)) {<z>
;<z>
).getNestedParameterType())) {<z>
);<z>
value()));<z>
true;<z>
() {<z>
== null) {<z>
getArguments().clone();<z>
return this.args;<z>
Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {<z>
class) {<z>
();<z>
;<z>
(<z>
.google.protobuf.CodedInputStream input,<z>
extensionRegistry)<z>
.IOException {<z>
= null;<z>
PARSER.parsePartialFrom(input, extensionRegistry);<z>
e) {<z>
) e.getUnfinishedMessage();<z>
e;<z>
finally {<z>
(parsedMessage != null) {<z>
mergeFrom(parsedMessage);<z>
this;<z>
public RequestMappingHandlerMapping requestMappingHandlerMapping(<z>
("webFluxContentTypeResolver") RequestedContentTypeResolver contentTypeResolver) {<z>
RequestMappingHandlerMapping mapping = createRequestMappingHandlerMapping();<z>
;<z>
mapping.setContentTypeResolver(contentTypeResolver);<z>
PathMatchConfigurer configurer = getPathMatchConfigurer();<z>
);<z>
= configurer.getPathPrefixes();<z>
if (pathPrefixes != null) {<z>
(pathPrefixes);<z>
mapping;<z>
public ValueRef getValueRef(ExpressionState state) throws SpelEvaluationException {<z>
.name.equals(THIS)) {<z>
),this);<z>
equals(ROOT)) {<z>
(state.getRootContextObject(),this);<z>
);<z>
,state.getEvaluationContext());<z>
Log logger) {<z>
(responseType, "'responseType' must not be null");<z>
"'messageConverters' must not be empty");<z>
"'messageConverters' must not contain null elements");<z>
.responseType = responseType;<z>
>) responseType : null);<z>
= messageConverters;<z>
.logger = logger;<z>
) {<z>
);<z>
forEach((name, values) -><z>
forEach(value -> {<z>
0) {<z>
.append('&');<z>
, charset));<z>
value != null) {<z>
append('=');<z>
);<z>
;<z>
();<z>
> sink) {<z>
(), new Callback() {<z>
) {<z>
buffer);<z>
{<z>
buffer);<z>
;<z>
);<z>
<?> targetClass, Object... args) {<z>
.incrementAndGet();<z>
) {<z>
clazz.getName()) &&<z>
.methodName))) {<z>
return true;<z>
;<z>
(<z>
protobuf.CodedInputStream input,<z>
com.google.protobuf.ExtensionRegistryLite extensionRegistry)<z>
{<z>
;<z>
@SuppressWarnings("unused")<z>
= 0;<z>
.protobuf.UnknownFieldSet.Builder unknownFields =<z>
);<z>
done = false;<z>
(!done) {<z>
;<z>
{<z>
0:<z>
;<z>
default: {<z>
unknownFields,<z>
extensionRegistry, tag)) {<z>
;<z>
case 8: {<z>
;<z>
readInt32();<z>
.InvalidProtocolBufferException e) {<z>
setUnfinishedMessage(this);<z>
io.IOException e) {<z>
.InvalidProtocolBufferException(<z>
;<z>
{<z>
);<z>
;<z>
protected String determineRootDir(String location) {<z>
;<z>
();<z>
, rootDirEnd))) {<z>
) + 1;<z>
(rootDirEnd == 0) {<z>
rootDirEnd = prefixEnd;<z>
substring(0, rootDirEnd);<z>
{<z>
MediaType>)<z>
(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);<z>
)) {<z>
ArrayList<>(mediaTypes);<z>
singletonList(MediaType.ALL);<z>
TransactionAttribute attr) {<z>
isDebugEnabled()) {<z>
+ "]");<z>
DefaultTransactionAttribute dta) {<z>
dta.resolveAttributeStrings(this.embeddedValueResolver);<z>
nameMap.put(methodName, attr);<z>
<T> type) {<z>
;<z>
, false);<z>
if (value == null) {<z>
);<z>
;<z>
callback) {<z>
synchronized (this.lifecycleMonitor) {<z>
stop();<z>
();<z>
> attributeType) {<z>
"Attribute name must not be null");<z>
attributeTypes.contains(attributeType)) {<z>
;<z>
;<z>
;<z>
propertyName) {<z>
propertyName);<z>
(0))) {<z>
return new String[] {suffix};<z>
;<z>
@Nullable String etag, Instant lastModified) {<z>
().getStatusCode();<z>
OK.equals(status))) {<z>
this.notModified;<z>
(validateIfUnmodifiedSince(lastModified)) {<z>
(this.notModified) {<z>
().setStatusCode(HttpStatus.PRECONDITION_FAILED);<z>
notModified;<z>
etag);<z>
{<z>
;<z>
).getMethod());<z>
if (this.notModified) {<z>
isHttpGetOrHead ?<z>
NOT_MODIFIED : HttpStatus.PRECONDITION_FAILED);<z>
) {<z>
== -1) {<z>
.toEpochMilli());<z>
().getETag() == null) {<z>
etag));<z>
this.notModified;<z>
(Collection<? extends Cache> caches) {<z>
new ArrayList<>();<z>
{<z>
));<z>
return names;<z>
{<z>
.delegatingTransformer, transformer);<z>
{<z>
"Could not add transformer on JBoss ClassLoader: " + this.classLoader, ex);<z>
?> results)<z>
{<z>
);<z>
(URI url, WebSocketHandler handler,<z>
Void> completionSink, DefaultConfigurator configurator) {<z>
(handler, session -><z>
, completionSink));<z>
(String name) {<z>
?> propertySource : this.propertySources) {<z>
);<z>
(candidate != null) {<z>
candidate;<z>
return null;<z>
protected void cleanupAfterBeanCreationFailure(String beanName) {<z>
this.mergedBeanDefinitions) {<z>
alreadyCreated.remove(beanName);<z>
, @Nullable Class<?> fieldType) {<z>
codeList = new LinkedHashSet<>();<z>
);<z>
fieldList);<z>
, objectName, fieldList);<z>
field.lastIndexOf('.');<z>
) {<z>
(dotIndex + 1), fieldList);<z>
, fieldList);<z>
) {<z>
, fieldType.getName());<z>
);<z>
codeList);<z>
Type getHttpEntityType(MethodParameter parameter) {<z>
;<z>
);<z>
) {<z>
{<z>
IllegalArgumentException("Expected single generic parameter on '" +<z>
+ parameter.getMethod());<z>
;<z>
{<z>
Object.class;<z>
;<z>
URI url, Session jettySession) {<z>
HttpHeaders();<z>
::put);<z>
.getFirst("Sec-WebSocket-Protocol");<z>
(), protocol);<z>
Nullable SQLWarning warning) throws SQLWarningException {<z>
if (warning != null) {<z>
);<z>
propertyPath) {<z>
pos = PropertyAccessorUtils.getFirstNestedPropertySeparatorIndex(propertyPath);<z>
1) {<z>
.substring(0, pos);<z>
propertyPath.substring(pos + 1);<z>
nestedProperty);<z>
(nestedPath);<z>
return this;<z>
) {<z>
return Mono.fromCallable(() -> {<z>
4);<z>
.write((byte)'-');<z>
)'-');<z>
);<z>
write((byte)'\r');<z>
write((byte)'\n');<z>
buffer;<z>
;<z>
unmarshalFromTextMessage(TextMessage message, Unmarshaller unmarshaller)<z>
{<z>
.getText()));<z>
.unmarshal(source);<z>
{<z>
definition, parserContext);<z>
.hasText(id)) {<z>
.getAttribute("path");<z>
id;<z>
Annotation[] annotations, AnnotatedElement annotatedElement) {<z>
if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {<z>
annotations;<z>
(Annotation[]) Array.newInstance(<z>
getComponentType(), annotations.length);<z>
length; i++) {<z>
annotatedElement);<z>
synthesized;<z>
) {<z>
== obj) {<z>
true;<z>
(obj == null) {<z>
;<z>
.getClass()) {<z>
return false;<z>
ParsedProfiles that = (ParsedProfiles) obj;<z>
);<z>
relativePropertySourceName, PropertySource<?> propertySource) {<z>
assertLegalRelativeAddition(relativePropertySourceName, propertySource);<z>
.propertySourceList) {<z>
propertySource);<z>
);<z>
index, propertySource);<z>
{<z>
, off, len);<z>
flush();<z>
();<z>
) {<z>
.startNegate();<z>
.accept(visitor);<z>
);<z>
, ? extends U> after) {<z>
(after, "After Converter must not be null");<z>
(S s) -> {<z>
s);<z>
) : null);<z>
) {<z>
this.matches]) {<z>
.matches++;<z>
length);<z>
;<z>
CandidateComponentsMetadata readMetadata() {<z>
;<z>
(IOException ex) {<z>
null;<z>
.ValueHolder> ias) {<z>
)) {<z>
(valueHolder.getValue());<z>
{<z>
.setValue(newVal);<z>
MediaType defaultType) {<z>
() != null) {<z>
;<z>
return main;<z>
statusCode,<z>
charset) {<z>
body, charset);<z>
left, Bindings right) {<z>
(left, "Left side Bindings must not be null");<z>
right, "Right side Bindings must not be null");<z>
;<z>
getBindings().values());<z>
getBindings().values());<z>
result);<z>
void logMappings() {<z>
(mappingsLogger.isDebugEnabled()) {<z>
());<z>
if (logger.isDebugEnabled()) {<z>
formatMappingName());<z>
String annType, String attribute) throws IOException {<z>
.metadata.getAnnotationAttributes(annType, true);<z>
annotationAttributes.containsKey(attribute)) {<z>
;<z>
[]) annotationAttributes.get(attribute);<z>
();<z>
{<z>
;<z>
result;<z>
) {<z>
null;<z>
;<z>
int endOfPath = placeholder.lastIndexOf('/');<z>
(endOfPath != -1) {<z>
, endOfPath);<z>
placeholder.substring(endOfPath + 1);<z>
(path, key, this.userPrefs);<z>
) {<z>
, key, this.systemPrefs);<z>
) {<z>
(placeholder);<z>
value;<z>
FormatStyle convertStyleCharacter(char c) {<z>
{<z>
case 'S': return FormatStyle.SHORT;<z>
return FormatStyle.MEDIUM;<z>
LONG;<z>
FULL;<z>
return null;<z>
"Invalid style character '" + c + "'");<z>
Element element, BeanDefinitionBuilder builder) {<z>
.getAttribute("type");<z>
type)) {<z>
type);<z>
Object bean, String beanName) {<z>
ApplicationListener) {<z>
.singletonNames.get(beanName);<z>
TRUE.equals(flag)) {<z>
;<z>
flag)) {<z>
) {<z>
.warn("Inner bean '" + beanName + "' implements ApplicationListener interface " +<z>
;<z>
.singletonNames.remove(beanName);<z>
;<z>
AnnotatedElement element,<z>
annotationType, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {<z>
?> mergedAnnotation = findAnnotations(element)<z>
firstDirectlyDeclared());<z>
(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);<z>
builder) throws IOException {<z>
;<z>
(this) {<z>
{<z>
), entry.getMediaType());<z>
void handleMissingValueAfterConversion(<z>
{<z>
(name, parameter, true);<z>
SAXException {<z>
(target, data);<z>
(XMLStreamException ex) {<z>
), ex);<z>
(ExpressionState state) throws SpelEvaluationException {<z>
)) {<z>
.getActiveContextObject();<z>
this.name.equals(ROOT)) {<z>
.getRootContextObject();<z>
toDescriptorFromObject(result.getValue());<z>
result;<z>
this.name);<z>
;<z>
).getModifiers())) {<z>
= "Ljava/lang/Object";<z>
.exitTypeDescriptor = CodeFlow.toDescriptorFromObject(value);<z>
return result;<z>
{<z>
descriptor).getClassName();<z>
;<z>
, this.access,<z>
, annotations);<z>
accept(metadata);<z>
DataBuffer> content, long byteCount) {<z>
;<z>
.content = content;<z>
.byteCount = byteCount;<z>
[] args)<z>
{<z>
ReflectionUtils.makeAccessible(method);<z>
);<z>
ex) {<z>
.getTargetException();<z>
{<z>
AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +<z>
);<z>
IllegalAccessException ex) {<z>
;<z>
void prepareResponse(Exception ex, HttpServletResponse response) {<z>
preventResponseCaching) {<z>
;<z>
(Element element, ParserContext parserContext) {<z>
registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);<z>
);<z>
null;<z>
operandExpression) {<z>
) {<z>
.RIGHT_OPERAND_PROBLEM);<z>
) {<z>
) {<z>
()) {<z>
refresh();<z>
;<z>
;<z>
{<z>
(getServletContext(), attrName);<z>
.findWebApplicationContext(getServletContext());<z>
args, Locale locale) {<z>
&& ObjectUtils.isEmpty(args)) {<z>
msg;<z>
MessageFormat messageFormat = null;<z>
{<z>
messageFormatsPerMessage.get(msg);<z>
!= null) {<z>
.get(locale);<z>
;<z>
messageFormatsPerMessage.put(msg, messageFormatsPerLocale);<z>
null) {<z>
msg, locale);<z>
{<z>
(isAlwaysUseMessageFormat()) {<z>
throw ex;<z>
messageFormat = INVALID_MESSAGE_FORMAT;<z>
(locale, messageFormat);<z>
) {<z>
;<z>
synchronized (messageFormat) {<z>
(args, locale));<z>
boolean supportsMimeType(@Nullable MimeType mimeType) {<z>
null) {<z>
return true;<z>
supportedMimeType : this.mimeTypes) {<z>
) {<z>
;<z>
false;<z>
List<String> requestedProtocols, WebSocketHandler webSocketHandler) {<z>
determineHandlerSupportedProtocols(webSocketHandler);<z>
for (String protocol : requestedProtocols) {<z>
toLowerCase())) {<z>
;<z>
) {<z>
;<z>
;<z>
{<z>
) {<z>
put(beanDefinition.getBeanName(),<z>
.propertyName, this.propertyValue));<z>
<? extends Annotation> annotationType,<z>
Class<?> fieldType) {<z>
.annotationType = annotationType;<z>
;<z>
= fieldType;<z>
(ServerRequest request,<z>
PathPattern pattern) {<z>
= request;<z>
.requestPath(), info);<z>
, info.getUriVariables(), pattern);<z>
hasMappingForPattern(String pathPattern) {<z>
registration : this.registrations) {<z>
)) {<z>
return true;<z>
;<z>
bodyClass) throws ServletException, IOException {<z>
;<z>
MediaType.APPLICATION_OCTET_STREAM);<z>
<?> messageConverter : this.messageConverters) {<z>
{<z>
T> genericMessageConverter =<z>
messageConverter;<z>
)) {<z>
.read(bodyType, bodyClass, inputMessage);<z>
) {<z>
T> theConverter =<z>
<T>) messageConverter;<z>
Class<? extends T>) bodyClass;<z>
;<z>
(contentType, Collections.emptyList());<z>
postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {<z>
mergeProperties();<z>
);<z>
mergedProps);<z>
ex) {<z>
BeanInitializationException("Could not load properties", ex);<z>
, Object value,<z>
ValueExtractor valueExtractor) {<z>
), value, valueExtractor);<z>
SendTo getSendTo(Method specificMethod) {<z>
.class);<z>
if (ann == null) {<z>
);<z>
ann;<z>
) {<z>
null) {<z>
.contentNegotiationManager.getAllFileExtensions();<z>
return null;<z>
TypeProvider provider) {<z>
providedType = provider.getType();<z>
providedType == null || providedType instanceof Serializable) {<z>
;<z>
)) {<z>
return providedType;<z>
providedType);<z>
null) {<z>
return cached;<z>
type : SUPPORTED_SERIALIZABLE_TYPES) {<z>
isInstance(providedType)) {<z>
provider.getClass().getClassLoader();<z>
};<z>
InvocationHandler handler = new TypeProxyInvocationHandler(provider);<z>
;<z>
(providedType, cached);<z>
;<z>
);<z>
String sql, SqlParameterSource paramSource) throws DataAccessException {<z>
).query(<z>
SqlRowSetResultSetExtractor());<z>
!= null, "No result");<z>
;<z>
AnnotationConfigApplicationContext() {<z>
getApplicationStartup().start("spring.context.annotated-bean-reader.create");<z>
.reader = new AnnotatedBeanDefinitionReader(this);<z>
();<z>
;<z>
checkIfClosed() throws XMLStreamException {<z>
(this.closed) {<z>
new XMLStreamException("XMLEventReader has been closed");<z>
beanDefinition) {<z>
resolvedDestroyMethodName;<z>
) {<z>
beanDefinition.getDestroyMethodName();<z>
);<z>
(AbstractBeanDefinition.INFER_METHOD.equals(destroyMethodName) ||<z>
(destroyMethodName == null && autoCloseable)) {<z>
destroyMethodName = null;<z>
instanceof DisposableBean)) {<z>
if (autoCloseable) {<z>
;<z>
();<z>
(NoSuchMethodException ex) {<z>
);<z>
catch (NoSuchMethodException ex2) {<z>
);<z>
destroyMethodName) ? destroyMethodName : null);<z>
containerEle, ParserContext parserContext) {<z>
();<z>
DESTINATION_TYPE_ATTRIBUTE);<z>
;<z>
subscriptionDurable = false;<z>
= false;<z>
equals(destinationType)) {<z>
true;<z>
= true;<z>
;<z>
.equals(destinationType)) {<z>
= true;<z>
subscriptionShared = true;<z>
(destinationType)) {<z>
true;<z>
;<z>
) {<z>
true;<z>
|| DESTINATION_TYPE_QUEUE.equals(destinationType)) {<z>
.getReaderContext().error("Invalid listener container 'destination-type': only " +<z>
containerEle);<z>
properties.add("pubSubDomain", pubSubDomain);<z>
add("subscriptionDurable", subscriptionDurable);<z>
"subscriptionShared", subscriptionShared);<z>
boolean replyPubSubDomain = false;<z>
(RESPONSE_DESTINATION_TYPE_ATTRIBUTE);<z>
(!StringUtils.hasText(replyDestinationType)) {<z>
pubSubDomain;<z>
)) {<z>
replyPubSubDomain = true;<z>
(!DESTINATION_TYPE_QUEUE.equals(replyDestinationType)) {<z>
+<z>
, containerEle);<z>
("replyPubSubDomain", replyPubSubDomain);<z>
(CLIENT_ID_ATTRIBUTE)) {<z>
;<z>
{<z>
().error(<z>
;<z>
add("clientId", clientId);<z>
containerEle.hasAttribute(MESSAGE_CONVERTER_ATTRIBUTE)) {<z>
String messageConverter = containerEle.getAttribute(MESSAGE_CONVERTER_ATTRIBUTE);<z>
{<z>
().error(<z>
;<z>
;<z>
;<z>
(<z>
Nullable Reader characterStream, int contentLength)<z>
throws SQLException {<z>
(streamAsLob) {<z>
if (characterStream != null) {<z>
) {<z>
characterStream, contentLength);<z>
;<z>
(paramIndex, (Clob) null);<z>
else if (wrapAsLob) {<z>
if (characterStream != null) {<z>
));<z>
setClob(paramIndex, (Clob) null);<z>
contentLength >= 0) {<z>
, characterStream, contentLength);<z>
characterStream);<z>
logger.isDebugEnabled()) {<z>
!= null ? "Set character stream for CLOB with length " + contentLength :<z>
"Set CLOB to null");<z>
) {<z>
new HttpInputMessage() {<z>
getBody() {<z>
content) : StreamUtils.emptyInput());<z>
public HttpHeaders getHeaders() {<z>
HttpHeaders();<z>
);<z>
return headers;<z>
;<z>
ex) {<z>
("Failed to parse form data in request body", ex);<z>
static List<Route> staticRoutes() {<z>
(<z>
),<z>
("/why-spring"),<z>
Route("/microservices"),<z>
Route("/reactive"),<z>
Route("/event-driven"),<z>
"/cloud"),<z>
),<z>
new Route("/serverless"),<z>
,<z>
,<z>
,<z>
new Route("/community/events"),<z>
("/community/support"),<z>
Route("/some/other/section"),<z>
("/blog.atom")<z>
(MetadataReader reader, MetadataReaderFactory readerFactory) throws IOException {<z>
(this.entityTypeFilters != null) {<z>
filter : this.entityTypeFilters) {<z>
match(reader, readerFactory)) {<z>
true;<z>
return false;<z>
declaringClassName, String methodName, String descriptor) {<z>
;<z>
= methodName;<z>
.descriptor = descriptor;<z>
@Nullable Class<?> targetClass) {<z>
) {<z>
get(method);<z>
this.transactionAttributeMap) {<z>
if (!this.initialized) {<z>
initMethodMap(this.methodMap);<z>
= true;<z>
return this.transactionAttributeMap.get(method);<z>
{<z>
;<z>
);<z>
if (value instanceof JAXBElement) {<z>
).getDeclaredType();<z>
.supports(classToCheck);<z>
lastWeekdayOfMonth() {<z>
lastDayOfMonth();<z>
temporal -> {<z>
adjuster.adjustInto(temporal);<z>
result;<z>
get(ChronoField.DAY_OF_WEEK);<z>
(dow == 6) {<z>
ChronoUnit.DAYS);<z>
{<z>
;<z>
= lastDom;<z>
result);<z>
,<z>
, Element element, @Nullable Object source) {<z>
= element.getAttribute("resource-cache");<z>
(resourceCache)) {<z>
new ConstructorArgumentValues();<z>
.class);<z>
setSource(source);<z>
cachingResolverDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
cargs);<z>
;<z>
setSource(source);<z>
.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
cachingTransformerDef.setConstructorArgumentValues(cargs);<z>
element.getAttribute("cache-manager");<z>
= element.getAttribute("cache-name");<z>
)) {<z>
= new RuntimeBeanReference(cacheManagerName);<z>
;<z>
);<z>
;<z>
;<z>
cacheDef = new RootBeanDefinition(ConcurrentMapCache.class);<z>
cacheDef.setSource(source);<z>
cacheDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
cacheCavs);<z>
0, cacheDef);<z>
cachingResolverDef);<z>
resourceTransformers.add(cachingTransformerDef);<z>
heartbeat) {<z>
heartbeat[1] < 0)) {<z>
+ Arrays.toString(heartbeat));<z>
this.heartbeatValue = heartbeat;<z>
DataBuffer> getBody() {<z>
return this.inbound.receive()<z>
s -> {<z>
{<z>
{<z>
(<z>
);<z>
.map(byteBuf -> {<z>
;<z>
bufferFactory.wrap(byteBuf);<z>
);<z>
HttpMediaTypeNotAcceptableException ex,<z>
IOException {<z>
response.sendError(HttpServletResponse.SC_NOT_ACCEPTABLE);<z>
ModelAndView();<z>
(AsyncEvent event) throws IOException {<z>
(Runnable::run);<z>
.asyncContext = null;<z>
;<z>
(<z>
.InputStream input,<z>
)<z>
io.IOException {<z>
extensionRegistry);<z>
) throws Exception {<z>
> matches = new ArrayList<>();<z>
mappingRegistry.getMappingsByDirectPath(lookupPath);<z>
if (directPathMatches != null) {<z>
);<z>
.isEmpty()) {<z>
(), matches, request);<z>
(!matches.isEmpty()) {<z>
get(0);<z>
> 1) {<z>
);<z>
comparator);<z>
get(0);<z>
if (logger.isTraceEnabled()) {<z>
);<z>
CorsUtils.isPreFlightRequest(request)) {<z>
for (Match match : matches) {<z>
.hasCorsConfig()) {<z>
return PREFLIGHT_AMBIGUOUS_MATCH;<z>
(1);<z>
bestMatch, secondBestMatch) == 0) {<z>
().getMethod();<z>
).getMethod();<z>
);<z>
IllegalStateException(<z>
+ m1 + ", " + m2 + "}");<z>
());<z>
bestMatch.mapping, lookupPath, request);<z>
;<z>
keySet(), lookupPath, request);<z>
) {<z>
;<z>
: this.classFileTransformers) {<z>
bytes);<z>
!= null ? transformed : bytes);<z>
return bytes;<z>
ex) {<z>
throw new IllegalStateException(ex);<z>
name, boolean allowFactoryBeanInit) throws NoSuchBeanDefinitionException {<z>
(name);<z>
;<z>
.class) {<z>
isFactoryDereference(name)) {<z>
);<z>
getClass();<z>
);<z>
{<z>
);<z>
= getMergedLocalBeanDefinition(beanName);<z>
mbd.getDecoratedDefinition();<z>
&& !BeanFactoryUtils.isFactoryDereference(name)) {<z>
;<z>
getBeanName(), tbd);<z>
{<z>
targetClass;<z>
);<z>
class.isAssignableFrom(beanClass)) {<z>
name)) {<z>
).resolve();<z>
return beanClass;<z>
(name) ? beanClass : null);<z>
String propertyName) throws InvalidPropertyException {<z>
BeanWrapperImpl) getPropertyAccessorForPropertyPath(propertyName);<z>
, propertyName);<z>
getPropertyDescriptor(finalPath);<z>
if (pd == null) {<z>
(), getNestedPath() + propertyName,<z>
+ propertyName + "' found");<z>
return pd;<z>
(MessageSource messageSource) {<z>
!= null) {<z>
new IllegalArgumentException("MessageSource should not be set twice");<z>
this.messageSource = messageSource;<z>
) {<z>
<>(3);<z>
.class.getName());<z>
());<z>
jsr107Present && jcacheImplPresent) {<z>
.add(PROXY_JCACHE_CONFIGURATION_CLASS);<z>
toStringArray(result);<z>
resourceLoader) {<z>
);<z>
;<z>
.setMetadataReaderFactoryCalled) {<z>
= new CachingMetadataReaderFactory(resourceLoader);<z>
throws MissingResourceException {<z>
classLoader = getBundleClassLoader();<z>
!= null, "No bundle ClassLoader set");<z>
control = this.control;<z>
{<z>
(basename, locale, classLoader, control);<z>
{<z>
= null;<z>
encoding = getDefaultEncoding();<z>
null && logger.isInfoEnabled()) {<z>
logger.info("ResourceBundleMessageSource is configured to read resources with encoding '" +<z>
"' but ResourceBundle.Control not supported in current system environment: " +<z>
+ " - falling back to plain ResourceBundle.getBundle retrieval with the " +<z>
);<z>
.getBundle(basename, locale, classLoader);<z>
?>> predicate) {<z>
) {<z>
;<z>
);<z>
ScriptSource scriptSource)<z>
throws IOException, ScriptCompilationException {<z>
) {<z>
{<z>
wasModifiedForTypeCheck = true;<z>
).parseClass(<z>
());<z>
this.scriptClass)) {<z>
, this.scriptClass);<z>
);<z>
CachedResultHolder(result);<z>
.scriptResultClass = this.scriptClass;<z>
.scriptResultClass;<z>
) {<z>
this.scriptClass = null;<z>
= null;<z>
null;<z>
(scriptSource, ex);<z>
FreeMarkerViewResolver(String prefix, String suffix) {<z>
setViewClass(requiredViewClass());<z>
(prefix);<z>
(suffix);<z>
SQLErrorCodes errorCodes) {<z>
SQLExceptionTranslator customTranslator =<z>
(databaseName);<z>
(customTranslator != null) {<z>
isDebugEnabled()) {<z>
debug("Overriding already defined custom translator '" +<z>
+<z>
.getClass().getSimpleName() +<z>
+ databaseName + "'");<z>
(logger.isTraceEnabled()) {<z>
) +<z>
+ "'");<z>
customTranslator);<z>
(Element element, RootBeanDefinition beanDefinition) {<z>
{<z>
);<z>
hasAttribute("suffix")) {<z>
"suffix"));<z>
) {<z>
("cache-views"));<z>
) {<z>
"view-class"));<z>
)) {<z>
("view-names"));<z>
) {<z>
this.aspectBeanNames;<z>
null) {<z>
synchronized (this) {<z>
.aspectBeanNames;<z>
{<z>
);<z>
);<z>
String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<z>
, false);<z>
(String beanName : beanNames) {<z>
if (!isEligibleBean(beanName)) {<z>
.beanFactory.getType(beanName, false);<z>
) {<z>
)) {<z>
.add(beanName);<z>
AspectMetadata(beanType, beanName);<z>
== PerClauseKind.SINGLETON) {<z>
factory =<z>
, beanName);<z>
this.advisorFactory.getAdvisors(factory);<z>
{<z>
.advisorsCache.put(beanName, classAdvisors);<z>
;<z>
(classAdvisors);<z>
beanName)) {<z>
+ beanName +<z>
);<z>
factory =<z>
beanName);<z>
factory);<z>
.advisorFactory.getAdvisors(factory));<z>
.aspectBeanNames = aspectNames;<z>
;<z>
isEmpty()) {<z>
emptyList();<z>
<>();<z>
) {<z>
this.advisorsCache.get(aspectName);<z>
!= null) {<z>
addAll(cachedAdvisors);<z>
get(aspectName);<z>
(factory));<z>
return advisors;<z>
{<z>
)) {<z>
substring(1);<z>
new FileSystemResource(path);<z>
resolveUrlPathInternal(String resourceUrlPath,<z>
chain) {<z>
chain.resolveUrlPath(resourceUrlPath, locations);<z>
null) {<z>
= findWebJarResourcePath(resourceUrlPath);<z>
null) {<z>
);<z>
;<z>
throws IOException, XmlMappingException {<z>
if (source instanceof DOMSource) {<z>
return unmarshalDomSource((DOMSource) source);<z>
(StaxUtils.isStaxSource(source)) {<z>
;<z>
instanceof SAXSource) {<z>
unmarshalSaxSource((SAXSource) source);<z>
source instanceof StreamSource) {<z>
return unmarshalStreamSource((StreamSource) source);<z>
;<z>
) {<z>
.target.length()) {<z>
SpelEvaluationException(getStartPosition(), SpelMessage.STRING_INDEX_OUT_OF_BOUNDS,<z>
(), this.index);<z>
));<z>
<String> getDirectPaths() {<z>
isEmptyPathMapping()) {<z>
EMPTY_PATH_PATTERN;<z>
emptySet();<z>
String pattern : this.patterns) {<z>
) {<z>
: result);<z>
pattern);<z>
result;<z>
{<z>
);<z>
new ArrayList<>();<z>
;<z>
beanName;<z>
(factoryPrefix) {<z>
= FACTORY_BEAN_PREFIX + beanName;<z>
fullBeanName.equals(name)) {<z>
add(fullBeanName);<z>
.getAliases(beanName);<z>
? FACTORY_BEAN_PREFIX : "";<z>
(String retrievedAlias : retrievedAliases) {<z>
String alias = prefix + retrievedAlias;<z>
.equals(name)) {<z>
(alias);<z>
{<z>
;<z>
(parentBeanFactory != null) {<z>
));<z>
aliases);<z>
, @Nullable Object httpSocket, ServletContext servletContext) {<z>
);<z>
catch (Exception ex) {<z>
("Failed to upgrade TyrusMuxableWebSocket", ex);<z>
, boolean autoGrowNestedPaths) {<z>
super(objectName);<z>
target = target;<z>
;<z>
void configureXStream(XStream xstream) {<z>
null) {<z>
; i++) {<z>
.converters[i] instanceof Converter converter) {<z>
converter, i);<z>
[i] instanceof SingleValueConverter converter) {<z>
i);<z>
;<z>
) {<z>
(TypePermission permission : this.typePermissions) {<z>
permission);<z>
if (this.marshallingStrategy != null) {<z>
;<z>
) {<z>
;<z>
) {<z>
> classMap = toClassMap(this.aliases);<z>
classMap.forEach(xstream::alias);<z>
if (this.aliasesByType != null) {<z>
classMap = toClassMap(this.aliasesByType);<z>
.forEach(xstream::aliasType);<z>
this.fieldAliases != null) {<z>
()) {<z>
= entry.getValue();<z>
;<z>
field.lastIndexOf('.');<z>
) {<z>
field.substring(0, idx);<z>
.forName(className, this.beanClassLoader);<z>
(idx + 1);<z>
);<z>
("Field name [" + field + "] does not contain '.'");<z>
ClassNotFoundException ex) {<z>
("Failed to load specified alias class", ex);<z>
if (this.useAttributeForTypes != null) {<z>
> type : this.useAttributeForTypes) {<z>
.useAttributeFor(type);<z>
null) {<z>
()) {<z>
String key) {<z>
<?> clazz) {<z>
.useAttributeFor(key, clazz);<z>
(<z>
);<z>
) {<z>
value) {<z>
.useAttributeFor(key, value);<z>
?> listValue) {<z>
{<z>
) {<z>
key, value);<z>
"'useAttributesFor' property takes either Map<Class, String> " +<z>
;<z>
IllegalArgumentException(<z>
;<z>
if (this.implicitCollections != null) {<z>
(key, fields) -> {<z>
);<z>
for (String collectionField : collectionFields) {<z>
addImplicitCollection(key, collectionField);<z>
;<z>
if (this.omittedFields != null) {<z>
.forEach((key, value) -> {<z>
StringUtils.commaDelimitedListToStringArray(value);<z>
{<z>
;<z>
;<z>
!= null) {<z>
this.annotatedClasses);<z>
(this.autodetectAnnotations) {<z>
autodetectAnnotations(true);<z>
MessagingRSocket createResponder(ConnectionSetupPayload setupPayload, RSocket rsocket) {<z>
= setupPayload.dataMimeType();<z>
: this.defaultDataMimeType;<z>
dataMimeType, "No `dataMimeType` in ConnectionSetupPayload and no default value");<z>
), "Data MimeType '" + dataMimeType + "' not supported");<z>
);<z>
this.defaultMetadataMimeType;<z>
Assert.notNull(metaMimeType, "No `metadataMimeType` in ConnectionSetupPayload and no default value");<z>
;<z>
getMetadataExtractor(),<z>
(), this.strategies);<z>
Method method) {<z>
;<z>
<>(parameterTypes.length);<z>
) {<z>
());<z>
.getName()<z>
method.getName()<z>
.collectionToCommaDelimitedString(parameters) + ')';<z>
setUserDestinationPrefix(String prefix) {<z>
);<z>
prefix : prefix + "/");<z>
{<z>
("Attempting to refresh target");<z>
this.targetObject = freshTarget();<z>
.refreshCount++;<z>
.lastRefreshTime = System.currentTimeMillis();<z>
("Target refreshed successfully");<z>
parseState, @Nullable Throwable rootCause) {<z>
(message, "Message must not be null");<z>
(location, "Location must not be null");<z>
;<z>
;<z>
parseState;<z>
rootCause;<z>
, Supplier<? extends CharSequence> messageSupplier) {<z>
.isInfoEnabled()) {<z>
);<z>
dest) throws JMSException {<z>
: null);<z>
cachedProducers.get(cacheKey);<z>
producer != null) {<z>
)) {<z>
);<z>
);<z>
)) {<z>
("Registering cached JMS MessageProducer for destination [" + dest + "]: " + producer);<z>
);<z>
(producer);<z>
,<z>
HttpHeaders headers, XhrClientSockJsSession sockJsSession,<z>
> connectFuture) {<z>
.request = request;<z>
connection = connection;<z>
url;<z>
headers = headers;<z>
sockJsSession;<z>
.connectFuture = connectFuture;<z>
() {<z>
(isSqlReadyForUse()) {<z>
();<z>
callString = new StringBuilder(32);<z>
= getDeclaredParameters();<z>
parameterCount = 0;<z>
isFunction()) {<z>
resolveSql()).append('(');<z>
-1;<z>
;<z>
: parameters) {<z>
) {<z>
> 0) {<z>
(", ");<z>
>= 0) {<z>
callString.append('?');<z>
;<z>
.append(")}");<z>
callString = callString.toString();<z>
)) {<z>
;<z>
.callString, getDeclaredParameters());<z>
));<z>
));<z>
();<z>
int compareTo(AnnotatedElementKey other) {<z>
element.toString());<z>
this.targetClass != null) {<z>
targetClass == null) {<z>
return 1;<z>
targetClass.getName());<z>
result;<z>
() {<z>
(this.bindingResult == null) {<z>
this.directFieldAccess ?<z>
));<z>
return this.bindingResult;<z>
Class<?> clazz, String methodName) {<z>
<>(1);<z>
] methods = clazz.getMethods();<z>
Method method : methods) {<z>
())) {<z>
candidates.add(method);<z>
candidates;<z>
(Object other) {<z>
) {<z>
return true;<z>
this.type.isInstance(other)) {<z>
false;<z>
; i++) {<z>
.get(i);<z>
;<z>
);<z>
(thisValue, otherValue)) {<z>
false;<z>
;<z>
{<z>
{<z>
);<z>
successCallback.onSuccess(this.value);<z>
{<z>
) {<z>
message.getHeaders();<z>
);<z>
prefix)) {<z>
;<z>
= SimpMessageHeaderAccessor.getMessageType(headers);<z>
{<z>
switch (messageType) {<z>
:<z>
case UNSUBSCRIBE:<z>
;<z>
case MESSAGE:<z>
);<z>
return null;<z>
final Attribute attribute) {<z>
) {<z>
.visitAttribute(attribute);<z>
{<z>
(message.getHeaders());<z>
{<z>
(other.getMessageType())) {<z>
0;<z>
this.messageType)) {<z>
-1;<z>
equals(other.getMessageType())) {<z>
;<z>
return 0;<z>
Nullable ResourceLoader resourceLoader) {<z>
DefaultResourceLoader());<z>
;<z>
;<z>
(tempDir != null) {<z>
new File(tempDir));<z>
, new MockRequestDispatcher(this.defaultServletName));<z>
) {<z>
.client.newBuilder()<z>
.MILLISECONDS)<z>
.build();<z>
targetClass) {<z>
) == Object.class) {<z>
return null;<z>
getCacheKey(method, targetClass);<z>
);<z>
) {<z>
!= NULL_CACHING_ATTRIBUTE ? cached : null);<z>
computeCacheOperations(method, targetClass);<z>
null) {<z>
logger.isTraceEnabled()) {<z>
+ "' with attribute: " + cacheOps);<z>
put(cacheKey, cacheOps);<z>
attributeCache.put(cacheKey, NULL_CACHING_ATTRIBUTE);<z>
return cacheOps;<z>
> T getRequiredAttribute(String name) {<z>
(name);<z>
"Required attribute '" + name + "' is missing.");<z>
return value;<z>
,<z>
ParserContext parserContext, BeanDefinitionBuilder builder) {<z>
);<z>
(builder.getRawBeanDefinition());<z>
.getBeanDefinition(), generatedName));<z>
return new RuntimeBeanReference(generatedName);<z>
, Path file, WritableByteChannel channel) {<z>
;<z>
= file;<z>
= channel;<z>
AtomicLong(state.byteCount);<z>
getCache(String name) {<z>
, "No target CacheManager set");<z>
= this.targetCacheManager.getCache(name);<z>
(targetCache) : null);<z>
) throws JMException, IOException {<z>
.server == null) {<z>
.server = JmxUtils.locateMBeanServer();<z>
.serviceUrl);<z>
this.server);<z>
(this.forwarder != null) {<z>
;<z>
if (this.objectName != null) {<z>
(this.connectorServer, this.objectName);<z>
(this.threaded) {<z>
;<z>
Thread() {<z>
run() {<z>
);<z>
(IOException ex) {<z>
throw new JmxException("Could not start JMX connector server after delay", ex);<z>
);<z>
.daemon);<z>
connectorThread.start();<z>
;<z>
isInfoEnabled()) {<z>
.info("JMX connector server started: " + this.connectorServer);<z>
{<z>
;<z>
;<z>
extends T> candidates) {<z>
for (T candidate : candidates) {<z>
)) {<z>
;<z>
return false;<z>
private Mono<WebSession> createWebSession() {<z>
session = this.sessionStore.createWebSession();<z>
(logger.isDebugEnabled()) {<z>
s -> logger.debug("Created new WebSession."));<z>
;<z>
,<z>
) {<z>
=<z>
, RelativeRedirectResponseWrapper.class);<z>
response :<z>
new RelativeRedirectResponseWrapper(response, redirectStatus));<z>
) throws Exception {<z>
null) {<z>
IllegalArgumentException("'servletClass' is required");<z>
this.servletName == null) {<z>
.servletName = this.beanName;<z>
;<z>
.init(new DelegatingServletConfig());<z>
() {<z>
));<z>
Date(getStartupDate()));<z>
= getParent();<z>
{<z>
;<z>
();<z>
copyTo(MailMessage target) {<z>
);<z>
!= null) {<z>
getFrom());<z>
) != null) {<z>
target.setReplyTo(getReplyTo());<z>
() != null) {<z>
(copy(getTo()));<z>
getCc() != null) {<z>
getCc()));<z>
) {<z>
(getBcc()));<z>
) != null) {<z>
);<z>
{<z>
setSubject(getSubject());<z>
{<z>
());<z>
{<z>
"Name must not be null");<z>
synchronized (this.requestDestructionCallbacks) {<z>
(name);<z>
createJacksonConverter() {<z>
MappingJackson2MessageConverter messageConverter = super.createJacksonConverter();<z>
json();<z>
= getApplicationContext();<z>
applicationContext != null) {<z>
applicationContext(applicationContext);<z>
.build());<z>
return messageConverter;<z>
visitMethodInsn(<z>
,<z>
owner,<z>
,<z>
descriptor,<z>
) {<z>
code.length;<z>
descriptor, isInterface);<z>
== Opcodes.INVOKEINTERFACE) {<z>
put12(Opcodes.INVOKEINTERFACE, methodrefSymbol.index)<z>
0);<z>
{<z>
);<z>
null) {<z>
) {<z>
;<z>
{<z>
();<z>
);<z>
;<z>
if (opcode == Opcodes.INVOKESTATIC) {<z>
= relativeStackSize + stackSizeDelta + 1;<z>
else {<z>
+ stackSizeDelta;<z>
{<z>
;<z>
relativeStackSize = size;<z>
flush() throws IOException {<z>
= this.outputStream;<z>
)) {<z>
flush();<z>
this.flushOnNext = false;<z>
{<z>
= true;<z>
;<z>
true;<z>
request, Object handler) {<z>
LastModified) {<z>
(request);<z>
1L;<z>
(PropertyTokenHolder tokens) {<z>
);<z>
{<z>
canonicalName,<z>
"Could not determine property type for auto-growing a default value");<z>
canonicalName);<z>
.canonicalName, defaultValue);<z>
HttpInputMessage beforeBodyRead(HttpInputMessage inputMessage, MethodParameter methodParameter,<z>
> selectedConverterType) throws IOException {<z>
.getParameterAnnotation(JsonView.class);<z>
ann != null, "No JsonView annotation");<z>
value();<z>
) {<z>
new IllegalArgumentException(<z>
);<z>
);<z>
) throws ParseException {<z>
locale);<z>
if (this.roundingMode != null) {<z>
fractionDigits, this.roundingMode);<z>
setScale(this.fractionDigits);<z>
return decimal;<z>
Nullable MediaType mediaType) throws IOException {<z>
this.handler != null) {<z>
object, mediaType);<z>
) {<z>
sendFailed = true;<z>
ex;<z>
(Throwable ex) {<z>
true;<z>
new IllegalStateException("Failed to send " + object, ex);<z>
new DataWithMediaType(object, mediaType));<z>
ServletContext servletContext) {<z>
(CONTEXT_CLASS_PARAM);<z>
if (contextClassName != null) {<z>
.getDefaultClassLoader());<z>
ClassNotFoundException ex) {<z>
throw new ApplicationContextException(<z>
;<z>
getName());<z>
class.getClassLoader());<z>
(ClassNotFoundException ex) {<z>
ApplicationContextException(<z>
"Failed to load default context class [" + contextClassName + "]", ex);<z>
) {<z>
"ClientHttpConnector must not be null");<z>
notNull(strategies, "ExchangeStrategies must not be null");<z>
.connector = connector;<z>
this.strategies = strategies;<z>
.stream()<z>
filter(LoggingCodecSupport.class::isInstance)<z>
.forEach(reader -> {<z>
{<z>
;<z>
});<z>
private ObjectWriter createObjectWriter(<z>
, @Nullable MimeType mimeType,<z>
{<z>
), null);<z>
{<z>
Jackson2CodecSupport.JSON_VIEW_HINT);<z>
());<z>
{<z>
);<z>
;<z>
ReactiveHttpInputMessage> toFormData() {<z>
message, context) -> {<z>
= FORM_DATA_TYPE;<z>
= MediaType.APPLICATION_FORM_URLENCODED;<z>
, mediaType, context);<z>
message, context, elementType, reader);<z>
InjectionMetadata buildResourceMetadata(Class<?> clazz) {<z>
(clazz, resourceAnnotationTypes)) {<z>
InjectionMetadata.EMPTY;<z>
new ArrayList<>();<z>
<?> targetClass = clazz;<z>
<>();<z>
field -> {<z>
) {<z>
))) {<z>
;<z>
);<z>
{<z>
.getModifiers())) {<z>
"@Resource annotation is not supported on static fields");<z>
getName())) {<z>
, null));<z>
;<z>
-> {<z>
findBridgedMethod(method);<z>
isVisibilityBridgeMethodPair(method, bridgedMethod)) {<z>
.getMostSpecificMethod(method, clazz))) {<z>
null && bridgedMethod.isAnnotationPresent(ejbClass)) {<z>
.getModifiers())) {<z>
"@EJB annotation is not supported on static methods");<z>
getParameterCount() != 1) {<z>
IllegalStateException("@EJB annotation requires a single-arg method: " + method);<z>
;<z>
, bridgedMethod, pd));<z>
)) {<z>
())) {<z>
throw new IllegalStateException("@Resource annotation is not supported on static methods");<z>
;<z>
1) {<z>
;<z>
0].getName())) {<z>
);<z>
;<z>
);<z>
;<z>
targetClass = targetClass.getSuperclass();<z>
!= null && targetClass != Object.class);<z>
return InjectionMetadata.forElements(elements, clazz);<z>
) {<z>
;<z>
(task, null);<z>
);<z>
;<z>
RejectedExecutionException ex) {<z>
task, ex);<z>
private void reset() {<z>
= "0.0.0.0";<z>
;<z>
;<z>
this.handlerMap = null;<z>
;<z>
) {<z>
= dateFormat;<z>
;<z>
exactDateLength = exactDateLength;<z>
<DataBuffer> input, ResolvableType elementType,<z>
Map<String, Object> hints) {<z>
);<z>
isWritable() {<z>
();<z>
());<z>
ex) {<z>
return false;<z>
<String> predicate) {<z>
{<z>
applicationListenerBeans.removeIf(predicate);<z>
retrieverCache.clear();<z>
() {<z>
handlerMappings = this.handlerMappings;<z>
(handlerMappings == null) {<z>
) {<z>
.handlerMappings;<z>
== null) {<z>
{<z>
handlerMappingsLocation + "]");<z>
=<z>
, this.classLoader);<z>
isTraceEnabled()) {<z>
mappings);<z>
;<z>
mappings, handlerMappings);<z>
.handlerMappings = handlerMappings;<z>
(IOException ex) {<z>
IllegalStateException(<z>
);<z>
;<z>
String> messageSupplier) {<z>
) {<z>
throw new IllegalArgumentException(nullSafeGet(messageSupplier));<z>
) {<z>
;<z>
predicate.accept(this);<z>
builder.append(" -> ");<z>
handlerFunction).append('\n');<z>
) throws SQLException {<z>
sqlColIndx = 1;<z>
i++) {<z>
this.parameters.get(i);<z>
declaredParameter;<z>
instanceof SqlParameterValue paramValue) {<z>
= paramValue.getValue();<z>
= paramValue;<z>
(declaredParameters.size() <= i) {<z>
throw new InvalidDataAccessApiUsageException(<z>
sql + "]: unable to access parameter number " + (i + 1) +<z>
+ declaredParameters.size() + " parameters");<z>
get(i);<z>
) {<z>
;<z>
for (Object entry : entries) {<z>
Object[] valueArray) {<z>
) {<z>
declaredParameter, argValue);<z>
sqlColIndx++, declaredParameter, entry);<z>
++, declaredParameter, in);<z>
private void logRequest(ClientRequest request) {<z>
traceOn -><z>
request.url() +<z>
)<z>
boolean shouldParse(HttpServletRequest request) {<z>
);<z>
request.getMethod();<z>
method)) {<z>
MediaType.parseMediaType(contentType);<z>
(mediaType);<z>
) {<z>
false;<z>
, Description description) {<z>
);<z>
) {<z>
() + "]");<z>
testClass);<z>
;<z>
testContextManager);<z>
);<z>
, testClass);<z>
);<z>
return statement;<z>
{<z>
)) {<z>
.values((String) key));<z>
;<z>
{<z>
this.destinationCache.get(destination);<z>
) {<z>
(destination, _destination -> {<z>
matches = computeMatchingSubscriptions(destination);<z>
cacheEvictionPolicy.add(destination);<z>
incrementAndGet();<z>
matches;<z>
});<z>
);<z>
;<z>
, WebSocketMessage<?> message) throws Exception {<z>
()) {<z>
" in " + session);<z>
session, message);<z>
?> map, String prefix, String resourceDescription)<z>
{<z>
className = null;<z>
parent = null;<z>
;<z>
= false;<z>
lazyInit = false;<z>
ConstructorArgumentValues();<z>
MutablePropertyValues pvs = new MutablePropertyValues();<z>
= prefix + SEPARATOR;<z>
();<z>
.entrySet()) {<z>
);<z>
(prefixWithSep)) {<z>
= key.substring(beginIndex);<z>
CLASS_KEY.equals(property)) {<z>
)).strip();<z>
.equals(property)) {<z>
();<z>
)) {<z>
.strip();<z>
= TRUE_VALUE.equals(val);<z>
equals(property)) {<z>
;<z>
SINGLETON_KEY.equals(property)) {<z>
()).strip();<z>
|| TRUE_VALUE.equals(val) ?<z>
SCOPE_SINGLETON : BeanDefinition.SCOPE_PROTOTYPE);<z>
(LAZY_INIT_KEY.equals(property)) {<z>
;<z>
);<z>
)) {<z>
)) {<z>
, 10);<z>
)));<z>
;<z>
(index, readValue(entry));<z>
(property.endsWith(REF_SUFFIX)) {<z>
;<z>
strip();<z>
val = new RuntimeBeanReference(ref);<z>
add(property, val);<z>
, readValue(entry));<z>
(logger.isTraceEnabled()) {<z>
+ "' with " + pvs);<z>
beanName.equals(this.defaultParentBean)) {<z>
.defaultParentBean;<z>
AbstractBeanDefinition bd = BeanDefinitionReaderUtils.createBeanDefinition(<z>
);<z>
scope);<z>
isAbstract);<z>
lazyInit);<z>
;<z>
pvs);<z>
(beanName, bd);<z>
ClassNotFoundException ex) {<z>
);<z>
(LinkageError err) {<z>
;<z>
?> enclosingClass, String attributeName) {<z>
notNull(enclosingClass, "'enclosingClass' must not be null");<z>
"'attributeName' must not be null");<z>
.getName() + '.' + attributeName;<z>
(HttpServletRequest request, HttpServletResponse response)<z>
{<z>
.dispatchTraceRequest) {<z>
response);<z>
equals(response.getContentType())) {<z>
response);<z>
int getDimensions() {<z>
= 1;<z>
) == '[') {<z>
;<z>
return numDimensions;<z>
Nullable String requiredName) {<z>
0, "Index must not be negative");<z>
= this.indexedArgumentValues.get(index);<z>
valueHolder != null &&<z>
null || (requiredType != null &&<z>
getType()))) &&<z>
== null || (requiredName != null &&<z>
()))))) {<z>
valueHolder;<z>
;<z>
filename, Charset charset) {<z>
.notNull(filename, "'input' String` should not be null");<z>
Assert.notNull(charset, "'charset' should not be null");<z>
= filename.getBytes(charset);<z>
new ByteArrayOutputStream();<z>
;<z>
index < value.length) {<z>
b = value[index];<z>
isRFC5987AttrChar(b)) {<z>
;<z>
;<z>
- 2) {<z>
};<z>
, 16));<z>
(NumberFormatException ex) {<z>
INVALID_HEADER_FIELD_PARAMETER_FORMAT, ex);<z>
index+=3;<z>
throw new IllegalArgumentException(INVALID_HEADER_FIELD_PARAMETER_FORMAT);<z>
);<z>
RequestMatcher doesNotExist() {<z>
() {<z>
request) throws IOException, ParseException {<z>
(request.getBodyAsString());<z>
Class<?> genericIfc) {<z>
clazz).as(genericIfc);<z>
if (!resolvableType.hasGenerics()) {<z>
return null;<z>
resolvableType);<z>
, @Nullable PropertyDescriptor pd) {<z>
;<z>
PersistenceContext.class);<z>
);<z>
Class<?> resourceType = EntityManager.class;<z>
null) {<z>
{<z>
("Member may only be annotated with either " +<z>
+ member);<z>
properties = null;<z>
pc.properties();<z>
!ObjectUtils.isEmpty(pps)) {<z>
= new Properties();<z>
(PersistenceProperty pp : pps) {<z>
value());<z>
);<z>
();<z>
pc.synchronization());<z>
properties = properties;<z>
class;<z>
= pu.unitName();<z>
(resourceType);<z>
factory) {<z>
.notNull(factory, "ConnectionFactory must not be null");<z>
= factory;<z>
;<z>
() {<z>
) {<z>
:<z>
;<z>
case BOOLEAN:<z>
:<z>
BYTE:<z>
case SHORT:<z>
INT:<z>
case FLOAT:<z>
case ARRAY:<z>
OBJECT:<z>
INTERNAL:<z>
;<z>
case LONG:<z>
:<z>
2;<z>
new AssertionError();<z>
[] headers) {<z>
null;<z>
ObjectUtils.isEmpty(headers)) {<z>
{<z>
header);<z>
expr.value != null) {<z>
.parseMediaTypes(expr.value)) {<z>
result : new LinkedHashSet<>());<z>
.isNegated));<z>
{<z>
{<z>
));<z>
.add(new ProduceMediaTypeExpression(produce));<z>
));<z>
() throws ClassNotFoundException {<z>
instance == null) {<z>
? extends Driver>)<z>
HsqlEmbeddedDatabaseConfigurer.class.getClassLoader()));<z>
return instance;<z>
private Flux<TokenBuffer> endOfInput() {<z>
-> {<z>
endOfInput();<z>
);<z>
ex) {<z>
(), ex);<z>
) {<z>
.propagate(ex);<z>
;<z>
clear() {<z>
clear();<z>
blah_ = 0;<z>
bitField0_ = (bitField0_ & ~0x00000001);<z>
;<z>
() {<z>
.environment == null) {<z>
this.environment = createEnvironment();<z>
.environment;<z>
,<z>
Nullable HandlerMethod handlerMethod, Exception exception) {<z>
handlerMethod, exception);<z>
) {<z>
return null;<z>
.argumentResolvers != null) {<z>
.argumentResolvers);<z>
(this.returnValueHandlers != null) {<z>
returnValueHandlers);<z>
webRequest = new ServletWebRequest(request, response);<z>
);<z>
);<z>
)) {<z>
debug("Using @ExceptionHandler " + exceptionHandlerMethod);<z>
exToExpose = exception;<z>
!= null) {<z>
(exToExpose);<z>
exToExpose.getCause();<z>
);<z>
size() + 1];<z>
exceptions.toArray(arguments);<z>
[arguments.length - 1] = handlerMethod;<z>
.invokeAndHandle(webRequest, mavContainer, arguments);<z>
(Throwable invocationEx) {<z>
()) {<z>
"Failure in @ExceptionHandler " + exceptionHandlerMethod, invocationEx);<z>
;<z>
.isRequestHandled()) {<z>
return new ModelAndView();<z>
getModel();<z>
);<z>
, status);<z>
;<z>
) {<z>
));<z>
(model instanceof RedirectAttributes) {<z>
RedirectAttributes) model).getFlashAttributes();<z>
;<z>
return mav;<z>
String expression, SpelNodeImpl ast, SpelParserConfiguration configuration) {<z>
expression = expression;<z>
;<z>
configuration = configuration;<z>
{<z>
NettyDataBuffer) {<z>
buffer).getNativeBuffer();<z>
);<z>
setCacheLimit(int cacheLimit) {<z>
if (cacheLimit <= 0) {<z>
= null;<z>
LocalResourceCache) {<z>
).setCacheLimit(cacheLimit);<z>
this.metadataReaderCache = new LocalResourceCache(cacheLimit);<z>
mav, NativeWebRequest request, String location) {<z>
true);<z>
ModelMap model = mav.getModel();<z>
RedirectAttributes redirectAttributes) {<z>
.getFlashAttributes();<z>
(!CollectionUtils.isEmpty(flashAttributes)) {<z>
HttpServletRequest.class);<z>
.class);<z>
!= null) {<z>
).putAll(flashAttributes);<z>
res != null) {<z>
(location, req, res);<z>
(int isolationLevel) {<z>
{<z>
;<z>
TransactionDefinition.ISOLATION_DEFAULT ? isolationLevel : null);<z>
() {<z>
this.lifecycleMonitor) {<z>
;<z>
) {<z>
prefix = prefix;<z>
= namePrefix;<z>
;<z>
= hintFilterFunction;<z>
[][] delimiters) {<z>
length];<z>
delimiters.length; i++) {<z>
);<z>
;<z>
public String getId() {<z>
= null;<z>
{<z>
ChannelOperationsIdHelper.getId(this.response);<z>
null && this.response instanceof Connection connection) {<z>
.asShortText();<z>
ObjectUtils.getIdentityHexString(this));<z>
doFilterInternal(<z>
)<z>
IOException {<z>
;<z>
= false;<z>
WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);<z>
getAlreadyFilteredAttributeName();<z>
sessionFactory)) {<z>
participate = true;<z>
isFirstRequest = !isAsyncDispatch(request);<z>
asyncManager, key)) {<z>
);<z>
session = openSession(sessionFactory);<z>
SessionHolder sessionHolder = new SessionHolder(session);<z>
bindResource(sessionFactory, sessionHolder);<z>
new AsyncRequestInterceptor(sessionFactory, sessionHolder);<z>
registerCallableInterceptor(key, interceptor);<z>
asyncManager.registerDeferredResultInterceptor(key, interceptor);<z>
);<z>
{<z>
=<z>
;<z>
) {<z>
("Closing Hibernate Session in OpenSessionInViewFilter");<z>
closeSession(sessionHolder.getSession());<z>
) {<z>
< TIMEOUT_DEFAULT) {<z>
"Timeout must be a positive integer or TIMEOUT_DEFAULT");<z>
= timeout;<z>
{<z>
);<z>
.add(new WebFluxResponseStatusExceptionHandler());<z>
= new AcceptHeaderLocaleContextResolver();<z>
(int i, Throwable t) throws Throwable {<z>
t != null) {<z>
;<z>
;<z>
Session session, ByteBuffer payload, boolean isLast) {<z>
isLast);<z>
this.wsSession, binaryMessage);<z>
) {<z>
, logger);<z>
(DependencyDescriptor descriptor, @Nullable String beanName,<z>
@Nullable TypeConverter typeConverter) throws BeansException {<z>
InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);<z>
resolveShortcut(this);<z>
{<z>
;<z>
type = descriptor.getDependencyType();<z>
);<z>
{<z>
{<z>
value);<z>
(beanName) ?<z>
);<z>
);<z>
? typeConverter : getTypeConverter());<z>
);<z>
{<z>
return (descriptor.getField() != null ?<z>
.getField()) :<z>
descriptor.getMethodParameter()));<z>
);<z>
multipleBeans != null) {<z>
;<z>
= findAutowireCandidates(beanName, type, descriptor);<z>
isEmpty()) {<z>
(isRequired(descriptor)) {<z>
, descriptor.getResolvableType(), descriptor);<z>
null;<z>
String autowiredBeanName;<z>
instanceCandidate;<z>
.size() > 1) {<z>
autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);<z>
) {<z>
(type)) {<z>
getResolvableType(), matchingBeans);<z>
null;<z>
);<z>
;<z>
;<z>
entry.getValue();<z>
(autowiredBeanNames != null) {<z>
.add(autowiredBeanName);<z>
if (instanceCandidate instanceof Class) {<z>
this);<z>
result = instanceCandidate;<z>
NullBean) {<z>
if (isRequired(descriptor)) {<z>
, descriptor);<z>
;<z>
{<z>
());<z>
result;<z>
(previousInjectionPoint);<z>
int compareTo(MethodCacheKey other) {<z>
());<z>
if (result == 0) {<z>
.method.toString());<z>
;<z>
> annotationType) {<z>
element).stream(annotationType)<z>
)<z>
);<z>
buildNativeEntityManagerFactory() {<z>
;<z>
emf = createNativeEntityManagerFactory();<z>
) {<z>
class) {<z>
ex.getCause();<z>
{<z>
getMessage();<z>
;<z>
endsWith(causeString)) {<z>
;<z>
isErrorEnabled()) {<z>
+ ex.getMessage());<z>
;<z>
;<z>
{<z>
);<z>
{<z>
) + "'");<z>
;<z>
throws SpelEvaluationException {<z>
(index >= arrayLength) {<z>
SpelEvaluationException(getStartPosition(), SpelMessage.ARRAY_INDEX_OUT_OF_BOUNDS,<z>
index);<z>
... params) throws DataAccessException {<z>
(params);<z>
.clone());<z>
) == this.batchSize) {<z>
()) {<z>
);<z>
;<z>
-1;<z>
() {<z>
.getTargetObject();<z>
null && this.targetBeanName != null) {<z>
;<z>
.targetBeanName);<z>
;<z>
ex) {<z>
) {<z>
();<z>
return -1;<z>
) throws Exception {<z>
interceptor : this.interceptors) {<z>
(request, task);<z>
{<z>
this == NONE) {<z>
return false;<z>
)) ||<z>
);<z>
(Object key) {<z>
instanceof String) {<z>
String> oldValues = get(key);<z>
remove((String) key);<z>
return oldValues;<z>
null;<z>
) {<z>
ServletRequestWrapper) {<z>
;<z>
;<z>
WebTestClient.ResponseSpec assertStatusAndReturn(HttpStatus expected) {<z>
();<z>
expected, actual));<z>
return this.responseSpec;<z>
?> type) {<z>
Assert.notNull(type, "Type must not be null");<z>
;<z>
type = type;<z>
equals(@Nullable Object other) {<z>
(this == other) {<z>
true;<z>
otherPd)) {<z>
;<z>
()) &&<z>
()) &&<z>
)) &&<z>
;<z>
AbstractAspectJAdvice advice) {<z>
notNull(advice, "Advice must not be null");<z>
.advice = advice;<z>
;<z>
CacheOperationInvocationContext<?> context, CacheOperationInvoker invoker) {<z>
(invoker);<z>
= context.getOperation();<z>
) {<z>
, "No CacheResultInterceptor");<z>
this.cacheResultInterceptor.invoke(<z>
<CacheResultOperation>) context, adapter);<z>
) {<z>
);<z>
.invoke(<z>
context, adapter);<z>
else if (operation instanceof CacheRemoveOperation) {<z>
);<z>
invoke(<z>
CacheOperationInvocationContext<CacheRemoveOperation>) context, adapter);<z>
CacheRemoveAllOperation) {<z>
"No CacheRemoveAllInterceptor");<z>
this.cacheRemoveAllInterceptor.invoke(<z>
CacheOperationInvocationContext<CacheRemoveAllOperation>) context, adapter);<z>
new IllegalArgumentException("Cannot handle " + operation);<z>
, String destination, Object payload,<z>
{<z>
payload, null, postProcessor);<z>
? extends CharSequence> messageSupplier) {<z>
.isFatalEnabled()) {<z>
, cause);<z>
Class<T> annotationType) {<z>
{<z>
return null;<z>
.annotatedElement, annotationType);<z>
(<z>
AbstractExceptionHandlerMethodResolver resolver) {<z>
resolver);<z>
Method candidateMethod) {<z>
.getDeclaringClass() != Object.class &&<z>
) &&<z>
candidateMethod));<z>
protected void copyBodyToResponse(boolean complete) throws IOException {<z>
() > 0) {<z>
= (HttpServletResponse) getResponse();<z>
rawResponse.isCommitted()) {<z>
== null) {<z>
contentLength);<z>
contentLength = null;<z>
.getOutputStream());<z>
();<z>
(complete) {<z>
);<z>
) {<z>
, ThemeResolver.class);<z>
(logger.isTraceEnabled()) {<z>
+ this.themeResolver);<z>
logger.isDebugEnabled()) {<z>
;<z>
) {<z>
;<z>
isTraceEnabled()) {<z>
.trace("No ThemeResolver '" + THEME_RESOLVER_BEAN_NAME +<z>
);<z>
parameter) {<z>
(MatrixVariable.class);<z>
state(ann != null, "No MatrixVariable annotation");<z>
(ann);<z>
> doSetRollbackOnly(TransactionSynchronizationManager synchronizationManager,<z>
TransactionException {<z>
() -> {<z>
.getTransaction();<z>
status.isDebug()) {<z>
getConnection() +<z>
);<z>
setRollbackOnly();<z>
;<z>
) {<z>
notNull(other, "Other ProxyConfig object must not be null");<z>
this.proxyTargetClass = other.proxyTargetClass;<z>
;<z>
other.exposeProxy;<z>
frozen;<z>
other.opaque;<z>
public static WebApplicationContext findWebApplicationContext(<z>
Nullable ServletContext servletContext) {<z>
getAttribute(<z>
DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE);<z>
(webApplicationContext == null) {<z>
!= null) {<z>
webApplicationContext = WebApplicationContextUtils.getWebApplicationContext(servletContext);<z>
if (webApplicationContext == null) {<z>
webApplicationContext = ContextLoader.getCurrentWebApplicationContext();<z>
webApplicationContext;<z>
long expirationPeriod, SessionLookup sessionLookup) {<z>
= System.currentTimeMillis() + expirationPeriod;<z>
) {<z>
.afterDeserialization(sessionLookup);<z>
) {<z>
;<z>
{<z>
(parent instanceof AbstractMessageSource) {<z>
code, args, locale);<z>
locale);<z>
return null;<z>
) throws IOException {<z>
(isResourceUnderLocation(resource, location)) {<z>
true;<z>
) {<z>
()) {<z>
isResourceUnderLocation(resource, current)) {<z>
return true;<z>
return false;<z>
) {<z>
;<z>
int queryIndex = lookupPath.indexOf('?');<z>
0) {<z>
;<z>
lookupPath.indexOf('#');<z>
if (hashIndex > 0) {<z>
(suffixIndex, hashIndex);<z>
return suffixIndex;<z>
int depth) {<z>
contains(this.exceptionName)) {<z>
depth;<z>
== Throwable.class) {<z>
1;<z>
;<z>
{<z>
<?> propertySource : this.propertySourceList) {<z>
equals(name)) {<z>
;<z>
return false;<z>
TypedValue getValue() {<z>
.getValueInternal(<z>
this.targetType, this.arguments);<z>
();<z>
;<z>
PrintWriter getTargetWriter() throws IOException {<z>
== null) {<z>
;<z>
return this.targetWriter;<z>
{<z>
File fileToCheck = getFileForLastModifiedCheck();<z>
= fileToCheck.lastModified();<z>
0L && !fileToCheck.exists()) {<z>
+<z>
);<z>
return lastModified;<z>
) {<z>
getWriteMethod() == null) {<z>
;<z>
(getObjectType());<z>
parseCachingAnnotation(<z>
caching, Collection<CacheOperation> ops) {<z>
] cacheables = caching.cacheable();<z>
(Cacheable cacheable : cacheables) {<z>
;<z>
] cacheEvicts = caching.evict();<z>
for (CacheEvict cacheEvict : cacheEvicts) {<z>
cacheEvict));<z>
cachePuts = caching.put();<z>
cachePuts) {<z>
, cachePut));<z>
] getContent() {<z>
();<z>
(body, "Expected body content");<z>
return body;<z>
toListenableFuture(Object returnValue, MethodParameter returnType) {<z>
, returnValue);<z>
!= null) {<z>
)));<z>
;<z>
?> aspectClass) throws AopConfigException {<z>
;<z>
getAnnotation(Aspect.class) != null &&<z>
isAbstract(superclass.getModifiers())) {<z>
+<z>
) + "]");<z>
;<z>
!ajType.isAspect()) {<z>
throw new NotAnAtAspectException(aspectClass);<z>
.getKind() == PerClauseKind.PERCFLOW) {<z>
) + " uses percflow instantiation model: " +<z>
"This is not supported in Spring AOP.");<z>
) {<z>
+<z>
;<z>
{<z>
= deliveryMode;<z>
.priority = priority;<z>
.timeToLive = timeToLive;<z>
() throws IllegalStateException {<z>
!= null) {<z>
this.servletContext;<z>
servletContext = null;<z>
getWebApplicationContext();<z>
) {<z>
wac.getServletContext();<z>
) {<z>
this +<z>
"] does not run within a ServletContext. Make sure the object is fully configured!");<z>
servletContext;<z>
upgradeInternal(ServerHttpRequest request, ServerHttpResponse response,<z>
List<Extension> selectedExtensions, Endpoint endpoint)<z>
throws HandshakeFailureException {<z>
(request);<z>
servletResponse = getHttpServletResponse(response);<z>
= servletRequest.getRequestURL();<z>
String path = servletRequest.getRequestURI();<z>
Collections.emptyMap();<z>
path, endpoint);<z>
(Collections.singletonList(selectedProtocol));<z>
(selectedExtensions);<z>
servletResponse, endpointConfig, pathParams);<z>
catch (ServletException ex) {<z>
HandshakeFailureException(<z>
);<z>
) {<z>
(<z>
requestUrl, ex);<z>
ClassLoader classLoader) {<z>
;<z>
classLoader;<z>
{<z>
classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();<z>
;<z>
if (logger.isTraceEnabled()) {<z>
;<z>
));<z>
String factoryImplementationName : factoryImplementationNames) {<z>
);<z>
sort(result);<z>
;<z>
) throws JMSException {<z>
connectionMonitor) {<z>
.locallyStarted) {<z>
.locallyStarted = false;<z>
!= null) {<z>
;<z>
if (startedCount > 0) {<z>
--;<z>
void resetConnectionAfterTransaction(<z>
previousIsolationLevel, boolean resetReadOnly) {<z>
notNull(con, "No Connection specified");<z>
;<z>
) {<z>
{<z>
logger.debug("Resetting isolation level of JDBC Connection [" +<z>
previousIsolationLevel);<z>
(previousIsolationLevel);<z>
resetReadOnly) {<z>
if (debugEnabled) {<z>
.debug("Resetting read-only flag of JDBC Connection [" + con + "]");<z>
(false);<z>
(Throwable ex) {<z>
, ex);<z>
, @Nullable OrderSourceProvider sourceProvider) {<z>
o1 instanceof PriorityOrdered);<z>
= (o2 instanceof PriorityOrdered);<z>
p2) {<z>
1;<z>
) {<z>
return 1;<z>
);<z>
sourceProvider);<z>
, i2);<z>
Properties> content) {<z>
new LinkedMultiValueMap<>();<z>
(Properties entry : content) {<z>
forEach((type, values) -> {<z>
split(",");<z>
for (String stereotype : stereotypes) {<z>
((String) type));<z>
);<z>
return index;<z>
> context) {<z>
context);<z>
if (logger.isTraceEnabled()) {<z>
+ cache.getName() + "' for operation " +<z>
getOperation());<z>
).isEarlyRemove());<z>
,<z>
WebRequestInterceptor interceptor) {<z>
);<z>
{<z>
state = getState();<z>
isTraceEnabled()) {<z>
;<z>
state.cancel(this.publisher);<z>
<?> task) {<z>
{<z>
).afterCompletion(request, task);<z>
{<z>
.isTraceEnabled()) {<z>
trace("Ignoring failure in afterCompletion method", ex);<z>
{<z>
String id = beanName;<z>
;<z>
prefix = beanName + GENERATED_BEAN_NAME_SEPARATOR;<z>
containsBeanDefinition(id)) {<z>
counter++;<z>
= prefix + counter;<z>
return id;<z>
(BeanFactory beanFactory) {<z>
instanceof ConfigurableBeanFactory) {<z>
) beanFactory);<z>
{<z>
assertNotPreparedOperation();<z>
>(this.byIndex);<z>
(type));<z>
;<z>
getMatchingCondition(ServerWebExchange exchange) {<z>
getRequest())) {<z>
PRE_FLIGHT_MATCH;<z>
HeaderExpression expression : this.expressions) {<z>
{<z>
return null;<z>
return this;<z>
void sendError(int status) throws IOException {<z>
state(!isCommitted(), "Cannot set error status - response is already committed");<z>
.status = status;<z>
setCommitted(true);<z>
bindingContext) {<z>
handlerResult.getReturnValue();<z>
) {<z>
);<z>
;<z>
(isAsyncVoidType(type, adapter)) {<z>
(value));<z>
handlerResult.getReturnTypeSource());<z>
;<z>
);<z>
resetInternal() {<z>
()) {<z>
);<z>
);<z>
this.jettyServer.destroy();<z>
catch (Exception ex) {<z>
);<z>
jettyServer = null;<z>
.contextHandler = null;<z>
> strategyInterface) {<z>
;<z>
) != 1) {<z>
new BeanInitializationException(<z>
+ strategyInterface.getName() + "]");<z>
return strategies.get(0);<z>
long initialDelay) {<z>
);<z>
interval = interval;<z>
= initialDelay;<z>
void validateValue(<z>
value, Errors errors, Object... validationHints) {<z>
(this.targetValidator != null) {<z>
targetValidator.validateValue(<z>
);<z>
,<z>
TypeDescriptor targetType, ConvertiblePair convertiblePair) {<z>
converters.get(convertiblePair);<z>
if (convertersForPair != null) {<z>
, targetType);<z>
null) {<z>
converter;<z>
globalConverter : this.globalConverters) {<z>
matches(sourceType, targetType)) {<z>
globalConverter;<z>
;<z>
{<z>
originalDisableMessageID == null) {<z>
.target.getDisableMessageID();<z>
target.setDisableMessageID(disableMessageID);<z>
boolean equals(@Nullable Object other) {<z>
if (this == other) {<z>
;<z>
)) {<z>
;<z>
&&<z>
));<z>
<?>[] resolveGenerics() {<z>
[] generics = getGenerics();<z>
>[generics.length];<z>
length; i++) {<z>
resolve();<z>
resolvedGenerics;<z>
public void setValidator(Validator validator) {<z>
{<z>
.getValidator();<z>
(validator instanceof SpringValidatorAdapter) {<z>
class);<z>
this.validator = validator;<z>
String, Type, String> encoder) {<z>
= this.queryParams.size();<z>
= new LinkedMultiValueMap<>(size);<z>
, values) -> {<z>
apply(key, Type.QUERY_PARAM);<z>
values.size());<z>
(String value : values) {<z>
QUERY_PARAM) : null);<z>
, encodedValues);<z>
);<z>
.unmodifiableMultiValueMap(result);<z>
public Object getValue(@Nullable String name) {<z>
.getValue(name);<z>
(ObjectUtils.isArray(value)) {<z>
toObjectArray(value));<z>
value;<z>
<MediaType> requestedMediaTypes, RequestAttributes attrs) {<z>
{<z>
{<z>
)) {<z>
return candidateView;<z>
mediaType : requestedMediaTypes) {<z>
for (View candidateView : candidateViews) {<z>
.getContentType())) {<z>
parseMediaType(candidateView.getContentType());<z>
{<z>
();<z>
isDebugEnabled()) {<z>
+ "' given " + requestedMediaTypes);<z>
, RequestAttributes.SCOPE_REQUEST);<z>
return candidateView;<z>
null;<z>
MappingJackson2MessageConverter() {<z>
= new ObjectMapper();<z>
);<z>
(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);<z>
() {<z>
this.lifecycleMonitor) {<z>
;<z>
() {<z>
"Active Connection is required");<z>
if (this.currentConnection == null) {<z>
.connectionHandle.getConnection();<z>
return this.currentConnection;<z>
classWriter) {<z>
;<z>
null;<z>
];<z>
.constantPoolCount = 1;<z>
= new ByteVector();<z>
SQLException {<z>
.rowCount == 0) {<z>
();<z>
.columnCount = rsmd.getColumnCount();<z>
[this.columnCount];<z>
;<z>
{<z>
.getColumnType(i + 1);<z>
, i + 1);<z>
(rs, this.rowCount++);<z>
) {<z>
str.length();<z>
; i < strLen; i++) {<z>
.charAt(i))) {<z>
;<z>
false;<z>
<T> targetType) {<z>
), typedValue.getTypeDescriptor(),<z>
.valueOf(targetType));<z>
{<z>
;<z>
) result;<z>
JspException {<z>
=<z>
(EVALUATION_CONTEXT_PAGE_ATTRIBUTE);<z>
== null) {<z>
this.pageContext);<z>
);<z>
null) {<z>
expression.getValue(evaluationContext) : null);<z>
, result, this.scope);<z>
(this.expression != null ?<z>
);<z>
= ObjectUtils.getDisplayString(result);<z>
);<z>
result);<z>
.print(result);<z>
ex) {<z>
throw new JspException(ex);<z>
;<z>
String[] beanNamesForAnnotationIncludingAncestors(<z>
<? extends Annotation> annotationType) {<z>
.notNull(lbf, "ListableBeanFactory must not be null");<z>
] result = lbf.getBeanNamesForAnnotation(annotationType);<z>
HierarchicalBeanFactory hbf) {<z>
(hbf.getParentBeanFactory() instanceof ListableBeanFactory) {<z>
= beanNamesForAnnotationIncludingAncestors(<z>
annotationType);<z>
= mergeNamesWithParent(result, parentResult, hbf);<z>
;<z>
createWebSocketSession(<z>
completionSink) {<z>
, info, bufferFactory(), completionSink);<z>
propertyName) {<z>
processedProperties != null) {<z>
.remove(propertyName);<z>
> expectedResultType)<z>
throws EvaluationException {<z>
value = getValue(context);<z>
value), expectedResultType);<z>
httpSocket) {<z>
subjectHelper.getSubject(request)};<z>
(args);<z>
Exception ex) {<z>
"Failed to create TyrusMuxableWebSocket", ex);<z>
registerCallableInterceptors(CallableProcessingInterceptor... interceptors) {<z>
, "A CallableProcessingInterceptor is required");<z>
: interceptors) {<z>
+ interceptor.hashCode();<z>
.callableInterceptors.put(key, interceptor);<z>
throws IOException, ServletException {<z>
.parts;<z>
if (result == null) {<z>
stream()<z>
groupingBy(Part::getName,<z>
,<z>
.toList()));<z>
= result;<z>
return result;<z>
hashCode() {<z>
this.declaringClass.hashCode();<z>
(this.classes);<z>
;<z>
.initializers);<z>
result;<z>
public AspectJAroundAdvice(<z>
, AspectInstanceFactory aif) {<z>
;<z>
isJtaEntityManager() {<z>
.target.getTransaction();<z>
false;<z>
{<z>
;<z>
return true;<z>
) throws Exception {<z>
());<z>
> target = new ArrayList<>();<z>
.targetTypeDesc = TypeDescriptor.forObject(target);<z>
{<z>
[] notifTypes = notificationInfo.getNotificationTypes();<z>
notifTypes)) {<z>
("Must specify at least one notification type");<z>
();<z>
.hasText(name)) {<z>
new IllegalArgumentException("Must specify notification name");<z>
();<z>
, description);<z>
reader) throws IOException {<z>
);<z>
null) {<z>
for (String configLocation : configLocations) {<z>
configLocation);<z>
) {<z>
message = super.getMessage();<z>
cause = getCause();<z>
(cause instanceof JMSException) {<z>
).getLinkedException();<z>
null) {<z>
.getMessage();<z>
.getMessage();<z>
linkedMessage))) {<z>
= message + "; nested exception is " + linkedEx;<z>
;<z>
void onSuccess(@Nullable WebSocketSession session) {<z>
.compareAndSet(false, true)) {<z>
;<z>
)) {<z>
("Connect success/failure already handled for " + DefaultTransportRequest.this);<z>
String, ?> inParameters) {<z>
);<z>
.isProcedureColumnMetaDataUsed()) {<z>
;<z>
());<z>
for (SqlParameter parameter : this.callParameters) {<z>
()) {<z>
getName();<z>
parameterName);<z>
(parameterNameToMatch != null) {<z>
(), parameterName);<z>
());<z>
, parameterValue) -> {<z>
= provider.parameterNameToUse(parameterName);<z>
(parameterNameToMatch));<z>
(callParameterName == null) {<z>
if (logger.isDebugEnabled()) {<z>
value = parameterValue;<z>
if (value instanceof SqlParameterValue) {<z>
) value).getValue();<z>
{<z>
logger.debug("Unable to locate the corresponding IN or IN-OUT parameter for \"" +<z>
());<z>
.put(callParameterName, parameterValue);<z>
});<z>
() < callParameterNames.size()) {<z>
()) {<z>
provider.parameterNameToUse(parameterName);<z>
));<z>
&& logger.isInfoEnabled()) {<z>
("Unable to locate the corresponding parameter value for '" + parameterName +<z>
));<z>
(logger.isDebugEnabled()) {<z>
values());<z>
+ matchedParameters.keySet());<z>
matchedParameters;<z>
qualifier)<z>
BeansException {<z>
, "BeanFactory must not be null");<z>
if (beanFactory instanceof ListableBeanFactory) {<z>
);<z>
.containsBean(qualifier)) {<z>
);<z>
+<z>
qualifier +<z>
);<z>
afterPropertiesSet() {<z>
(logger.isDebugEnabled()) {<z>
= this.enableLoggingRequestDetails ?<z>
("enableLoggingRequestDetails='" + this.enableLoggingRequestDetails +<z>
"': form data and headers will be " + value);<z>
String descriptor) {<z>
++numElementValuePairs;<z>
{<z>
(name));<z>
(0);<z>
(symbolTable, true, annotation, null);<z>
void init() {<z>
);<z>
"bsh", "org.springframework.scripting.bsh.BshScriptFactory");<z>
, "org.springframework.scripting.support.StandardScriptFactory");<z>
ScriptingDefaultsParser());<z>
XMLStreamException {<z>
int eventType = next();<z>
eventType == XMLStreamConstants.CHARACTERS && isWhiteSpace() ||<z>
.SPACE ||<z>
eventType == XMLStreamConstants.COMMENT) {<z>
next();<z>
) {<z>
new XMLStreamException("expected start or end tag", getLocation());<z>
return eventType;<z>
) throws ExecutionException {<z>
(this.executionException != null) {<z>
executionException instanceof ExecutionException ?<z>
executionException :<z>
.executionException));<z>
value;<z>
, Object... inserts) {<z>
);<z>
this.position = pos;<z>
;<z>
= messageType;<z>
inserts;<z>
to, String personal) throws MessagingException, UnsupportedEncodingException {<z>
(to, "To address must not be null");<z>
() != null ?<z>
personal, getEncoding()) :<z>
InternetAddress(to, personal));<z>
PreparedStatementSetter pss,<z>
> rowMapper) throws DataAccessException {<z>
psc, ps -> {<z>
!= null) {<z>
ps);<z>
= ps.executeQuery();<z>
con = ps.getConnection();<z>
stream().onClose(() -> {<z>
rs);<z>
{<z>
pss).cleanupParameters();<z>
ps);<z>
));<z>
);<z>
, false));<z>
() throws ServletException {<z>
;<z>
)) {<z>
"Initializing Servlet '" + getServletName() + "'");<z>
currentTimeMillis();<z>
initWebApplicationContext();<z>
();<z>
(ServletException | RuntimeException ex) {<z>
logger.error("Context initialization failed", ex);<z>
;<z>
if (logger.isDebugEnabled()) {<z>
this.enableLoggingRequestDetails ?<z>
this.enableLoggingRequestDetails +<z>
+ value);<z>
)) {<z>
;<z>
() {<z>
getHeader(MessageHeaders.CONTENT_TYPE);<z>
{<z>
;<z>
(value.toString()));<z>
, int end) {<z>
.length == 0) {<z>
if (isLong) {<z>
;<z>
substring(start, end));<z>
if (isLong) {<z>
end));<z>
, data, start, end));<z>
) {<z>
notNull(componentType, "Component type must not be null");<z>
getClass();<z>
arrayClass, null, null, componentType);<z>
advisors) {<z>
<>(advisors.size());<z>
for (Advisor advisor : advisors) {<z>
.add(<z>
));<z>
sorted = PartialOrder.sort(partiallyComparableAdvisors);<z>
) {<z>
advisors.size());<z>
(PartiallyComparableAdvisorHolder pcAdvisor : sorted) {<z>
getAdvisor());<z>
return result;<z>
return super.sortAdvisors(advisors);<z>
(Class<?> clazz) {<z>
, "'clazz' cannot be null");<z>
.isAssignableFrom(clazz)) {<z>
(<z>
.getName() + "]: it's not a Throwable");<z>
;<z>
{<z>
null) {<z>
.endpoint;<z>
null, "No endpoint set");<z>
endpointProvider.getHandler();<z>
public ContextConfigurationAttributes(<z>
inheritLocations,<z>
<?>>[] initializers,<z>
, Class<? extends ContextLoader> contextLoaderClass) {<z>
, "'declaringClass' must not be null");<z>
, "'contextLoaderClass' must not be null");<z>
) {<z>
String.format(<z>
),<z>
));<z>
;<z>
locations = locations;<z>
;<z>
;<z>
.initializers = initializers;<z>
inheritInitializers;<z>
hasText(name) ? name : null);<z>
this.contextLoaderClass = contextLoaderClass;<z>
createSharedConnection() throws JMSException {<z>
;<z>
;<z>
;<z>
(JMSException ex) {<z>
);<z>
;<z>
) {<z>
);<z>
newTask = false;<z>
scheduledTask == null) {<z>
new ScheduledTask(task);<z>
= true;<z>
{<z>
.getTrigger());<z>
task);<z>
scheduledTask);<z>
: null);<z>
(Properties exceptionMappings, Exception ex) {<z>
= null;<z>
null;<z>
int deepest = Integer.MAX_VALUE;<z>
); names.hasMoreElements();) {<z>
.nextElement();<z>
, ex);<z>
&&<z>
)) {<z>
;<z>
;<z>
exceptionMapping);<z>
logger.isDebugEnabled()) {<z>
;<z>
;<z>
private void writeStatusAndHeaders(ServerHttpResponse response) {<z>
.setRawStatusCode(this.statusCode);<z>
headers, response.getHeaders());<z>
());<z>
markBeanAsCreated(String beanName) {<z>
contains(beanName)) {<z>
.mergedBeanDefinitions) {<z>
(beanName)) {<z>
clearMergedBeanDefinition(beanName);<z>
);<z>
) {<z>
= (Resource) templateSource;<z>
;<z>
{<z>
isDebugEnabled()) {<z>
+<z>
+ ex);<z>
1;<z>
public AnnotationVisitor visitLocalVariableAnnotation(<z>
typeRef,<z>
final TypePath typePath,<z>
Label[] start,<z>
end,<z>
[] index,<z>
String descriptor,<z>
) {<z>
);<z>
.putShort(start.length);<z>
.length; ++i) {<z>
bytecodeOffset)<z>
bytecodeOffset)<z>
[i]);<z>
put(typePath, typeAnnotation);<z>
)).putShort(0);<z>
(visible) {<z>
=<z>
(<z>
;<z>
else {<z>
return lastCodeRuntimeInvisibleTypeAnnotation =<z>
(<z>
;<z>
(MediaType contentType) {<z>
result -> {<z>
().getContentType();<z>
"Content type not set", actual);<z>
;<z>
,<z>
));<z>
jpMatch,<z>
Throwable t) throws Throwable {<z>
t));<z>
) {<z>
.SecondMsg(this);<z>
bitField0_;<z>
int to_bitField0_ = 0;<z>
& 0x00000001) == 0x00000001)) {<z>
to_bitField0_ |= 0x00000001;<z>
;<z>
= to_bitField0_;<z>
onBuilt();<z>
;<z>
) {<z>
(() -> {<z>
if (logger.isInfoEnabled()) {<z>
info("Connecting to WebSocket at " + getUri());<z>
endpointToUse = this.endpoint;<z>
endpointToUse == null) {<z>
);<z>
getHandler();<z>
;<z>
);<z>
ex) {<z>
ex);<z>
);<z>
RedirectViewControllerRegistration setStatusCode(HttpStatus statusCode) {<z>
(), "Not a redirect status code");<z>
(statusCode);<z>
this;<z>
> targetClass,<z>
cacheResolver) {<z>
operation;<z>
;<z>
targetClass;<z>
(targetClass) ?<z>
.method);<z>
this.targetMethod, targetClass);<z>
= keyGenerator;<z>
this.cacheResolver = cacheResolver;<z>
{<z>
));<z>
getResultSetType());<z>
.setUpdatableResults(isUpdatableResults());<z>
preparedStatementFactory.setReturnGeneratedKeys(isReturnGeneratedKeys());<z>
(getGeneratedKeysColumnNames() != null) {<z>
;<z>
);<z>
{<z>
super.processContextConfiguration(configAttributes);<z>
&& isGenerateDefaultLocations()) {<z>
);<z>
CompletableFuture<V> completable() {<z>
) {<z>
<>();<z>
);<z>
;<z>
);<z>
void closeWebApplicationContext(ServletContext servletContext) {<z>
);<z>
) {<z>
.close();<z>
.currentThread().getContextClassLoader();<z>
.getClassLoader()) {<z>
null;<z>
{<z>
);<z>
.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);<z>
putAbstractType(<z>
abstractType, final ByteVector output) {<z>
;<z>
) {<z>
abstractType & VALUE_MASK;<z>
(abstractType & KIND_MASK) {<z>
:<z>
(typeValue);<z>
REFERENCE_KIND:<z>
ITEM_OBJECT)<z>
.value).index);<z>
UNINITIALIZED_KIND:<z>
getType(typeValue).data);<z>
AssertionError();<z>
} else {<z>
(32);<z>
) {<z>
('[');<z>
) == REFERENCE_KIND) {<z>
('L')<z>
value)<z>
.append(';');<z>
} else {<z>
abstractType & VALUE_MASK) {<z>
Frame.ITEM_ASM_BOOLEAN:<z>
typeDescriptor.append('Z');<z>
case Frame.ITEM_ASM_BYTE:<z>
;<z>
.ITEM_ASM_CHAR:<z>
typeDescriptor.append('C');<z>
ITEM_ASM_SHORT:<z>
);<z>
case Frame.ITEM_INTEGER:<z>
.append('I');<z>
.ITEM_FLOAT:<z>
('F');<z>
ITEM_LONG:<z>
'J');<z>
case Frame.ITEM_DOUBLE:<z>
typeDescriptor.append('D');<z>
;<z>
.putByte(ITEM_OBJECT)<z>
)).index);<z>
, BigDecimal balance) {<z>
.name = name;<z>
.age = age;<z>
birth_date;<z>
this.balance = balance;<z>
, MultiValueMap<String, HttpCookie> cookies,<z>
InetSocketAddress remoteAddress,<z>
Nullable String logPrefix) {<z>
, "URI is required");<z>
.notNull(headers, "HttpHeaders are required");<z>
"`cookies` are required");<z>
, "Principal is required");<z>
, "'attributes' is required");<z>
this.uri = uri;<z>
= headers;<z>
cookies;<z>
.principalMono = principal;<z>
;<z>
remoteAddress;<z>
;<z>
this.logPrefix = logPrefix;<z>
) {<z>
this == other) {<z>
return true;<z>
instanceof AnnotatedElementKey otherKey)) {<z>
return false;<z>
equals(otherKey.element) &&<z>
otherKey.targetClass));<z>
T> type) {<z>
get(key);<z>
== null) {<z>
null;<z>
))) {<z>
("Incorrect type specified for header '" +<z>
+ "]");<z>
(T) value;<z>
<String, ?> attributes) {<z>
) {<z>
this::addAttribute);<z>
;<z>
messageSupplier) {<z>
hasText(text)) {<z>
);<z>
paramOrFileName) {<z>
);<z>
file != null) {<z>
return file.getContentType();<z>
part = getPart(paramOrFileName);<z>
) {<z>
part.getContentType();<z>
{<z>
);<z>
null;<z>
, MethodParameter parameter) {<z>
parameter.getParameterAnnotations()) {<z>
] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);<z>
if (validationHints != null) {<z>
.validate(validationHints);<z>
HttpServletResponse response,<z>
, IOException {<z>
);<z>
void afterPropertiesSet() {<z>
.BuilderConfiguration();<z>
setTrailingSlashMatch(useTrailingSlashMatch());<z>
getContentNegotiationManager());<z>
) != null) {<z>
);<z>
useSuffixPatternMatch && !this.useRegisteredSuffixPatternMatch,<z>
;<z>
.config.setSuffixPatternMatch(useSuffixPatternMatch());<z>
));<z>
(getPathMatcher());<z>
super.afterPropertiesSet();<z>
private static MediaType getResourceMediaType(<z>
String, Object> hints) {<z>
APPLICATION_OCTET_STREAM)) {<z>
;<z>
.orElse(MediaType.APPLICATION_OCTET_STREAM);<z>
hints)) {<z>
) + "Resource associated with '" + mediaType + "'");<z>
mediaType;<z>
,<z>
String labelProperty, boolean htmlEscape) {<z>
optionSource, "'optionSource' must not be null");<z>
.notNull(bindStatus, "'bindStatus' must not be null");<z>
optionSource = optionSource;<z>
= bindStatus;<z>
valueProperty;<z>
this.labelProperty = labelProperty;<z>
htmlEscape = htmlEscape;<z>
(<z>
.google.protobuf.ByteString data)<z>
.google.protobuf.InvalidProtocolBufferException {<z>
return PARSER.parseFrom(data);<z>
{<z>
getArguments();<z>
InvocationArgumentsAdapter adapter : argumentAdapters) {<z>
adapter.adaptArguments(arguments);<z>
return arguments;<z>
{<z>
);<z>
null) {<z>
)<z>
NATIVE_HEADERS);<z>
if (map != null) {<z>
(NATIVE_HEADERS, null);<z>
map));<z>
?> getEndpointConstructor() {<z>
)) {<z>
getParameterTypes();<z>
.class == types[1]) {<z>
return current;<z>
throw new IllegalStateException("No compatible Tyrus version found");<z>
> dataBuffers) {<z>
headers, "Headers must not be null");<z>
;<z>
);<z>
throws BeansException {<z>
"ListableBeanFactory must not be null");<z>
.getBeansOfType(type);<z>
return uniqueBean(type, beansOfType);<z>
{<z>
= new String[parameters.length];<z>
.length; i++) {<z>
= parameters[i];<z>
param.isNamePresent()) {<z>
;<z>
;<z>
parameterNames;<z>
compareTo(ExpressionKey other) {<z>
());<z>
== 0) {<z>
expression.compareTo(other.expression);<z>
result;<z>
{<z>
(DataSourceTransactionObject) transaction;<z>
= null;<z>
() ||<z>
.isSynchronizedWithTransaction()) {<z>
);<z>
{<z>
+ newCon + "] for JDBC transaction");<z>
ConnectionHolder(newCon), true);<z>
.setSynchronizedWithTransaction(true);<z>
getConnectionHolder().getConnection();<z>
= DataSourceUtils.prepareConnectionForTransaction(con, definition);<z>
;<z>
));<z>
(con.getAutoCommit()) {<z>
txObject.setMustRestoreAutoCommit(true);<z>
{<z>
debug("Switching JDBC Connection [" + con + "] to manual commit");<z>
);<z>
;<z>
(true);<z>
);<z>
!= TransactionDefinition.TIMEOUT_DEFAULT) {<z>
(timeout);<z>
(txObject.isNewConnectionHolder()) {<z>
;<z>
Throwable ex) {<z>
()) {<z>
());<z>
(null, false);<z>
throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex);<z>
DefaultTransactionStatus status) throws TransactionException {<z>
boolean beforeCompletionInvoked = false;<z>
= false;<z>
prepareForCommit(status);<z>
);<z>
triggerBeforeCompletion(status);<z>
beforeCompletionInvoked = true;<z>
hasSavepoint()) {<z>
{<z>
);<z>
isGlobalRollbackOnly();<z>
;<z>
(status.isNewTransaction()) {<z>
(status.isDebug()) {<z>
.debug("Initiating transaction commit");<z>
unexpectedRollback = status.isGlobalRollbackOnly();<z>
(status);<z>
()) {<z>
;<z>
(unexpectedRollback) {<z>
new UnexpectedRollbackException(<z>
);<z>
) {<z>
triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);<z>
ex;<z>
catch (TransactionException ex) {<z>
(isRollbackOnCommitFailure()) {<z>
;<z>
STATUS_UNKNOWN);<z>
throw ex;<z>
RuntimeException | Error ex) {<z>
(!beforeCompletionInvoked) {<z>
triggerBeforeCompletion(status);<z>
ex);<z>
ex;<z>
status);<z>
TransactionSynchronization.STATUS_COMMITTED);<z>
;<z>
> targetType) {<z>
);<z>
null),<z>
);<z>
) {<z>
.headers == null) {<z>
();<z>
.headers;<z>
) {<z>
"' available: " + message);<z>
= name;<z>
= null;<z>
{<z>
!= null) {<z>
.combine(newPattern);<z>
;<z>
) {<z>
.sessionAttributesHandlerCache.computeIfAbsent(<z>
,<z>
));<z>
(<z>
,<z>
,<z>
Handle bootstrapMethodHandle,<z>
... bootstrapMethodArguments) {<z>
return symbolTable.addConstantDynamic(<z>
descriptor, bootstrapMethodHandle, bootstrapMethodArguments)<z>
;<z>
throws IOException {<z>
(this.defaultClient) {<z>
= this.client.cache();<z>
{<z>
();<z>
).shutdown();<z>
connectionPool().evictAll();<z>
,<z>
) {<z>
response, "HttpServletResponse is required for CookieLocaleResolver");<z>
locale = null;<z>
null;<z>
{<z>
localeContext.getLocale();<z>
{<z>
) localeContext).getTimeZone();<z>
addCookie(response,<z>
: ""));<z>
;<z>
setAttribute(LOCALE_REQUEST_ATTRIBUTE_NAME,<z>
(request)));<z>
,<z>
)));<z>
void writeBuffer(DataBuffer dataBuffer) {<z>
dataBuffer)<z>
)<z>
blockingOperationScheduler)<z>
null,<z>
::emitError,<z>
this::writeComplete);<z>
<?> beanClass) throws BeansException {<z>
logger.isTraceEnabled()) {<z>
;<z>
this.beanInfo = getBeanInfo(beanClass);<z>
()) {<z>
) + "]");<z>
propertyDescriptors = new LinkedHashMap<>();<z>
HashSet<>();<z>
this.beanInfo.getPropertyDescriptors();<z>
{<z>
Class.class == beanClass &&<z>
)))) {<z>
isTraceEnabled()) {<z>
.getName() + "'" +<z>
getName() + "]" : "") +<z>
) != null ?<z>
));<z>
;<z>
(), pd);<z>
= pd.getReadMethod();<z>
{<z>
());<z>
= beanClass;<z>
Object.class) {<z>
beanClass, currClass, readMethodNames);<z>
();<z>
beanClass, readMethodNames);<z>
();<z>
{<z>
"]", ex);<z>
>[] paramTypes) {<z>
i++) {<z>
) {<z>
;<z>
{<z>
this.rawArguments[i])) {<z>
return Integer.MAX_VALUE - 512;<z>
return Integer.MAX_VALUE - 1024;<z>
{<z>
(n)) {<z>
.addCap(DEMAND_FIELD_UPDATER, publisher, n);<z>
);<z>
response,<z>
filterChain) throws ServletException, IOException {<z>
(this.removeOnly) {<z>
wrappedRequest = new ForwardedHeaderRemovingRequest(request);<z>
filterChain.doFilter(wrappedRequest, response);<z>
wrappedRequest =<z>
(request);<z>
HttpServletResponse wrappedResponse = this.relativeRedirects ?<z>
, HttpStatus.SEE_OTHER) :<z>
response, wrappedRequest);<z>
;<z>
() {<z>
.debug("Clearing all views from the cache");<z>
this.viewCreationCache) {<z>
.clear();<z>
this.viewCreationCache.clear();<z>
ExpressionState state) throws EvaluationException {<z>
getLeftOperand();<z>
();<z>
, String.class);<z>
);<z>
== null) {<z>
,<z>
(Object) null);<z>
(right instanceof String rightString)) {<z>
getStartPosition(),<z>
right);<z>
.patternCache.get(rightString);<z>
{<z>
.compile(rightString);<z>
.putIfAbsent(rightString, pattern);<z>
;<z>
);<z>
(PatternSyntaxException ex) {<z>
(<z>
right);<z>
) {<z>
(<z>
right);<z>
{<z>
(conversionService, "ConversionService must not be null");<z>
;<z>
) != null) {<z>
);<z>
protected String processPath(String path) {<z>
, "/");<z>
;<z>
;<z>
Supplier<String> sqlSupplier) {<z>
String sql = sqlSupplier.get();<z>
.hasText(sql), "SQL returned by SQL supplier must not be empty!");<z>
;<z>
,<z>
, Object... uriVariables) {<z>
;<z>
;<z>
);<z>
public boolean shouldClose(Connection con) {<z>
) {<z>
&& con != this.target);<z>
public Mono<Void> suspend() {<z>
(this.holderActive) {<z>
-> {<z>
);<z>
.connectionHolder.isOpen()) {<z>
), this.connectionFactory)<z>
this.connectionHolder.setConnection(null));<z>
empty();<z>
});<z>
();<z>
mi) throws Throwable {<z>
return mi.proceed();<z>
), null, null);<z>
> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,<z>
annotationType) {<z>
);<z>
{<z>
selected = null;<z>
.delegates) {<z>
;<z>
) {<z>
selected != null) {<z>
"No unique MessageCodesResolver found: {" +<z>
);<z>
messageCodesResolver;<z>
return selected;<z>
void verify() {<z>
int count = verifyInternal();<z>
if (count > 0) {<z>
+ count + " unsatisfied expectation(s).\n";<z>
));<z>
() throws Exception {<z>
Session session = this.session;<z>
()) {<z>
;<z>
null;<z>
{<z>
);<z>
(pd != null) {<z>
method);<z>
hasText(ma.getDescription())) {<z>
();<z>
= obtainAttributeSource().getManagedMetric(method);<z>
getDescription())) {<z>
getDescription();<z>
return method.getName();<z>
.getManagedOperation(method);<z>
())) {<z>
();<z>
;<z>
CannotLoadBeanClassException(@Nullable String resourceDescription, String beanName,<z>
, LinkageError cause) {<z>
beanName + "'" +<z>
" defined in " + resourceDescription : "") +<z>
;<z>
resourceDescription;<z>
this.beanName = beanName;<z>
.beanClassName = beanClassName;<z>
() {<z>
getThis() == null) {<z>
UnsupportedOperationException("No source location joinpoint available: target is null");<z>
getThis().getClass();<z>
) {<z>
(mimeType)) {<z>
false;<z>
() != null) {<z>
;<z>
)) {<z>
false;<z>
mimeType);<z>
== null) {<z>
false;<z>
= elementType.toClass();<z>
) {<z>
;<z>
.class == clazz) {<z>
;<z>
) {<z>
.canSerialize(clazz);<z>
> causeRef = new AtomicReference<>();<z>
mapper.canSerialize(clazz, causeRef)) {<z>
;<z>
clazz, causeRef.get());<z>
;<z>
request, @Nullable HttpServletResponse response,<z>
{<z>
this.request = request;<z>
;<z>
this.model = model;<z>
;<z>
if (wac == null) {<z>
;<z>
wac == null) {<z>
("No WebApplicationContext found: not in a DispatcherServlet " +<z>
;<z>
= wac;<z>
null;<z>
TimeZone timeZone = null;<z>
);<z>
if (localeResolver instanceof LocaleContextResolver) {<z>
);<z>
locale = localeContext.getLocale();<z>
{<z>
TimeZoneAwareLocaleContext) localeContext).getTimeZone();<z>
else if (localeResolver != null) {<z>
request);<z>
this.locale = locale;<z>
timeZone = timeZone;<z>
webApplicationContext.getServletContext());<z>
.responseEncodedHtmlEscape =<z>
.webApplicationContext.getServletContext());<z>
= new UrlPathHelper();<z>
(RequestContextUtils.REQUEST_DATA_VALUE_PROCESSOR_BEAN_NAME)) {<z>
(<z>
);<z>
public Mono<T> one() {<z>
return all().buffer(2)<z>
flatMap(list -> {<z>
list.isEmpty()) {<z>
();<z>
{<z>
IncorrectResultSizeDataAccessException(<z>
.format("Query [%s] returned non unique result.", this.sql),<z>
));<z>
just(list.get(0));<z>
}).next();<z>
jmsListener, Method mostSpecificMethod, Object bean) {<z>
));<z>
= createMethodJmsListenerEndpoint();<z>
bean);<z>
.setMethod(invocableMethod);<z>
.setMostSpecificMethod(mostSpecificMethod);<z>
.messageHandlerMethodFactory);<z>
.setEmbeddedValueResolver(this.embeddedValueResolver);<z>
beanFactory);<z>
endpoint.setId(getEndpointId(jmsListener));<z>
));<z>
hasText(jmsListener.selector())) {<z>
resolve(jmsListener.selector()));<z>
.subscription())) {<z>
(jmsListener.subscription()));<z>
)) {<z>
);<z>
= null;<z>
(jmsListener.containerFactory());<z>
.hasText(containerFactoryBeanName)) {<z>
(this.beanFactory != null, "BeanFactory must be set to obtain container factory by bean name");<z>
.class);<z>
(NoSuchBeanDefinitionException ex) {<z>
"Could not register JMS listener endpoint on [" +<z>
+ JmsListenerContainerFactory.class.getSimpleName() +<z>
);<z>
;<z>
<?> clazz) {<z>
(clazz != null &&<z>
isAssignableFrom(clazz) ||<z>
getMXBeanInterface(clazz) != null)));<z>
, int length) {<z>
length);<z>
= getParent();<z>
);<z>
) {<z>
;<z>
data);<z>
);<z>
() {<z>
return result -> {<z>
();<z>
, getDefinedEncoding(response));<z>
public void registerExceptionHandlerAdvice(<z>
resolver) {<z>
, resolver);<z>
{<z>
instanceof String) {<z>
{<z>
"Cannot resolve bean names if not running in a BeanFactory");<z>
= (String) mapValue;<z>
beanFactory, beanName)) {<z>
beanKey);<z>
beanName, objectName);<z>
;<z>
= this.beanFactory.getBean(beanName);<z>
);<z>
, objectName);<z>
;<z>
this.beanFactory != null) {<z>
beansOfSameType =<z>
), false, this.allowEagerInit);<z>
entrySet()) {<z>
{<z>
;<z>
, beanKey);<z>
replaceNotificationListenerBeanNameKeysIfNecessary(beanName, objectName);<z>
objectName;<z>
;<z>
{<z>
throw new UnableToRegisterMBeanException(<z>
ex);<z>
String message, String statusText,<z>
body, @Nullable Charset charset) {<z>
;<z>
throws XmlMappingException {<z>
.createContentHandler(eventWriter);<z>
;<z>
marshalSaxHandlers(graph, contentHandler, lexicalHandler);<z>
pointcutDefinition) {<z>
"Advisor <advice(ref)='" +<z>
"', pointcut(expression)=[" +<z>
;<z>
Object[] toArray() {<z>
.toArray();<z>
;<z>
result;<z>
getHandlerMapping() {<z>
> urlMap = new LinkedHashMap<>();<z>
) {<z>
registration.getMappings();<z>
) -> {<z>
) {<z>
, httpHandler);<z>
;<z>
WebSocketHandlerMapping();<z>
.setUrlMap(urlMap);<z>
(this.order);<z>
null) {<z>
.urlPathHelper);<z>
return hm;<z>
private void setResponseStatus(ServletWebRequest webRequest) throws IOException {<z>
status = getResponseStatus();<z>
null) {<z>
;<z>
(response != null) {<z>
);<z>
if (StringUtils.hasText(reason)) {<z>
(status.value(), reason);<z>
;<z>
(View.RESPONSE_STATUS_ATTRIBUTE, status);<z>
protected Object convertFromInternal(<z>
Nullable Object conversionHint) {<z>
();<z>
<MergedContextConfiguration> removedContexts, MergedContextConfiguration key) {<z>
.notNull(key, "Key must not be null");<z>
;<z>
) {<z>
(MergedContextConfiguration child : children) {<z>
;<z>
);<z>
(key);<z>
ConfigurableApplicationContext) {<z>
.close();<z>
);<z>
T> targetClass) throws MessagingException {<z>
(destinationName);<z>
) {<z>
return doConvert(message, targetClass);<z>
;<z>
) {<z>
long data =<z>
< typeTableIndex2<z>
((long) typeTableIndex2) << 32)<z>
;<z>
+ typeTableIndex2);<z>
Entry entry = get(hashCode);<z>
(entry != null) {<z>
entry.data == data) {<z>
.info;<z>
entry.next;<z>
type1 = typeTable[typeTableIndex1].value;<z>
value;<z>
type1, type2));<z>
, hashCode)).info = commonSuperTypeIndex;<z>
;<z>
<T> targetValueType, boolean resolveNestedPlaceholders) {<z>
!= null) {<z>
this.propertySources) {<z>
{<z>
"' in PropertySource '" +<z>
);<z>
value = propertySource.getProperty(key);<z>
!= null) {<z>
value instanceof String) {<z>
value = resolveNestedPlaceholders((String) value);<z>
, propertySource, value);<z>
);<z>
()) {<z>
+ "' in any property source");<z>
return null;<z>
SQLException {<z>
= dataSource.getConnection();<z>
(con == null) {<z>
IllegalStateException("DataSource returned null from getConnection(): " + dataSource);<z>
con;<z>
PreparedStatement prepareStatementForGeneratedKeys(Connection con) throws SQLException {<z>
.length < 1) {<z>
new InvalidDataAccessApiUsageException("Generated Key Name(s) not specified. " +<z>
"Using the generated keys features requires specifying the name(s) of the generated column(s).");<z>
PreparedStatement ps;<z>
) {<z>
if (logger.isDebugEnabled()) {<z>
("Using generated keys support with array of column names.");<z>
());<z>
)) {<z>
"Using generated keys support with Statement.RETURN_GENERATED_KEYS.");<z>
;<z>
ps;<z>
) {<z>
()<z>
true)<z>
)<z>
.build();<z>
MockHttpServletRequest createServletRequest(ServletContext servletContext) {<z>
;<z>
null ?<z>
getCharacterEncoding()) : StandardCharsets.UTF_8);<z>
request::addFile);<z>
part -> {<z>
addPart(part);<z>
part.getName();<z>
.getSubmittedFileName();<z>
.getInputStream();<z>
{<z>
is));<z>
, defaultCharset));<z>
copyToString(reader);<z>
);<z>
(IOException ex) {<z>
+ part.getName(), ex);<z>
});<z>
;<z>
static int hash(<z>
,<z>
String value1,<z>
String value2,<z>
final String value3,<z>
final int value4) {<z>
value4);<z>
NOT_ACCEPTABLE_VIEW = new View() {<z>
String getContentType() {<z>
;<z>
request, HttpServletResponse response) {<z>
response.setStatus(HttpServletResponse.SC_NOT_ACCEPTABLE);<z>
, String qualifiedName) {<z>
indexOf(':');<z>
== -1) {<z>
qualifiedName);<z>
qualifiedName.substring(0, idx);<z>
substring(idx + 1);<z>
);<z>
IOException {<z>
);<z>
request);<z>
isDebugEnabled()) {<z>
" " + url);<z>
;<z>
EvaluationException {<z>
();<z>
).getValue();<z>
instanceof Number rightNumber) {<z>
BigDecimal || rightNumber instanceof BigDecimal) {<z>
BigDecimal.class);<z>
class);<z>
), rightBigDecimal.scale());<z>
RoundingMode.HALF_EVEN));<z>
instanceof Double) {<z>
exitTypeDescriptor = "D";<z>
;<z>
rightNumber instanceof Float) {<z>
;<z>
/ rightNumber.floatValue());<z>
BigInteger) {<z>
(leftNumber, BigInteger.class);<z>
rightNumber, BigInteger.class);<z>
(leftBigInteger.divide(rightBigInteger));<z>
instanceof Long || rightNumber instanceof Long) {<z>
"J";<z>
rightNumber.longValue());<z>
) {<z>
.exitTypeDescriptor = "I";<z>
());<z>
());<z>
, leftOperand, rightOperand);<z>
(HttpMethod method) {<z>
) {<z>
) {<z>
"]" + "Releasing body, not yet subscribed.");<z>
);<z>
{<z>
this.corePoolSize != null) {<z>
taskExecutor.setCorePoolSize(this.corePoolSize);<z>
) {<z>
;<z>
.keepAliveSeconds != null) {<z>
.setKeepAliveSeconds(this.keepAliveSeconds);<z>
(this.queueCapacity != null) {<z>
taskExecutor.setQueueCapacity(this.queueCapacity);<z>
taskExecutor;<z>
returnType,<z>
Exception {<z>
{<z>
);<z>
= webRequest.getNativeResponse(HttpServletResponse.class);<z>
, "No HttpServletResponse");<z>
ServletServerHttpResponse(response);<z>
(returnValue instanceof ResponseEntity) {<z>
>) returnValue;<z>
responseEntity.getStatusCodeValue());<z>
getHeaders());<z>
.getBody();<z>
{<z>
true);<z>
;<z>
;<z>
request != null, "No ServletRequest");<z>
ShallowEtagHeaderFilter.disableContentCaching(request);<z>
);<z>
StreamingResponseBody streamingBody = (StreamingResponseBody) returnValue;<z>
streamingBody);<z>
(callable, mavContainer);<z>
<ApplicationListener<?>> getApplicationListeners() {<z>
this.applicationListeners;<z>
;<z>
(applicationListeners == null || applicationListenerBeans == null) {<z>
return null;<z>
new ArrayList<>(<z>
size());<z>
);<z>
) {<z>
= getBeanFactory();<z>
applicationListenerBeans) {<z>
, ApplicationListener.class));<z>
) {<z>
!applicationListenerBeans.isEmpty()) {<z>
AnnotationAwareOrderComparator.sort(allListeners);<z>
allListeners;<z>
URL determineDefaultPersistenceUnitRootUrl() {<z>
this.defaultPersistenceUnitRootLocation == null) {<z>
;<z>
).getURL();<z>
);<z>
IOException ex) {<z>
PersistenceException("Unable to resolve persistence unit root URL", ex);<z>
Connection connection, ConnectionFactory connectionFactory) {<z>
return TransactionSynchronizationManager.forCurrentTransaction()<z>
-> {<z>
) synchronizationManager.getResource(connectionFactory);<z>
{<z>
();<z>
;<z>
));<z>
, T mapping) {<z>
notNull(mapping, "Mapping must not be null");<z>
createHandlerMethod(handler, method);<z>
);<z>
(newHandlerMethod)) {<z>
() +<z>
"\nto " + mapping + ": There is already '" +<z>
) + "' bean method\n" + oldHandlerMethod + " mapped.");<z>
);<z>
put(mapping, newHandlerMethod);<z>
) {<z>
-> new CopyOnWriteArrayList<>());<z>
;<z>
findAndRemoveReactiveAttribute(Model model, String attributeName) {<z>
().stream()<z>
{<z>
{<z>
false;<z>
;<z>
if (adapter == null) {<z>
false;<z>
.getReactiveType());<z>
);<z>
)<z>
.map(entry -> {<z>
getKey());<z>
return entry.getValue();<z>
(null);<z>
{<z>
{<z>
return this.order;<z>
getOrder();<z>
UserDestinationMessageHandler userDestinationMessageHandler(<z>
AbstractSubscribableChannel clientOutboundChannel,<z>
, UserDestinationResolver userDestinationResolver) {<z>
=<z>
, userDestinationResolver);<z>
= getBrokerRegistry(clientInboundChannel, clientOutboundChannel);<z>
destination = registry.getUserDestinationBroadcast();<z>
null) {<z>
(destination);<z>
return handler;<z>
, final int flags) {<z>
ASM9);<z>
(this, classReader);<z>
COMPUTE_FRAMES) != 0) {<z>
COMPUTE_ALL_FRAMES;<z>
(flags & COMPUTE_MAXS) != 0) {<z>
;<z>
{<z>
.COMPUTE_NOTHING;<z>
payload) {<z>
TextMessage(payload);<z>
handleMessage(this.wsSession, message);<z>
{<z>
wsSession, ex, logger);<z>
int off, int len) throws IOException {<z>
int available = available();<z>
0) {<z>
, available);<z>
read(bytes, off, len);<z>
;<z>
-1;<z>
throws IllegalStateException {<z>
get();<z>
if (mi == null) {<z>
(<z>
"must be invoked from the same thread.");<z>
mi;<z>
private HttpHeaders initHeaders() {<z>
defaultHeaders == null) {<z>
new HttpHeaders();<z>
defaultHeaders;<z>
@Nullable String etag, long lastModifiedTimestamp) {<z>
getResponse();<z>
!= response.getStatus())) {<z>
this.notModified;<z>
)) {<z>
notModified && response != null) {<z>
PRECONDITION_FAILED.value());<z>
this.notModified;<z>
= validateIfNoneMatch(etag);<z>
(!validated) {<z>
(lastModifiedTimestamp);<z>
null) {<z>
(getRequest().getMethod());<z>
this.notModified) {<z>
?<z>
.value());<z>
if (isHttpGetOrHead) {<z>
-1) {<z>
.LAST_MODIFIED, lastModifiedTimestamp);<z>
{<z>
, padEtagIfNecessary(etag));<z>
this.notModified;<z>
?> controllerType, Method method) {<z>
.notNull(controllerType, "'controllerType' is required");<z>
Assert.notNull(method, "'method' is required");<z>
fromPath(getPath());<z>
this.controllerType = controllerType;<z>
method;<z>
getParameterCount()];<z>
t) {<z>
publisher.changeState(this, COMPLETED)) {<z>
s = publisher.subscriber;<z>
.state(s != null, "No subscriber");<z>
);<z>
publishError(publisher, t);<z>
localeContext) {<z>
TimeZone timeZone = null;<z>
{<z>
localeContext).getTimeZone();<z>
;<z>
HttpHeaders createHeaders(HttpServletResponse servletResponse) {<z>
);<z>
);<z>
));<z>
(MethodParameter parameter) {<z>
);<z>
).getParameterTypes();<z>
1]));<z>
;<z>
public void onTimeout(AsyncEvent event) {<z>
.getThrowable();<z>
("Async operation timeout."));<z>
;<z>
) {<z>
= getBinding();<z>
{<z>
.getVariable(name);<z>
) {<z>
name);<z>
)) {<z>
(GroovyBeanDefinitionWrapper)<z>
));<z>
(beanDefinition != null) {<z>
(name, beanDefinition, false);<z>
RuntimeBeanReference(name, false);<z>
currentBeanDefinition != null) {<z>
getPropertyValues();<z>
) {<z>
(name);<z>
.getBeanName() + name);<z>
(dp != null) {<z>
;<z>
name);<z>
, name);<z>
Parameter parameter) {<z>
;<z>
[] allParams = executable.getParameters();<z>
++) {<z>
{<z>
return i;<z>
.length; i++) {<z>
i])) {<z>
i;<z>
new IllegalArgumentException("Given parameter [" + parameter +<z>
);<z>
mimeType1, T mimeType2) {<z>
!mimeType2.isWildcardType()) {<z>
;<z>
) {<z>
;<z>
mimeType2.getType())) {<z>
;<z>
mimeType2.isWildcardSubtype()) {<z>
return 1;<z>
) {<z>
1;<z>
)) {<z>
return 0;<z>
, mimeType2);<z>
) {<z>
producer, "'producer' must not be null");<z>
;<z>
));<z>
.notNull(adapter, "'producer' type is unknown to ReactiveAdapterRegistry");<z>
), ResolvableType.forType(elementTypeRef));<z>
;<z>
> messageConverters,<z>
{<z>
messageConverters, requestResponseBodyAdvice);<z>
Object concurrentResult) {<z>
exceptionResult = null;<z>
preProcessIndex; i >= 0; i--) {<z>
request, task, concurrentResult);<z>
ex) {<z>
(exceptionResult != null) {<z>
.isTraceEnabled()) {<z>
);<z>
ex;<z>
!= null) ? exceptionResult : concurrentResult;<z>
ifc) {<z>
<?> pubIfc : this.publishedInterfaces) {<z>
ifc.isAssignableFrom(pubIfc)) {<z>
true;<z>
false;<z>
) {<z>
();<z>
();<z>
.getFilename();<z>
null) {<z>
+ " (" + filename + ")}";<z>
return "DefaultFilePart{(" + filename + ")}";<z>
{<z>
sessions.size() +<z>
webSocket.get() +<z>
httpStreaming.get() +<z>
httpPolling.get() + "), " +<z>
.total.get() + " total, " +<z>
noMessagesReceived.get()) + " closed abnormally (" +<z>
) + " connect failure, " +<z>
.limitExceeded.get() + " send limit, " +<z>
this.transportError.get() + " transport error)";<z>
AspectJExpressionPointcut declaredPointcut,<z>
aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,<z>
declarationOrder, String aspectName) {<z>
;<z>
();<z>
aspectJAdviceMethod.getName();<z>
aspectJAdviceMethod.getParameterTypes();<z>
;<z>
;<z>
this.aspectInstanceFactory = aspectInstanceFactory;<z>
= declarationOrder;<z>
= aspectName;<z>
getAspectMetadata().isLazilyInstantiated()) {<z>
preInstantiationPointcut = Pointcuts.union(<z>
.declaredPointcut);<z>
pointcut = new PerTargetInstantiationModelPointcut(<z>
this.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);<z>
.lazy = true;<z>
;<z>
.lazy = false;<z>
.instantiatedAdvice = instantiateAdvice(this.declaredPointcut);<z>
String getErrorMessage(<z>
@Nullable Charset charset) {<z>
;<z>
)) {<z>
return preface + "[no body]";<z>
StandardCharsets.UTF_8);<z>
, charset);<z>
, -1, true);<z>
return preface + bodyText;<z>
] includePatterns, @Nullable String[] excludePatterns,<z>
interceptor) {<z>
;<z>
[] in, File out) throws IOException {<z>
(in, "No input byte array specified");<z>
out, "No output File specified");<z>
)));<z>
void makeAccessible(Field field) {<z>
)) ||<z>
.getDeclaringClass().getModifiers()) ||<z>
&& !field.isAccessible()) {<z>
);<z>
handlerDecorator) {<z>
.httpHandlerDecorator = (this.httpHandlerDecorator != null ?<z>
.httpHandlerDecorator) : handlerDecorator);<z>
;<z>
{<z>
).toCharArray();<z>
null && characters.isIgnorableWhiteSpace()) {<z>
, data.length);<z>
null) {<z>
getLexicalHandler().startCDATA();<z>
) {<z>
;<z>
&& getLexicalHandler() != null) {<z>
endCDATA();<z>
Class<?> beanClass, String beanName) {<z>
()) {<z>
;<z>
Object cacheKey = getCacheKey(beanClass, beanName);<z>
cacheKey);<z>
protected Object doGetTransaction() {<z>
();<z>
.setResourceHolder(<z>
obtainConnectionFactory()));<z>
txObject;<z>
String, MediaType> mediaTypes) {<z>
super(mediaTypes);<z>
false);<z>
;<z>
.urlPathHelper.setUrlDecode(false);<z>
?> paramMap) throws DataAccessException {<z>
);<z>
ParsedSql parsedSql = getParsedSql();<z>
);<z>
substituteNamedParameters(parsedSql, paramSource);<z>
parsedSql, paramSource, getDeclaredParameters());<z>
, params));<z>
checkRowsAffected(rowsAffected);<z>
return rowsAffected;<z>
Class<?>... annotatedClasses) {<z>
) {<z>
annotatedClass);<z>
;<z>
predicate,<z>
> handlerFunction) {<z>
;<z>
{<z>
, null, this.locale);<z>
return true;<z>
NoSuchMessageException ex) {<z>
false;<z>
> matcher, Class<T> targetType) {<z>
new AbstractJsonPathRequestMatcher() {<z>
MockClientHttpRequest request) throws IOException, ParseException {<z>
body = request.getBodyAsString();<z>
.assertValue(body, matcher, targetType);<z>
UriComponentsBuilder uriComponents(UriComponents uriComponents) {<z>
;<z>
;<z>
;<z>
ConfigurableBeanFactory beanFactory) {<z>
.configurableBeanFactory = beanFactory;<z>
=<z>
);<z>
(<z>
, @Nullable Object source) {<z>
;<z>
null) {<z>
;<z>
);<z>
{<z>
= getDefaultExecutorBeanDefinition(name);<z>
.class);<z>
{<z>
"corePoolSize", executorElem.getAttribute("core-pool-size"));<z>
{<z>
"max-pool-size"));<z>
if (executorElem.hasAttribute("keep-alive-seconds")) {<z>
, executorElem.getAttribute("keep-alive-seconds"));<z>
{<z>
"queue-capacity"));<z>
ConstructorArgumentValues cargs = new ConstructorArgumentValues();<z>
!= null) {<z>
"threadNamePrefix", name + "-");<z>
String executorName = name + "Executor";<z>
, context, source);<z>
(0, new RuntimeBeanReference(executorName));<z>
null);<z>
= new ManagedList<>();<z>
(element != null) {<z>
(element, "interceptors");<z>
.parseBeanSubElements(interceptorsElement, context));<z>
new ImmutableMessageChannelInterceptor());<z>
);<z>
channelDef, context, source);<z>
;<z>
Nullable String methodName) {<z>
Assert.notNull(clazz, "Class must not be null");<z>
this.clazz = clazz;<z>
.methodName = methodName;<z>
throws Throwable {<z>
name = createInvocationTraceName(invocation);<z>
);<z>
stopWatch.start(name);<z>
proceed();<z>
.stop();<z>
.shortSummary());<z>
getSupportedMediaTypes(Class<?> clazz) {<z>
> mediaTypeSet = new LinkedHashSet<>();<z>
) {<z>
clazz));<z>
= new ArrayList<>(mediaTypeSet);<z>
result);<z>
;<z>
BeanFactory beanFactory) throws BeansException {<z>
) {<z>
new FatalBeanException(<z>
);<z>
.beanFactory = (ListableBeanFactory) beanFactory;<z>
) {<z>
HttpHeaders headers = new HttpHeaders();<z>
TEXT_EVENT_STREAM);<z>
));<z>
;<z>
ServletServerHttpRequest createInputMessage(NativeWebRequest webRequest) {<z>
getNativeRequest(HttpServletRequest.class);<z>
);<z>
ServletServerHttpRequest(servletRequest);<z>
) {<z>
= getContextAttribute();<z>
== null) {<z>
;<z>
=<z>
(), attrName);<z>
null) {<z>
("No WebApplicationContext found: initializer not registered?");<z>
return wac;<z>
invokeExceptionListener(JMSException ex) {<z>
exceptionListener = getExceptionListener();<z>
exceptionListener != null) {<z>
onException(ex);<z>
{<z>
1;<z>
{<z>
notNull(attributeName, "'attributeName' must not be null");<z>
)) {<z>
;<z>
-1];<z>
= 0;<z>
boolean upperCaseNext = false;<z>
length(); i++ ) {<z>
(i);<z>
(c == '-') {<z>
= true;<z>
else if (upperCaseNext) {<z>
Character.toUpperCase(c);<z>
;<z>
;<z>
currPos);<z>
{<z>
, transformer);<z>
ex) {<z>
));<z>
catch (Throwable ex) {<z>
IllegalStateException("Could not invoke GlassFish addTransformer method", ex);<z>
HttpServletRequest request, @Nullable MessageSource messageSource) {<z>
RequestContextUtils.getLocale(request);<z>
request, Config.FMT_LOCALE, jstlLocale);<z>
);<z>
if (timeZone != null) {<z>
Config.FMT_TIME_ZONE, timeZone);<z>
{<z>
(messageSource, request);<z>
request, Config.FMT_LOCALIZATION_CONTEXT, jstlContext);<z>
XmlMappingException convertXStreamException(Exception ex, boolean marshalling) {<z>
instanceof StreamException || ex instanceof CannotResolveClassException ||<z>
) {<z>
(marshalling) {<z>
, ex);<z>
ex);<z>
);<z>
targetType) {<z>
true;<z>
converterFactory instanceof ConditionalConverter) {<z>
matches(sourceType, targetType);<z>
) {<z>
getConverter(targetType.getType());<z>
(converter instanceof ConditionalConverter) {<z>
).matches(sourceType, targetType);<z>
return matches;<z>
String, MediaType> mediaTypes) {<z>
.mediaTypes.clear();<z>
mediaTypes(mediaTypes);<z>
;<z>
) throws IllegalArgumentException {<z>
paramName);<z>
{<z>
(ex.getMessage());<z>
indexOf(IntPredicate predicate, int fromIndex) {<z>
);<z>
(fromIndex < 0) {<z>
0;<z>
.writePosition) {<z>
-1;<z>
< this.writePosition; i++) {<z>
byteBuffer.get(i);<z>
(predicate.test(b)) {<z>
return i;<z>
-1;<z>
List<HandlerInterceptor> interceptorList) {<z>
instanceof HandlerExecutionChain originalChain) {<z>
.handler = originalChain.getHandler();<z>
addAll(originalChain.interceptorList);<z>
handler = handler;<z>
.interceptorList.addAll(interceptorList);<z>
) {<z>
);<z>
(name, values) -> {<z>
== null) {<z>
), "Null name in form data: " + formData);<z>
forEach(value -> {<z>
) {<z>
'&');<z>
, charset));<z>
null) {<z>
append('=');<z>
value), charset));<z>
});<z>
});<z>
builder.toString();<z>
[] paramInfo)<z>
{<z>
.getDefaultClassLoader());<z>
Class<?> clazz) {<z>
);<z>
this.clazz = clazz;<z>
(clazz.getClassLoader());<z>
? super MergedAnnotation<A>> action) {<z>
()) {<z>
.get(this.aggregateCursor);<z>
)) {<z>
return true;<z>
++;<z>
;<z>
;<z>
Nullable Object obj) {<z>
(obj == null) {<z>
0;<z>
).isArray()) {<z>
if (obj instanceof Object[]) {<z>
;<z>
[]) {<z>
boolean[]) obj);<z>
[]) {<z>
obj);<z>
instanceof char[]) {<z>
);<z>
{<z>
);<z>
(obj instanceof float[]) {<z>
) obj);<z>
[]) {<z>
(int[]) obj);<z>
long[]) {<z>
) obj);<z>
{<z>
]) obj);<z>
obj.hashCode();<z>
) throws IllegalArgumentException {<z>
(dataSource instanceof DataSource) {<z>
) dataSource;<z>
(dataSource instanceof String) {<z>
dataSourceLookup.getDataSource((String) dataSource);<z>
new IllegalArgumentException(<z>
;<z>
Message message, Unmarshaller unmarshaller)<z>
{<z>
message.getClass() +<z>
"]. MarshallingMessageConverter by default only supports TextMessages and BytesMessages.");<z>
{<z>
registeredType == null ||<z>
(requiredType != null &&<z>
||<z>
.registeredType))) ||<z>
== null &&<z>
.isArray()))) {<z>
return this.propertyEditor;<z>
null;<z>
<String> resolveUrlPathInternal(String resourceUrlPath,<z>
ResourceResolverChain chain) {<z>
, locations)<z>
switchIfEmpty(Mono.defer(() -> {<z>
);<z>
!= null) {<z>
);<z>
return Mono.empty();<z>
}));<z>
{<z>
;<z>
result = null;<z>
(headerValues != null) {<z>
.get(0) : headerValues);<z>
return result;<z>
) {<z>
);<z>
.currentSteps.offerFirst(sequenceId);<z>
new FlightRecorderStartupStep(sequenceId, name,<z>
(sequenceId));<z>
getFoo() {<z>
foo_;<z>
{<z>
String) ref;<z>
{<z>
bs =<z>
.ByteString) ref;<z>
;<z>
(bs.isValidUtf8()) {<z>
s;<z>
return s;<z>
{<z>
GET.equals(httpMethod)) {<z>
);<z>
httpMethod)) {<z>
(uri);<z>
HttpMethod.POST.equals(httpMethod)) {<z>
new HttpPost(uri);<z>
(httpMethod)) {<z>
;<z>
(httpMethod)) {<z>
;<z>
{<z>
new HttpDelete(uri);<z>
(httpMethod)) {<z>
(uri);<z>
httpMethod)) {<z>
return new HttpTrace(uri);<z>
);<z>
source, TypeDescriptor streamType, TypeDescriptor targetType) {<z>
emptyList());<z>
streamType.getElementTypeDescriptor());<z>
);<z>
Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {<z>
;<z>
parsedProps);<z>
getAttribute("location");<z>
(location)) {<z>
location);<z>
.commaDelimitedListToStringArray(location);<z>
locations);<z>
"ignoreResourceNotFound",<z>
"ignore-resource-not-found")));<z>
builder.addPropertyValue("localOverride",<z>
));<z>
element.getAttribute(SCOPE_ATTRIBUTE);<z>
)) {<z>
.setScope(scope);<z>
RequestMappingInfo getMatchingCondition(ServerWebExchange exchange) {<z>
this.methodsCondition.getMatchingCondition(exchange);<z>
(methods == null) {<z>
return null;<z>
getMatchingCondition(exchange);<z>
params == null) {<z>
return null;<z>
;<z>
{<z>
return null;<z>
this.consumesCondition.getMatchingCondition(exchange);<z>
== null) {<z>
;<z>
getMatchingCondition(exchange);<z>
(produces == null) {<z>
return null;<z>
.getMatchingCondition(exchange);<z>
(patterns == null) {<z>
;<z>
;<z>
if (custom == null) {<z>
;<z>
new RequestMappingInfo(this.name, patterns,<z>
getCondition(), this.options);<z>
(Class<?> beanClass) throws BeansException {<z>
.get(beanClass);<z>
(results != null) {<z>
results;<z>
get(beanClass);<z>
) {<z>
return results;<z>
;<z>
<Class<?>, CachedIntrospectionResults> classCacheToUse;<z>
getClassLoader()) ||<z>
)) {<z>
;<z>
if (logger.isDebugEnabled()) {<z>
+ "] because it is not cache-safe");<z>
= softClassCache;<z>
= classCacheToUse.putIfAbsent(beanClass, results);<z>
null ? existing : results);<z>
ConnectionFactory connectionFactory) {<z>
;<z>
connectionFactory);<z>
);<z>
encode, Type type) {<z>
);<z>
(sb);<z>
false;<z>
void onException(JMSException ex) {<z>
) {<z>
listener.onException(ex);<z>
(UriTemplateVariables variables) {<z>
size = this.queryParams.size();<z>
);<z>
variables);<z>
forEach((key, values) -> {<z>
, queryVariables, this.variableEncoder);<z>
);<z>
values) {<z>
value, queryVariables, this.variableEncoder));<z>
.put(name, expandedValues);<z>
);<z>
CollectionUtils.unmodifiableMultiValueMap(result);<z>
protected void updateAccessedSessionAttributes() {<z>
sessionAttributesToUpdate.isEmpty()) {<z>
HttpSession session = getSession(false);<z>
null) {<z>
this.sessionAttributesToUpdate.entrySet()) {<z>
;<z>
Object newValue = entry.getValue();<z>
.getAttribute(name);<z>
name, newValue)) {<z>
);<z>
) {<z>
clear();<z>
, Object... params) {<z>
) {<z>
error("Unexpected exception occurred invoking async method: " + method, ex);<z>
<T> processor) {<z>
(processor.isFlushPending()) {<z>
);<z>
flushIfPossible();<z>
.COMPLETED)) {<z>
;<z>
;<z>
dataSource, int timeout) throws SQLException {<z>
(stmt, "No Statement specified");<z>
= null;<z>
null) {<z>
(ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);<z>
&& holder.hasTimeout()) {<z>
holder.getTimeToLiveInSeconds());<z>
timeout >= 0) {<z>
stmt.setQueryTimeout(timeout);<z>
{<z>
) {<z>
());<z>
VALUES_ONLY)) {<z>
.encodeUriVariables(uriVars);<z>
expand(uriVars);<z>
uric);<z>
Throwable ex) {<z>
getRequest();<z>
getRawQuery();<z>
: "";<z>
;<z>
() + query + "\"";<z>
).checkpoint(description + " [ExceptionHandlingWebHandler]");<z>
EntityManagerHolder resourceHolder) {<z>
();<z>
if (em instanceof EntityManagerProxy) {<z>
) em).getTargetEntityManager();<z>
TransactionSynchronizationManager.hasResource(target)) {<z>
em.flush();<z>
catch (RuntimeException ex) {<z>
;<z>
null) {<z>
.jpaDialect.translateExceptionIfPossible(ex);<z>
(ex);<z>
);<z>
BeanDefinitionRegistry registry, @Nullable Element sourceElement) {<z>
if (sourceElement != null) {<z>
.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));<z>
if (proxyTargetClass) {<z>
forceAutoProxyCreatorToUseClassProxying(registry);<z>
);<z>
) {<z>
AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);<z>
[] exceptions) {<z>
.equals(name)) {<z>
, desc, isStatic(access));<z>
;<z>
IOException {<z>
(algorithm);<z>
if (inputStream instanceof UpdateMessageDigestInputStream){<z>
updateMessageDigest(messageDigest);<z>
return messageDigest.digest();<z>
= new byte[StreamUtils.BUFFER_SIZE];<z>
;<z>
)) != -1) {<z>
bytesRead);<z>
.digest();<z>
<T> type) throws InvalidResultSetAccessException {<z>
.resultSet.getObject(columnIndex, type);<z>
) {<z>
se);<z>
?> targetClass, boolean hasIntroductions) {<z>
.notNull(mm, "MethodMatcher must not be null");<z>
?<z>
method, targetClass, hasIntroductions) :<z>
);<z>
getTransactionAwareConnectionProxy(DataSource targetDataSource) {<z>
Proxy.newProxyInstance(<z>
class.getClassLoader(),<z>
,<z>
TransactionAwareInvocationHandler(targetDataSource));<z>
{<z>
offset, length, true);<z>
this.wsSession, message);<z>
Exception ex) {<z>
.wsSession, ex, logger);<z>
) {<z>
-> {<z>
());<z>
.orElseThrow(<z>
attributeName +<z>
getName()));<z>
;<z>
) > 0) {<z>
;<z>
value;<z>
int index) {<z>
remove(index);<z>
beanPostProcessorCache = null;<z>
result;<z>
, ServerHttpResponse response,<z>
frameFormat) throws SockJsException {<z>
.responseLock) {<z>
isClosed()) {<z>
().getContentBytes());<z>
.response = response;<z>
;<z>
response);<z>
control;<z>
start(-1);<z>
(request);<z>
(request, response, false);<z>
.readyToSend = isActive();<z>
Throwable ex) {<z>
);<z>
getId(), ex);<z>
messageTypeMessageCondition,<z>
{<z>
messageTypeMessageCondition, destinationConditions);<z>
(<z>
String prefix, String suffix) {<z>
coll)) {<z>
;<z>
) * delim.length();<z>
coll) {<z>
).length();<z>
= new StringBuilder(totalLength);<z>
= coll.iterator();<z>
{<z>
append(suffix);<z>
(it.hasNext()) {<z>
(delim);<z>
toString();<z>
(PathPatternParser parser) {<z>
ChangePathPatternParserVisitor.Target) {<z>
).changeParser(parser);<z>
right instanceof ChangePathPatternParserVisitor.Target) {<z>
this.right).changeParser(parser);<z>
matchers) {<z>
return result -> {<z>
(ResultMatcher matcher : matchers) {<z>
result);<z>
throws MessagingException {<z>
Assert.notNull(file, "File must not be null");<z>
dataSource = new FileDataSource(file);<z>
));<z>
(attachmentFilename, dataSource);<z>
) {<z>
, SET_CALLBACK, null);<z>
(0);<z>
ProcessSwitchCallback() {<z>
processCase(int key, Label end) {<z>
.load_this();<z>
.load_arg(1);<z>
]);<z>
key));<z>
end);<z>
) {<z>
);<z>
e.return_value();<z>
e.end_method();<z>
) {<z>
) {<z>
(dataBuffer);<z>
channel);<z>
{<z>
release(dataBuffer);<z>
(this.channel);<z>
State.DISPOSED);<z>
;<z>
this.position.addAndGet(read);<z>
(read);<z>
.sink.next(dataBuffer);<z>
> 0) {<z>
;<z>
State.IDLE)) {<z>
);<z>
() {<z>
{<z>
, Callable<T> task) throws Exception {<z>
RESULT_NONE);<z>
) throws Exception {<z>
.call() : CallableProcessingInterceptor.RESULT_NONE);<z>
throws Exception {<z>
completionCallback != null) {<z>
.run();<z>
(Calendar source) {<z>
(source instanceof GregorianCalendar) {<z>
.toZonedDateTime();<z>
getTimeInMillis()),<z>
.getTimeZone().toZoneId());<z>
ExceptionTypeFilter createExceptionTypeFilter(<z>
) {<z>
;<z>
)<z>
throws PersistenceException {<z>
true);<z>
public ServletRequestParameterPropertyValues(<z>
{<z>
super(WebUtils.getParametersStartingWith(<z>
));<z>
resultSet) throws InvalidResultSetAccessException {<z>
this.resultSet = resultSet;<z>
.getMetaData());<z>
(SQLException se) {<z>
se);<z>
resultSet.getMetaData();<z>
{<z>
();<z>
.columnLabelMap = CollectionUtils.newHashMap(columnCount);<z>
1; i <= columnCount; i++) {<z>
;<z>
key)) {<z>
(key, i);<z>
Collections.emptyMap();<z>
se) {<z>
(se);<z>
String, String[]> getParameterMap() {<z>
;<z>
;<z>
hasMoreElements()) {<z>
names.nextElement();<z>
name, getParameterValues(name));<z>
result;<z>
public EmbeddedDatabaseBuilder setDataSourceFactory(DataSourceFactory dataSourceFactory) {<z>
dataSourceFactory, "DataSourceFactory is required");<z>
.setDataSourceFactory(dataSourceFactory);<z>
return this;<z>
public static EntityManager createContainerManagedEntityManager(<z>
EntityManagerFactoryInfo emfInfo) {<z>
(rawEntityManager, emfInfo, true, true);<z>
(JmsListenerEndpoint endpoint,<z>
JmsListenerContainerFactory<?> containerFactory) {<z>
this.endpoint = endpoint;<z>
= containerFactory;<z>
{<z>
requiredParameterTypes.length;<z>
int argumentCount = args.length;<z>
(parameterCount != args.length ||<z>
- 1] !=<z>
: null)) {<z>
[] newArgs = new Object[parameterCount];<z>
, newArgs.length - 1);<z>
0;<z>
if (argumentCount >= parameterCount) {<z>
varargsArraySize = argumentCount - (parameterCount - 1);<z>
parameterCount - 1].getComponentType();<z>
= Array.newInstance(componentType, varargsArraySize);<z>
{<z>
i]);<z>
newArgs.length - 1] = varargsArray;<z>
newArgs;<z>
;<z>
@Nullable Class<?> targetClass) {<z>
;<z>
this.cache.get(cacheKey);<z>
null) {<z>
cached : null);<z>
operation = computeCacheOperation(method, targetClass);<z>
(operation != null) {<z>
)) {<z>
getName() + "' with operation: " + operation);<z>
);<z>
cacheKey, NULL_CACHING_ATTRIBUTE);<z>
;<z>
Type resolvedType) {<z>
{<z>
().toJson(payload, resolvedType);<z>
(payload);<z>
{<z>
get();<z>
!= null) {<z>
);<z>
currentInjectionPoint.remove();<z>
return old;<z>
{<z>
<Advisor> candidateAdvisors = findCandidateAdvisors();<z>
candidateAdvisors) {<z>
AspectJPointcutAdvisor &&<z>
getAspectName().equals(beanName)) {<z>
return true;<z>
shouldSkip(beanClass, beanName);<z>
(String... names) {<z>
mvcResult -> {<z>
(mvcResult);<z>
{<z>
);<z>
);<z>
ClientDefaultCodecsImpl(ClientDefaultCodecsImpl other) {<z>
super(other);<z>
?<z>
: null);<z>
this.sseDecoder = other.sseDecoder;<z>
> definition) {<z>
definition.getMappingName();<z>
(name == null) {<z>
= definition.getHandlerMethod();<z>
get(name);<z>
null) {<z>
) <= 1) {<z>
remove(name);<z>
1);<z>
) {<z>
) {<z>
);<z>
name, newList);<z>
resolveCodeWithoutArguments(String code, Locale locale) {<z>
getCacheMillis() < 0) {<z>
propHolder = getMergedProperties(locale);<z>
.getProperty(code);<z>
!= null) {<z>
result;<z>
) {<z>
basename, locale);<z>
(String filename : filenames) {<z>
getProperties(filename);<z>
);<z>
!= null) {<z>
result;<z>
return null;<z>
? extends HandlerMethodReturnValueHandler> initReturnValueHandlers() {<z>
;<z>
;<z>
().getCustomHandlers());<z>
;<z>
) {<z>
null) {<z>
packaze, access, modules);<z>
) {<z>
= this.headers.get(name);<z>
() : null);<z>
{<z>
);<z>
value instanceof Number) {<z>
).longValue();<z>
instanceof String) {<z>
, (String) value);<z>
else if (value != null) {<z>
throw new IllegalArgumentException(<z>
+ "' is not a Date, Number, or String: " + value);<z>
return -1L;<z>
) {<z>
(cachingConfigurerSupplier);<z>
.adapt(config -> {<z>
config instanceof JCacheConfigurer) {<z>
) config).exceptionCacheResolver();<z>
null;<z>
);<z>
MimeType other) {<z>
.parameters.size()) {<z>
false;<z>
) {<z>
= entry.getKey();<z>
parameters.containsKey(key)) {<z>
;<z>
PARAM_CHARSET.equals(key)) {<z>
), other.getCharset())) {<z>
;<z>
))) {<z>
false;<z>
return true;<z>
afterAllMappingsSet() {<z>
);<z>
size(); i++) {<z>
mirrorSets.get(i));<z>
this.claimedAliases.clear();<z>
DataSource dataSource) {<z>
.connectionHolder = connectionHolder;<z>
;<z>
);<z>
Object returnValue, MethodParameter returnType,<z>
) throws Exception {<z>
);<z>
, "HttpHeaders expected");<z>
) returnValue;<z>
if (!headers.isEmpty()) {<z>
(HttpServletResponse.class);<z>
null, "No HttpServletResponse");<z>
outputMessage = new ServletServerHttpResponse(servletResponse);<z>
(headers);<z>
outputMessage.getBody();<z>
visitInsnAnnotation(<z>
boolean visible) {<z>
{<z>
lastCodeRuntimeVisibleTypeAnnotation =<z>
(<z>
(lastBytecodeOffset << 8),<z>
;<z>
else {<z>
return lastCodeRuntimeInvisibleTypeAnnotation =<z>
AnnotationWriter.create(<z>
(lastBytecodeOffset << 8),<z>
;<z>
comment) {<z>
{<z>
name);<z>
getComment());<z>
{<z>
(target, "Connection must not be null");<z>
target;<z>
;<z>
: target);<z>
HttpOutputMessage outputMessage)<z>
, HttpMessageNotWritableException {<z>
;<z>
HttpMessageConversionException ex) {<z>
;<z>
Exception ex) {<z>
ex);<z>
StompHeaders processConnectHeaders(@Nullable StompHeaders connectHeaders) {<z>
= super.processConnectHeaders(connectHeaders);<z>
) {<z>
, "TaskScheduler must be set if heartbeats are enabled");<z>
return connectHeaders;<z>
resetSessionState() {<z>
this.previousFlushMode != null) {<z>
.session.setFlushMode(this.previousFlushMode);<z>
.needsConnectionReset &&<z>
isPhysicallyConnected()) {<z>
conToReset = this.session.connection();<z>
resetConnectionAfterTransaction(<z>
.readOnly);<z>
(<z>
TransactionDefinition definition,<z>
Object suspendedResources) {<z>
= newReactiveTransaction(synchronizationManager,<z>
, newTransaction, debug, suspendedResources);<z>
;<z>
;<z>
HttpServletResponse response, Object handler,<z>
@Nullable ModelAndView modelAndView) throws Exception {<z>
request, response, handler, modelAndView);<z>
Nullable Connection con) {<z>
) {<z>
);<z>
) {<z>
);<z>
(Throwable ex) {<z>
("Unexpected exception on closing JDBC Connection", ex);<z>
protected void doSetRollbackOnly(DefaultTransactionStatus status) {<z>
.getTransaction();<z>
status.isDebug()) {<z>
("Setting JTA transaction rollback-only");<z>
;<z>
{<z>
).setRollbackOnly();<z>
ex) {<z>
, ex);<z>
) {<z>
ex);<z>
public String tableNameToUse(@Nullable String tableName) {<z>
tableName == null) {<z>
;<z>
(isStoresUpperCaseIdentifiers()) {<z>
);<z>
()) {<z>
);<z>
;<z>
Class<?> interfaceType) {<z>
= defaultImplType;<z>
.interfaceType = interfaceType;<z>
);<z>
(delegate);<z>
suppressInterface(IntroductionInterceptor.class);<z>
suppressInterface(DynamicIntroductionAdvice.class);<z>
String pathWithinMapping,<z>
{<z>
.setAttribute(BEST_MATCHING_PATTERN_ATTRIBUTE, bestMatchingPattern);<z>
);<z>
)<z>
throws Exception {<z>
<>();<z>
!= null) {<z>
.contentNegotiationManager != null, "No ContentNegotiationManager set");<z>
ViewResolver viewResolver : this.viewResolvers) {<z>
, locale);<z>
) {<z>
(view);<z>
requestedMediaTypes) {<z>
contentNegotiationManager.resolveFileExtensions(requestedMediaType);<z>
) {<z>
;<z>
= viewResolver.resolveViewName(viewNameWithExtension, locale);<z>
{<z>
;<z>
isEmpty(this.defaultViews)) {<z>
.defaultViews);<z>
candidateViews;<z>
> acceptedMediaTypes) {<z>
result = null;<z>
expressions) {<z>
if (expression.match(acceptedMediaTypes)) {<z>
<>();<z>
);<z>
return result;<z>
?> targetClass) {<z>
(MessageConverter converter : getConverters()) {<z>
.fromMessage(message, targetClass);<z>
!= null) {<z>
result;<z>
return null;<z>
String expression) {<z>
+ "]: must contain text");<z>
(expression, "()&|!", true);<z>
);<z>
, ParameterizedTypeReference<T> bodyType) {<z>
bodyType)<z>
)<z>
))<z>
-> cookies.addAll(this.cookies))<z>
build();<z>
void suspend() {<z>
holderActive) {<z>
;<z>
connectionHolder.isOpen()) {<z>
.dataSource);<z>
.connectionHolder.setConnection(null);<z>
void cleanupMultipart(MultipartHttpServletRequest request) {<z>
request instanceof AbstractMultipartHttpServletRequest) ||<z>
) request).isResolved()) {<z>
()) {<z>
.getName()) != null) {<z>
.delete();<z>
{<z>
;<z>
result) {<z>
this.conditionPassing == null) {<z>
())) {<z>
(result);<z>
,<z>
);<z>
this.conditionPassing = true;<z>
conditionPassing;<z>
) {<z>
, "You can no longer add iterators to a composite iterator that's already in use");<z>
) {<z>
IllegalArgumentException("You cannot add the same iterator twice");<z>
;<z>
Charset charset, OutputStream out) throws IOException {<z>
notNull(in, "No input String specified");<z>
);<z>
"No OutputStream specified");<z>
;<z>
);<z>
();<z>
(<z>
> beanClass, String beanName) {<z>
startsWith("prototype")) {<z>
null;<z>
return new PrototypeTargetSource();<z>
Method method) {<z>
, method);<z>
(this.initBinderArgumentResolvers != null) {<z>
(this.initBinderArgumentResolvers);<z>
);<z>
);<z>
return binderMethod;<z>
{<z>
if (path.isEmpty()) {<z>
;<z>
;<z>
);<z>
{<z>
"Unexpected separator: '" + separator + "'");<z>
elements = new ArrayList<>();<z>
begin;<z>
) {<z>
= 1;<z>
(separatorElement);<z>
= 0;<z>
()) {<z>
indexOf(separator, begin);<z>
begin));<z>
!segment.isEmpty()) {<z>
) ?<z>
decodeAndParsePathSegment(segment) :<z>
separatorElement));<z>
{<z>
;<z>
end + 1;<z>
, elements);<z>
{<z>
) {<z>
);<z>
return this.viewResolvers;<z>
@Nullable Object[] args)<z>
BeanCreationException {<z>
BeanWrapper instanceWrapper = null;<z>
.isSingleton()) {<z>
;<z>
if (instanceWrapper == null) {<z>
mbd, args);<z>
= instanceWrapper.getWrappedInstance();<z>
();<z>
if (beanType != NullBean.class) {<z>
beanType;<z>
synchronized (mbd.postProcessingLock) {<z>
mbd.postProcessed) {<z>
applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);<z>
ex) {<z>
.getResourceDescription(), beanName,<z>
ex);<z>
.postProcessed = true;<z>
&& this.allowCircularReferences &&<z>
);<z>
) {<z>
if (logger.isTraceEnabled()) {<z>
("Eagerly caching bean '" + beanName +<z>
;<z>
bean));<z>
= bean;<z>
, mbd, instanceWrapper);<z>
, mbd);<z>
) {<z>
{<z>
;<z>
(<z>
), beanName, "Initialization of bean failed", ex);<z>
if (earlySingletonExposure) {<z>
, false);<z>
earlySingletonReference != null) {<z>
== bean) {<z>
exposedObject = earlySingletonReference;<z>
(beanName)) {<z>
(beanName);<z>
.length);<z>
: dependentBeans) {<z>
) {<z>
;<z>
!actualDependentBeans.isEmpty()) {<z>
new BeanCurrentlyInCreationException(beanName,<z>
+ beanName + "' has been injected into other beans [" +<z>
(actualDependentBeans) +<z>
"'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.");<z>
bean, mbd);<z>
{<z>
new BeanCreationException(<z>
), beanName, "Invalid destruction signature", ex);<z>
return exposedObject;<z>
toString() {<z>
Long.MAX_VALUE ?<z>
));<z>
+ FixedBackOff.this.interval +<z>
currentAttempts +<z>
", maxAttempts=" + attemptValue +<z>
(XmlBeanDefinitionReader reader) throws BeansException, IOException {<z>
Resource[] configResources = getConfigResources();<z>
if (configResources != null) {<z>
reader.loadBeanDefinitions(configResources);<z>
[] configLocations = getConfigLocations();<z>
!= null) {<z>
.loadBeanDefinitions(configLocations);<z>
float getRequiredFloatParameter(ServletRequest request, String name)<z>
throws ServletRequestBindingException {<z>
(name));<z>
, HttpHeaders headers) {<z>
;<z>
uri, contextPath);<z>
= HttpHeaders.readOnlyHttpHeaders(headers);<z>
,<z>
initializer) {<z>
= (char[]) newArray;<z>
.length; i++) {<z>
.getTypedValue(state);<z>
;<z>
int hashCode() {<z>
().hashCode();<z>
Exception {<z>
.advised.isExposeProxy();<z>
();<z>
getTargetSource().isStatic();<z>
advised);<z>
;<z>
exposeProxy) {<z>
isStatic ?<z>
.getTarget()) :<z>
)));<z>
?<z>
).getTarget()) :<z>
.getTargetSource()));<z>
= (isStatic ?<z>
);<z>
new Callback[] {<z>
(),<z>
.advisedDispatcher,<z>
.advised),<z>
)<z>
] callbacks;<z>
{<z>
] methods = rootClass.getMethods();<z>
;<z>
.newHashMap(methods.length);<z>
{<z>
];<z>
, rootClass);<z>
= new FixedChainStaticTargetInterceptor(<z>
advised.getTargetClass());<z>
(method, x);<z>
mainCallbacks.length + fixedCallbacks.length];<z>
);<z>
, fixedCallbacks.length);<z>
length;<z>
mainCallbacks;<z>
callbacks;<z>
> getFiles(String name) {<z>
).get(name);<z>
multipartFiles != null) {<z>
return multipartFiles;<z>
return Collections.emptyList();<z>
name, Object value) {<z>
Assert.hasLength(name, "Name must not be empty");<z>
notNull(value, "Value must not be null");<z>
= new LinkedHashMap<>();<z>
attributes.put(name, value);<z>
;<z>
{<z>
);<z>
ObjectUtils.isEmpty(handlers)) {<z>
(Arrays.asList(handlers));<z>
return this;<z>
{<z>
)) {<z>
= false;<z>
handlers.values()) {<z>
) {<z>
stop();<z>
) {<z>
.exactMatches) {<z>
)) {<z>
;<z>
("/")) {<z>
;<z>
endsWithMatches) {<z>
.endsWith(pattern)) {<z>
return true;<z>
) {<z>
) {<z>
;<z>
;<z>
ArrayList<? extends ResourceResolver> resolvers) {<z>
null, null);<z>
);<z>
)) {<z>
;<z>
chain;<z>
BitsCronField zeroNanos() {<z>
if (zeroNanos == null) {<z>
field = new BitsCronField(Type.NANO);<z>
;<z>
= field;<z>
zeroNanos;<z>
private void skipCaptureRegex() {<z>
;<z>
.pos;<z>
int curlyBracketDepth = 0;<z>
false;<z>
pathPatternLength) {<z>
this.pos];<z>
ch == '\\' && !previousBackslash) {<z>
;<z>
true;<z>
'{' && !previousBackslash) {<z>
++;<z>
) {<z>
0) {<z>
pos) {<z>
throw new PatternParseException(regexStart, this.pathPatternData,<z>
);<z>
;<z>
!previousBackslash) {<z>
.pos, this.pathPatternData,<z>
MISSING_CLOSE_CAPTURE);<z>
.pos++;<z>
= false;<z>
pos - 1, this.pathPatternData,<z>
;<z>
{<z>
);<z>
= htmlEscape(content);<z>
javaScriptEscape(content) : content);<z>
content);<z>
IOException ex) {<z>
;<z>
);<z>
) {<z>
;<z>
{<z>
("Detected " + this.multipartResolver);<z>
.isDebugEnabled()) {<z>
());<z>
ex) {<z>
= null;<z>
{<z>
;<z>
{<z>
headers;<z>
instanceof HttpResource) {<z>
original).getResponseHeaders();<z>
();<z>
this.coding);<z>
, HttpHeaders.ACCEPT_ENCODING);<z>
return headers;<z>
static void clear() {<z>
synchronizations.remove();<z>
;<z>
();<z>
remove();<z>
();<z>
void setParentThemeSource(@Nullable ThemeSource parent) {<z>
;<z>
) {<z>
.themeCache.values()) {<z>
theme);<z>
, WebSocketHandler handler) {<z>
>();<z>
WebSocketClientSockJsSession(request, handler, future);<z>
(session);<z>
.addTimeoutTask(session.getTimeoutTask());<z>
);<z>
request.getHandshakeHeaders());<z>
) {<z>
"Starting WebSocket session on " + url);<z>
, headers, url).addCallback(<z>
WebSocketSession>() {<z>
Nullable WebSocketSession webSocketSession) {<z>
onFailure(Throwable ex) {<z>
(ex);<z>
);<z>
return future;<z>
throws PersistenceException {<z>
this.persistenceUnitManager;<z>
{<z>
internalPersistenceUnitManager.afterPropertiesSet();<z>
this.internalPersistenceUnitManager;<z>
this.persistenceUnitInfo = determinePersistenceUnitInfo(managerToUse);<z>
;<z>
instanceof SmartPersistenceUnitInfo) {<z>
);<z>
(rootPackage != null) {<z>
setPersistenceProviderPackageName(rootPackage);<z>
afterPropertiesSet();<z>
(String uri) {<z>
0) == '/' ? 1 : 0);<z>
'.');<z>
;<z>
;<z>
elementType, @Nullable String propertyPath) {<z>
) {<z>
)) {<z>
entry.getKey(), propertyPath) &&<z>
null) {<z>
return true;<z>
.customEditors.containsKey(elementType));<z>
{<z>
nestedMethodParameter;<z>
(nestedParam != null && typeIndex == null) {<z>
return nestedParam;<z>
nestingLevel + 1, typeIndex);<z>
null) {<z>
.nestedMethodParameter = nestedParam;<z>
return nestedParam;<z>
void flush() {<z>
isSynchronizationActive()) {<z>
TransactionSynchronizationUtils.triggerFlush();<z>
{<z>
);<z>
);<z>
executeInsertInternal(values);<z>
toString() {<z>
;<z>
);<z>
beanDefinitionNames));<z>
append("]; ");<z>
);<z>
null) {<z>
;<z>
));<z>
.toString();<z>
ClassFilter cf1, MethodMatcher mm2, ClassFilter cf2) {<z>
mm2);<z>
this.cf1 = cf1;<z>
.cf2 = cf2;<z>
) {<z>
getBytes(getCharset());<z>
bytes);<z>
));<z>
resource, Resource location) throws IOException {<z>
) {<z>
;<z>
Resource[] allowedLocations = getAllowedLocations();<z>
(allowedLocations != null) {<z>
Resource current : allowedLocations) {<z>
(resource, current)) {<z>
;<z>
return false;<z>
T> targetClass) {<z>
destination);<z>
if (message != null) {<z>
message, targetClass);<z>
return null;<z>
public AutowiredAnnotationBeanPostProcessor() {<z>
autowiredAnnotationTypes.add(Autowired.class);<z>
;<z>
<? extends Annotation>)<z>
)));<z>
logger.trace("'jakarta.inject.Inject' annotation found and supported for autowiring");<z>
catch (ClassNotFoundException ex) {<z>
((Class<? extends Annotation>)<z>
);<z>
"'javax.inject.Inject' annotation found and supported for autowiring");<z>
catch (ClassNotFoundException ex) {<z>
AsyncSupportConfigurer registerDeferredResultInterceptors(<z>
{<z>
(interceptors));<z>
;<z>
parameterName, CallParameterMetaData meta) {<z>
(meta.getTypeName())) {<z>
));<z>
;<z>
Object returnValue, MethodParameter returnType,<z>
ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {<z>
;<z>
) {<z>
());<z>
, returnType, mavContainer, webRequest);<z>
int hashCode() {<z>
super.hashCode();<z>
);<z>
;<z>
;<z>
{<z>
null) {<z>
(this.chronology);<z>
if (this.timeZone != null) {<z>
;<z>
.getLocaleContext();<z>
) {<z>
TimeZoneAwareLocaleContext) localeContext).getTimeZone();<z>
!= null) {<z>
timeZone.toZoneId());<z>
formatter;<z>
T createDefensiveInputFactory(Supplier<T> instanceSupplier) {<z>
.get();<z>
setProperty(XMLInputFactory.SUPPORT_DTD, false);<z>
XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);<z>
(NO_OP_XML_RESOLVER);<z>
;<z>
parseInternal(Element element, ParserContext parserContext) {<z>
(AnnotationMBeanExporter.class);<z>
builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
(element));<z>
(DEFAULT_DOMAIN_ATTRIBUTE);<z>
(defaultDomain)) {<z>
, defaultDomain);<z>
);<z>
.hasText(serverBeanName)) {<z>
;<z>
.getAttribute(REGISTRATION_ATTRIBUTE);<z>
RegistrationPolicy.FAIL_ON_EXISTING;<z>
) {<z>
RegistrationPolicy.IGNORE_EXISTING;<z>
REGISTRATION_REPLACE_EXISTING.equals(registration)) {<z>
.REPLACE_EXISTING;<z>
builder.addPropertyValue("registrationPolicy", registrationPolicy);<z>
getBeanDefinition();<z>
(BeanDefinitionRegistry registry) {<z>
= new ArrayList<>();<z>
= registry.getBeanDefinitionNames();<z>
: candidateNames) {<z>
);<z>
) != null) {<z>
isDebugEnabled()) {<z>
beanDef);<z>
checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {<z>
;<z>
isEmpty()) {<z>
bd2) -> {<z>
getBeanDefinition());<z>
getOrder(bd2.getBeanDefinition());<z>
Integer.compare(i1, i2);<z>
;<z>
= null;<z>
{<z>
sbr = (SingletonBeanRegistry) registry;<z>
if (!this.localBeanNameGeneratorSet) {<z>
BeanNameGenerator) sbr.getSingleton(<z>
.CONFIGURATION_BEAN_NAME_GENERATOR);<z>
!= null) {<z>
componentScanBeanNameGenerator = generator;<z>
generator;<z>
this.environment == null) {<z>
environment = new StandardEnvironment();<z>
ConfigurationClassParser(<z>
metadataReaderFactory, this.problemReporter, this.environment,<z>
, this.componentScanBeanNameGenerator, registry);<z>
>(configCandidates);<z>
(configCandidates.size());<z>
"spring.context.config-classes.parse");<z>
.parse(candidates);<z>
.validate();<z>
.getConfigurationClasses());<z>
alreadyParsed);<z>
.reader == null) {<z>
reader = new ConfigurationClassBeanDefinitionReader(<z>
sourceExtractor, this.resourceLoader, this.environment,<z>
importBeanNameGenerator, parser.getImportRegistry());<z>
loadBeanDefinitions(configClasses);<z>
configClasses);<z>
.end();<z>
);<z>
) > candidateNames.length) {<z>
);<z>
;<z>
new HashSet<>();<z>
for (ConfigurationClass configurationClass : alreadyParsed) {<z>
getMetadata().getClassName());<z>
(String candidateName : newCandidateNames) {<z>
.contains(candidateName)) {<z>
);<z>
bd, this.metadataReaderFactory) &&<z>
getBeanClassName())) {<z>
candidateName));<z>
= newCandidateNames;<z>
));<z>
.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {<z>
;<z>
this.metadataReaderFactory instanceof CachingMetadataReaderFactory cachingMetadataReaderFactory) {<z>
cachingMetadataReaderFactory.clearCache();<z>
(ResolvableType bodyType,<z>
mediaType) {<z>
()<z>
.stream())<z>
Collectors.toList());<z>
bodyType);<z>
applyPropertyValue(<z>
property, String value) {<z>
BeanDefinition bd = factory.getBeanDefinition(beanName);<z>
= bd;<z>
!= null) {<z>
= bd;<z>
);<z>
property, value);<z>
pv.setOptional(this.ignoreInvalidKeys);<z>
;<z>
public String prettyPrint() {<z>
));<z>
;<z>
keepTaskList) {<z>
append("No task info kept");<z>
sb.append("---------------------------------------------\n");<z>
);<z>
.append("---------------------------------------------\n");<z>
;<z>
.setMinimumIntegerDigits(9);<z>
;<z>
getPercentInstance();<z>
3);<z>
);<z>
task : getTaskInfo()) {<z>
append(" ");<z>
);<z>
).append('\n');<z>
;<z>
<String> getAllowedOriginPatterns() {<z>
) {<z>
return null;<z>
)<z>
map(OriginPattern::getDeclaredPattern)<z>
;<z>
, List<Annotation> annotations) {<z>
this.aggregateIndex = aggregateIndex;<z>
= source;<z>
annotations = annotations;<z>
new AnnotationTypeMappings[annotations.size()];<z>
annotations.size(); i++) {<z>
i).annotationType());<z>
clearSingletonCache() {<z>
.singletonObjects) {<z>
this.singletonObjects.clear();<z>
.singletonFactories.clear();<z>
.earlySingletonObjects.clear();<z>
();<z>
this.singletonsCurrentlyInDestruction = false;<z>
{<z>
();<z>
XMLStreamException ex) {<z>
(ex.getMessage());<z>
ctor, String attributeName, MethodParameter parameter,<z>
) throws Exception {<z>
== 0) {<z>
;<z>
paramNames = BeanUtils.getParameterNames(ctor);<z>
;<z>
];<z>
null, attributeName);<z>
();<z>
= binder.getFieldMarkerPrefix();<z>
false;<z>
);<z>
< paramNames.length; i++) {<z>
i];<z>
> paramType = paramTypes[i];<z>
);<z>
) == 1) {<z>
= Array.get(value, 0);<z>
{<z>
!= null) {<z>
paramName);<z>
if (value == null) {<z>
null) {<z>
= binder.getEmptyValue(paramType);<z>
paramType, webRequest);<z>
new FieldAwareConstructorParameter(ctor, i, paramName);<z>
== null && methodParam.isOptional()) {<z>
);<z>
methodParam);<z>
{<z>
;<z>
args[i] = null;<z>
(paramName);<z>
.recordFieldValue(paramName, paramType, value);<z>
.getBindingResult());<z>
bindingFailure = true;<z>
bindingFailure) {<z>
binder.getBindingResult();<z>
++) {<z>
i];<z>
paramName)) {<z>
Object value = args[i];<z>
paramTypes[i], value);<z>
value);<z>
)) {<z>
;<z>
BindException(result) {<z>
getTarget() {<z>
return target;<z>
catch (BeanInstantiationException ex) {<z>
BindException(result);<z>
(ctor, args);<z>
) {<z>
get(RSOCKET_REQUESTER_HEADER);<z>
"Missing '" + RSOCKET_REQUESTER_HEADER + "'");<z>
class, headerValue, "Expected header value of type RSocketRequester");<z>
) headerValue;<z>
.getParameterType();<z>
RSocketRequester.class.equals(type)) {<z>
(requester);<z>
) {<z>
(requester.rsocket());<z>
new IllegalArgumentException("Unexpected parameter type: " + parameter));<z>
) throws MessagingException {<z>
"Attachment filename must not be null");<z>
Assert.notNull(dataSource, "DataSource must not be null");<z>
new MimeBodyPart();<z>
(Part.ATTACHMENT);<z>
mimeBodyPart.setFileName(isEncodeFilenames() ?<z>
attachmentFilename) : attachmentFilename);<z>
(dataSource));<z>
mimeBodyPart);<z>
UnsupportedEncodingException ex) {<z>
, ex);<z>
static ApplicationEvents getRequiredApplicationEvents() {<z>
= applicationEvents.get();<z>
!= null, "Failed to retrieve ApplicationEvents for the current thread. " +<z>
;<z>
events;<z>
WebApplicationContext createWebApplicationContext(ServletContext sc) {<z>
;<z>
(contextClass)) {<z>
) +<z>
+ "]");<z>
contextClass);<z>
> set) {<z>
(isEmpty(set)) {<z>
null;<z>
instanceof SortedSet) {<z>
;<z>
= set.iterator();<z>
= null;<z>
)) {<z>
next();<z>
return last;<z>
setBeanName(String name) {<z>
;<z>
(this.servletName == null) {<z>
.servletName = name;<z>
public static Session doGetTransactionalSession(<z>
ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection)<z>
JMSException {<z>
);<z>
.notNull(resourceFactory, "ResourceFactory must not be null");<z>
resourceHolder =<z>
(connectionFactory);<z>
(resourceHolder != null) {<z>
resourceFactory.getSession(resourceHolder);<z>
null) {<z>
) {<z>
con = resourceFactory.getConnection(resourceHolder);<z>
) {<z>
();<z>
return session;<z>
.isFrozen()) {<z>
;<z>
isSynchronizationActive()) {<z>
null;<z>
;<z>
== null) {<z>
;<z>
resourceFactory.getConnection(resourceHolderToUse);<z>
null;<z>
isExistingCon = (con != null);<z>
!isExistingCon) {<z>
resourceFactory.createConnection();<z>
;<z>
createSession(con);<z>
session, con);<z>
if (startConnection) {<z>
con.start();<z>
{<z>
!= null) {<z>
();<z>
{<z>
!= null) {<z>
;<z>
ex2) {<z>
throw ex;<z>
if (resourceHolderToUse != resourceHolder) {<z>
.registerSynchronization(<z>
(resourceHolderToUse, connectionFactory,<z>
);<z>
;<z>
resourceHolderToUse);<z>
;<z>
{<z>
(this.lifecycleMonitor) {<z>
;<z>
);<z>
annotation) {<z>
())) {<z>
valueMethod, annotation);<z>
return super.findRepeatedAnnotations(annotation);<z>
CachedMessageProducer(MessageProducer target) throws JMSException {<z>
;<z>
target.getDeliveryMode();<z>
= target.getPriority();<z>
);<z>
boolean equals(@Nullable Object other) {<z>
other) {<z>
true;<z>
)) {<z>
false;<z>
type.equals(otherMessage.type) &&<z>
otherMessage.payload));<z>
throws DataAccessException {<z>
?>>) session -> {<z>
;<z>
prepareQuery(queryObject);<z>
values != null) {<z>
i < values.length; i++) {<z>
(i, values[i]);<z>
.list();<z>
}));<z>
<String, Object> hints) {<z>
+ "Read " +<z>
() ?<z>
traceOn) :<z>
.keySet() + " (content masked)"));<z>
Builder clear() {<z>
();<z>
"";<z>
~0x00000001);<z>
(blahBuilder_ == null) {<z>
springframework.protobuf.SecondMsg.getDefaultInstance();<z>
{<z>
clear();<z>
;<z>
this;<z>
{<z>
= getCookie(name).isSecure();<z>
) -> {<z>
= getMessage(name) + " secure";<z>
, expected, isSecure);<z>
;<z>
responseSpec;<z>
{<z>
builder = new StringBuilder();<z>
hasNext();) {<z>
MimeType mimeType = iterator.next();<z>
.appendTo(builder);<z>
.hasNext()) {<z>
append(", ");<z>
;<z>
) {<z>
super(message, cause);<z>
.expressionString = null;<z>
.position = 0;<z>
boolean relative(int rows) throws InvalidResultSetAccessException {<z>
resultSet.relative(rows);<z>
catch (SQLException se) {<z>
InvalidResultSetAccessException(se);<z>
@Nullable String name) {<z>
.uriVariables.containsKey(name)) {<z>
new IllegalArgumentException("Map has no value for '" + name + "'");<z>
return this.uriVariables.get(name);<z>
{<z>
) == null) {<z>
(new LazyCacheResolver());<z>
getExceptionCacheResolver();<z>
) {<z>
= messageType;<z>
= destination;<z>
subscriptionId = subscriptionId;<z>
;<z>
simpValidator() {<z>
Validator validator = getValidator();<z>
validator == null) {<z>
containsBean(MVC_VALIDATOR_NAME)) {<z>
MVC_VALIDATOR_NAME, Validator.class);<z>
().getClassLoader())) {<z>
<?> clazz;<z>
;<z>
.getClassLoader());<z>
{<z>
"Could not find default validator class", ex);<z>
Validator) BeanUtils.instantiateClass(clazz);<z>
() {<z>
) {<z>
return false;<z>
@Nullable Object target, Errors errors) {<z>
return validator;<z>
getLengthFor(Resource resource) {<z>
long contentLength = resource.contentLength();<z>
.isTrue(contentLength > 0, "Resource content length should be > 0");<z>
;<z>
) {<z>
throw new IllegalArgumentException("Failed to obtain Resource content length", ex);<z>
<ServerResponse, R> function) {<z>
= this.futureResponse.getNow(null);<z>
) {<z>
;<z>
"Future ServerResponse has not yet completed");<z>
)<z>
, InvocationTargetException, InstantiationException {<z>
kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor);<z>
null) {<z>
.newInstance(args);<z>
)) {<z>
setAccessible(kotlinConstructor, true);<z>
KParameter> parameters = kotlinConstructor.getParameters();<z>
newHashMap(parameters.size());<z>
),<z>
"Number of provided arguments should be less of equals than number of constructor parameters");<z>
) {<z>
&& args[i] == null)) {<z>
]);<z>
;<z>
protected Attribute read(<z>
ClassReader classReader,<z>
offset,<z>
final int length,<z>
,<z>
codeAttributeOffset,<z>
] labels) {<z>
type);<z>
= new byte[length];<z>
;<z>
return attribute;<z>
) throws JMSException {<z>
sharedConnectionEnabled()) {<z>
;<z>
synchronized (this.lifecycleMonitor) {<z>
true;<z>
lifecycleMonitor.notifyAll();<z>
();<z>
sharedConnectionEnabled()) {<z>
();<z>
public boolean equals(final Object object) {<z>
) {<z>
true;<z>
object instanceof Handle)) {<z>
false;<z>
object;<z>
tag == handle.tag<z>
== handle.isInterface<z>
owner)<z>
(handle.name)<z>
;<z>
boolean indicatesDisconnectedClient(Throwable ex) {<z>
getMostSpecificCause(ex).getMessage();<z>
;<z>
ex.getClass().getSimpleName();<z>
contains(className));<z>
invokeAwareInterfaces(Object bean) {<z>
{<z>
;<z>
(bean instanceof EmbeddedValueResolverAware) {<z>
setEmbeddedValueResolver(this.embeddedValueResolver);<z>
if (bean instanceof ResourceLoaderAware) {<z>
applicationContext);<z>
if (bean instanceof ApplicationEventPublisherAware) {<z>
(this.applicationContext);<z>
instanceof MessageSourceAware) {<z>
).setMessageSource(this.applicationContext);<z>
(bean instanceof ApplicationStartupAware) {<z>
());<z>
instanceof ApplicationContextAware) {<z>
.applicationContext);<z>
(HttpServletRequest request) {<z>
return new TimeZoneAwareLocaleContext() {<z>
getLocale() {<z>
getDefaultLocale();<z>
TimeZone getTimeZone() {<z>
();<z>
] args) {<z>
getDeclaringClass();<z>
= targetBean.getClass();<z>
(!methodDeclaringClass.isAssignableFrom(targetBeanClass)) {<z>
"The mapped handler method class '" + methodDeclaringClass.getName() +<z>
) + "'. If the endpoint requires proxying " +<z>
IllegalStateException(formatInvokeError(text, args));<z>
(Runnable task) {<z>
ExecutorService executor = getThreadPoolExecutor();<z>
);<z>
;<z>
return future;<z>
ex) {<z>
task, ex);<z>
<MediaType> getMediaTypesFor(ResolvableType elementType) {<z>
new ArrayList<>();<z>
()) {<z>
(elementType, null)) {<z>
converter.getWritableMediaTypes(elementType));<z>
return writableMediaTypes;<z>
readOnly)<z>
, SQLException {<z>
EclipseLinkConnectionHandle(entityManager);<z>
ReactiveTypeDescriptor descriptor,<z>
, Publisher<?>> toPublisherFunction,<z>
) {<z>
, fromPublisherFunction);<z>
) {<z>
);<z>
(ex);<z>
>(Mono.error(ex));<z>
public int hashCode() {<z>
? 64 : 0)<z>
descriptor.hashCode();<z>
Method destroyMethod) {<z>
getParameterCount();<z>
] args = new Object[paramCount];<z>
{<z>
0] = Boolean.TRUE;<z>
if (logger.isTraceEnabled()) {<z>
this.destroyMethodName +<z>
.beanName + "'");<z>
ReflectionUtils.makeAccessible(destroyMethod);<z>
);<z>
{<z>
msg = "Custom destroy method '" + this.destroyMethodName + "' on bean with name '" +<z>
.beanName + "' threw an exception";<z>
)) {<z>
;<z>
());<z>
{<z>
+ this.destroyMethodName +<z>
;<z>
) throws ServletRequestBindingException {<z>
()) {<z>
new ServletRequestBindingException(<z>
"'",<z>
));<z>
Message<?> message,<z>
Nullable Object conversionHint) {<z>
getMimeType(message.getHeaders());<z>
final Object payload = message.getPayload();<z>
null) {<z>
PROTOBUF;<z>
);<z>
charset == null) {<z>
= DEFAULT_CHARSET;<z>
builder = getMessageBuilder(targetClass);<z>
) {<z>
.extensionRegistry);<z>
null) {<z>
);<z>
(IOException ex) {<z>
getMessage(), ex);<z>
return builder.build();<z>
access, final String version) {<z>
ASM6) {<z>
);<z>
) {<z>
;<z>
return null;<z>
{<z>
genericParameterType;<z>
paramType == null) {<z>
.parameterIndex < 0) {<z>
);<z>
null ?<z>
KotlinDetector.isKotlinType(getContainingClass()) ?<z>
getGenericReturnType()) : void.class);<z>
();<z>
parameterIndex;<z>
this.executable instanceof Constructor &&<z>
.executable.getDeclaringClass()) &&<z>
.getParameterCount() - 1) {<z>
index = this.parameterIndex - 1;<z>
>= 0 && index < genericParameterTypes.length ?<z>
());<z>
.genericParameterType = paramType;<z>
;<z>
attributeValue) {<z>
.notNull(attributeName, "Model attribute name must not be null");<z>
put(attributeName, attributeValue);<z>
return this;<z>
int abstractType) {<z>
initializations == null) {<z>
= new int[2];<z>
;<z>
{<z>
[] newInitializations =<z>
)];<z>
0, newInitializations, 0, initializationsLength);<z>
;<z>
[initializationCount++] = abstractType;<z>
{<z>
parameter);<z>
if (result == null) {<z>
: this.argumentResolvers) {<z>
(methodArgumentResolver.supportsParameter(parameter)) {<z>
result = methodArgumentResolver;<z>
;<z>
;<z>
) {<z>
getAttributeIndex(attributeName, true);<z>
, true, false);<z>
.valueExtractor));<z>
String headerName, String... headerValues) {<z>
: headerValues) {<z>
.add(headerName, headerValue);<z>
return this;<z>
> get(Object key) {<z>
name = (String) key;<z>
);<z>
.isEmpty(parameterValues)) {<z>
return Arrays.asList(parameterValues);<z>
);<z>
public final void setBeanFactory(BeanFactory beanFactory) {<z>
ConfigurableBeanFactory)) {<z>
+<z>
));<z>
.beanFactory = (ConfigurableBeanFactory) beanFactory;<z>
>> route(ServerRequest serverRequest) {<z>
.predicate.nest(serverRequest)<z>
map(nestedRequest -> {<z>
)) {<z>
trace(<z>
String.format(<z>
));<z>
result =<z>
route(nestedRequest);<z>
nestedRequest != serverRequest) {<z>
().clear();<z>
attributes());<z>
;<z>
orElseGet(Optional::empty);<z>
, List<MethodResolver> resolvers,<z>
{<z>
.propertyAccessors = accessors;<z>
.methodResolvers = resolvers;<z>
converter : new StandardTypeConverter());<z>
: TypedValue.NULL);<z>
( HttpServletRequest request, @Nullable HttpServletResponse response,<z>
) {<z>
UnsupportedOperationException("Cannot change fixed locale - use a different locale resolution strategy");<z>
String, Object> arguments) {<z>
null) {<z>
;<z>
, String expression) {<z>
.equals(expression)) {<z>
new CronTask(task, expression));<z>
(<z>
MethodParameter param, BindingContext bindingContext, ServerWebExchange exchange) {<z>
);<z>
null, "No RequestBody annotation");<z>
exchange);<z>
(ApplicationEvent event) {<z>
) event;<z>
> message = subProtocolEvent.getMessage();<z>
= message.getHeaders();<z>
= SimpMessageHeaderAccessor.getSessionId(headers);<z>
(sessionId != null, "No session id");<z>
if (event instanceof SessionSubscribeEvent) {<z>
.get(sessionId);<z>
null) {<z>
getSubscriptionId(headers);<z>
getDestination(headers);<z>
&& destination != null) {<z>
id, destination);<z>
(event instanceof SessionConnectedEvent) {<z>
getUser();<z>
if (user == null) {<z>
.getName();<z>
{<z>
= destinationUserNameProvider.getDestinationUserName();<z>
sessionLock) {<z>
name);<z>
(simpUser == null) {<z>
, user);<z>
.put(name, simpUser);<z>
sessionId, simpUser);<z>
simpUser.addSession(session);<z>
.sessions.put(sessionId, session);<z>
{<z>
.sessionLock) {<z>
(sessionId);<z>
!= null) {<z>
getUser();<z>
user.removeSession(sessionId);<z>
user.hasSessions()) {<z>
remove(user.getName());<z>
SessionUnsubscribeEvent) {<z>
sessionId);<z>
(session != null) {<z>
getSubscriptionId(headers);<z>
!= null) {<z>
subscriptionId);<z>
{<z>
method = methodCache.get(clazz);<z>
== null) {<z>
clazz.getMethod("newBuilder");<z>
put(clazz, method);<z>
(clazz);<z>
ex) {<z>
throw new MessageConversionException(<z>
);<z>
public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {<z>
0].getValueInternal(state);<z>
) {<z>
return value;<z>
.getValueInternal(state);<z>
computeExitTypeDescriptor();<z>
;<z>
<String> asyncFoo(int id) {<z>
).getName());<z>
() != null, "Thread-local counter not exposed");<z>
().findFoo(id));<z>
public BeanDefinitionValueResolver(AbstractAutowireCapableBeanFactory beanFactory, String beanName,<z>
, TypeConverter typeConverter) {<z>
this.beanFactory = beanFactory;<z>
= beanName;<z>
beanDefinition;<z>
this.typeConverter = typeConverter;<z>
{<z>
(text)) {<z>
);<z>
(null);<z>
last() throws InvalidResultSetAccessException {<z>
);<z>
(SQLException se) {<z>
);<z>
) {<z>
;<z>
classFilter;<z>
.methodMatcher = MethodMatcher.TRUE;<z>
) {<z>
isMutable(), "Already immutable");<z>
();<z>
values == null) {<z>
{<z>
true);<z>
map.remove(name);<z>
null) {<z>
map = new LinkedMultiValueMap<>(3);<z>
(NATIVE_HEADERS, map);<z>
)) {<z>
setModified(true);<z>
;<z>
ResolvableType type, @Nullable MediaType mediaType,<z>
String, Object> hints) {<z>
message.getHeaders();<z>
;<z>
headers.setContentType(resourceMediaType);<z>
< 0) {<z>
= lengthOf(resource);<z>
!= -1) {<z>
.setContentLength(length);<z>
, hints)<z>
) -> {<z>
;<z>
;<z>
hints);<z>
logger.isDebugEnabled()) {<z>
touchDataBuffer(buffer, hints, logger));<z>
message.writeWith(body);<z>
);<z>
Nullable Object requiredType) {<z>
{<z>
return true;<z>
> actualType = mapping.getAnnotationType();<z>
);<z>
) {<z>
new StringBuilder();<z>
SimpMessageType messageType = getMessageType();<z>
);<z>
String destination = getDestination();<z>
!= null) {<z>
(destination);<z>
);<z>
(subscriptionId != null) {<z>
.append(subscriptionId);<z>
);<z>
;<z>
if (user != null) {<z>
));<z>
;<z>
void destroy() throws Exception {<z>
) {<z>
("Closing Commons ObjectPool");<z>
.close();<z>
ModelAndView writeToInternal(HttpServletRequest request, HttpServletResponse response,<z>
context) throws ServletException, IOException {<z>
result;<z>
null) {<z>
.toMillis());<z>
();<z>
.writeAsync(request, response, result);<z>
, result));<z>
return null;<z>
static TransactionStatus currentTransactionStatus() throws NoTransactionException {<z>
;<z>
null) {<z>
);<z>
transactionStatus;<z>
void clearCache() {<z>
instanceof LocalResourceCache) {<z>
) {<z>
metadataReaderCache.clear();<z>
null) {<z>
DEFAULT_CACHE_LIMIT);<z>
{<z>
= 0;<z>
this.scheduledInvokers) {<z>
)) {<z>
++;<z>
;<z>
marshaller)<z>
IOException, XmlMappingException {<z>
writer = new StringWriter(1024);<z>
result = new StreamResult(writer);<z>
marshaller.marshal(object, result);<z>
;<z>
boolean equals(@Nullable Object other) {<z>
other) {<z>
true;<z>
(other instanceof PropertyValue otherPv)) {<z>
false;<z>
(otherPv.name) &&<z>
) &&<z>
getSource()));<z>
sessionId, SockJsServiceConfig config,<z>
) {<z>
(sessionId, config, wsHandler, attributes);<z>
servletConfig,<z>
Nullable RequestBuilder defaultRequestBuilder,<z>
globalResultHandlers,<z>
Nullable List<DispatcherServletCustomizer> dispatcherServletCustomizers) {<z>
);<z>
if (dispatcherServletCustomizers != null) {<z>
for (DispatcherServletCustomizer customizers : dispatcherServletCustomizers) {<z>
);<z>
(servletConfig);<z>
{<z>
("Failed to initialize TestDispatcherServlet", ex);<z>
(dispatcherServlet, filters);<z>
.setDefaultRequest(defaultRequestBuilder);<z>
globalResultMatchers);<z>
.setGlobalResultHandlers(globalResultHandlers);<z>
;<z>
DataBufferFactory bufferFactory) {<z>
httpMethod, "HttpMethod is required");<z>
(uri, "URI is required");<z>
);<z>
;<z>
uri;<z>
bufferFactory = bufferFactory;<z>
uri);<z>
) {<z>
changeState(this, COMPLETED)) {<z>
();<z>
get().onComplete(processor);<z>
@Nullable Object other) {<z>
other) {<z>
return true;<z>
))) {<z>
return false;<z>
WebSocketExtension otherExt = (WebSocketExtension) other;<z>
otherExt.parameters));<z>
DisposableBean bean) {<z>
(this.disposableBeans) {<z>
, bean);<z>
) {<z>
.registration = new SockJsServiceRegistration();<z>
registration.setTaskScheduler(this.sockJsTaskScheduler);<z>
();<z>
interceptors.length > 0) {<z>
.registration.setInterceptors(interceptors);<z>
this.handshakeHandler != null) {<z>
;<z>
);<z>
)) {<z>
.toStringArray(this.allowedOrigins));<z>
this.allowedOriginPatterns.isEmpty()) {<z>
toStringArray(this.allowedOriginPatterns));<z>
;<z>
replaceUriTemplateVariables(<z>
<String, String> currentUriVariables, String encodingScheme)<z>
throws UnsupportedEncodingException {<z>
);<z>
matcher(targetUrl);<z>
;<z>
find()) {<z>
group(1);<z>
currentUriVariables.get(name));<z>
{<z>
+ "'");<z>
endLastMatch, matcher.start());<z>
encodingScheme));<z>
end();<z>
);<z>
return result;<z>
targetType) {<z>
targetType.getObjectType()) {<z>
;<z>
);<z>
.isAssignableFrom(this.targetType) &&<z>
{<z>
false;<z>
ConditionalConverter) ||<z>
);<z>
static org.springframework.protobuf.Msg parseFrom(<z>
byte[] data,<z>
)<z>
InvalidProtocolBufferException {<z>
extensionRegistry);<z>
status) throws IOException {<z>
)) {<z>
(this.disconnectLock) {<z>
{<z>
.disconnected = true;<z>
null) {<z>
);<z>
() {<z>
forEach((beanName, bd) -> {<z>
(!isBeanEligibleForMetadataCaching(beanName)) {<z>
true;<z>
});<z>
String nestHost) {<z>
api < Opcodes.ASM7) {<z>
);<z>
null) {<z>
;<z>
> source, WritableByteChannel channel) {<z>
source, "'source' must not be null");<z>
;<z>
> flux = Flux.from(source);<z>
return Flux.create(sink -> {<z>
;<z>
;<z>
;<z>
;<z>
{<z>
()) {<z>
;<z>
.transports) {<z>
&& lifecycle.isRunning()) {<z>
lifecycle.stop();<z>
apply(Project project) {<z>
)) {<z>
().apply(JapicmpPlugin.class);<z>
getPlugins().withType(JapicmpPlugin.class,<z>
project));<z>
() {<z>
> 1) {<z>
= getGenericParameterType();<z>
i <= this.nestingLevel; i++) {<z>
instanceof ParameterizedType) {<z>
;<z>
Integer index = getTypeIndexForLevel(i);<z>
? index : args.length - 1];<z>
type;<z>
return getGenericParameterType();<z>
TypeDescriptor getTypeDescriptor() {<z>
null && this.value != null) {<z>
forObject(this.value);<z>
this.typeDescriptor;<z>
(WebSocketMessage<?> message) throws IOException {<z>
;<z>
()) {<z>
this);<z>
) {<z>
((TextMessage) message);<z>
BinaryMessage) {<z>
sendBinaryMessage((BinaryMessage) message);<z>
else if (message instanceof PingMessage) {<z>
PingMessage) message);<z>
PongMessage) {<z>
);<z>
);<z>
maxParts, int maxInMemorySize, long maxDiskUsagePerPart,<z>
<Path> fileStorageDirectory, Scheduler blockingOperationScheduler) {<z>
;<z>
this.maxParts = maxParts;<z>
maxInMemorySize;<z>
= maxDiskUsagePerPart;<z>
;<z>
.fileStorageDirectory = fileStorageDirectory;<z>
= blockingOperationScheduler;<z>
ConfigurableEnvironment environment) {<z>
setEnvironment(environment);<z>
reader.setEnvironment(environment);<z>
.scanner.setEnvironment(environment);<z>
out) throws IOException {<z>
);<z>
"No Writer specified");<z>
charCount = 0;<z>
[BUFFER_SIZE];<z>
;<z>
) != -1) {<z>
(buffer, 0, charsRead);<z>
+= charsRead;<z>
;<z>
charCount;<z>
(in);<z>
out);<z>
handlerMethod, Object handler) {<z>
;<z>
handler, "Handler object is required");<z>
;<z>
beanFactory;<z>
messageSource = handlerMethod.messageSource;<z>
.beanType = handlerMethod.beanType;<z>
handlerMethod.method;<z>
handlerMethod.bridgedMethod;<z>
.parameters = handlerMethod.parameters;<z>
;<z>
responseStatusReason = handlerMethod.responseStatusReason;<z>
= handlerMethod;<z>
this.description = handlerMethod.description;<z>
attributeName, String defaultValue) {<z>
= element.getAttribute(attributeName);<z>
) {<z>
attribute.trim();<z>
return defaultValue;<z>
,<z>
useDefaultResolution) {<z>
super(beanFactory);<z>
;<z>
Object object, Supplier<String> messageSupplier) {<z>
) {<z>
);<z>
(HttpServletRequest request, int contentCacheLimit) {<z>
request);<z>
new ByteArrayOutputStream(contentCacheLimit);<z>
this.contentCacheLimit = contentCacheLimit;<z>
adapt(ServerSentEvent<?> sse) {<z>
.event();<z>
;<z>
);<z>
= sse.retry();<z>
sse.comment();<z>
sse.data();<z>
null) {<z>
.id(id);<z>
if (event != null) {<z>
event);<z>
!= null) {<z>
data(data);<z>
(retry != null) {<z>
));<z>
null) {<z>
(comment);<z>
;<z>
@Nullable Object rootObject) {<z>
);<z>
, "Target object must not be null");<z>
: "");<z>
.wrappedObject);<z>
= null;<z>
);<z>
public void afterSingletonsInstantiated() {<z>
getDefaultCacheResolver(), "Cache resolver should have been initialized");<z>
Nullable Object value) {<z>
{<z>
= BindingResult.MODEL_KEY_PREFIX + key;<z>
(BindingResult) get(resultKey);<z>
&& result.getTarget() != value) {<z>
(resultKey);<z>
public String toStringAST() {<z>
);<z>
startsWith(FACTORY_BEAN_PREFIX)) {<z>
;<z>
)) {<z>
;<z>
.append('\'');<z>
);<z>
Map<String, CorsConfiguration> getCorsConfigurations() {<z>
));<z>
), config));<z>
);<z>
<?> getReturnType(Method method) {<z>
function = ReflectJvmMapping.getKotlinFunction(method);<z>
null && function.isSuspend()) {<z>
getJavaType(function.getReturnType());<z>
) {<z>
void.class;<z>
.resolve(method.getReturnType());<z>
catch (UnsupportedOperationException ex) {<z>
.getReturnType();<z>
(Workbook workbook, HttpServletResponse response) throws IOException {<z>
= response.getOutputStream();<z>
.write(out);<z>
.close();<z>
Feed feed,<z>
HttpServletResponse response) throws Exception {<z>
model, request, response);<z>
);<z>
) {<z>
currentLength = length;<z>
> data.length) {<z>
;<z>
;<z>
(longValue >>> 32);<z>
) (intValue >>> 24);<z>
);<z>
> 8);<z>
= (byte) intValue;<z>
= (int) longValue;<z>
;<z>
>>> 16);<z>
>>> 8);<z>
currentLength++] = (byte) intValue;<z>
length = currentLength;<z>
this;<z>
{<z>
: annotatedPackages) {<z>
annotatedPackage);<z>
this;<z>
public void addAllowedOriginPattern(@Nullable String originPattern) {<z>
(originPattern == null) {<z>
(this.allowedOriginPatterns == null) {<z>
);<z>
;<z>
new OriginPattern(originPattern));<z>
== DEFAULT_PERMIT_ALL) {<z>
.allowedOrigins = null;<z>
, HttpServletResponse response,<z>
throws ServletException, IOException {<z>
(request, response);<z>
) {<z>
;<z>
intf.isInterface()) {<z>
"] is not an interface");<z>
{<z>
.interfaces.add(intf);<z>
;<z>
WebSocketMessage toMessage(Type type, T message) {<z>
(type)) {<z>
message).getBytes(StandardCharsets.UTF_8);<z>
).wrap(bytes));<z>
.BINARY.equals(type)) {<z>
);<z>
BINARY, buffer);<z>
.PONG.equals(type)) {<z>
[]) message);<z>
PONG, buffer);<z>
new IllegalArgumentException("Unexpected message type: " + message);<z>
TaskScheduler taskScheduler) {<z>
isDefaultHeartbeatEnabled()) {<z>
10000, 10000});<z>
(taskScheduler);<z>
mbd, BeanWrapper bw,<z>
) {<z>
customConverter = this.beanFactory.getCustomTypeConverter();<z>
: bw);<z>
=<z>
converter);<z>
.getArgumentCount();<z>
) {<z>
getKey();<z>
(index < 0) {<z>
, beanName,<z>
"Invalid constructor argument index: " + index);<z>
> minNrOfArgs) {<z>
;<z>
entry.getValue();<z>
if (valueHolder.isConverted()) {<z>
);<z>
=<z>
valueHolder.getValue());<z>
=<z>
(), valueHolder.getName());<z>
(valueHolder);<z>
;<z>
getGenericArgumentValues()) {<z>
if (valueHolder.isConverted()) {<z>
resolvedValues.addGenericArgumentValue(valueHolder);<z>
Object resolvedValue =<z>
));<z>
= new ConstructorArgumentValues.ValueHolder(<z>
));<z>
setSource(valueHolder);<z>
resolvedValueHolder);<z>
;<z>
ExpressionState state) throws EvaluationException {<z>
);<z>
);<z>
left);<z>
= CodeFlow.toDescriptorFromObject(right);<z>
Number rightNumber) {<z>
(leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {<z>
BigDecimal.class);<z>
);<z>
0);<z>
instanceof Double) {<z>
);<z>
Float || rightNumber instanceof Float) {<z>
;<z>
BigInteger) {<z>
(leftNumber, BigInteger.class);<z>
, BigInteger.class);<z>
.compareTo(rightBigInteger) >= 0);<z>
{<z>
;<z>
instanceof Integer) {<z>
>= rightNumber.intValue());<z>
{<z>
) >= rightNumber.shortValue());<z>
Byte || rightNumber instanceof Byte) {<z>
() >= rightNumber.byteValue());<z>
());<z>
);<z>
)<z>
{<z>
return null;<z>
Object> model, ServerWebExchange exchange) {<z>
SimpleHash(getObjectWrapper());<z>
fmModel.putAll(model);<z>
;<z>
?> clazz, String resourceName) {<z>
, "Resource name must not be null");<z>
(!resourceName.startsWith("/")) {<z>
(clazz) + '/' + resourceName;<z>
classPackageAsResourcePath(clazz) + resourceName;<z>
public String getMessage() {<z>
this.variableName + "' for method parameter type " +<z>
+ " is " +<z>
() ? "present but converted to null" : "not present");<z>
Class<?> aspectClass) {<z>
methods = new ArrayList<>();<z>
::add, adviceMethodFilter);<z>
size() > 1) {<z>
methods.sort(adviceMethodComparator);<z>
;<z>
public void error(Throwable t) {<z>
) {<z>
.deferredResult.setErrorResult(t);<z>
(Object metadata, @Nullable MimeType mimeType) {<z>
{<z>
(mimeType, "MimeType is required for composite metadata entries.");<z>
null) {<z>
mimeType = this.metadataMimeType;<z>
this.metadataMimeType.equals(mimeType)) {<z>
IllegalArgumentException(<z>
.metadataMimeType + "'.");<z>
.getAdapter(metadata.getClass());<z>
!= null) {<z>
+ metadata);<z>
;<z>
this.hasAsyncValues = true;<z>
;<z>
);<z>
return this;<z>
,<z>
vars) {<z>
if (route != null) {<z>
[0]);<z>
isEmpty(metadata)) {<z>
> entry : metadata.entrySet()) {<z>
, entry.getValue());<z>
;<z>
return this;<z>
) {<z>
this.hasVersionResolver && !this.hasCssLinkTransformer) {<z>
;<z>
);<z>
.transformers.get(0) instanceof CachingResourceTransformer;<z>
));<z>
;<z>
.transformers;<z>
{<z>
, index);<z>
this.writePosition - 1);<z>
.byteBuffer.get(index);<z>
readWithMessageConverters(NativeWebRequest webRequest, MethodParameter parameter,<z>
, HttpMessageNotReadableException {<z>
inputMessage = createInputMessage(webRequest);<z>
, parameter, paramType);<z>
(Set setVal) {<z>
;<z>
false;<z>
Object elem : setVal) {<z>
: 0);<z>
(elem);<z>
() : 0);<z>
;<z>
newVal != elem || newValHash != elemHash);<z>
(entriesModified) {<z>
();<z>
);<z>
Nullable HandlerMethodArgumentResolver... resolvers) {<z>
resolvers != null) {<z>
;<z>
return this;<z>
basenames) {<z>
(basenames)) {<z>
basename : basenames) {<z>
.hasText(basename, "Basename must not be empty");<z>
add(basename.trim());<z>
(HttpMethod method, URI uri,<z>
requestCallback) {<z>
if (!uri.isAbsolute()) {<z>
new IllegalArgumentException("URI is not absolute: " + uri));<z>
.isStarted()) {<z>
.httpClient.start();<z>
Exception ex) {<z>
;<z>
);<z>
, this.bufferFactory);<z>
).then(execute(request));<z>
Object payload) {<z>
) == null) {<z>
(payload);<z>
getBaseLogMessage();<z>
(getSessionAttributes())) {<z>
" attributes=").append(getSessionAttributes());<z>
>) getHeader(NATIVE_HEADERS))) {<z>
));<z>
(payload));<z>
return sb.toString();<z>
public boolean supportsParameter(MethodParameter parameter) {<z>
> paramType = parameter.getParameterType();<z>
) ||<z>
||<z>
));<z>
writeInternal(Resource resource, HttpOutputMessage outputMessage)<z>
throws IOException, HttpMessageNotWritableException {<z>
(resource, outputMessage);<z>
) {<z>
, "At least one ContentNegotiationStrategy is expected");<z>
strategies);<z>
ContentNegotiationStrategy strategy : this.strategies) {<z>
strategy instanceof MediaTypeFileExtensionResolver) {<z>
;<z>
Publisher<? extends DataBuffer>> body) {<z>
);<z>
Proxy proxy) throws IOException {<z>
openConnection());<z>
)) {<z>
IllegalStateException(<z>
);<z>
;<z>
> implementationClass) {<z>
Assert.notNull(field, "Field must not be null");<z>
));<z>
;<z>
prepareForRendering(HttpServletRequest request, HttpServletResponse response)<z>
{<z>
= getUrl();<z>
(path != null, "'url' not set");<z>
this.preventDispatchLoop) {<z>
= request.getRequestURI();<z>
uri, path))) {<z>
"]: would dispatch back " +<z>
+ "] again. Check your ViewResolver setup! " +<z>
);<z>
return path;<z>
disableMessageTimestamp) throws JMSException {<z>
.originalDisableMessageTimestamp == null) {<z>
this.target.getDisableMessageTimestamp();<z>
target.setDisableMessageTimestamp(disableMessageTimestamp);<z>
() {<z>
.elements.isEmpty()) {<z>
Object.class;<z>
get(0);<z>
firstElement instanceof Enum) {<z>
getDeclaringClass();<z>
;<z>
(TagWriter tagWriter) throws JspException {<z>
getItems();<z>
;<z>
);<z>
();<z>
String valueProperty =<z>
)) : null);<z>
=<z>
, itemLabel)) : null);<z>
.getValueType();<z>
isEnum()) {<z>
getEnumConstants();<z>
) {<z>
throw new IllegalArgumentException("Attribute 'items' is required and must be a Collection, an Array or a Map");<z>
) {<z>
) itemsObject;<z>
itemsArray.length; i++) {<z>
Object item = itemsArray[i];<z>
, labelProperty, item, i);<z>
(itemsObject instanceof Collection) {<z>
>) itemsObject;<z>
int itemIndex = 0;<z>
; itemIndex++) {<z>
();<z>
);<z>
(itemsObject instanceof Map) {<z>
?, ?>) itemsObject;<z>
0;<z>
; itemIndex++) {<z>
.Entry) it.next();<z>
);<z>
;<z>
return SKIP_BODY;<z>
arg2, Object arg3) {<z>
);<z>
this.arg1 = arg1;<z>
arg2;<z>
arg3;<z>
public void afterPropertiesSet() {<z>
routeMatcher == null) {<z>
);<z>
pathMatcher.setPathSeparator(".");<z>
SimpleRouteMatcher(pathMatcher);<z>
super.afterPropertiesSet();<z>
) throws NamingException {<z>
= activated;<z>
null) {<z>
();<z>
);<z>
;<z>
return builder;<z>
void onAllDataRead() {<z>
.get();<z>
.isTraceEnabled()) {<z>
+ state + "]");<z>
state.onAllDataRead(this);<z>
String resourceLoaderPath) {<z>
;<z>
[paths.length + 1];<z>
= "";<z>
paths.length; i++) {<z>
];<z>
)) {<z>
;<z>
resourceLoaderPaths[i + 1] = path;<z>
) {<z>
;<z>
!= null) {<z>
initializer.initHeaders(headerAccessor);<z>
(BeanDefinition beanDefinition) {<z>
(beanDefinition);<z>
(beanDefinition);<z>
visitFactoryBeanName(beanDefinition);<z>
visitFactoryMethodName(beanDefinition);<z>
);<z>
beanDefinition.hasPropertyValues()) {<z>
.getPropertyValues());<z>
{<z>
beanDefinition.getConstructorArgumentValues();<z>
;<z>
;<z>
] arguments,<z>
, SpringValidatorAdapter adapter) {<z>
getMessage());<z>
.adapter = adapter;<z>
violation;<z>
(violation);<z>
void setDaysOfMonth(BitSet bits, String field) {<z>
;<z>
1);<z>
clear(0);<z>
msg) {<z>
msg);<z>
.resourceDescription = resourceDescription;<z>
.beanName = null;<z>
{<z>
)) {<z>
;<z>
singletonInstance = createInstance();<z>
;<z>
resolveAnnotations() {<z>
this);<z>
== null) {<z>
LinkedHashMap<>();<z>
;<z>
);<z>
);<z>
new Annotation[0]);<z>
this, annotations);<z>
annotations;<z>
Element element, Element scriptElement) {<z>
scriptSeparator = scriptElement.getAttribute("separator");<z>
hasLength(scriptSeparator)) {<z>
;<z>
element.getAttribute("separator");<z>
)) {<z>
;<z>
null;<z>
<?> actualType) {<z>
"Object of type [" + actualType + "] available at JNDI location [" +<z>
+ requiredType.getName() + "]");<z>
.requiredType = requiredType;<z>
;<z>
Nullable List<HandlerMethodReturnValueHandler> returnValueHandlers) {<z>
) {<z>
returnValueHandlers.clear();<z>
);<z>
subroutineId) {<z>
Label listOfBlocksToProcess = this;<z>
listOfBlocksToProcess.nextListElement = EMPTY_LIST;<z>
(listOfBlocksToProcess != EMPTY_LIST) {<z>
= listOfBlocksToProcess;<z>
nextListElement;<z>
;<z>
subroutineId == 0) {<z>
.subroutineId = subroutineId;<z>
);<z>
getCookieHeader(Cookie cookie) {<z>
;<z>
);<z>
cookie.getPath())) {<z>
));<z>
cookie.getDomain())) {<z>
append(cookie.getDomain());<z>
);<z>
() : null);<z>
(maxAge >= 0) {<z>
.append(maxAge);<z>
);<z>
{<z>
format(DateTimeFormatter.RFC_1123_DATE_TIME));<z>
;<z>
* maxAge : 0);<z>
;<z>
else if (expires != null) {<z>
append("; Expires=");<z>
(DateTimeFormatter.RFC_1123_DATE_TIME));<z>
if (cookie.getSecure()) {<z>
);<z>
if (cookie.isHttpOnly()) {<z>
("; HttpOnly");<z>
) {<z>
;<z>
())) {<z>
.getSameSite());<z>
();<z>
target, String name) {<z>
, name);<z>
this.initializer != null) {<z>
);<z>
initDataBinder(dataBinder, exchange);<z>
sessionFactory,<z>
{<z>
(sessionId);<z>
if (session != null) {<z>
;<z>
== null) {<z>
;<z>
);<z>
(sessionId, session);<z>
return session;<z>
ReadableByteChannelGenerator(<z>
int bufferSize) {<z>
.channel = channel;<z>
.dataBufferFactory = dataBufferFactory;<z>
this.bufferSize = bufferSize;<z>
public String toString() {<z>
getExpression() +<z>
"]; advice method [" + this.aspectJAdviceMethod + "]; perClauseKind=" +<z>
getPerClause().getKind();<z>
equals(@Nullable Object other) {<z>
{<z>
true;<z>
) {<z>
return false;<z>
MergedContextConfiguration otherConfig = (MergedContextConfiguration) other;<z>
.locations, otherConfig.locations)) {<z>
return false;<z>
.classes, otherConfig.classes)) {<z>
;<z>
.contextInitializerClasses)) {<z>
false;<z>
)) {<z>
false;<z>
propertySourceLocations)) {<z>
false;<z>
.propertySourceProperties, otherConfig.propertySourceProperties)) {<z>
return false;<z>
{<z>
return false;<z>
parent == null) {<z>
!= null) {<z>
;<z>
parent.equals(otherConfig.parent)) {<z>
;<z>
)) {<z>
;<z>
;<z>
OutputStream out) throws IOException {<z>
);<z>
;<z>
;<z>
.flush();<z>
rs, int index) throws SQLException {<z>
obj = rs.getObject(index);<z>
null;<z>
{<z>
obj.getClass().getName();<z>
if (obj instanceof Blob blob) {<z>
length());<z>
clob) {<z>
());<z>
.equals(className)) {<z>
);<z>
{<z>
).getColumnClassName(index);<z>
) {<z>
);<z>
getDate(index);<z>
java.sql.Date) {<z>
().getColumnClassName(index))) {<z>
= rs.getTimestamp(index);<z>
;<z>
(@Nullable BeanFactory parentBeanFactory) {<z>
parentBeanFactory != parentBeanFactory) {<z>
this.parentBeanFactory);<z>
this == parentBeanFactory) {<z>
;<z>
this.parentBeanFactory = parentBeanFactory;<z>
parseQualifierElements(Element beanEle, AbstractBeanDefinition bd) {<z>
nl = beanEle.getChildNodes();<z>
); i++) {<z>
node = nl.item(i);<z>
nodeNameEquals(node, QUALIFIER_ELEMENT)) {<z>
bd);<z>
String relativePath) throws MalformedURLException {<z>
)) {<z>
(1);<z>
(relativePath, "#", "%23");<z>
(this.url, relativePath);<z>
@Nullable Object transaction, Object suspendedResources) {<z>
= (JtaTransactionObject) transaction;<z>
suspendedResources);<z>
ex) {<z>
ex);<z>
{<z>
;<z>
catch (SystemException ex) {<z>
TransactionSystemException("JTA failure on resume", ex);<z>
setBeanNames(String... beanNames) {<z>
beanNames, "'beanNames' must not be empty");<z>
new ArrayList<>(beanNames.length);<z>
String mappedName : beanNames) {<z>
());<z>
protected boolean isEligibleForOverriding(String className) {<z>
this.isExcluded(className)) {<z>
return false;<z>
(findLoadedClassMethod);<z>
ClassLoader parent = getParent();<z>
(parent != null) {<z>
!= null) {<z>
;<z>
;<z>
return true;<z>
getChars() {<z>
);<z>
'{');<z>
;<z>
{<z>
));<z>
);<z>
sb.toString().toCharArray();<z>
{<z>
{<z>
) bean).postProcessBeforeInit();<z>
;<z>
() {<z>
null) {<z>
, PageContext.REQUEST_SCOPE);<z>
, PageContext.REQUEST_SCOPE);<z>
return EVAL_PAGE;<z>
ByteVector output) {<z>
putShort(nameIndex).putShort(descriptorIndex);<z>
= 0;<z>
if (signatureIndex != 0) {<z>
attributesCount;<z>
{<z>
;<z>
{<z>
attributesCount;<z>
lastRuntimeVisibleTypeAnnotation != null) {<z>
++attributesCount;<z>
null) {<z>
;<z>
if (firstAttribute != null) {<z>
getAttributeCount();<z>
;<z>
0, signatureIndex, output);<z>
putAnnotations(<z>
;<z>
!= null) {<z>
);<z>
(String resourceUrlPath,<z>
Resource> locations, ResourceResolverChain chain) {<z>
resourceUrlPath, locations);<z>
Visitor visitor) {<z>
();<z>
.left.accept(visitor);<z>
.or();<z>
this.right.accept(visitor);<z>
visitor.endOr();<z>
) throws IOException {<z>
{<z>
new byte[0];<z>
out = new ByteArrayOutputStream(BUFFER_SIZE);<z>
out);<z>
;<z>
(Response response) {<z>
) {<z>
);<z>
(logger.isTraceEnabled()) {<z>
("XHR receive request completed.");<z>
transportUrl, this.receiveHeaders, this);<z>
IllegalArgumentException {<z>
.notNull(this.type, "Property 'type' is required");<z>
"Property 'hostname' is required");<z>
0 || this.port > 65535) {<z>
this.port);<z>
.port);<z>
(this.type, socketAddress);<z>
public MessageHandler userRegistryMessageHandler(<z>
, AbstractSubscribableChannel clientOutboundChannel,<z>
,<z>
{<z>
clientInboundChannel, clientOutboundChannel);<z>
== null) {<z>
return null;<z>
.class, userRegistry, "MultiServerUserRegistry required");<z>
UserRegistryMessageHandler((MultiServerUserRegistry) userRegistry,<z>
brokerMessagingTemplate, brokerRegistry.getUserRegistryBroadcast(),<z>
;<z>
) {<z>
?<z>
violation) :<z>
;<z>
(<z>
context, ServerWebExchange exchange) {<z>
HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE;<z>
());<z>
, @Nullable String[] headers) {<z>
<ConsumeMediaTypeExpression> result = null;<z>
(!ObjectUtils.isEmpty(headers)) {<z>
for (String header : headers) {<z>
= new HeaderExpression(header);<z>
name) && expr.value != null) {<z>
);<z>
parseMediaTypes(expr.value)) {<z>
, expr.isNegated));<z>
consumes)) {<z>
LinkedHashSet<>());<z>
: consumes) {<z>
);<z>
emptyList());<z>
Nullable MediaType contentType, ServerWebExchange exchange) {<z>
;<z>
;<z>
>) this.writer).write(<z>
contentType, exchange.getResponse(),<z>
exchange.getLogPrefix()));<z>
LobHandler lobHandler) {<z>
bytes;<z>
? bytes.length : 0);<z>
= lobHandler.getLobCreator();<z>
) {<z>
) {<z>
"(none)";<z>
;<z>
> expectedMap, boolean containsExactly) {<z>
-> {<z>
request);<z>
containsExactly) {<z>
());<z>
entrySet()) {<z>
();<z>
> values = entry.getValue();<z>
name) != null);<z>
(), containsExactly ?<z>
get(name).size() :<z>
get(name).size());<z>
i++) {<z>
expected = values.get(i);<z>
;<z>
expected instanceof Resource) {<z>
).getInputStream());<z>
(expected instanceof byte[]) {<z>
byte[]);<z>
assertEquals("Multipart content", expected, actual);<z>
{<z>
"Multipart is not a String", actual instanceof String);<z>
;<z>
;<z>
adapter, ResolvableType elementType) {<z>
this.result = result;<z>
adapter.isMultiValue();<z>
this.values = new CollectedValuesList(elementType);<z>
void closeMessageConsumer(@Nullable MessageConsumer consumer) {<z>
(consumer != null) {<z>
boolean wasInterrupted = Thread.interrupted();<z>
close();<z>
catch (JMSException ex) {<z>
"Could not close JMS MessageConsumer", ex);<z>
) {<z>
ex);<z>
wasInterrupted) {<z>
.interrupt();<z>
) {<z>
MessageConverter converter = getMessageConverter();<z>
null) {<z>
.fromMessage(message);<z>
message;<z>
) {<z>
);<z>
> BodyInserter<P, ReactiveHttpOutputMessage> fromPublisher(<z>
P publisher, Class<T> elementClass) {<z>
;<z>
.notNull(elementClass, "'elementClass' must not be null");<z>
-><z>
ResolvableType.forClass(elementClass), null);<z>
) {<z>
= getAttachmentAsDataHandler(cid);<z>
dataHandler.getInputStream());<z>
(IOException ex) {<z>
new UnmarshallingFailureException("Could not read attachment", ex);<z>
startPos, int endPos, SpelNodeImpl... expressionComponents) {<z>
super(startPos, endPos, expressionComponents);<z>
if (expressionComponents.length < 2) {<z>
"Do not build compound expressions with less than two entries: " +<z>
length);<z>
String name) {<z>
.propertySources) {<z>
containsProperty(name)) {<z>
return true;<z>
return false;<z>
release() {<z>
;<z>
.name = "";<z>
null;<z>
valueSet = false;<z>
<List<T>> trySplit() {<z>
= this.delegate.trySplit();<z>
null) {<z>
;<z>
null;<z>
protected String getMessagePayload(HttpServletRequest request) {<z>
ContentCachingRequestWrapper wrapper =<z>
class);<z>
null) {<z>
] buf = wrapper.getContentAsByteArray();<z>
(buf.length > 0) {<z>
));<z>
wrapper.getCharacterEncoding());<z>
) {<z>
;<z>
null;<z>
) {<z>
{<z>
0;<z>
;<z>
array) {<z>
hashCode(element);<z>
return hash;<z>
{<z>
;<z>
;<z>
annotationRequired;<z>
String name) throws ClassNotFoundException {<z>
".class";<z>
);<z>
{<z>
(name);<z>
] bytes = FileCopyUtils.copyToByteArray(is);<z>
, bytes);<z>
, bytes, 0, bytes.length);<z>
{<z>
;<z>
!= -1) {<z>
packageSeparator);<z>
null, null, null);<z>
.classCache.put(name, cls);<z>
return cls;<z>
catch (IOException ex) {<z>
;<z>
info, ServerWebExchange exchange) {<z>
info = info;<z>
exchange) != null;<z>
null;<z>
) != null;<z>
null;<z>
) {<z>
this();<z>
) {<z>
(propertySource);<z>
getDisplayValue() {<z>
instanceof String) {<z>
) this.value;<z>
.value != null) {<z>
));<z>
;<z>
Nullable TransactionInfo txInfo) {<z>
!= null) {<z>
);<z>
(HttpServletRequest request) {<z>
WebUtils.INCLUDE_SERVLET_PATH_ATTRIBUTE);<z>
(servletPath == null) {<z>
servletPath = request.getServletPath();<z>
("/") && shouldRemoveTrailingServletPathSlash(request)) {<z>
1);<z>
servletPath;<z>
(Method method, String beanKey) {<z>
>[] ifaces = null;<z>
if (this.resolvedInterfaceMappings != null) {<z>
(beanKey);<z>
(ifaces == null) {<z>
ifaces = this.managedInterfaces;<z>
if (ifaces == null) {<z>
));<z>
?> ifc : ifaces) {<z>
ifc.getMethods()) {<z>
)) &&<z>
.getParameterCount() &&<z>
))) {<z>
;<z>
;<z>
part, Charset defaultCharset) {<z>
part.getContentType() != null) {<z>
.parseMediaType(part.getContentType());<z>
!= null) {<z>
);<z>
;<z>
beanClassLoader) {<z>
beanClassLoader = beanClassLoader;<z>
setMetadataReaderFactoryCalled) {<z>
metadataReaderFactory = new CachingMetadataReaderFactory(beanClassLoader);<z>
{<z>
targetType = this.targetType;<z>
if (targetType != null) {<z>
return targetType;<z>
.factoryMethodReturnType;<z>
) {<z>
;<z>
Method factoryMethod = this.factoryMethodToIntrospect;<z>
factoryMethod != null) {<z>
ResolvableType.forMethodReturnType(factoryMethod);<z>
super.getResolvableType();<z>
) {<z>
(!isCancelled()) {<z>
();<z>
done();<z>
> insert(ClientHttpRequest outputMessage, Context context) {<z>
HttpEntity<?>>> messageWriter =<z>
context, MULTIPART_DATA_TYPE, MediaType.MULTIPART_FORM_DATA);<z>
;<z>
(Mono.just(body), MULTIPART_DATA_TYPE,<z>
, context.hints());<z>
(MethodVisitor mv, CodeFlow cf) {<z>
method = this.method;<z>
state(method != null, "No method handle");<z>
().replace('.', '/');<z>
, this.children);<z>
),<z>
.createSignatureDescriptor(method), false);<z>
cf.pushDescriptor(this.exitTypeDescriptor);<z>
(JtaTransactionObject txObject, int timeout) throws SystemException {<z>
TransactionDefinition.TIMEOUT_DEFAULT) {<z>
;<z>
if (timeout > 0) {<z>
txObject.resetTransactionTimeout = true;<z>
(Path directory) {<z>
(directory)) {<z>
;<z>
= newDirectory;<z>
newDirectory;<z>
directory);<z>
) {<z>
== other) {<z>
return true;<z>
!(other instanceof RequestMappingInfo otherInfo)) {<z>
;<z>
(otherInfo.getActivePatternsCondition()) &&<z>
methodsCondition.equals(otherInfo.methodsCondition) &&<z>
equals(otherInfo.paramsCondition) &&<z>
(otherInfo.headersCondition) &&<z>
equals(otherInfo.consumesCondition) &&<z>
.equals(otherInfo.producesCondition) &&<z>
.customConditionHolder));<z>
Context context) {<z>
).getContentType();<z>
());<z>
context.viewResolvers().stream();<z>
Flux.fromStream(viewResolverStream)<z>
locale))<z>
)<z>
(Mono.error(() -><z>
))<z>
(view -> {<z>
mediaTypes = view.getSupportedMediaTypes();<z>
.render(model(),<z>
,<z>
;<z>
;<z>
{<z>
();<z>
{<z>
("Local JMS transaction failed to commit", ex);<z>
, String namespace) throws SAXException {<z>
StringUtils.hasLength(namespace)) {<z>
prefix == null) {<z>
prefix = "";<z>
(prefix))) {<z>
;<z>
, namespace);<z>
String propertyPath) {<z>
propertyPath)) {<z>
;<z>
{<z>
;<z>
PROPERTY_KEY_PREFIX_CHAR) {<z>
false;<z>
) + 1) ==<z>
() - 1);<z>
) throws IOException {<z>
(this.reader == null) {<z>
, getCharacterEncoding()));<z>
return this.reader;<z>
clientConfig) {<z>
) {<z>
return clientConfig;<z>
RequestConfig.copy(clientConfig);<z>
requestConfig.getConnectTimeout();<z>
{<z>
builder.setConnectTimeout(connectTimeout);<z>
requestConfig.getConnectionRequestTimeout();<z>
0) {<z>
builder.setConnectionRequestTimeout(connectionRequestTimeout);<z>
);<z>
{<z>
.setSocketTimeout(socketTimeout);<z>
();<z>
dataBuffer, ResolvableType targetType,<z>
{<z>
= selectObjectMapper(targetType, mimeType);<z>
if (mapper == null) {<z>
IllegalStateException("No ObjectMapper for " + targetType);<z>
(mapper, targetType, hints);<z>
());<z>
);<z>
value;<z>
IOException ex) {<z>
(ex);<z>
dataBuffer);<z>
(HttpMethod method, URI uri, HttpClientContext context,<z>
) {<z>
context;<z>
;<z>
= dataBufferFactory;<z>
{<z>
.logger.isWarnEnabled()) {<z>
null, null);<z>
() {<z>
PartialMatch match : this.partialMatches) {<z>
(match.hasMethodsMatch()) {<z>
return false;<z>
return true;<z>
protected Object convertToInternal(<z>
Nullable MessageHeaders headers, @Nullable Object conversionHint) {<z>
payload;<z>
Void> rollback(ReactiveTransaction transaction) throws TransactionException {<z>
transaction.isCompleted()) {<z>
new IllegalTransactionStateException(<z>
));<z>
flatMap(synchronizationManager -> {<z>
GenericReactiveTransaction) transaction;<z>
reactiveTx);<z>
});<z>
SSLSession session) {<z>
notNull(session, "SSLSession is required");<z>
);<z>
.peerCertificates = initCertificates(session);<z>
) {<z>
.get();<z>
catch (InterruptedException ex) {<z>
);<z>
("Interrupted during initialization of Hibernate SessionFactory", ex);<z>
) {<z>
= ex.getCause();<z>
HibernateException) {<z>
) cause;<z>
throw new IllegalStateException("Failed to asynchronously initialize Hibernate SessionFactory: " +<z>
getMessage(), cause);<z>
mi) throws Throwable {<z>
{<z>
);<z>
(pmi);<z>
JoinPointMatch jpm = getJoinPointMatch(pmi);<z>
jpm, null, null);<z>
> Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,<z>
Class<? extends Annotation> containerAnnotationType) {<z>
null ?<z>
) :<z>
);<z>
(annotatedElement, SearchStrategy.DIRECT, repeatableContainers)<z>
.stream(annotationType)<z>
.map(MergedAnnotation::withNonMergedAttributes)<z>
.collect(MergedAnnotationCollectors.toAnnotationSet());<z>
public static LocaleContext getLocaleContext() {<z>
;<z>
{<z>
inheritableLocaleContextHolder.get();<z>
;<z>
valueProperty,<z>
) throws JspException {<z>
forBeanPropertyAccess(item);<z>
Object renderValue;<z>
!= null) {<z>
renderValue = wrapper.getPropertyValue(valueProperty);<z>
if (item instanceof Enum) {<z>
;<z>
;<z>
.getPropertyValue(labelProperty) : item);<z>
, renderValue, renderLabel, itemIndex);<z>
{<z>
getClass().getName());<z>
append(" errors");<z>
()) {<z>
'\n').append(error);<z>
();<z>
(<z>
{<z>
;<z>
{<z>
;<z>
autowiredBeanNames = new LinkedHashSet<>(4);<z>
;<z>
) {<z>
bw.getPropertyDescriptor(propertyName);<z>
class != pd.getPropertyType()) {<z>
methodParam = BeanUtils.getWriteMethodParameter(pd);<z>
getWrappedInstance() instanceof PriorityOrdered);<z>
AutowireByTypeDependencyDescriptor(methodParam, eager);<z>
, converter);<z>
) {<z>
(propertyName, autowiredArgument);<z>
) {<z>
autowiredBeanName, beanName);<z>
()) {<z>
logger.trace("Autowiring by type from bean name '" + beanName + "' via property '" +<z>
autowiredBeanName + "'");<z>
autowiredBeanNames.clear();<z>
BeansException ex) {<z>
, propertyName, ex);<z>
{<z>
if (instance == null) {<z>
("derby.stream.error.method",<z>
.getName() + ".getNoopOutputStream");<z>
instance = new DerbyEmbeddedDatabaseConfigurer();<z>
return instance;<z>
ModelAndView handleBindException(BindException ex, HttpServletRequest request,<z>
handler) throws IOException {<z>
;<z>
();<z>
(ServletContext servletContext) {<z>
attributeName == null) {<z>
);<z>
attributeName);<z>
attribute == null) {<z>
;<z>
, HttpHeaders headers,<z>
CompletionStage<T> entity, Type entityType) {<z>
, headers, cookies, entity, entityType);<z>
message)<z>
JMSException {<z>
Connection conToClose = null;<z>
sessionToClose = null;<z>
= session;<z>
)) {<z>
();<z>
conToClose);<z>
= sessionToClose;<z>
.onMessage(message, sessionToUse);<z>
!= session) {<z>
isSessionLocallyTransacted(sessionToUse)) {<z>
;<z>
sessionToClose);<z>
;<z>
getEncodeHints(ResolvableType actualType, ResolvableType elementType,<z>
ServerHttpRequest request, ServerHttpResponse response) {<z>
) {<z>
?>) this.encoder;<z>
request, response);<z>
;<z>
setAttributes(AttributeList attributes) {<z>
().getContextClassLoader();<z>
(this.managedResourceClassLoader);<z>
(attributes);<z>
currentThread().setContextClassLoader(currentClassLoader);<z>
> T merge(T entity) throws DataAccessException {<z>
return nonNull(executeWithNativeSession(session -> {<z>
(session);<z>
) session.merge(entity);<z>
);<z>
HandlerMethodArgumentResolver> requestMappingResolvers(<z>
adapterRegistry,<z>
readers) {<z>
;<z>
String> toSingleValueMap() {<z>
);<z>
h.getValue()));<z>
map;<z>
<String> patterns) {<z>
.excludePatterns = (this.excludePatterns != null ?<z>
()));<z>
excludePatterns.addAll(patterns);<z>
;<z>
{<z>
);<z>
{<z>
);<z>
onError(this, ex);<z>
() {<z>
).millis());<z>
();<z>
millis());<z>
{<z>
scheduledExecutionTime != null, "No scheduled execution");<z>
.scheduledExecutionTime, actualExecutionTime, completionTime);<z>
()) {<z>
;<z>
args, Object target) throws Throwable {<z>
) {<z>
TransactionInterceptor.currentTransactionStatus();<z>
();<z>
);<z>
{<z>
, target);<z>
> message) {<z>
(parameter);<z>
null) {<z>
"Unsupported parameter type [" +<z>
() + "]. supportsParameter should be called first.");<z>
message);<z>
{<z>
.allowedOrigins.clear();<z>
isEmpty(allowedOrigins)) {<z>
;<z>
this;<z>
CachePutOperation(<z>
, KeyGenerator keyGenerator) {<z>
super(methodDetails, cacheResolver, keyGenerator);<z>
;<z>
));<z>
=<z>
, this.allParameterDetails);<z>
(valueParameterDetail == null) {<z>
throw new IllegalArgumentException("No parameter annotated with @CacheValue was found for " +<z>
.getMethod());<z>
valueParameterDetail = valueParameterDetail;<z>
isExcludedFromDependencyCheck(PropertyDescriptor pd) {<z>
AutowireUtils.isExcludedFromDependencyCheck(pd) ||<z>
getPropertyType()) ||<z>
isSetterDefinedInInterface(pd, this.ignoredDependencyInterfaces));<z>
(String extension) {<z>
);<z>
.extensionPredicate = s -> {<z>
;<z>
, match);<z>
;<z>
;<z>
{<z>
== DisposedState.INSTANCE) {<z>
.getAndSet(newState);<z>
(logger.isTraceEnabled()) {<z>
"Changed state: " + oldState + " -> " + newState);<z>
oldState.dispose();<z>
applyDefaultConfig(BaseCodecConfigurer.DefaultCustomCodecs customCodecs) {<z>
.getTypedReaders());<z>
getObjectReaders());<z>
getTypedWriters());<z>
applyDefaultConfig(customCodecs.getObjectWriters());<z>
;<z>
void setAdvice(Advice advice) {<z>
) {<z>
advice = advice;<z>
AbstractMediaTypeExpression other) {<z>
.getMediaType();<z>
);<z>
(mediaType2)) {<z>
-1;<z>
mediaType1.isLessSpecific(mediaType2)) {<z>
return 1;<z>
;<z>
returnType,<z>
{<z>
(this.mavResolvers != null) {<z>
this.mavResolvers) {<z>
> handlerType = returnType.getContainingClass();<z>
Method method = returnType.getMethod();<z>
null, "No handler method");<z>
(ExtendedModelMap) mavContainer.getModel();<z>
);<z>
ModelAndViewResolver.UNRESOLVED) {<z>
addAllAttributes(mav.getModel());<z>
;<z>
)) {<z>
(mav.getView());<z>
this.modelAttributeProcessor.supportsReturnType(returnType)) {<z>
);<z>
"Unexpected return type: " +<z>
);<z>
private static String lookupDefaultSchema(DatabaseMetaData databaseMetaData) {<z>
null;<z>
;<z>
con == null) {<z>
.debug("Cannot check default schema - no Connection from DatabaseMetaData");<z>
null;<z>
.prepareCall("{? = call sys_context('USERENV', 'CURRENT_SCHEMA')}");<z>
VARCHAR);<z>
);<z>
getString(1);<z>
if (cstmt != null) {<z>
();<z>
(SQLException ex) {<z>
("Exception encountered during default schema lookup", ex);<z>
return null;<z>
registerEndpoints() {<z>
= new LinkedHashSet<>();<z>
) {<z>
;<z>
context = getApplicationContext();<z>
if (context != null) {<z>
getBeanNamesForAnnotation(ServerEndpoint.class);<z>
beanName : endpointBeanNames) {<z>
context.getType(beanName));<z>
> endpointClass : endpointClasses) {<z>
registerEndpoint(endpointClass);<z>
if (context != null) {<z>
class);<z>
ServerEndpointConfig endpointConfig : endpointConfigMap.values()) {<z>
registerEndpoint(endpointConfig);<z>
) {<z>
;<z>
!= null) {<z>
close();<z>
catch (IOException ex) {<z>
;<z>
false;<z>
String propertyName,<z>
Method readMethod, @Nullable Method writeMethod,<z>
<?> propertyEditorClass) throws IntrospectionException {<z>
, null, null);<z>
;<z>
: null);<z>
.findBridgedMethod(writeMethod) : null);<z>
== null && readMethodToUse != null) {<z>
.getMethodIfAvailable(<z>
null);<z>
() == 1) {<z>
= candidate;<z>
readMethod = readMethodToUse;<z>
writeMethodToUse;<z>
null) {<z>
.readMethod == null) {<z>
HashSet<>();<z>
method : beanClass.getMethods()) {<z>
.getName()) &&<z>
&& !method.isBridge() &&<z>
()) {<z>
ambiguousCandidates.add(method);<z>
{<z>
= ambiguousCandidates;<z>
).withContainingClass(this.beanClass);<z>
this.readMethod != null) {<z>
beanClass);<z>
if (this.writeMethodParameter != null) {<z>
.writeMethodParameter.getParameterType();<z>
propertyEditorClass = propertyEditorClass;<z>
() {<z>
= this.introspectedClass.getInterfaces();<z>
[ifcs.length];<z>
) {<z>
ifcs[i].getName();<z>
ifcNames;<z>
() {<z>
= this.bean;<z>
this.bean instanceof String beanName) {<z>
"Cannot resolve bean name without BeanFactory");<z>
.beanFactory.getBean(beanName);<z>
);<z>
void forward(ServletRequest request, ServletResponse response) {<z>
;<z>
"Response must not be null");<z>
), "Cannot perform forward - response is already committed");<z>
;<z>
if (logger.isDebugEnabled()) {<z>
"]");<z>
public Object resolveArgumentValue(<z>
{<z>
();<z>
) {<z>
maxHeadersSize) {<z>
return true;<z>
emitError(new DataBufferLimitException("Part headers exceeded the memory usage limit of " +<z>
.maxHeadersSize + " bytes"));<z>
return false;<z>
String unitName, boolean extended) {<z>
this.extendedPersistenceContexts : this.persistenceContexts);<z>
(contexts != null) {<z>
);<z>
) {<z>
this.defaultPersistenceUnitName;<z>
(unitNameForLookup);<z>
size() == 1) {<z>
();<z>
(jndiName != null) {<z>
;<z>
{<z>
, ex);<z>
null;<z>
method, URI url) {<z>
method, "HttpMethod must not be null");<z>
);<z>
this.method = method;<z>
this.url = url;<z>
(Class<? extends Annotation> autowiredAnnotationType) {<z>
.notNull(autowiredAnnotationType, "'autowiredAnnotationType' must not be null");<z>
);<z>
(autowiredAnnotationType);<z>
) {<z>
Assert.notNull(uri, "'uri' must not be null");<z>
.size());<z>
(uri);<z>
find()) {<z>
{<z>
variableNames.get(i - 1);<z>
String value = matcher.group(i);<z>
put(name, value);<z>
;<z>
FieldTypeCustomizer() {<z>
{<z>
Constants.TYPE_CLASS)) {<z>
.TYPE_CLASS, GET_NAME);<z>
{<z>
)) {<z>
Constants.TYPE_STRING;<z>
return type;<z>
) {<z>
);<z>
{<z>
());<z>
invocableHelper.addArgumentResolvers(resolvers);<z>
= initReturnValueHandlers();<z>
if (handlers.isEmpty()) {<z>
getCustomHandlers());<z>
invocableHelper.addReturnValueHandlers(handlers);<z>
);<z>
protected AsyncTaskExecutor determineAsyncExecutor(Method method) {<z>
);<z>
executor == null) {<z>
Executor targetExecutor;<z>
method);<z>
if (StringUtils.hasLength(qualifier)) {<z>
.beanFactory, qualifier);<z>
.get();<z>
) {<z>
;<z>
?<z>
targetExecutor : new TaskExecutorAdapter(targetExecutor));<z>
.executors.put(method, executor);<z>
;<z>
() {<z>
if (isFile()) {<z>
();<z>
IOException ex) {<z>
;<z>
).close();<z>
return true;<z>
) {<z>
getDescription(), ex);<z>
return false;<z>
(<z>
, ReactiveAdapterRegistry registry) {<z>
super(factory, registry);<z>
springframework.protobuf.Msg parseFrom(<z>
CodedInputStream input,<z>
.google.protobuf.ExtensionRegistryLite extensionRegistry)<z>
{<z>
;<z>
name) {<z>
name);<z>
ex) {<z>
new String[0];<z>
(<z>
int contentLength)<z>
SQLException {<z>
{<z>
!= null) {<z>
>= 0) {<z>
setBlob(paramIndex, binaryStream, contentLength);<z>
setBlob(paramIndex, binaryStream);<z>
, (Blob) null);<z>
else if (wrapAsLob) {<z>
binaryStream != null) {<z>
contentLength));<z>
(paramIndex, (Blob) null);<z>
>= 0) {<z>
contentLength);<z>
, binaryStream);<z>
()) {<z>
? "Set binary stream for BLOB with length " + contentLength :<z>
);<z>
DataBuffer> getBody() {<z>
())<z>
.flatMapIterable(Function.identity())<z>
bufferFactory::wrap)<z>
class, DataBufferUtils::release);<z>
private String getAspectName(Advisor advisor) {<z>
AspectJPrecedenceInformation precedenceInfo = AspectJAopUtils.getAspectJPrecedenceInformationFor(advisor);<z>
null, () -> "Unresolvable AspectJPrecedenceInformation for " + advisor);<z>
);<z>
) {<z>
, valueList) -> {<z>
Object value : valueList) {<z>
builder.part(key, value);<z>
;<z>
return this;<z>
updateExecutorInterceptorsFor(ChannelInterceptor interceptor) {<z>
interceptor instanceof ExecutorChannelInterceptor) {<z>
);<z>
) {<z>
(URL_TYPE_ABSOLUTE)) {<z>
type = UrlType.ABSOLUTE;<z>
value;<z>
("/")) {<z>
this.type = UrlType.CONTEXT_RELATIVE;<z>
;<z>
this.type = UrlType.RELATIVE;<z>
value = value;<z>
) {<z>
{<z>
.transactionManager.getReactiveTransaction(this.transactionDefinition);<z>
mono,<z>
transactionManager::rollback)<z>
.error(ex))));<z>
.getOrCreateContext())<z>
);<z>
{<z>
);<z>
WebApplicationContext) {<z>
getApplicationContext();<z>
) {<z>
"WebApplicationObjectSupport instance [" + this +<z>
);<z>
;<z>
{<z>
{<z>
rsWriteFlushLogger.trace(<z>
"current \"write\" Publisher completed");<z>
null;<z>
this.processor);<z>
webClient) {<z>
notNull(webClient, "WebClient must not be null");<z>
webClient));<z>
webClient;<z>
;<z>
private boolean maybeEatSelection(boolean nullSafeNavigation) {<z>
= peekToken();<z>
()) {<z>
;<z>
t != null, "No token");<z>
;<z>
= eatExpression();<z>
if (expr == null) {<z>
SpelMessage.MISSING_SELECTION_EXPRESSION);<z>
(TokenKind.RSQUARE);<z>
kind == TokenKind.SELECT_FIRST) {<z>
, t.endPos, expr));<z>
SELECT_LAST) {<z>
;<z>
));<z>
true;<z>
{<z>
computeIfAbsent(key, k -> {<z>
);<z>
ex) {<z>
ValueRetrievalException(key, valueLoader, ex);<z>
}));<z>
void send(MessageCreator messageCreator) throws JmsException {<z>
);<z>
if (defaultDestination != null) {<z>
send(defaultDestination, messageCreator);<z>
(), messageCreator);<z>
?> targetClass) {<z>
classLoader = targetClass.getClassLoader();<z>
this.pointcutClassLoader) {<z>
);<z>
Throwable ex) {<z>
"Failed to create fallback PointcutExpression", ex);<z>
;<z>
handlerMethod,<z>
String mappingName, boolean corsConfig) {<z>
;<z>
.notNull(handlerMethod, "HandlerMethod must not be null");<z>
this.mapping = mapping;<z>
= handlerMethod;<z>
);<z>
mappingName;<z>
this.corsConfig = corsConfig;<z>
? extends DataBuffer> publisher, long maxByteCount) {<z>
"Publisher must not be null");<z>
);<z>
{<z>
;<z>
return Flux.from(publisher)<z>
{<z>
readableByteCount());<z>
;<z>
(buffer -> {<z>
= countDown.get();<z>
0) {<z>
0);<z>
int)remainder;<z>
;<z>
buffer.slice(start, length);<z>
buffer;<z>
;<z>
PooledDataBuffer.class, DataBufferUtils::release);<z>
(ExpressionState state) throws EvaluationException {<z>
);<z>
;<z>
left);<z>
(right);<z>
right instanceof Number rightNumber) {<z>
{<z>
class);<z>
convertNumberToTargetClass(rightNumber, BigDecimal.class);<z>
) < 0);<z>
leftNumber instanceof Double || rightNumber instanceof Double) {<z>
rightNumber.doubleValue());<z>
instanceof Float || rightNumber instanceof Float) {<z>
floatValue());<z>
rightNumber instanceof BigInteger) {<z>
(leftNumber, BigInteger.class);<z>
BigInteger.class);<z>
< 0);<z>
Long) {<z>
;<z>
(leftNumber instanceof Integer || rightNumber instanceof Integer) {<z>
.intValue());<z>
leftNumber instanceof Short || rightNumber instanceof Short) {<z>
());<z>
instanceof Byte) {<z>
< rightNumber.byteValue());<z>
));<z>
instanceof CharSequence) {<z>
left.toString();<z>
= right.toString();<z>
< 0);<z>
standardClassXMLGregorianCalendar() throws DatatypeConfigurationException {<z>
calendar =<z>
.getInstance());<z>
;<z>
) {<z>
> clazz : commonClasses) {<z>
clazz.getName(), clazz);<z>
ApplicationListener<?> listener) {<z>
, "ApplicationListener must not be null");<z>
this.applicationEventMulticaster != null) {<z>
(listener);<z>
listener);<z>
urlPath, Object handler) throws BeansException, IllegalStateException {<z>
Assert.notNull(urlPath, "URL path must not be null");<z>
Assert.notNull(handler, "Handler object must not be null");<z>
Object resolvedHandler = handler;<z>
this.lazyInitHandlers && handler instanceof String handlerName) {<z>
applicationContext = obtainApplicationContext();<z>
) {<z>
(handlerName);<z>
);<z>
{<z>
{<z>
(<z>
(handler) + " to URL path [" + urlPath +<z>
"]: There is already " + getHandlerDescription(mappedHandler) + " mapped.");<z>
equals("/")) {<z>
isTraceEnabled()) {<z>
handler));<z>
;<z>
.equals("/*")) {<z>
) {<z>
));<z>
(resolvedHandler);<z>
, resolvedHandler);<z>
!= null) {<z>
, resolvedHandler);<z>
) {<z>
urlPath + "] onto " + getHandlerDescription(handler));<z>
(StreamSource streamSource) throws XmlMappingException, IOException {<z>
() != null) {<z>
{<z>
unmarshalInputStream(streamSource.getInputStream());<z>
.getInputStream());<z>
getDefaultEncoding());<z>
new SAXSource(inputSource));<z>
) != null) {<z>
isProcessExternalEntities() && isSupportDtd()) {<z>
.getReader());<z>
))));<z>
));<z>
(@Nullable HttpStatus status) {<z>
) {<z>
;<z>
;<z>
return true;<z>
String name, TypedValue value, EvaluationContext evaluationContext) {<z>
name;<z>
;<z>
evaluationContext = evaluationContext;<z>
RequestAttributes getFacesRequestAttributes() {<z>
FacesContext facesContext = FacesContext.getCurrentInstance();<z>
) : null);<z>
(NoClassDefFoundError err) {<z>
return null;<z>
(<z>
dstFrame, final int catchTypeIndex) {<z>
boolean frameChanged = false;<z>
int numLocal = inputLocals.length;<z>
;<z>
inputLocals == null) {<z>
= new int[numLocal];<z>
frameChanged = true;<z>
) {<z>
;<z>
.length) {<z>
[i];<z>
0) {<z>
concreteOutputType = inputLocals[i];<z>
{<z>
;<z>
} else {<z>
;<z>
(initializations != null) {<z>
getInitializedType(symbolTable, concreteOutputType);<z>
;<z>
0) {<z>
i < numLocal; ++i) {<z>
, dstFrame.inputLocals, i);<z>
if (dstFrame.inputStack == null) {<z>
= new int[1];<z>
true;<z>
, dstFrame.inputStack, 0);<z>
frameChanged;<z>
+ outputStackStart;<z>
null) {<z>
[numInputStack + outputStackTop];<z>
= true;<z>
< numInputStack; ++i) {<z>
[i];<z>
if (initializations != null) {<z>
getInitializedType(symbolTable, concreteOutputType);<z>
.inputStack, i);<z>
) {<z>
i];<z>
(abstractOutputType, numStack);<z>
) {<z>
getInitializedType(symbolTable, concreteOutputType);<z>
i);<z>
frameChanged;<z>
char separator) {<z>
);<z>
this.regex = regex;<z>
caseSensitive;<z>
= buildPattern(regex, completePattern);<z>
... componentClasses) {<z>
this();<z>
(componentClasses);<z>
();<z>
(Object value) {<z>
&&<z>
.stream()<z>
);<z>
Object handler)<z>
IOException {<z>
{<z>
{<z>
isUserInRole(role)) {<z>
return true;<z>
);<z>
return false;<z>
{<z>
;<z>
< 0) {<z>
return -1;<z>
.writerIndex() - 1);<z>
)::test);<z>
int annotationHashCode() {<z>
hashCode = this.hashCode;<z>
) {<z>
;<z>
this.hashCode = hashCode;<z>
;<z>
) {<z>
(beanFactory, "BeanFactory must not be null");<z>
;<z>
{<z>
this.resourceFactory = beanFactory;<z>
) {<z>
= new EmbeddedValueResolver(configurableBeanFactory);<z>
getConfigurableWebBindingInitializer(<z>
FormattingConversionService mvcConversionService, Validator mvcValidator) {<z>
initializer = new ConfigurableWebBindingInitializer();<z>
;<z>
;<z>
messageCodesResolver = getMessageCodesResolver();<z>
{<z>
);<z>
initializer;<z>
<ResourceRegion> resourceRegions,<z>
{<z>
notNull(resourceRegions, "Collection of ResourceRegion should not be null");<z>
outputMessage.getHeaders();<z>
();<z>
);<z>
(HttpHeaders.CONTENT_TYPE, "multipart/byteranges; boundary=" + boundaryString);<z>
= outputMessage.getBody();<z>
;<z>
= null;<z>
= 0;<z>
region : resourceRegions) {<z>
- inputStreamPosition;<z>
|| resource != region.getResource()) {<z>
{<z>
close();<z>
.getResource();<z>
getInputStream();<z>
= 0;<z>
;<z>
1;<z>
(out);<z>
+ boundaryString);<z>
println(out);<z>
!= null) {<z>
+ contentType);<z>
(out);<z>
).contentLength();<z>
resourceLength - inputStreamPosition - 1);<z>
print(out, "Content-Range: bytes " +<z>
+ region.getCount() - 1) +<z>
;<z>
;<z>
out);<z>
out, start, end);<z>
inputStreamPosition += (end + 1);<z>
) {<z>
.close();<z>
(IOException ex) {<z>
out);<z>
;<z>
void setSession(Session session) {<z>
);<z>
this.newSessionHolder = true;<z>
newSession = true;<z>
String qName, Attributes attributes) {<z>
parent = getParent();<z>
uri, qName);<z>
{<z>
String attrUri = attributes.getURI(i);<z>
(i);<z>
);<z>
"xmlns")) {<z>
);<z>
element);<z>
(element);<z>
public long getDelay(TimeUnit unit) {<z>
?> curr;<z>
) {<z>
;<z>
unit);<z>
<?> targetType) {<z>
= getCurrentProxiedBeanName();<z>
) {<z>
FuzzyBoolean.MAYBE;<z>
{<z>
.NO;<z>
(targetType != null) {<z>
= FactoryBean.class.isAssignableFrom(targetType);<z>
fromBoolean(<z>
FACTORY_BEAN_PREFIX + advisedBeanName : advisedBeanName));<z>
.fromBoolean(matchesBean(advisedBeanName) ||<z>
(BeanFactory.FACTORY_BEAN_PREFIX + advisedBeanName));<z>
throws JMException {<z>
AopUtils.getTargetClass(bean);<z>
bean.getClass()) {<z>
.getMXBeanInterface(targetClass);<z>
null) {<z>
bean)) {<z>
+ bean +<z>
;<z>
>) ifc), true);<z>
JmxUtils.getMBeanInterface(targetClass);<z>
!= null) {<z>
(bean)) {<z>
NotCompliantMBeanException("Managed bean [" + bean +<z>
;<z>
;<z>
return null;<z>
(@Nullable String contentType) {<z>
contentType;<z>
if (contentType != null) {<z>
.parseMediaType(contentType);<z>
{<z>
mediaType.getCharset().name();<z>
{<z>
.indexOf(CHARSET_PREFIX);<z>
-1) {<z>
+ CHARSET_PREFIX.length());<z>
;<z>
) throws IOException {<z>
("data:");<z>
).write(builderBytes());<z>
getClass();<z>
> converter : this.messageConverters) {<z>
(dataClass, MediaType.APPLICATION_JSON)) {<z>
>) converter;<z>
this.outputMessage);<z>
);<z>
().write(NL_NL);<z>
);<z>
IOException ex) {<z>
= true;<z>
ex;<z>
0);<z>
) {<z>
== NONE) {<z>
;<z>
;<z>
(ResolvableType generic : generics) {<z>
&& !generic.isWildcardWithoutBounds()) {<z>
;<z>
true;<z>
Class<?> staticClass,<z>
{<z>
methodExecutor;<z>
.staticClass = staticClass;<z>
;<z>
argumentTypes;<z>
conversionHint) {<z>
classes = annotation.value();<z>
.length != 1) {<z>
(<z>
"@JsonView only supported for handler methods with exactly 1 class argument: " + conversionHint);<z>
[0];<z>
{<z>
afterPropertiesSet();<z>
{<z>
this.proxyInterface = getManagementInterface();<z>
proxyInterface == null) {<z>
new IllegalArgumentException("Property 'proxyInterface' or 'managementInterface' is required");<z>
{<z>
;<z>
).getProxy(this.beanClassLoader);<z>
Object key) {<z>
?<z>
+ key + PropertyAccessor.PROPERTY_KEY_SUFFIX :<z>
;<z>
String transformedBeanName(String name) {<z>
, "'name' must not be null");<z>
(BeanFactory.FACTORY_BEAN_PREFIX)) {<z>
return name;<z>
(name, beanName -> {<z>
length());<z>
.startsWith(BeanFactory.FACTORY_BEAN_PREFIX));<z>
beanName;<z>
);<z>
DataBuffer dataBuffer) {<z>
(this.maxInMemorySize > 0) {<z>
.byteCount) {<z>
();<z>
byteCount += dataBuffer.readableByteCount();<z>
RSocketStrategies strategies, Object... candidateHandlers) {<z>
notEmpty(candidateHandlers, "No handlers");<z>
);<z>
candidateHandlers) {<z>
) : obj);<z>
();<z>
(handlers);<z>
;<z>
handler.afterPropertiesSet();<z>
;<z>
<?> clazz, HttpInputMessage inputMessage)<z>
, HttpMessageNotReadableException {<z>
;<z>
(URI uri) {<z>
();<z>
uri(uri);<z>
builder;<z>
> responseType,<z>
) throws RestClientException {<z>
responseType);<z>
responseExtractor =<z>
getMessageConverters(), logger);<z>
;<z>
registration) {<z>
);<z>
if (this.pathHelper != null) {<z>
handler.setUrlPathHelper(this.pathHelper);<z>
.contentNegotiationManager != null) {<z>
contentNegotiationManager);<z>
(this.servletContext);<z>
applicationContext);<z>
.afterPropertiesSet();<z>
ex) {<z>
("Failed to init ResourceHttpRequestHandler", ex);<z>
return handler;<z>
@Nullable String origin) {<z>
StringUtils.hasText(origin)) {<z>
;<z>
origin);<z>
) {<z>
ALL)) {<z>
();<z>
;<z>
for (String allowedOrigin : this.allowedOrigins) {<z>
{<z>
return origin;<z>
allowedOriginPatterns)) {<z>
OriginPattern p : this.allowedOriginPatterns) {<z>
matches()) {<z>
return origin;<z>
return null;<z>
serverCodecConfigurer() {<z>
;<z>
(serverCodecConfigurer);<z>
serverCodecConfigurer;<z>
Scope scope) {<z>
scopeName, "Scope identifier must not be null");<z>
(scope, "Scope must not be null");<z>
)) {<z>
new IllegalArgumentException("Cannot replace existing scopes 'singleton' and 'prototype'");<z>
(scopeName, scope);<z>
(previous != null && previous != scope) {<z>
) {<z>
+ previous + "] to [" + scope + "]");<z>
if (logger.isTraceEnabled()) {<z>
+ "' with implementation [" + scope + "]");<z>
initWebApplicationContext() {<z>
WebApplicationContext rootContext =<z>
WebApplicationContextUtils.getWebApplicationContext(getServletContext());<z>
wac = null;<z>
null) {<z>
;<z>
&& !cwac.isActive()) {<z>
(cwac.getParent() == null) {<z>
);<z>
(cwac);<z>
) {<z>
();<z>
if (wac == null) {<z>
wac = createWebApplicationContext(rootContext);<z>
this.refreshEventReceived) {<z>
onRefreshMonitor) {<z>
wac);<z>
.publishContext) {<z>
attrName = getServletContextAttributeName();<z>
(attrName, wac);<z>
wac;<z>
filters) {<z>
servlet, "DispatcherServlet is required");<z>
"Filters cannot be null");<z>
(filters, "Filters cannot contain null values");<z>
servlet = servlet;<z>
.filters = filters;<z>
= servlet.getServletContext();<z>
candidates) {<z>
[candidates.size()];<z>
;<z>
candidate : candidates) {<z>
) candidate) :<z>
(candidate));<z>
++;<z>
return batch;<z>
read(ResolvableType elementType,<z>
String, Object> hints) {<z>
elementType, message, hints));<z>
Validator webFluxValidator() {<z>
Validator validator = getValidator();<z>
{<z>
getClassLoader())) {<z>
Class<?> clazz;<z>
= "org.springframework.validation.beanvalidation.OptionalValidatorFactoryBean";<z>
.getClassLoader());<z>
ex) {<z>
BeanInitializationException("Failed to resolve default validator class", ex);<z>
;<z>
);<z>
validator;<z>
maybeEatIndexer() {<z>
);<z>
, true)) {<z>
false;<z>
t != null, "No token");<z>
;<z>
state(expr != null, "No node");<z>
RSQUARE);<z>
);<z>
return true;<z>
compareTo(ProducesRequestCondition other, HttpServletRequest request) {<z>
MediaType> acceptedMediaTypes = getAcceptedMediaTypes(request);<z>
for (MediaType acceptedMediaType : acceptedMediaTypes) {<z>
int thisIndex = this.indexOfEqualMediaType(acceptedMediaType);<z>
other.indexOfEqualMediaType(acceptedMediaType);<z>
otherIndex);<z>
) {<z>
return result;<z>
.indexOfIncludedMediaType(acceptedMediaType);<z>
;<z>
thisIndex, other, otherIndex);<z>
) {<z>
return result;<z>
0;<z>
{<z>
IllegalStateException("Cannot compare without having any requested media types", ex);<z>
void appendDirective(StringBuilder builder, String value) {<z>
length() > 0) {<z>
;<z>
;<z>
messageConverters,<z>
manager) {<z>
);<z>
initSseConverters(messageConverters);<z>
executor, manager);<z>
static HttpStatus resolve(int statusCode) {<z>
VALUES) {<z>
if (status.value == statusCode) {<z>
status;<z>
return null;<z>
String> queryParam(String name) {<z>
);<z>
isEmpty(queryParamValues)) {<z>
.empty();<z>
0);<z>
(value == null) {<z>
= "";<z>
(value);<z>
protected void invokeDelegate(<z>
FilterChain filterChain)<z>
{<z>
, response, filterChain);<z>
> process(<z>
) {<z>
repeatableContainers.findRepeatedAnnotations(annotation);<z>
if (repeatedAnnotations != null) {<z>
, source, repeatedAnnotations);<z>
AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(<z>
, repeatableContainers, annotationFilter);<z>
); i++) {<z>
i);<z>
) {<z>
TypeMappedAnnotation.createIfPossible(<z>
, IntrospectionFailureLogger.INFO);<z>
.predicate.test(candidate))) {<z>
selector.isBestCandidate(candidate)) {<z>
;<z>
updateLastResult(candidate);<z>
return null;<z>
,<z>
InetSocketAddress remoteAddress,<z>
logPrefix) {<z>
remoteAddress, attributes, logPrefix);<z>
(HttpServletRequest request) {<z>
;<z>
(this.value != null) {<z>
matchValue(request);<z>
;<z>
return this.isNegated != isMatch;<z>
handleMissingServletRequestPart(<z>
HttpStatus status, WebRequest request) {<z>
);<z>
? extends Publisher<Void>> writeAction) {<z>
NEW, State.COMMITTING)) {<z>
();<z>
(() -><z>
(() -> {<z>
();<z>
);<z>
.COMMITTED);<z>
;<z>
null) {<z>
add(writeAction);<z>
()<z>
));<z>
.then();<z>
<?>> getPartWriters() {<z>
if (this.multipartCodecs != null) {<z>
getWriters();<z>
.partWritersSupplier != null) {<z>
();<z>
Collections.emptyList();<z>
{<z>
"Attribute name must not be null");<z>
) {<z>
:<z>
remove(name);<z>
REQUEST_SCOPE:<z>
;<z>
case SESSION_SCOPE:<z>
getSession().removeAttribute(name);<z>
:<z>
servletContext.removeAttribute(name);<z>
+ scope);<z>
String text) throws IllegalArgumentException {<z>
.setAsText(text);<z>
);<z>
: null);<z>
IOException ex) {<z>
ex);<z>
String type2) {<z>
();<z>
;<z>
), false, classLoader);<z>
(ClassNotFoundException e) {<z>
, e);<z>
> class2;<z>
);<z>
{<z>
TypeNotPresentException(type2, e);<z>
class1.isAssignableFrom(class2)) {<z>
;<z>
) {<z>
return type2;<z>
() || class2.isInterface()) {<z>
;<z>
{<z>
;<z>
(!class1.isAssignableFrom(class2));<z>
.replace('.', '/');<z>
{<z>
Assert.hasText(placeholder, "Placeholder must not be empty!");<z>
) {<z>
{<z>
placeholder);<z>
identifiablePlaceholders() {<z>
false;<z>
throws IOException {<z>
.tryLock()) {<z>
while (true) {<z>
.buffer.poll();<z>
shouldNotSend()) {<z>
message.getPayloadLength());<z>
sendStartTime = System.currentTimeMillis();<z>
getDelegate().sendMessage(message);<z>
this.sendStartTime = 0;<z>
= 0;<z>
);<z>
true;<z>
return false;<z>
(MutablePersistenceUnitInfo pui) {<z>
);<z>
{<z>
postProcessors) {<z>
postProcessor.postProcessPersistenceUnitInfo(pui);<z>
, Object... args) throws BeanInstantiationException {<z>
"Constructor must not be null");<z>
makeAccessible(ctor);<z>
ctor.getDeclaringClass())) {<z>
, args);<z>
();<z>
.length, "Can't specify more arguments than constructor parameters");<z>
= new Object[args.length];<z>
; i++) {<z>
[i] == null) {<z>
parameterTypes[i];<z>
null);<z>
args[i];<z>
;<z>
(InstantiationException ex) {<z>
ctor, "Is it an abstract class?", ex);<z>
ex) {<z>
, ex);<z>
{<z>
);<z>
catch (InvocationTargetException ex) {<z>
"Constructor threw exception", ex.getTargetException());<z>
> parseDocument(<z>
) throws IOException {<z>
persistence = document.getDocumentElement();<z>
= persistence.getAttribute(PERSISTENCE_VERSION);<z>
= determinePersistenceUnitRootUrl(resource);<z>
;<z>
) {<z>
);<z>
;<z>
SpelNodeImpl... operands) {<z>
"++", startPos, endPos, operands);<z>
postfix;<z>
, "Operands must not be empty");<z>
{<z>
this.type);<z>
builder.append('/');<z>
builder.append(this.subtype);<z>
appendTo(this.parameters, builder);<z>
hookOnError(Throwable throwable) {<z>
.set(throwable);<z>
) {<z>
throwable);<z>
private boolean checkHttpMethod(String currentMethod) {<z>
();<z>
{<z>
true;<z>
configuredMethod : configuredMethods) {<z>
currentMethod)) {<z>
;<z>
return false;<z>
final int computeAttributesSize(<z>
SymbolTable symbolTable,<z>
final byte[] code,<z>
codeLength,<z>
int maxStack,<z>
final int maxLocals) {<z>
ClassWriter classWriter = symbolTable.classWriter;<z>
= 0;<z>
attribute = this;<z>
) {<z>
symbolTable.addConstantUtf8(attribute.type);<z>
, maxStack, maxLocals).length;<z>
.nextAttribute;<z>
return size;<z>
?> attributesSnapshot) {<z>
);<z>
);<z>
)) {<z>
nextElement();<z>
DEFAULT_STRATEGIES_PREFIX)) {<z>
add(attrName);<z>
String>) attributesSnapshot.keySet());<z>
String attrName : attrsToCheck) {<z>
.get(attrName);<z>
null) {<z>
.removeAttribute(attrName);<z>
attrName)) {<z>
;<z>
) throws ScriptException {<z>
(connection, "Connection must not be null");<z>
.concatMap(resource -> {<z>
;<z>
this.dataBufferFactory, this.continueOnError,<z>
this.separator, this.blockCommentStartDelimiter,<z>
;<z>
;<z>
viewControllerHandlerMapping(<z>
Qualifier("mvcConversionService") FormattingConversionService conversionService,<z>
@Qualifier("mvcResourceUrlProvider") ResourceUrlProvider resourceUrlProvider) {<z>
applicationContext);<z>
);<z>
handlerMapping = registry.buildHandlerMapping();<z>
if (handlerMapping == null) {<z>
return null;<z>
();<z>
null) {<z>
));<z>
);<z>
());<z>
;<z>
());<z>
;<z>
> messageSupplier) {<z>
expression) {<z>
nullSafeGet(messageSupplier));<z>
Nullable String text) throws IllegalArgumentException {<z>
;<z>
null) {<z>
);<z>
IOException ex) {<z>
(<z>
ex);<z>
(props);<z>
final @Nullable V newValue) {<z>
.RESTRUCTURE_BEFORE, TaskOption.SKIP_IF_EMPTY) {<z>
) {<z>
.getValue(), oldValue)) {<z>
.setValue(newValue);<z>
true;<z>
;<z>
;<z>
.TRUE.equals(result));<z>
HttpServletRequest request, AsyncContext asyncContext,<z>
bufferSize)<z>
URISyntaxException {<z>
servletPath, bufferFactory, bufferSize);<z>
(FacesContext fc) {<z>
);<z>
.getExternalContext();<z>
).get(WebUtils.SESSION_MUTEX_ATTRIBUTE);<z>
== null) {<z>
getSession(true);<z>
mutex;<z>
) {<z>
= new HashMap<>();<z>
.knownAttributeNames) {<z>
request, name);<z>
null) {<z>
);<z>
attributes;<z>
{<z>
() == null) {<z>
return 0;<z>
1] > 0) {<z>
], getHeartbeatValue()[1]);<z>
] : getHeartbeatValue()[1]);<z>
public ConcurrentWebSocketSessionDecorator(<z>
overflowStrategy) {<z>
delegate);<z>
sendTimeLimit;<z>
.bufferSizeLimit = bufferSizeLimit;<z>
= overflowStrategy;<z>
ClassNotFoundException {<z>
!this.acceptProxyClasses) {<z>
NotSerializableException("Not allowed to accept serialized proxy classes");<z>
null) {<z>
>[interfaces.length];<z>
.length; i++) {<z>
i], this.classLoader);<z>
{<z>
;<z>
resolvedInterfaces, this.classLoader);<z>
) {<z>
ClassNotFoundException(null, ex);<z>
resolveProxyClass(interfaces);<z>
catch (ClassNotFoundException ex) {<z>
];<z>
++) {<z>
interfaces[i], ex);<z>
;<z>
String attributeName) {<z>
;<z>
) {<z>
new NoSuchElementException("No element at attribute index "<z>
+ attributeIndex + " for name " + attributeName);<z>
return value;<z>
> clazz2) {<z>
(clazz1 == null) {<z>
clazz2;<z>
(clazz2 == null) {<z>
return clazz1;<z>
isAssignableFrom(clazz2)) {<z>
clazz1;<z>
) {<z>
;<z>
> ancestor = clazz1;<z>
;<z>
{<z>
null;<z>
));<z>
ancestor;<z>
{<z>
Properties entityReferences = new Properties();<z>
PROPERTIES_FILE);<z>
null) {<z>
throw new IllegalStateException(<z>
"Cannot find reference definition file [HtmlCharacterEntityReferences.properties] as class path resource");<z>
.load(is);<z>
close();<z>
catch (IOException ex) {<z>
IllegalStateException(<z>
.getMessage());<z>
keys = entityReferences.propertyNames();<z>
) {<z>
;<z>
key);<z>
&& referredChar < 10000)),<z>
referredChar);<z>
referredChar - 7000);<z>
String reference = entityReferences.getProperty(key);<z>
[index] = REFERENCE_START + reference + REFERENCE_END;<z>
, (char) referredChar);<z>
<? super Node> matcher) {<z>
{<z>
.getResponse();<z>
matcher);<z>
) {<z>
(name);<z>
cookie == null) {<z>
this.exchangeResult.assertWithDiagnostics(() -><z>
));<z>
cookie);<z>
findDefaultScheduler() {<z>
(this.beanFactory != null) {<z>
class);<z>
new IllegalStateException(<z>
);<z>
throws InvalidResultSetAccessException {<z>
column);<z>
) {<z>
se);<z>
public void stop() {<z>
isRunning()) {<z>
instanceof Lifecycle) {<z>
.webSocketClient).stop();<z>
this.running = false;<z>
{<z>
.class);<z>
(ann != null, "No RequestHeader annotation");<z>
;<z>
Object source) {<z>
, "Name must not be null");<z>
name = name;<z>
= source;<z>
, String redirectUrl) {<z>
Assert.notNull(urlPath, "'urlPath' is required.");<z>
notNull(redirectUrl, "'redirectUrl' is required.");<z>
this.urlPath = urlPath;<z>
redirectView = new RedirectView(redirectUrl);<z>
;<z>
controller.setView(this.redirectView);<z>
resourceName, @Nullable ClassLoader classLoader) throws IOException {<z>
);<z>
= classLoader;<z>
null) {<z>
);<z>
:<z>
ClassLoader.getSystemResources(resourceName));<z>
Properties();<z>
while (urls.hasMoreElements()) {<z>
;<z>
);<z>
(con);<z>
{<z>
)) {<z>
{<z>
;<z>
loadFromXML(is);<z>
load(is);<z>
props;<z>
) {<z>
();<z>
getSession(true);<z>
;<z>
null) {<z>
: externalContext);<z>
mutex;<z>
beanFactory) {<z>
servletConfig));<z>
ignoreDependencyInterface(ServletContextAware.class);<z>
.class);<z>
registerWebApplicationScopes(beanFactory, this.servletContext);<z>
servletContext, this.servletConfig);<z>
merge(@Nullable Object parent) {<z>
parent instanceof RequestBuilder) {<z>
if (parent instanceof MockHttpServletRequestBuilder) {<z>
MockHttpServletRequestBuilder copiedParent = MockMvcRequestBuilders.get("/");<z>
copiedParent.merge(parent);<z>
= copiedParent;<z>
this.parentBuilder = (RequestBuilder) parent;<z>
if (parent instanceof SmartRequestBuilder) {<z>
(SmartRequestBuilder) parent;<z>
this;<z>
Object arg, MethodParameter parameter) {<z>
.getParameterType() == Optional.class) {<z>
isEmpty()) ||<z>
) arg).length == 0)) {<z>
return Optional.empty();<z>
Optional.of(arg);<z>
;<z>
(@Nullable MimeType other) {<z>
if (other == null) {<z>
return false;<z>
)) {<z>
;<z>
))) {<z>
))) {<z>
return true;<z>
()) {<z>
.lastIndexOf('+');<z>
if (thisPlusIdx == -1) {<z>
true;<z>
).lastIndexOf('+');<z>
if (otherPlusIdx != -1) {<z>
thisPlusIdx);<z>
thisPlusIdx + 1);<z>
);<z>
(thisSubtypeNoSuffix)) {<z>
true;<z>
;<z>
exposedHeader) {<z>
null) {<z>
4);<z>
this.exposedHeaders.add(exposedHeader);<z>
) {<z>
(name);<z>
StringUtils.hasLength(name)) {<z>
.uncapitalize(name));<z>
) {<z>
capitalize(name));<z>
return pd;<z>
(<z>
, ServerWebExchange exchange) {<z>
-> {<z>
= getEngine();<z>
= getUrl();<z>
!= null, "'url' not set");<z>
String template = getTemplate(url);<z>
templateLoader = path -> {<z>
return getTemplate(path);<z>
(IOException ex) {<z>
new IllegalStateException(ex);<z>
getLocaleContext());<z>
context = new RenderingContext(<z>
), locale, templateLoader, url);<z>
html;<z>
if (this.renderFunction == null) {<z>
;<z>
bindings.putAll(model);<z>
"renderingContext", context);<z>
(template, bindings);<z>
else if (this.renderObject != null) {<z>
;<z>
model, context);<z>
);<z>
.UTF_8);<z>
;<z>
catch (ScriptException ex) {<z>
));<z>
ex) {<z>
;<z>
}));<z>
public boolean matches(HttpServletRequest request) {<z>
request);<z>
) {<z>
path = path.toString();<z>
(path instanceof PathContainer);<z>
)) {<z>
for (PatternAdapter adapter : this.excludePatterns) {<z>
)) {<z>
false;<z>
includePatterns)) {<z>
return true;<z>
{<z>
this.pathMatcher)) {<z>
return true;<z>
false;<z>
> getAllowedMethods() {<z>
return this.partialMatches.stream().<z>
.<z>
)).<z>
);<z>
sourceType, TypeDescriptor targetType) {<z>
isAssignableTo(BYTE_BUFFER_TYPE);<z>
(sourceType.isAssignableTo(BYTE_BUFFER_TYPE)) {<z>
return (byteBufferTarget || matchesFromByteBuffer(targetType));<z>
));<z>
{<z>
new LinkedHashSet<>();<z>
.isEmpty()) {<z>
patterns) {<z>
other.patterns) {<z>
(pattern1, pattern2));<z>
!this.patterns.isEmpty()) {<z>
patterns);<z>
()) {<z>
result.addAll(other.patterns);<z>
"");<z>
DestinationPatternsMessageCondition(result, this.routeMatcher);<z>
void assertHttpMethod(String method) {<z>
)) {<z>
equalsIgnoreCase(method)) {<z>
);<z>
message, String statusText,<z>
@Nullable Charset charset) {<z>
);<z>
void activate() throws IllegalStateException, NamingException {<z>
.info("Activating simple JNDI environment");<z>
) {<z>
if (!initialized) {<z>
!NamingManager.hasInitialContextFactoryBuilder(),<z>
;<z>
;<z>
initialized = true;<z>
;<z>
static MessageSource getJstlAwareMessageSource(<z>
MessageSource messageSource) {<z>
{<z>
(Config.FMT_LOCALIZATION_CONTEXT);<z>
if (jstlInitParam != null) {<z>
= new ResourceBundleMessageSource();<z>
setBasename(jstlInitParam);<z>
messageSource);<z>
return jstlBundleWrapper;<z>
;<z>
() {<z>
getApplicationContext();<z>
if (context == null) {<z>
) {<z>
context);<z>
context);<z>
beans));<z>
Builder executeFunction(ExecuteFunction executeFunction) {<z>
.notNull(executeFunction, "ExecuteFunction must not be null");<z>
this.executeFunction = executeFunction;<z>
;<z>
(Object value) {<z>
) {<z>
;<z>
;<z>
{<z>
.equals(messageBytes)) {<z>
return true;<z>
;<z>
) {<z>
{<z>
().add("requestBodyAdvice",<z>
);<z>
repeatable) {<z>
repeatable.getAnnotation(Repeatable.class);<z>
annotation, () -> "Annotation type must be a repeatable annotation: " +<z>
repeatable.getName());<z>
return annotation.value();<z>
metadataReaderFactory)<z>
{<z>
(matchSelf(metadataReader)) {<z>
return true;<z>
metadataReader.getClassMetadata();<z>
))) {<z>
true;<z>
this.considerInherited) {<z>
.getSuperClassName();<z>
superClassName != null) {<z>
superClassMatch = matchSuperClass(superClassName);<z>
superClassMatch != null) {<z>
) {<z>
;<z>
{<z>
;<z>
ex) {<z>
)) {<z>
("Could not read super class [" + metadata.getSuperClassName() +<z>
"]");<z>
considerInterfaces) {<z>
.getInterfaceNames()) {<z>
Boolean interfaceMatch = matchInterface(ifc);<z>
null) {<z>
booleanValue()) {<z>
return true;<z>
ifc, metadataReaderFactory)) {<z>
return true;<z>
) {<z>
(logger.isDebugEnabled()) {<z>
+<z>
);<z>
false;<z>
SAXException {<z>
);<z>
ex) {<z>
;<z>
{<z>
ex.getLocation());<z>
(), locator, ex);<z>
if (getErrorHandler() != null) {<z>
;<z>
;<z>
DataBuffer> input, ResolvableType elementType,<z>
<String, Object> hints) {<z>
) {<z>
= new AaltoDataBufferToXmlEvent(this.maxInMemorySize);<z>
Flux.from(input)<z>
(mapper)<z>
(signalType -> mapper.endOfInput());<z>
this.maxInMemorySize)<z>
-> {<z>
asInputStream();<z>
;<z>
();<z>
((XMLEvent) event));<z>
return result;<z>
XMLStreamException ex) {<z>
, ex);<z>
buffer);<z>
;<z>
MethodParameter bodyParameter, boolean isBodyRequired,<z>
{<z>
exchange);<z>
(PathPattern pattern2string) {<z>
patternString)) {<z>
patternString)) {<z>
("");<z>
;<z>
.hasLength(pattern2string.patternString)) {<z>
;<z>
patternString) && this.capturedVariableCount == 0 &&<z>
{<z>
pattern2string;<z>
endsWithSeparatorWildcard) {<z>
return this.parser.parse(concat(<z>
patternString.length() - 2),<z>
;<z>
("*.");<z>
) == '.') {<z>
patternString));<z>
patternString.substring(starDotPos1 + 1);<z>
= pattern2string.patternString;<z>
= p2string.indexOf('.');<z>
));<z>
.substring(dotPos2));<z>
".*") || firstExtension.isEmpty());<z>
isEmpty());<z>
if (!firstExtensionWild && !secondExtensionWild) {<z>
throw new IllegalArgumentException(<z>
pattern2string);<z>
(firstExtensionWild ? secondExtension : firstExtension));<z>
Session session, Object result) throws JMSException {<z>
= preProcessResponse(result instanceof JmsResponse<z>
: result);<z>
();<z>
converter != null) {<z>
{<z>
(content, session);<z>
converter.toMessage(content, session);<z>
instanceof Message)) {<z>
(<z>
"No MessageConverter specified - cannot handle message [" + content + "]");<z>
return (Message) content;<z>
Object o) {<z>
this.valueLoader.call());<z>
{<z>
(o, this.valueLoader, ex);<z>
protected StringBuilder getOperationDescription() {<z>
(getClass().getSimpleName());<z>
.name);<z>
.append(this.cacheNames);<z>
(this.key);<z>
(this.keyGenerator);<z>
"' | cacheManager='").append(this.cacheManager);<z>
cacheResolver);<z>
.append('\'');<z>
;<z>
other) {<z>
if (this == other) {<z>
true;<z>
!super.equals(other)) {<z>
return false;<z>
other;<z>
uriTemplate, otherEntity.uriTemplate) &&<z>
uriVarsArray) &&<z>
uriVarsMap, otherEntity.uriVarsMap));<z>
status) {<z>
) {<z>
).clear();<z>
(false);<z>
if (this.newSession) {<z>
this.sessionHolder.getSession());<z>
Object other) {<z>
(this == other) {<z>
true;<z>
other instanceof AnnotationConverterKey otherKey)) {<z>
;<z>
annotation));<z>
> fieldType) {<z>
{<z>
;<z>
(fieldType.isArray()) {<z>
getComponentType(), 0);<z>
) {<z>
);<z>
Map.class.isAssignableFrom(fieldType)) {<z>
0);<z>
catch (IllegalArgumentException ex) {<z>
logger.isDebugEnabled()) {<z>
getMessage());<z>
null;<z>
Subscriber<? super Void> subscriber) {<z>
(subscriber, "Subscriber must not be null");<z>
)) {<z>
= new WriteResultSubscription(publisher);<z>
.subscriber = subscriber;<z>
;<z>
changeState(SUBSCRIBING, SUBSCRIBED);<z>
.completedBeforeSubscribed) {<z>
);<z>
= publisher.errorBeforeSubscribed;<z>
null) {<z>
ex);<z>
(toString());<z>
Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {<z>
);<z>
("ignoreInvalidKeys",<z>
"ignore-unresolvable")));<z>
(HttpServletRequest request) {<z>
<ServerResponse> result;<z>
.timeout != null) {<z>
.timeout.toMillis());<z>
>();<z>
-> {<z>
!= null) {<z>
() != null) {<z>
();<z>
);<z>
errorResponse != null) {<z>
result.setResult(errorResponse);<z>
setErrorResult(ex);<z>
result.setResult(value);<z>
;<z>
;<z>
return result;<z>
) {<z>
{<z>
content.resize(size);<z>
void putAttributes(<z>
,<z>
int accessFlags,<z>
int signatureIndex,<z>
final ByteVector output) {<z>
0<z>
) < Opcodes.V1_5) {<z>
)).putInt(0);<z>
signatureIndex != 0) {<z>
Constants.SIGNATURE))<z>
putInt(2)<z>
);<z>
.ACC_DEPRECATED) != 0) {<z>
);<z>
other) {<z>
other == null) {<z>
false;<z>
(other.subtype);<z>
{<z>
this.unitName, false);<z>
(em == null) {<z>
emf = getPersistenceUnit(this.unitName);<z>
== null) {<z>
requestingBeanName);<z>
) {<z>
.createSharedEntityManager(<z>
properties, this.synchronizedWithTransaction);<z>
(<z>
));<z>
;<z>
element, ReaderContext readerCtx) {<z>
.getAttribute(METHOD_ATTRIBUTE);<z>
if (StringUtils.hasText(method)) {<z>
.trim();<z>
hasText(this.method)) {<z>
return this.method;<z>
), element);<z>
null;<z>
void setLoggingPeriod(long period) {<z>
!= null) {<z>
.loggingTask.cancel(true);<z>
.loggingPeriod = period;<z>
initLoggingTask(0);<z>
request, @Nullable ModelAndView mv) throws Exception {<z>
) {<z>
;<z>
null) {<z>
defaultViewName);<z>
[] getArgumentTypes(final String methodDescriptor) {<z>
0;<z>
;<z>
) != ')') {<z>
charAt(currentOffset) == '[') {<z>
currentOffset++;<z>
charAt(currentOffset++) == 'L') {<z>
(';', currentOffset);<z>
;<z>
numArgumentTypes;<z>
= new Type[numArgumentTypes];<z>
;<z>
currentArgumentTypeIndex = 0;<z>
methodDescriptor.charAt(currentOffset) != ')') {<z>
currentArgumentTypeOffset = currentOffset;<z>
== '[') {<z>
++;<z>
.charAt(currentOffset++) == 'L') {<z>
);<z>
+ 1);<z>
currentArgumentTypeIndex++] =<z>
;<z>
return argumentTypes;<z>
Reader getCharacterStream() throws SQLException {<z>
{<z>
new StringReader(this.content);<z>
.characterStream != null) {<z>
;<z>
return new InputStreamReader(<z>
()),<z>
);<z>
(TransportRequest request, WebSocketHandler handler) {<z>
> connectFuture = new SettableListenableFuture<>();<z>
, connectFuture);<z>
));<z>
request.getTransportUrl();<z>
()) {<z>
"Starting XHR " +<z>
);<z>
handshakeHeaders = new HttpHeaders();<z>
request.getHandshakeHeaders());<z>
);<z>
return connectFuture;<z>
) {<z>
{<z>
.getContentType();<z>
, actual);<z>
, MediaType.parseMediaType(actual));<z>
beanKey) {<z>
] params = getOperationParameters(method, beanKey);<z>
== 0) {<z>
method);<z>
ModelMBeanOperationInfo(method.getName(),<z>
,<z>
beanKey),<z>
.getName(),<z>
UNKNOWN);<z>
, FrameType frameType) {<z>
frameType, null);<z>
payload);<z>
int refCount = refCount(dataBuffer);<z>
= MessageBuilder.createMessage(dataBuffer, headers);<z>
))<z>
(s -> {<z>
(refCount(dataBuffer) == refCount) {<z>
;<z>
;<z>
(String attributeName) {<z>
attributeName) &&<z>
attributeName) &&<z>
.equals(attributeName));<z>
String getNamespaceURI(String prefix) {<z>
Assert.notNull(prefix, "No prefix given");<z>
.equals(prefix)) {<z>
;<z>
equals(prefix)) {<z>
return XMLConstants.XMLNS_ATTRIBUTE_NS_URI;<z>
{<z>
.defaultNamespaceUri;<z>
.prefixToNamespaceUri.containsKey(prefix)) {<z>
this.prefixToNamespaceUri.get(prefix);<z>
return "";<z>
isNestedAssignable(@Nullable TypeDescriptor nestedTypeDescriptor,<z>
) {<z>
== null || otherNestedTypeDescriptor == null ||<z>
isAssignableTo(otherNestedTypeDescriptor));<z>
,<z>
@Nullable Object rootAnnotation, ValueExtractor valueExtractor,<z>
Predicate<String> attributeFilter,<z>
) {<z>
this.classLoader = classLoader;<z>
source = source;<z>
rootAttributes = rootAnnotation;<z>
valueExtractor;<z>
this.mapping = mapping;<z>
;<z>
this.useMergedValues = useMergedValues;<z>
attributeFilter;<z>
this.resolvedRootMirrors = resolvedRootMirrors;<z>
= resolvedMirrors;<z>
{<z>
();<z>
, "No MvcResult");<z>
, serverResult);<z>
return new ResultActions() {<z>
matcher) throws Exception {<z>
matcher.match((MvcResult) serverResult);<z>
return this;<z>
andDo(ResultHandler handler) throws Exception {<z>
handler.handle((MvcResult) serverResult);<z>
return this;<z>
() {<z>
return (MvcResult) serverResult;<z>
{<z>
scriptEngineManager = new ScriptEngineManager(this.beanClassLoader);<z>
scriptEngineName != null) {<z>
scriptEngineName);<z>
scriptSource instanceof ResourceScriptSource) {<z>
getFilename();<z>
{<z>
extension = StringUtils.getFilenameExtension(filename);<z>
null) {<z>
ScriptEngine engine = scriptEngineManager.getEngineByExtension(extension);<z>
null) {<z>
return engine;<z>
;<z>
ParameterResolverConfigurer parameterResolver() {<z>
);<z>
parameterBuilder::createResolver);<z>
;<z>
void removeTrailingSlash() {<z>
1;<z>
.charAt(index) == '/') {<z>
;<z>
registerBeanPostProcessors(<z>
<BeanPostProcessor> postProcessors) {<z>
instanceof AbstractBeanFactory) {<z>
AbstractBeanFactory) beanFactory).addBeanPostProcessors(postProcessors);<z>
BeanPostProcessor postProcessor : postProcessors) {<z>
postProcessor);<z>
afterPropertiesSet() {<z>
&& getTargetConnectionFactory() == null) {<z>
("Target Connection or ConnectionFactory is required");<z>
ModelAndViewContainer container) {<z>
(ModelMethod modelMethod : this.modelMethods) {<z>
checkDependencies(container)) {<z>
(modelMethod);<z>
return modelMethod;<z>
= this.modelMethods.get(0);<z>
);<z>
modelMethod;<z>
, HttpServletRequest request, HttpServletResponse response) {<z>
flashMap)) {<z>
flashMap.getTargetRequestPath(), request);<z>
(path);<z>
startExpirationPeriod(getFlashMapTimeout());<z>
getFlashMapsMutex(request);<z>
) {<z>
{<z>
request);<z>
new CopyOnWriteArrayList<>());<z>
(flashMap);<z>
, response);<z>
request);<z>
new ArrayList<>(1));<z>
add(flashMap);<z>
, response);<z>
) {<z>
contains(type)) {<z>
add(type);<z>
) {<z>
.typeHelper.getType(type));<z>
type);<z>
if (superClass != null) {<z>
, superClass);<z>
type).forEach(<z>
stereotypes, i));<z>
{<z>
;<z>
).toGenericString())) {<z>
(logger.isDebugEnabled()) {<z>
formatArgumentError(parameter, exMsg));<z>
(<z>
, @Nullable Class<?> sourceType) {<z>
listener instanceof GenericApplicationListener ?<z>
(listener));<z>
smartListener.supportsSourceType(sourceType));<z>
boolean publicMethodsOnly) {<z>
publicMethodsOnly = publicMethodsOnly;<z>
(jta12Present || ejb3Present) {<z>
(4);<z>
new SpringTransactionAnnotationParser());<z>
(jta12Present) {<z>
;<z>
(ejb3Present) {<z>
;<z>
Collections.singleton(new SpringTransactionAnnotationParser());<z>
extends Annotation> Set<A> getMergedRepeatableAnnotations(<z>
Class<A> annotationType,<z>
containerType) {<z>
annotationType)<z>
)<z>
(MergedAnnotationCollectors.toAnnotationSet());<z>
) {<z>
(url);<z>
);<z>
setPassword(password);<z>
DataBufferFactory factory,<z>
{<z>
(session, info, factory, completionMono);<z>
();<z>
(Map<String, ?> args) {<z>
;<z>
matchInParameterValuesWithInsertColumns(args);<z>
return executeInsertAndReturnKeyInternal(values);<z>
isDefaultJndiEnvironmentAvailable() {<z>
shouldIgnoreDefaultJndiEnvironment) {<z>
return false;<z>
();<z>
return true;<z>
Throwable ex) {<z>
;<z>
() {<z>
DefaultPointcutAdvisor(<z>
() {<z>
method, Class<?> targetClass) {<z>
.equals(String.class);<z>
new TraceBeforeAdvice());<z>
(<z>
@Nullable Object returnValue) {<z>
== target &&<z>
())) {<z>
= proxy;<z>
();<z>
.TYPE && returnType.isPrimitive()) {<z>
(<z>
+ method);<z>
returnValue;<z>
setCorePoolSize(int corePoolSize) {<z>
{<z>
null) {<z>
threadPoolExecutor.setCorePoolSize(corePoolSize);<z>
corePoolSize = corePoolSize;<z>
handleRequest(HttpServletRequest request, HttpServletResponse response)<z>
ServletException, IOException {<z>
= getResource(request);<z>
== null) {<z>
"Resource not found");<z>
.SC_NOT_FOUND);<z>
) {<z>
(HttpHeaders.ALLOW, getAllowHeader());<z>
);<z>
))) {<z>
;<z>
(response);<z>
mediaType = getMediaType(request, resource);<z>
;<z>
);<z>
null) {<z>
.resourceHttpMessageConverter != null, "Not initialized");<z>
.write(resource, mediaType, outputMessage);<z>
resourceRegionHttpMessageConverter != null, "Not initialized");<z>
;<z>
;<z>
SC_PARTIAL_CONTENT);<z>
.write(<z>
);<z>
ex) {<z>
resource.contentLength());<z>
response.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);<z>
PollingSockJsSession createSession(<z>
, Map<String, Object> attributes) {<z>
(), handler, attributes);<z>
HttpServletRequest request, HttpServletResponse response)<z>
Exception {<z>
);<z>
) != null) {<z>
is3xxRedirection()) {<z>
(View.RESPONSE_STATUS_ATTRIBUTE, getStatusCode());<z>
().value());<z>
HttpStatus.NO_CONTENT) && viewName == null) {<z>
;<z>
()) {<z>
null;<z>
ModelAndView();<z>
RequestContextUtils.getInputFlashMap(request));<z>
{<z>
;<z>
setView(getView());<z>
modelAndView;<z>
(int columnIndex) throws InvalidResultSetAccessException {<z>
getLong(columnIndex);<z>
SQLException se) {<z>
InvalidResultSetAccessException(se);<z>
config,<z>
annotated, Class<?> implClass) {<z>
(implClass);<z>
,<z>
{<z>
super(binderMethods, initializer);<z>
?> clazz) {<z>
.autowiredAnnotationTypes)) {<z>
.EMPTY;<z>
elements = new ArrayList<>();<z>
= clazz;<z>
);<z>
.doWithLocalFields(targetClass, field -> {<z>
= findAutowiredAnnotation(field);<z>
(ann != null) {<z>
))) {<z>
isInfoEnabled()) {<z>
);<z>
determineRequiredStatus(ann);<z>
(new AutowiredFieldElement(field, required));<z>
);<z>
targetClass, method -> {<z>
findBridgedMethod(method);<z>
(method, bridgedMethod)) {<z>
);<z>
.getMostSpecificMethod(method, clazz))) {<z>
) {<z>
) {<z>
.info("Autowired annotation is not supported on static methods: " + method);<z>
.getParameterCount() == 0) {<z>
if (logger.isInfoEnabled()) {<z>
.info("Autowired annotation should only be used on methods with parameters: " +<z>
;<z>
determineRequiredStatus(ann);<z>
= BeanUtils.findPropertyForMethod(bridgedMethod, clazz);<z>
));<z>
});<z>
(0, currElements);<z>
;<z>
class);<z>
(elements, clazz);<z>
) {<z>
(mv);<z>
;<z>
).exitTypeDescriptor;<z>
leftPrim = CodeFlow.isPrimitive(leftDesc);<z>
);<z>
enterCompilationScope();<z>
mv, cf);<z>
);<z>
) {<z>
.charAt(0));<z>
cf.enterCompilationScope();<z>
(mv, cf);<z>
exitCompilationScope();<z>
(rightPrim) {<z>
;<z>
'/');<z>
().replace('.', '/');<z>
, "equalityCheck",<z>
;<z>
"Z");<z>
{<z>
()) {<z>
singletonInstance);<z>
public short getShort(int columnIndex) throws InvalidResultSetAccessException {<z>
.getShort(columnIndex);<z>
) {<z>
);<z>
DataBuffer> dataBuffers) {<z>
.notEmpty(dataBuffers, "DataBuffer List must not be empty");<z>
);<z>
1) {<z>
);<z>
(bufferCount);<z>
DataBuffer dataBuffer : dataBuffers) {<z>
dataBuffer);<z>
) dataBuffer).getNativeBuffer());<z>
composite, this);<z>
DataBuffer> generateNewLine(DataBufferFactory bufferFactory) {<z>
Mono.fromCallable(() -> {<z>
DataBuffer buffer = bufferFactory.allocateBuffer(2);<z>
.write((byte)'\r');<z>
)'\n');<z>
;<z>
;<z>
protected void openConnection() {<z>
logger.isInfoEnabled()) {<z>
getUri());<z>
ListenableFuture<WebSocketSession> future =<z>
getUri());<z>
<WebSocketSession>() {<z>
@Nullable WebSocketSession result) {<z>
= result;<z>
;<z>
onFailure(Throwable ex) {<z>
;<z>
);<z>
Annotation> loadAnnotationType(String name) {<z>
>)<z>
());<z>
ex) {<z>
null;<z>
JspException {<z>
= getAction();<z>
getServletRelativeAction();<z>
{<z>
getDisplayString(evaluate(ACTION_ATTRIBUTE, action));<z>
return processAction(action);<z>
StringUtils.hasText(servletRelativeAction)) {<z>
().getPathToServlet();<z>
servletRelativeAction.startsWith("/") &&<z>
))) {<z>
pathToServlet + servletRelativeAction;<z>
(evaluate(ACTION_ATTRIBUTE, servletRelativeAction));<z>
(servletRelativeAction);<z>
);<z>
;<z>
encodePath(requestUri, encoding);<z>
catch (UnsupportedCharsetException ex) {<z>
= this.pageContext.getResponse();<z>
HttpServletResponse) {<z>
encodeURL(requestUri);<z>
getQueryString();<z>
StringUtils.hasText(queryString)) {<z>
"?" + HtmlUtils.htmlEscape(queryString);<z>
{<z>
;<z>
"Attribute 'action' is required. " +<z>
;<z>
headers, @Nullable Object conversionHint) {<z>
(), conversionHint);<z>
)) {<z>
out = new ByteArrayOutputStream(1024);<z>
);<z>
, writer);<z>
writer.flush();<z>
return out.toByteArray();<z>
(payload, resolvedType);<z>
(Exception ex) {<z>
;<z>
?> resolveTargetType(TypedStringValue value) throws ClassNotFoundException {<z>
hasTargetType()) {<z>
;<z>
.getBeanClassLoader());<z>
@Nullable ResolvableType implementationType) {<z>
(field, "Field must not be null");<z>
!= null ? implementationType : NONE);<z>
.getDeclaringClass());<z>
));<z>
, MethodProxy proxy) {<z>
(ReflectionUtils.isObjectMethod(method)) {<z>
object, args);<z>
method;<z>
return null;<z>
> headers,<z>
Nullable HttpMethod method, URI url) {<z>
url, null);<z>
JMSException {<z>
= getTargetConnectionFactory();<z>
TopicConnectionFactory)) {<z>
.jms.IllegalStateException("'targetConnectionFactory' is no TopicConnectionFactory");<z>
;<z>
TopicConnection) getTransactionAwareConnectionProxy(targetConnection);<z>
, MediaType> mediaTypes) {<z>
== null) {<z>
<>(mediaTypes.size());<z>
, type) -><z>
Locale.ENGLISH), type));<z>
{<z>
length()==1) {<z>
)) {<z>
'I':<z>
(IASTORE);<z>
'J':<z>
visitInsn(LASTORE);<z>
case 'F':<z>
mv.visitInsn(FASTORE);<z>
:<z>
DASTORE);<z>
:<z>
BASTORE);<z>
case 'C':<z>
(CASTORE);<z>
'S':<z>
;<z>
'Z':<z>
(BASTORE);<z>
new IllegalArgumentException(<z>
"Unexpected arraytype " + arrayElementType.charAt(0));<z>
mv.visitInsn(AASTORE);<z>
other) {<z>
putAll(other.typedReaders);<z>
.putAll(other.typedWriters);<z>
.objectReaders);<z>
objectWriters);<z>
public Locale resolveLocale(HttpServletRequest request) {<z>
this.localeAttributeName);<z>
null) {<z>
);<z>
return locale;<z>
void registerCustomEditors(PropertyEditorRegistry registry) {<z>
{<z>
PropertyEditorRegistrySupport) registry).useConfigValueEditors();<z>
this.propertyEditorRegistrars.isEmpty()) {<z>
{<z>
.registerCustomEditors(registry);<z>
catch (BeanCreationException ex) {<z>
;<z>
) {<z>
rootCause;<z>
String bceBeanName = bce.getBeanName();<z>
{<z>
logger.isDebugEnabled()) {<z>
() +<z>
));<z>
onSuppressedException(ex);<z>
ex;<z>
()) {<z>
editorClass) -><z>
.instantiateClass(editorClass)));<z>
target, String name) throws AccessException {<z>
);<z>
?>) target;<z>
value = map.get(name);<z>
(name)) {<z>
);<z>
(value);<z>
) {<z>
, "Value must not be empty");<z>
StringUtils.delimitedListToStringArray(value, ",");<z>
];<z>
< fields.length; i++) {<z>
], type);<z>
, type, value);<z>
{<z>
notNull(sessions, "Sessions Map must not be null");<z>
);<z>
"WebRequest must not be null");<z>
sessions = sessions;<z>
this.webClient = webClient;<z>
webRequest;<z>
public Void call() throws Exception {<z>
.writeTo(this.outputStream);<z>
this.outputStream.flush();<z>
return null;<z>
(@Nullable Object other) {<z>
== other) {<z>
return true;<z>
instanceof ConverterCacheKey otherKey)) {<z>
;<z>
equals(otherKey.sourceType)) &&<z>
.equals(otherKey.targetType);<z>
) {<z>
(typeName)) {<z>
;<z>
) {<z>
("java")) {<z>
false;<z>
, getClass().getClassLoader());<z>
getAnnotation(clazz, this.annotationType) :<z>
) != null);<z>
catch (Throwable ex) {<z>
return null;<z>
extends DataBuffer> body) {<z>
Mono.<Void>create(sink -> {<z>
Content content = Flux.from(body)<z>
buffer, sink))<z>
chunks, getContentType()));<z>
;<z>
sink.success();<z>
(doCommit());<z>
) {<z>
|| heartbeat[1] < 0) {<z>
;<z>
heartbeat;<z>
, boolean allowInit) {<z>
getTypeForFactoryBeanFromAttributes(mbd);<z>
.NONE) {<z>
;<z>
)) {<z>
, FactoryBean.class, null, true);<z>
factoryBean);<z>
ResolvableType.NONE);<z>
) {<z>
class)) {<z>
.format("Bean currently in creation on FactoryBean type check: %s", ex));<z>
else if (mbd.isLazyInit()) {<z>
LogMessage.format("Bean creation exception on lazy FactoryBean type check: %s", ex));<z>
("Bean creation exception on eager FactoryBean type check: %s", ex));<z>
onSuppressedException(ex);<z>
.NONE;<z>
NULL_PATH_COMPONENT = new PathComponent() {<z>
{<z>
;<z>
List<String> getPathSegments() {<z>
emptyList();<z>
String> encoder) {<z>
return this;<z>
) {<z>
<String> encoder) {<z>
return this;<z>
void copyToUriComponentsBuilder(UriComponentsBuilder builder) {<z>
other) {<z>
other);<z>
) {<z>
);<z>
InterceptorRegistration addWebRequestInterceptor(WebRequestInterceptor interceptor) {<z>
adapted = new WebRequestHandlerInterceptorAdapter(interceptor);<z>
InterceptorRegistration registration = new InterceptorRegistration(adapted);<z>
registration);<z>
return registration;<z>
) {<z>
.classLoader));<z>
{<z>
ex.getCause());<z>
catch (Throwable ex) {<z>
("Could not invoke Tomcat copy method", ex);<z>
{<z>
getDestination(), "Destination header is required");<z>
receiptId = checkOrAddReceipt(headers);<z>
Receiptable receiptable = new ReceiptHandler(receiptId);<z>
accessor = createHeaderAccessor(StompCommand.SEND);<z>
);<z>
> message = createMessage(accessor, payload);<z>
);<z>
receiptable;<z>
, @Nullable JettyResourceFactory resourceFactory) {<z>
notNull(httpClient, "HttpClient is required");<z>
{<z>
;<z>
());<z>
());<z>
httpClient;<z>
public String toString() {<z>
;<z>
) {<z>
+ "...(truncated)";<z>
, "\n", "\\n");<z>
replace(result, "\r", "\\r");<z>
"'";<z>
{<z>
return String.format("*.%s",<z>
this.extension != null) ?<z>
.extension :<z>
.extensionPredicate);<z>
{<z>
;<z>
(validationModeToUse != VALIDATION_AUTO) {<z>
return validationModeToUse;<z>
resource);<z>
if (detectedMode != VALIDATION_AUTO) {<z>
;<z>
VALIDATION_XSD;<z>
... providers) {<z>
mv != null) {<z>
.visitProvide(service, providers);<z>
userName,<z>
long processingTimeMillis, @Nullable Throwable failureCause) {<z>
processingTimeMillis);<z>
.failureCause = failureCause;<z>
{<z>
();<z>
bd.setScope(BeanDefinition.SCOPE_PROTOTYPE);<z>
bd.setBeanClass(clazz);<z>
().registerBeanDefinition(name, bd);<z>
parsePointcut(Element pointcutElement, ParserContext parserContext) {<z>
id = pointcutElement.getAttribute(ID);<z>
EXPRESSION);<z>
AbstractBeanDefinition pointcutDefinition = null;<z>
;<z>
createPointcutDefinition(expression);<z>
));<z>
String pointcutBeanName = id;<z>
hasText(pointcutBeanName)) {<z>
().registerBeanDefinition(pointcutBeanName, pointcutDefinition);<z>
().registerWithGeneratedName(pointcutDefinition);<z>
parserContext.registerComponent(<z>
);<z>
);<z>
return pointcutDefinition;<z>
long getTimeToLiveInMillis() throws TransactionTimedOutException{<z>
(this.deadline == null) {<z>
new IllegalStateException("No timeout specified for this resource holder");<z>
getTime() - System.currentTimeMillis();<z>
(timeToLive <= 0);<z>
return timeToLive;<z>
) {<z>
().getSimpleName());<z>
targetBeanName).append('\'');<z>
.targetClass != null) {<z>
(']');<z>
;<z>
, String name, long defaultVal) {<z>
(name) == null) {<z>
;<z>
getRequiredLongParameter(request, name);<z>
) {<z>
;<z>
void afterPropertiesSet() throws NamingException {<z>
;<z>
if (this.lookupOnStartup) {<z>
= lookup();<z>
{<z>
= object;<z>
);<z>
) {<z>
>(30);<z>
RequestParamMethodArgumentResolver(getBeanFactory(), false));<z>
);<z>
resolvers.add(new PathVariableMethodArgumentResolver());<z>
add(new PathVariableMapMethodArgumentResolver());<z>
);<z>
add(new MatrixVariableMapMethodArgumentResolver());<z>
;<z>
this.requestResponseBodyAdvice));<z>
getMessageConverters(), this.requestResponseBodyAdvice));<z>
new RequestHeaderMethodArgumentResolver(getBeanFactory()));<z>
.add(new RequestHeaderMapMethodArgumentResolver());<z>
()));<z>
ExpressionValueMethodArgumentResolver(getBeanFactory()));<z>
SessionAttributeMethodArgumentResolver());<z>
(new RequestAttributeMethodArgumentResolver());<z>
new ServletRequestMethodArgumentResolver());<z>
add(new ServletResponseMethodArgumentResolver());<z>
requestResponseBodyAdvice));<z>
());<z>
));<z>
);<z>
.add(new ErrorsMethodArgumentResolver());<z>
new SessionStatusMethodArgumentResolver());<z>
));<z>
(KotlinDetector.isKotlinPresent()) {<z>
ContinuationHandlerMethodArgumentResolver());<z>
getCustomArgumentResolvers() != null) {<z>
getCustomArgumentResolvers());<z>
.add(new PrincipalMethodArgumentResolver());<z>
;<z>
(new ServletModelAttributeMethodProcessor(true));<z>
return resolvers;<z>
method) {<z>
)) {<z>
);<z>
) {<z>
return true;<z>
;<z>
Object[] args) throws Throwable {<z>
)) {<z>
"equals":<z>
[0];<z>
(other instanceof Type) {<z>
= unwrap((Type) other);<z>
);<z>
case "hashCode":<z>
.getType());<z>
"getTypeProvider":<z>
return this.provider;<z>
&& ObjectUtils.isEmpty(args)) {<z>
1));<z>
)) {<z>
;<z>
; i++) {<z>
i));<z>
;<z>
getType(), args);<z>
InvocationTargetException ex) {<z>
();<z>
(<z>
ParameterizedTypeReference<T> typeReference) {<z>
;<z>
)<z>
{<z>
;<z>
);<z>
streamingOutputMessage) {<z>
(t, new HttpOutputMessage() {<z>
() {<z>
;<z>
) {<z>
return headers;<z>
);<z>
);<z>
;<z>
protected void adviceChanged() {<z>
();<z>
{<z>
logger.debug("Advice has changed; re-caching singleton instance");<z>
) {<z>
= null;<z>
throws InvalidResultSetAccessException {<z>
column);<z>
{<z>
new InvalidResultSetAccessException(se);<z>
ResourceResolverChain resolverChain,<z>
{<z>
DefaultResourceTransformerChain(resolverChain, null, null);<z>
listIterator(transformers.size());<z>
it.hasPrevious()) {<z>
, it.previous(), chain);<z>
chain;<z>
o) {<z>
.remove(o)) {<z>
) o).getKey());<z>
return true;<z>
return false;<z>
defaultServletName) {<z>
(defaultServletName, "defaultServletName must not be null or empty");<z>
.defaultServletName);<z>
this.defaultServletName = defaultServletName;<z>
.defaultServletName));<z>
) {<z>
.allocateBuffer();<z>
;<z>
(delimited) {<z>
());<z>
asOutputStream());<z>
;<z>
return buffer;<z>
) {<z>
, ex);<z>
if (release) {<z>
.release(buffer);<z>
() {<z>
this.distance == 0) {<z>
= this.root.getAttributes();<z>
conventionMappings;<z>
; i++) {<z>
get(i).getName();<z>
getAssigned(i);<z>
int mapped = rootAttributes.indexOf(name);<z>
) && mapped != -1) {<z>
mappings[i] = mapped;<z>
!= null) {<z>
); j++) {<z>
j)] = mapped;<z>
) throws TransactionException {<z>
) {<z>
(<z>
;<z>
)) {<z>
(<z>
"Cannot create nested transaction when not exposing a JDBC transaction");<z>
);<z>
compareTo(ConverterCacheKey other) {<z>
.compareTo(<z>
.toString());<z>
(result == 0) {<z>
compareTo(<z>
.getResolvableType().toString());<z>
result;<z>
) {<z>
{<z>
);<z>
String userName = getUserName();<z>
? userName.toUpperCase() : null);<z>
{<z>
.mutate();<z>
builder);<z>
));<z>
, P publisher, ResolvableType resolvableType) {<z>
;<z>
"'publisher' must not be null");<z>
, "'resolvableType' must not be null");<z>
resolvableType;<z>
checkConfigurationClassCandidate(<z>
beanDef, MetadataReaderFactory metadataReaderFactory) {<z>
getBeanClassName();<z>
null) {<z>
return false;<z>
;<z>
if (beanDef instanceof AnnotatedBeanDefinition &&<z>
))) {<z>
AnnotatedBeanDefinition) beanDef).getMetadata();<z>
beanDef).hasBeanClass()) {<z>
).getBeanClass();<z>
||<z>
isAssignableFrom(beanClass) ||<z>
.isAssignableFrom(beanClass) ||<z>
.isAssignableFrom(beanClass)) {<z>
return false;<z>
(beanClass);<z>
= metadataReaderFactory.getMetadataReader(className);<z>
metadataReader.getAnnotationMetadata();<z>
catch (IOException ex) {<z>
isDebugEnabled()) {<z>
"Could not find class file for introspecting configuration annotations: " +<z>
ex);<z>
false;<z>
(Configuration.class.getName());<z>
("proxyBeanMethods"))) {<z>
, CONFIGURATION_CLASS_FULL);<z>
(metadata)) {<z>
(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);<z>
;<z>
= getOrder(metadata);<z>
{<z>
(ORDER_ATTRIBUTE, order);<z>
true;<z>
{<z>
this.sessionHolder = new SessionHolder(session);<z>
;<z>
.newSession = false;<z>
public void configureBean(Object beanInstance) {<z>
) {<z>
logger.isDebugEnabled()) {<z>
(getClass()) + ": " +<z>
getDescriptiveType(beanInstance) + "]. Proceeding without injection.");<z>
BeanWiringInfoResolver bwiResolver = this.beanWiringInfoResolver;<z>
!= null, "No BeanWiringInfoResolver available");<z>
bwiResolver.resolveWiringInfo(beanInstance);<z>
) {<z>
= this.beanFactory;<z>
beanFactory != null, "No BeanFactory available");<z>
;<z>
) && beanName != null &&<z>
!beanFactory.containsBean(beanName))) {<z>
getDependencyCheck());<z>
beanName : ""));<z>
? beanName : ""));<z>
) {<z>
Throwable rootCause = ex.getMostSpecificCause();<z>
(rootCause instanceof BeanCurrentlyInCreationException) {<z>
bce = (BeanCreationException) rootCause;<z>
.getBeanName();<z>
bceBeanName)) {<z>
.isDebugEnabled()) {<z>
debug("Failed to create target bean '" + bce.getBeanName() +<z>
.getClass().getName() +<z>
"and usually not fatal. Proceeding without injection. Original exception: " + ex);<z>
throw ex;<z>
, Object... inserts) {<z>
;<z>
this.position = pos;<z>
;<z>
messageType;<z>
inserts;<z>
(<z>
{<z>
(responseProcessor, "ResponseProcessor must not be null");<z>
) -> next.handle(request)<z>
, serverResponse)));<z>
setAllowNullValues(boolean allowNullValues) {<z>
(allowNullValues != this.allowNullValues) {<z>
= allowNullValues;<z>
();<z>
) throws JMSException {<z>
);<z>
;<z>
con instanceof QueueConnection) {<z>
createQueueSession(transacted, ackMode);<z>
.pubSubMode) && con instanceof TopicConnection) {<z>
(transacted, ackMode);<z>
(transacted, ackMode);<z>
(boolean flag) {<z>
this.scheduledExecutor instanceof ScheduledThreadPoolExecutor) {<z>
);<z>
;<z>
String viewName) throws Exception {<z>
(viewName);<z>
);<z>
(this.allowRequestOverride);<z>
);<z>
.setAllowSessionOverride(this.allowSessionOverride);<z>
this.exposeSpringMacroHelpers);<z>
return view;<z>
toString() {<z>
);<z>
("; nested PropertyAccessExceptions (");<z>
).append(") are:");<z>
) {<z>
+ 1).append(": ");<z>
append(this.propertyAccessExceptions[i]);<z>
toString();<z>
Nullable Class<?> targetClass) {<z>
Assert.notNull(element, "AnnotatedElement must not be null");<z>
= element;<z>
.targetClass = targetClass;<z>
void registerAdapters(ReactiveAdapterRegistry registry) {<z>
registerReactiveType(<z>
.singleOptionalValue(<z>
io.smallrye.mutiny.Uni.class,<z>
).nothing()),<z>
),<z>
createFrom().publisher(publisher));<z>
registry.registerReactiveType(<z>
ReactiveTypeDescriptor.multiValue(<z>
Multi.class,<z>
createFrom().empty()),<z>
,<z>
publisher));<z>
{<z>
.equals(EncodingMode.URI_COMPONENT)) {<z>
uric = result.build();<z>
);<z>
.replacePath(null);<z>
()) {<z>
segment);<z>
)) {<z>
.path("/");<z>
decodeInternal(HttpServletRequest request, String source) {<z>
determineEncoding(request);<z>
);<z>
{<z>
.isDebugEnabled()) {<z>
"Could not decode request string [" + source + "] with encoding '" + enc +<z>
"': falling back to platform default encoding; exception message: " + ex.getMessage());<z>
.decode(source);<z>
, HttpServletResponse response,<z>
Transformer transformer) {<z>
);<z>
transformer);<z>
;<z>
) {<z>
;<z>
MethodParameter[count];<z>
< count; i++) {<z>
= new HandlerMethodParameter(i);<z>
return result;<z>
@Nullable TransactionDefinition definition)<z>
TransactionException {<z>
withDefaults());<z>
TransactionSynchronizationManager.forCurrentTransaction()<z>
{<z>
synchronizationManager);<z>
debugEnabled = logger.isDebugEnabled();<z>
if (isExistingTransaction(transaction)) {<z>
, debugEnabled);<z>
TIMEOUT_DEFAULT) {<z>
.getTimeout()));<z>
TransactionDefinition.PROPAGATION_MANDATORY) {<z>
Mono.error(new IllegalTransactionStateException(<z>
"No existing transaction found for transaction marked with propagation 'mandatory'"));<z>
def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||<z>
||<z>
() == TransactionDefinition.PROPAGATION_NESTED) {<z>
return TransactionContextManager.currentContext()<z>
.map(TransactionSynchronizationManager::new)<z>
flatMap(nestedSynchronizationManager -><z>
null)<z>
Optional::of)<z>
))<z>
{<z>
) {<z>
;<z>
() -> {<z>
GenericReactiveTransaction status = newReactiveTransaction(<z>
def, transaction, true,<z>
(null));<z>
return doBegin(nestedSynchronizationManager, transaction, def)<z>
, status, def))<z>
status);<z>
}).onErrorResume(ErrorPredicates.RUNTIME_OR_ERROR,<z>
suspendedResources.orElse(null))<z>
.error(ex)));<z>
));<z>
) {<z>
"Custom isolation level specified but no actual transaction initiated; " +<z>
;<z>
null, true, debugEnabled, null));<z>
);<z>
) {<z>
;<z>
{<z>
+ "}";<z>
"DefaultPart";<z>
() {<z>
{<z>
running = false;<z>
();<z>
{<z>
if (this.asyncSupportConfigurer == null) {<z>
;<z>
this.asyncSupportConfigurer);<z>
this.asyncSupportConfigurer;<z>
isUriVariable(CharSequence source) {<z>
!= '}') {<z>
return false;<z>
;<z>
++) {<z>
i);<z>
(c == ':' && i > 1) {<z>
;<z>
c == '}') {<z>
return false;<z>
);<z>
;<z>
(Map<String, ?> inParameters) {<z>
(inParameters.size());<z>
this.tableColumns) {<z>
(column);<z>
{<z>
;<z>
== null) {<z>
> entry : inParameters.entrySet()) {<z>
{<z>
);<z>
.add(value);<z>
return values;<z>
?> message) {<z>
();<z>
) {<z>
(DataBuffer) payload);<z>
payload instanceof Publisher) {<z>
payload).map(value -> {<z>
) {<z>
return (DataBuffer) value;<z>
;<z>
+ ">");<z>
});<z>
;<z>
) {<z>
) {<z>
return true;<z>
getClass()) {<z>
return false;<z>
);<z>
ImageOutputStream createImageOutputStream(OutputStream os) throws IOException {<z>
cacheDir != null) {<z>
FileCacheImageOutputStream(os, this.cacheDir);<z>
);<z>
) {<z>
());<z>
toClass()));<z>
ex) {<z>
;<z>
@Nullable Object returnValue, MethodParameter returnType,<z>
, NativeWebRequest webRequest) throws Exception {<z>
instanceof CharSequence) {<z>
toString();<z>
setViewName(viewName);<z>
) {<z>
;<z>
(returnValue != null) {<z>
"Unexpected return type: " +<z>
+ " in method: " + returnType.getMethod());<z>
getDispatcherTypes() {<z>
isAsyncSupported() ?<z>
) :<z>
.INCLUDE));<z>
(GenericWebApplicationContext context,<z>
{<z>
);<z>
parent instanceof WebApplicationContext)) {<z>
);<z>
resourceBasePath.startsWith(ResourceLoader.CLASSPATH_URL_PREFIX) ?<z>
: new FileSystemResourceLoader());<z>
servletContext = new MockServletContext(resourceBasePath, resourceLoader);<z>
(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, context);<z>
(servletContext);<z>
= null;<z>
{<z>
getParent() instanceof WebApplicationContext)) {<z>
;<z>
parent.getParent();<z>
(servletContext != null, "Failed to find root WebApplicationContext in the context hierarchy");<z>
setServletContext(servletContext);<z>
emitNewInstanceCallbacks(ClassEmitter ce) {<z>
, null);<z>
Type thisType = getThisType(e);<z>
0);<z>
SET_THREAD_CALLBACKS, false);<z>
);<z>
Throwable failure) {<z>
connection);<z>
failure)) {<z>
{<z>
;<z>
.session.handleTransportError(failure);<z>
getMessage()));<z>
int maxRowsAffected) {<z>
;<z>
setSql(sql);<z>
);<z>
;<z>
) {<z>
DisposedCallback callback = new DisposedCallback();<z>
).withConnection(callback);<z>
);<z>
public boolean supports(HandlerResult result) {<z>
MethodParameter returnType = result.getReturnTypeSource();<z>
;<z>
, ResponseBody.class) ||<z>
.class));<z>
@Nullable MessagePostProcessor postProcessor)<z>
MessagingException {<z>
);<z>
, ContextConfiguration contextConfiguration) {<z>
locations(), contextConfiguration.classes(),<z>
inheritLocations(), contextConfiguration.initializers(),<z>
));<z>
(Object bean, String beanName) throws BeansException {<z>
Servlet) {<z>
this.servletConfig;<z>
{<z>
beanName, this.servletContext);<z>
) bean).init(config);<z>
catch (ServletException ex) {<z>
"Servlet.init threw exception", ex);<z>
return bean;<z>
protected Object invoke(<z>
invoker) {<z>
CacheRemoveAllOperation operation = context.getOperation();<z>
earlyRemove = operation.isEarlyRemove();<z>
(earlyRemove) {<z>
);<z>
= invoker.invoke();<z>
(!earlyRemove) {<z>
;<z>
result;<z>
) {<z>
getOriginal();<z>
(original.getClass())) {<z>
context);<z>
;<z>
T> decoder) {<z>
.notNull(decoder, "Decoder is required");<z>
(decoder);<z>
.decoder = decoder;<z>
.getDecodableMimeTypes());<z>
... patterns) {<z>
patterns);<z>
add(registration);<z>
return registration;<z>
int statusCode, HttpHeaders headers,<z>
{<z>
.emptyMap());<z>
name;<z>
model));<z>
MissingPathVariableException(<z>
missingAfterConversion) {<z>
"", missingAfterConversion);<z>
= variableName;<z>
parameter;<z>
MethodParameter returnType) {<z>
.getParameterType())) {<z>
true;<z>
(returnType.getParameterType())) {<z>
getGeneric().resolve();<z>
;<z>
return false;<z>
, JAXBException {<z>
this.jaxbContexts.createMarshaller(clazz);<z>
UTF_8.name());<z>
);<z>
return marshaller;<z>
(ServerWebExchange exchange) {<z>
;<z>
;<z>
return this;<z>
,<z>
Throwable t) throws Exception {<z>
true;<z>
TypeDescriptor sourceType, TypeDescriptor targetType) {<z>
{<z>
TypeDescriptor targetElement = targetType.getElementTypeDescriptor();<z>
targetElement != null &&<z>
GenericConversionService) this.conversionService).canBypassConvert(<z>
{<z>
;<z>
));<z>
(sourceList, sourceType, targetType);<z>
Object destination) {<z>
destination instanceof RouteMatcher.Route ?<z>
.Route) destination) :<z>
pattern, (String) destination);<z>
checkCompiled() {<z>
if (!isCompiled()) {<z>
.debug("JdbcInsert not compiled before execution - invoking compile");<z>
();<z>
void resolveFactoryMethodIfPossible(RootBeanDefinition mbd) {<z>
;<z>
;<z>
.getFactoryBeanName() != null) {<z>
.getFactoryBeanName());<z>
= false;<z>
);<z>
= true;<z>
(factoryClass != null, "Unresolvable factory class");<z>
.getUserClass(factoryClass);<z>
candidates = getCandidateMethods(factoryClass, mbd);<z>
uniqueCandidate = null;<z>
Method candidate : candidates) {<z>
candidate)) {<z>
{<z>
= candidate;<z>
isParamMismatch(uniqueCandidate, candidate)) {<z>
null;<z>
mbd.factoryMethodToIntrospect = uniqueCandidate;<z>
StatementFilterFunction filter) {<z>
);<z>
new DefaultGenericExecuteSpec(<z>
this.filterFunction.andThen(filter));<z>
void flush() {<z>
).getEntityManager().flush();<z>
{<z>
);<z>
get(Object key) {<z>
) {<z>
((String) key);<z>
;<z>
Builder setBlah(<z>
builderForValue) {<z>
if (blahBuilder_ == null) {<z>
();<z>
;<z>
{<z>
;<z>
0x00000002;<z>
this;<z>
?> targetClass) {<z>
= AopUtils.getMostSpecificMethod(method, targetClass);<z>
) {<z>
= ClassUtils.getAllInterfacesForClassAsSet(targetClass);<z>
(ifcs.size() > 1) {<z>
Class<?> compositeInterface = ClassUtils.createCompositeInterface(<z>
getClassLoader());<z>
ClassUtils.getMostSpecificMethod(targetMethod, compositeInterface);<z>
(IllegalArgumentException ex) {<z>
);<z>
Nullable List<ResourceTransformer> resourceTransformers) {<z>
;<z>
null) {<z>
;<z>
public int hashCode() {<z>
int hashCode = super.hashCode();<z>
;<z>
;<z>
return hashCode;<z>
public boolean applyBeforeHandshake(ServerHttpRequest request, ServerHttpResponse response,<z>
<String, Object> attributes) throws Exception {<z>
; i++) {<z>
this.interceptors.get(i);<z>
.wsHandler, attributes)) {<z>
)) {<z>
debug(interceptor + " returns false from beforeHandshake - precluding handshake");<z>
null);<z>
false;<z>
;<z>
return true;<z>
ServletContext servletContext) {<z>
null) {<z>
.entrySet()) {<z>
entry.getKey();<z>
{<z>
.getAttribute(attributeName) != null) {<z>
debug("Replacing existing ServletContext attribute with name '" + attributeName + "'");<z>
, entry.getValue());<z>
)) {<z>
+ "'");<z>
Class<?> type, boolean asArray,<z>
<?>> visited) {<z>
) {<z>
;<z>
(type)) {<z>
.add(index, type);<z>
(HttpServletRequest request, HttpServletResponse response) throws Exception {<z>
.isWarnEnabled()) {<z>
;<z>
throwExceptionIfNoHandlerFound) {<z>
,<z>
getHeaders());<z>
);<z>
static int getExceptionTableLength(final Handler firstHandler) {<z>
= 0;<z>
;<z>
) {<z>
++;<z>
handler.nextHandler;<z>
length;<z>
{<z>
array == null) {<z>
0;<z>
int hash = INITIAL_HASH;<z>
for (byte element : array) {<z>
hash = MULTIPLIER * hash + element;<z>
hash;<z>
annotations) {<z>
annotations.length);<z>
annotations);<z>
result;<z>
channel) {<z>
this.immutableMessageInterceptorPresent != null) {<z>
;<z>
if (channel instanceof AbstractMessageChannel) {<z>
AbstractMessageChannel) channel).getInterceptors()) {<z>
if (interceptor instanceof ImmutableMessageChannelInterceptor) {<z>
= true;<z>
;<z>
immutableMessageInterceptorPresent = false;<z>
;<z>
boolean isInvalidEncodedPath(String resourcePath) {<z>
contains("%")) {<z>
StandardCharsets.UTF_8);<z>
decodedPath.contains("..\\")) {<z>
warn(LogFormatUtils.formatValue(<z>
+ resourcePath, -1, true));<z>
return true;<z>
catch (IllegalArgumentException ex) {<z>
false;<z>
startTime) {<z>
);<z>
false), initialDelay, TimeUnit.MILLISECONDS);<z>
ex) {<z>
task, ex);<z>
HttpServerResponse reactorResponse) {<z>
NettyDataBufferFactory(reactorResponse.alloc());<z>
= new ReactorServerHttpRequest(reactorRequest, bufferFactory);<z>
new ReactorServerHttpResponse(reactorResponse, bufferFactory);<z>
getMethod() == HttpMethod.HEAD) {<z>
(response);<z>
.handle(request, response)<z>
)))<z>
.getLogPrefix() + "Handling completed"));<z>
{<z>
()) {<z>
);<z>
(HttpResponseStatus.BAD_REQUEST);<z>
empty();<z>
cal) throws InvalidResultSetAccessException {<z>
;<z>
(SQLException se) {<z>
new InvalidResultSetAccessException(se);<z>
protected Object createAttribute(String attributeName, MethodParameter parameter,<z>
webRequest) throws Exception {<z>
parameter.nestedIfOptional();<z>
getNestedParameterType();<z>
= BeanUtils.getResolvableConstructor(clazz);<z>
;<z>
{<z>
.of(attribute);<z>
return attribute;<z>
{<z>
getJaxbContext(clazz);<z>
unmarshaller = jaxbContext.createUnmarshaller();<z>
;<z>
;<z>
(JAXBException ex) {<z>
HttpMessageConversionException(<z>
.getMessage(), ex);<z>
name, String alias) {<z>
name, alias);<z>
(alias)) {<z>
+<z>
+ name + "': Alias would override bean definition '" + alias + "'");<z>
String toString() {<z>
);<z>
this.includes);<z>
);<z>
", matchIfEmpty=").append(this.matchIfEmpty);<z>
.toString();<z>
findNextPotentialReference(int startPosition) {<z>
;<z>
=<z>
('&', this.nextPotentialReferencePosition);<z>
this.nextSemicolonPosition != -1 &&<z>
.nextPotentialReferencePosition) {<z>
+ 1);<z>
this.nextPotentialReferencePosition == -1) {<z>
) {<z>
1;<z>
< MAX_REFERENCE_SIZE) {<z>
;<z>
.nextPotentialReferencePosition != -1);<z>
void visitNestMember(final String nestMember) {<z>
.ASM7) {<z>
"NestMember requires ASM7");<z>
) {<z>
(nestMember);<z>
deactivatePatternCache() {<z>
cachePatterns = false;<z>
;<z>
;<z>
PathContainer pathContainer) {<z>
{<z>
return !hasLength(pathContainer) ||<z>
.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer));<z>
hasLength(pathContainer)) {<z>
this.head instanceof CaptureTheRestPathElement) {<z>
= EMPTY_PATH;<z>
;<z>
, false);<z>
);<z>
) {<z>
();<z>
Throwable ex) {<z>
ex);<z>
Class<?> type) {<z>
null) {<z>
= Object.class;<z>
);<z>
);<z>
) {<z>
null && this.useDefaultConverter) {<z>
typeConverter = getDefaultTypeConverter();<z>
.typeConverter;<z>
{<z>
;<z>
) == null) {<z>
getDefaultHeartbeat());<z>
return connectHeaders;<z>
DataSource getDataSource() {<z>
.persistenceUnitInfo != null) {<z>
) != null ?<z>
getJtaDataSource() :<z>
.getNonJtaDataSource());<z>
getDefaultJtaDataSource() != null ?<z>
this.internalPersistenceUnitManager.getDefaultJtaDataSource() :<z>
;<z>
@Nullable String requestingBeanName,<z>
, @Nullable TypeConverter typeConverter) throws BeansException {<z>
getParameterNameDiscoverer());<z>
.getDependencyType()) {<z>
return createOptionalDependency(descriptor, requestingBeanName);<z>
class == descriptor.getDependencyType() ||<z>
class == descriptor.getDependencyType()) {<z>
);<z>
.getDependencyType()) {<z>
;<z>
(<z>
requestingBeanName);<z>
) {<z>
);<z>
result;<z>
(Encoder<?> encoder) {<z>
if (encoder instanceof AbstractEncoder &&<z>
().startsWith("org.springframework.core.codec")) {<z>
;<z>
logger);<z>
) {<z>
onError(event);<z>
Exception ex) {<z>
StringBuilder buffer, Object obj) {<z>
getClass().isArray()) {<z>
;<z>
styleIdentityHashCode(buffer, obj);<z>
;<z>
obj);<z>
.append(' ');<z>
styleValue(buffer, obj);<z>
factory,<z>
) {<z>
notNull(endpoint, "Endpoint must not be null");<z>
, "Factory must not be null");<z>
endpoint.getId();<z>
id, "Endpoint id must be set");<z>
{<z>
{<z>
new IllegalStateException("Another endpoint is already registered with id '" + id + "'");<z>
MessageListenerContainer container = createListenerContainer(endpoint, factory);<z>
.listenerContainers.put(id, container);<z>
if (startImmediately) {<z>
);<z>
, Class<?> handlerType) {<z>
createRequestMappingInfo(method);<z>
!= null) {<z>
= createRequestMappingInfo(handlerType);<z>
typeInfo != null) {<z>
);<z>
) {<z>
test(handlerType)) {<z>
String prefix = entry.getKey();<z>
embeddedValueResolver != null) {<z>
this.embeddedValueResolver.resolveStringValue(prefix);<z>
.combine(info);<z>
;<z>
static ExchangeFilterFunction statusError(Predicate<HttpStatus> statusPredicate,<z>
) {<z>
.notNull(statusPredicate, "Predicate must not be null");<z>
"Function must not be null");<z>
return ExchangeFilterFunction.ofResponseProcessor(<z>
(response.statusCode()) ?<z>
(response)));<z>
obj, @Nullable MediaType contentType) {<z>
.convert(obj, String.class);<z>
null) {<z>
0L;<z>
(value, contentType);<z>
mav, String modelName, Object expectedValue) {<z>
class);<z>
assertTrue("Model value with name '" + modelName + "' is not the same as the expected value which was '" +<z>
));<z>
{<z>
) {<z>
: this.internalBeanFactories.values()) {<z>
);<z>
createRequest(<z>
, ServerInfo serverInfo) {<z>
());<z>
.transports) {<z>
: transport.getTransportTypes()) {<z>
.WEBSOCKET.equals(type)) {<z>
urlInfo, headers, getHttpRequestHeaders(headers),<z>
;<z>
CollectionUtils.isEmpty(requests)) {<z>
(<z>
;<z>
{<z>
DefaultTransportRequest request = requests.get(i);<z>
user = getUser();<z>
{<z>
user);<z>
) {<z>
());<z>
);<z>
;<z>
);<z>
MethodVisitor mv, CodeFlow cf) {<z>
().generateCode(mv, cf);<z>
= getLeftOperand().exitTypeDescriptor;<z>
String exitDesc = this.exitTypeDescriptor;<z>
(exitDesc != null, "No exit type descriptor");<z>
charAt(0);<z>
, leftDesc, targetDesc);<z>
(this.children.length > 1) {<z>
();<z>
).generateCode(mv, cf);<z>
.exitTypeDescriptor;<z>
();<z>
);<z>
) {<z>
:<z>
;<z>
case 'J':<z>
;<z>
'F':<z>
;<z>
:<z>
);<z>
throw new IllegalStateException(<z>
+ "'");<z>
.exitTypeDescriptor);<z>
contexts,<z>
Collection<CachePutRequest> putRequests) {<z>
) {<z>
(isConditionPassing(context, result)) {<z>
key = generateKey(context, result);<z>
(context, key));<z>
() {<z>
getTarget(),<z>
getObjectName(), isAutoGrowNestedPaths());<z>
.conversionService != null) {<z>
.conversionService);<z>
) {<z>
this.messageCodesResolver);<z>
result;<z>
modelName) {<z>
model != null) {<z>
get(modelName);<z>
request.getAttribute(modelName);<z>
context, AnnotatedElement source, SearchStrategy searchStrategy,<z>
{<z>
, source, searchStrategy, processor);<z>
processor.finish(result);<z>
Path destination, OpenOption... options) {<z>
Assert.notNull(source, "Source must not be null");<z>
);<z>
options);<z>
Mono.create(sink -> {<z>
);<z>
channel));<z>
::release,<z>
sink::error,<z>
;<z>
{<z>
(ex);<z>
);<z>
create(<z>
{<z>
transactionManager, transactionDefinition);<z>
(Message message) throws JMSException, MessageConversionException {<z>
;<z>
if (message instanceof TextMessage textMessage) {<z>
;<z>
message instanceof BytesMessage bytesMessage) {<z>
.unmarshaller);<z>
(message, this.unmarshaller);<z>
{<z>
new MessageConversionException("Could not access message content: " + message, ex);<z>
{<z>
;<z>
,<z>
String, Object> hints) {<z>
.stringDecoder<z>
(inputStream, elementType, mimeType, hints)<z>
, jsonText));<z>
() throws JMSException {<z>
{<z>
this.consumers != null) {<z>
("Closing JMS MessageConsumers");<z>
) {<z>
JmsUtils.closeMessageConsumer(consumer);<z>
sessions != null) {<z>
logger.debug("Closing JMS Sessions");<z>
.sessions) {<z>
;<z>
synchronizationManager,<z>
status, TransactionDefinition definition) {<z>
isNewSynchronization()) {<z>
hasTransaction());<z>
.setCurrentTransactionIsolationLevel(<z>
.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?<z>
);<z>
.isReadOnly());<z>
(definition.getName());<z>
();<z>
(HttpServletRequest request) {<z>
) {<z>
return this;<z>
(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD);<z>
return matchRequestMethod(expectedMethod);<z>
) {<z>
{<z>
;<z>
asList(activeProfiles));<z>
profilesSet);<z>
) {<z>
== null) {<z>
);<z>
instanceof Optional) {<z>
source;<z>
hasGenerics()) {<z>
;<z>
) == 0) ||<z>
target).isEmpty())) {<z>
empty();<z>
;<z>
.of(source);<z>
String sessionId, String subscriptionId) {<z>
destination, (_destination, sessionIdToSubscriptionIds) -> {<z>
sessionIdToSubscriptionIds = sessionIdToSubscriptionIds.clone();<z>
_sessionId, subscriptionIds) -> {<z>
)) {<z>
null;<z>
= new ArrayList<>(subscriptionIds);<z>
;<z>
) ? null : subscriptionIds);<z>
});<z>
;<z>
;<z>
) {<z>
.sb != null) {<z>
toString(), TEXT_PLAIN));<z>
null;<z>
WebFilter... filters) {<z>
{<z>
(4));<z>
(filters));<z>
);<z>
{<z>
if (getUrl() == null) {<z>
new IllegalStateException("'url' property is required for lazily initializing a Connection");<z>
connectionMonitor) {<z>
;<z>
(), getPassword());<z>
.target);<z>
)) {<z>
;<z>
);<z>
{<z>
);<z>
) {<z>
.argumentResolvers);<z>
;<z>
.setDataBinderFactory(factory);<z>
return attrMethod;<z>
Annotation> A findAnnotationOnBean(<z>
Class<A> annotationType, boolean allowFactoryBeanInit)<z>
{<z>
(beanName, allowFactoryBeanInit);<z>
) : null);<z>
public int hashCode() {<z>
this.locations);<z>
.classes);<z>
.contextInitializerClasses.hashCode();<z>
Arrays.hashCode(this.activeProfiles);<z>
.propertySourceLocations);<z>
+ Arrays.hashCode(this.propertySourceProperties);<z>
result + this.contextCustomizers.hashCode();<z>
;<z>
.contextLoader).hashCode();<z>
return result;<z>
{<z>
CollectionUtils.isEmpty(results)) {<z>
new EmptyResultDataAccessException(1);<z>
CollectionUtils.hasUniqueObject(results)) {<z>
());<z>
iterator().next();<z>
bd, @Nullable String propertyName) {<z>
propertyName != null ?<z>
+ propertyName + "'" :<z>
);<z>
getChildNodes();<z>
Element subElement = null;<z>
(); i++) {<z>
;<z>
DESCRIPTION_ELEMENT) &&<z>
)) {<z>
) {<z>
;<z>
= (Element) node;<z>
ele.hasAttribute(REF_ATTRIBUTE);<z>
);<z>
&& hasValueAttribute) ||<z>
) && subElement != null)) {<z>
elementName +<z>
, ele);<z>
(hasRefAttribute) {<z>
(REF_ATTRIBUTE);<z>
{<z>
, ele);<z>
);<z>
ele));<z>
;<z>
) {<z>
ele.getAttribute(VALUE_ATTRIBUTE));<z>
ele));<z>
return valueHolder;<z>
!= null) {<z>
);<z>
, ele);<z>
;<z>
) {<z>
pvs.getPropertyValues();<z>
pv : pvArray) {<z>
(pv.getValue());<z>
newVal, pv.getValue())) {<z>
newVal);<z>
MessageFormat resolveCode(String code, Locale locale) {<z>
);<z>
null) {<z>
null;<z>
holder = localeMap.get(locale);<z>
) {<z>
;<z>
();<z>
<?> exType) {<z>
(exType == null) {<z>
false;<z>
)) {<z>
true;<z>
.propertyAccessExceptions) {<z>
{<z>
true;<z>
return false;<z>
annotation) {<z>
{<z>
String origin : annotation.origins()) {<z>
);<z>
()) {<z>
;<z>
{<z>
());<z>
) {<z>
header));<z>
{<z>
header));<z>
resolveCorsAnnotationValue(annotation.allowCredentials());<z>
.equalsIgnoreCase(allowCredentials)) {<z>
config.setAllowCredentials(true);<z>
.equalsIgnoreCase(allowCredentials)) {<z>
(false);<z>
()) {<z>
("@CrossOrigin's allowCredentials value must be \"true\", \"false\", " +<z>
;<z>
{<z>
));<z>
getFirst(String headerName) {<z>
{<z>
String value = super.getFirst(headerName);<z>
: servletResponse.getHeader(headerName));<z>
value = servletResponse.getHeader(headerName);<z>
.getFirst(headerName));<z>
String getForLookupPath(String lookupPath) {<z>
String previous;<z>
lookupPath;<z>
, "/");<z>
;<z>
matchingPatterns = new ArrayList<>();<z>
()) {<z>
{<z>
pattern);<z>
{<z>
().getPatternComparator(lookupPath);<z>
(patternComparator);<z>
matchingPatterns) {<z>
;<z>
(pathWithinMapping));<z>
(pattern);<z>
);<z>
getLocations());<z>
null) {<z>
;<z>
.isTraceEnabled()) {<z>
trace("No match for \"" + lookupPath + "\"");<z>
;<z>
{<z>
SubscriptionNameProvider) {<z>
getSubscriptionName();<z>
.getName();<z>
{<z>
, "Method must not be null");<z>
getPropertyDescriptors(clazz);<z>
(PropertyDescriptor pd : pds) {<z>
.getWriteMethod())) {<z>
return pd;<z>
return null;<z>
public UnknownHttpStatusCodeException(<z>
) {<z>
statusCode + "]", statusCode, "",<z>
headers, responseBody, responseCharset);<z>
clientOutboundChannel,<z>
> destinationPrefixes) {<z>
destinationPrefixes);<z>
DefaultSubscriptionRegistry();<z>
() {<z>
== null) {<z>
();<z>
metadataReaderFactory;<z>
, MimeType contentType, Charset charset)<z>
IOException, MessageConversionException {<z>
(APPLICATION_JSON)) {<z>
charset);<z>
, writer);<z>
.flush();<z>
MessageConversionException(<z>
+ contentType);<z>
resolveArgumentValue(<z>
) {<z>
class, bindingContext);<z>
;<z>
) throws IOException {<z>
getURI(this.resource);<z>
(Exception ex) {<z>
"Failed to obtain URI for " + this.resource, ex);<z>
introductionInfo) {<z>
"Advice must not be null");<z>
.advice = advice;<z>
null) {<z>
);<z>
length == 0) {<z>
throw new IllegalArgumentException(<z>
);<z>
: introducedInterfaces) {<z>
(ifc);<z>
encode(Charset charset) {<z>
encodeState.isEncoded()) {<z>
;<z>
= getScheme();<z>
String fragment = getFragment();<z>
) : null);<z>
Type.FRAGMENT) : null);<z>
charset, Type.USER_INFO) : null);<z>
getHostType()) : null);<z>
, type);<z>
encode(encoder);<z>
encoder);<z>
(schemeTo, fragmentTo, userInfoTo,<z>
, null);<z>
{<z>
.singletonInstance;<z>
null) {<z>
this) {<z>
;<z>
instance == null) {<z>
null) {<z>
instance = this.instanceSupplier.get();<z>
null) {<z>
this.defaultSupplier.get();<z>
singletonInstance = instance;<z>
;<z>
{<z>
(sort == OBJECT) {<z>
, valueEnd + 1);<z>
) {<z>
';');<z>
} else {<z>
, valueEnd);<z>
value) {<z>
{<z>
&&<z>
protobuf.SecondMsg.getDefaultInstance()) {<z>
();<z>
else {<z>
blah_ = value;<z>
);<z>
else {<z>
blahBuilder_.mergeFrom(value);<z>
|= 0x00000002;<z>
;<z>
final Object getAspectInstance() {<z>
);<z>
{<z>
AopConfigException(<z>
.aspectClass.getName(), ex);<z>
) {<z>
(<z>
aspectClass.getName(), ex);<z>
ex) {<z>
throw new AopConfigException(<z>
(), ex);<z>
{<z>
(<z>
());<z>
symbolTable,<z>
final boolean useNamedValues,<z>
ByteVector annotation,<z>
AnnotationWriter previousAnnotation) {<z>
;<z>
;<z>
= useNamedValues;<z>
;<z>
.length - 2;<z>
;<z>
{<z>
nextAnnotation = this;<z>
public String getPath() {<z>
();<z>
(PathComponent pathComponent : this.pathComponents) {<z>
append(pathComponent.getPath());<z>
toString();<z>
, ClassNotFoundException {<z>
ois.defaultReadObject();<z>
rememberedMethods = new ConcurrentHashMap<>(32);<z>
?> type, Object targetObject) {<z>
(targetObject instanceof Class) {<z>
);<z>
;<z>
methods) {<z>
getModifiers())) {<z>
;<z>
, getMethods(Class.class));<z>
result;<z>
(type)) {<z>
new LinkedHashSet<>();<z>
)) {<z>
] methods = getMethods(ifc);<z>
) {<z>
(isCandidateForInvocation(method, type)) {<z>
result.add(method);<z>
;<z>
<>();<z>
] methods = getMethods(type);<z>
: methods) {<z>
) {<z>
add(method);<z>
result;<z>
, boolean toParent) {<z>
, "'beanType' must not be empty");<z>
beanName = beanType.getName();<z>
beanType;<z>
toParent;<z>
EntityManagerFactory obtainEntityManagerFactory() {<z>
getEntityManagerFactory();<z>
emf != null, "No EntityManagerFactory set");<z>
return emf;<z>
{<z>
= SpringProperties.getProperty(<z>
);<z>
) :<z>
;<z>
Class<? extends CacheAwareContextLoaderDelegate> clazz =<z>
? extends CacheAwareContextLoaderDelegate>) ClassUtils.forName(<z>
());<z>
)) {<z>
("Instantiating CacheAwareContextLoaderDelegate from class [%s]", className));<z>
.class);<z>
Throwable ex) {<z>
("Could not create CacheAwareContextLoaderDelegate [" + className + "]", ex);<z>
parsePersistenceUnitInfo(<z>
URL rootUrl) throws IOException {<z>
);<z>
unitInfo.setPersistenceXMLSchemaVersion(version);<z>
(rootUrl);<z>
.trim());<z>
();<z>
hasText(txType)) {<z>
valueOf(txType));<z>
= DomUtils.getChildElementValueByTagName(persistenceUnit, JTA_DATA_SOURCE);<z>
StringUtils.hasText(jtaDataSource)) {<z>
)));<z>
);<z>
(nonJtaDataSource)) {<z>
()));<z>
, PROVIDER);<z>
)) {<z>
.trim());<z>
persistenceUnit, EXCLUDE_UNLISTED_CLASSES);<z>
excludeUnlistedClasses != null) {<z>
= DomUtils.getTextValue(excludeUnlistedClasses);<z>
excludeText));<z>
, SHARED_CACHE_MODE);<z>
{<z>
SharedCacheMode.valueOf(cacheMode));<z>
, VALIDATION_MODE);<z>
(StringUtils.hasText(validationMode)) {<z>
ValidationMode.valueOf(validationMode));<z>
);<z>
unitInfo);<z>
;<z>
unitInfo);<z>
return unitInfo;<z>
) throws Exception {<z>
null) {<z>
.printValue("Type", null);<z>
());<z>
, BeanInitializationException {<z>
checkDaoConfig();<z>
);<z>
{<z>
throw new BeanInitializationException("Initialization of DAO failed", ex);<z>
() {<z>
serializablePostProcessors = null;<z>
{<z>
;<z>
postProcessor : this.beanPostProcessors) {<z>
(postProcessor instanceof Serializable) {<z>
);<z>
DisposableBeanAdapter(<z>
,<z>
;<z>
(<z>
, @Nullable Set<String> visitedPlaceholders) {<z>
indexOf(this.placeholderPrefix);<z>
1) {<z>
return value;<z>
StringBuilder result = new StringBuilder(value);<z>
-1) {<z>
result, startIndex);<z>
endIndex != -1) {<z>
), endIndex);<z>
originalPlaceholder = placeholder;<z>
(visitedPlaceholders == null) {<z>
>(4);<z>
)) {<z>
new IllegalArgumentException(<z>
"' in property definitions");<z>
);<z>
);<z>
!= null) {<z>
indexOf(this.valueSeparator);<z>
) {<z>
separatorIndex);<z>
length());<z>
(actualPlaceholder);<z>
{<z>
propVal = defaultValue;<z>
(propVal != null) {<z>
= parseStringValue(propVal, placeholderResolver, visitedPlaceholders);<z>
.placeholderSuffix.length(), propVal);<z>
) {<z>
.trace("Resolved placeholder '" + placeholder + "'");<z>
.length());<z>
else if (this.ignoreUnresolvablePlaceholders) {<z>
.length());<z>
new IllegalArgumentException("Could not resolve placeholder '" +<z>
"'" + " in value \"" + value + "\"");<z>
remove(originalPlaceholder);<z>
;<z>
.toString();<z>
?> message) {<z>
namedValueInfo = getNamedValueInfo(parameter);<z>
);<z>
resolvedName = resolveEmbeddedValuesAndExpressions(namedValueInfo.name);<z>
{<z>
throw new IllegalArgumentException(<z>
+ namedValueInfo.name + "]");<z>
, message, resolvedName.toString());<z>
(arg == null) {<z>
(namedValueInfo.defaultValue != null) {<z>
arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);<z>
.isOptional()) {<z>
, nestedParameter, message);<z>
, arg, nestedParameter.getNestedParameterType());<z>
namedValueInfo.defaultValue != null) {<z>
(namedValueInfo.defaultValue);<z>
, arg)) {<z>
));<z>
.defaultValue == null &&<z>
.isOptional()) {<z>
nestedParameter, message);<z>
;<z>
{<z>
if (!this.mergeEnabled) {<z>
IllegalStateException("Not allowed to merge when the 'mergeEnabled' property is set to 'false'");<z>
{<z>
return this;<z>
instanceof Map)) {<z>
+ parent.getClass() + "]");<z>
new ManagedMap<>();<z>
parent);<z>
);<z>
merged;<z>
{<z>
;<z>
this.objectClass, interceptor);<z>
;<z>
interceptor.getInvokedMethod();<z>
(method);<z>
> annotationTypes) {<z>
annotationType : annotationTypes) {<z>
) {<z>
true;<z>
false;<z>
, Class<T> requiredType)<z>
DataAccessException {<z>
, argTypes, getSingleColumnRowMapper(requiredType));<z>
handleExistingTransaction(TransactionSynchronizationManager synchronizationManager,<z>
throws TransactionException {<z>
TransactionDefinition.PROPAGATION_NEVER) {<z>
return Mono.error(new IllegalTransactionStateException(<z>
));<z>
{<z>
) {<z>
("Suspending current transaction");<z>
synchronizationManager, transaction);<z>
suspendedResources -> prepareReactiveTransaction(synchronizationManager,<z>
, false, debugEnabled, suspendedResources))<z>
prepareReactiveTransaction(synchronizationManager,<z>
null, false, debugEnabled, null)))<z>
);<z>
{<z>
(debugEnabled) {<z>
"Suspending current transaction, creating new transaction with name [" +<z>
getName() + "]");<z>
> suspendedResources = suspend(synchronizationManager, transaction);<z>
flatMap(suspendedResourcesHolder -> {<z>
synchronizationManager,<z>
transaction, true, debugEnabled, suspendedResourcesHolder);<z>
.doOnSuccess(ignore -><z>
status, definition)).thenReturn(status)<z>
, beginEx -><z>
resumeAfterBeginException(synchronizationManager, transaction, suspendedResourcesHolder, beginEx)<z>
Mono.error(beginEx)));<z>
});<z>
.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {<z>
{<z>
.getName() + "]");<z>
newReactiveTransaction(synchronizationManager,<z>
true, debugEnabled, null);<z>
transaction, definition).doOnSuccess(ignore -><z>
;<z>
if (debugEnabled) {<z>
debug("Participating in existing transaction");<z>
;<z>
long start, long end) throws IOException {<z>
in, "No InputStream specified");<z>
"No OutputStream specified");<z>
skip(start);<z>
) {<z>
+ " bytes out of " + start + " required");<z>
+ 1;<z>
(StreamUtils.BUFFER_SIZE, bytesToCopy)];<z>
{<z>
(buffer);<z>
bytesRead == -1) {<z>
) {<z>
, bytesRead);<z>
;<z>
, (int) bytesToCopy);<z>
0;<z>
1 - bytesToCopy);<z>
{<z>
{<z>
(this.beanInstance);<z>
extends DataBuffer> publisher,<z>
>> publisherNested) {<z>
null) {<z>
("At most one publisher expected");<z>
= publisher != null ?<z>
.from(publisher)<z>
= true)<z>
::write)<z>
handleOnError)<z>
handleOnComplete)<z>
doOnComplete(this::handleOnComplete) : null;<z>
publisherNested = publisherNested != null ?<z>
Flux.from(publisherNested)<z>
s -> this.hasContentConsumer = true)<z>
.doOnError(this::handleOnError))<z>
::handleOnError)<z>
(this::handleOnComplete)<z>
this::handleOnComplete) : null;<z>
publisher == null && publisherNested == null) {<z>
;<z>
(<z>
{<z>
(adapterRegistry);<z>
notEmpty(messageReaders, "At least one HttpMessageReader is required");<z>
"ReactiveAdapterRegistry is required");<z>
this.messageReaders = messageReaders;<z>
(ServerWebExchange exchange, @Nullable Instant lastModified,<z>
) {<z>
== null) {<z>
.MIN;<z>
, lastModified)) {<z>
);<z>
)<z>
getResponse().getHeaders()))<z>
.build();<z>
empty();<z>
, Cookie> cookies() {<z>
;<z>
{<z>
= new Cookie[0];<z>
LinkedMultiValueMap<>(cookies.length);<z>
for (Cookie cookie : cookies) {<z>
), cookie);<z>
result;<z>
) {<z>
beanFactory);<z>
beanFactory instanceof ConfigurableListableBeanFactory)) {<z>
throw new IllegalArgumentException(<z>
+ beanFactory);<z>
(ConfigurableListableBeanFactory) beanFactory);<z>
) {<z>
.methodMappings != null) {<z>
beanKey);<z>
) {<z>
));<z>
getName()));<z>
(int size) {<z>
-> {<z>
result);<z>
= 0;<z>
).keySet()) {<z>
startsWith(BindingResult.MODEL_KEY_PREFIX)) {<z>
++;<z>
, actual);<z>
) throws DataAccessException {<z>
executeWithNativeSession(session -> {<z>
) {<z>
entity, new LockOptions(lockMode));<z>
.refresh(entity);<z>
null;<z>
);<z>
{<z>
;<z>
) {<z>
header.getName()));<z>
values;<z>
Void> resume() {<z>
{<z>
.forCurrentTransaction()<z>
synchronizationManager -><z>
connectionFactory, this.connectionHolder))<z>
then();<z>
Mono.empty();<z>
final boolean visible) {<z>
if (delegate != null) {<z>
visible);<z>
;<z>
Locale locale) {<z>
formatter = new CurrencyStyleFormatter();<z>
getCurrencyCode()));<z>
.pattern);<z>
locale);<z>
{<z>
]> conn = connection;<z>
conn != null) {<z>
send(HEARTBEAT).addCallback(<z>
<Void>() {<z>
public void onSuccess(@Nullable Void result) {<z>
void onFailure(Throwable ex) {<z>
handleFailure(ex);<z>
});<z>
{<z>
>() {<z>
) {<z>
();<z>
{<z>
return "Current JSF FacesContext";<z>
;<z>
) {<z>
ExternalContext getObject() {<z>
).getExternalContext();<z>
String toString() {<z>
;<z>
});<z>
getProperties(String filename) {<z>
= this.cachedProperties.get(filename);<z>
long originalTimestamp = -2;<z>
{<z>
;<z>
) - getCacheMillis()) {<z>
return propHolder;<z>
PropertiesHolder();<z>
.cachedProperties.putIfAbsent(filename, propHolder);<z>
null) {<z>
existingHolder;<z>
() >= 0) {<z>
) {<z>
return propHolder;<z>
propHolder.refreshLock.lock();<z>
;<z>
originalTimestamp) {<z>
return existingHolder;<z>
propHolder);<z>
refreshLock.unlock();<z>
Annotation> AnnotationVisitor visitAnnotation(<z>
) {<z>
(descriptor).getClassName();<z>
matches(className)) {<z>
return null;<z>
;<z>
, consumer);<z>
GeneratorStrategy strategy) {<z>
(strategy == null)<z>
;<z>
strategy = strategy;<z>
) {<z>
tyrusEndpoint != null) {<z>
;<z>
{<z>
, @Nullable String defaultTypeName) {<z>
value = DomUtils.getTextValue(ele);<z>
.getAttribute(TYPE_ATTRIBUTE);<z>
= specifiedTypeName;<z>
(typeName)) {<z>
;<z>
;<z>
extractSource(ele));<z>
specifiedTypeName);<z>
return typedValue;<z>
catch (ClassNotFoundException ex) {<z>
, ele, ex);<z>
value;<z>
algorithm) {<z>
);<z>
(NoSuchAlgorithmException ex) {<z>
("Could not find MessageDigest with algorithm \"" + algorithm + "\"", ex);<z>
(BeanDefinition other) {<z>
getBeanClassName())) {<z>
));<z>
(other.getScope())) {<z>
getScope());<z>
());<z>
hasLength(other.getFactoryBeanName())) {<z>
.getFactoryBeanName());<z>
) {<z>
());<z>
.getRole());<z>
other.getSource());<z>
copyAttributesFrom(other);<z>
other instanceof AbstractBeanDefinition otherAbd) {<z>
)) {<z>
;<z>
()) {<z>
;<z>
(otherAbd.hasPropertyValues()) {<z>
other.getPropertyValues());<z>
.hasMethodOverrides()) {<z>
());<z>
Boolean lazyInit = otherAbd.getLazyInit();<z>
{<z>
);<z>
);<z>
getDependencyCheck());<z>
.getDependsOn());<z>
;<z>
));<z>
(otherAbd);<z>
(otherAbd.getInstanceSupplier());<z>
));<z>
otherAbd.isLenientConstructorResolution());<z>
{<z>
otherAbd.getInitMethodName());<z>
setEnforceInitMethod(otherAbd.isEnforceInitMethod());<z>
!= null) {<z>
(otherAbd.getDestroyMethodName());<z>
otherAbd.isEnforceDestroyMethod());<z>
isSynthetic());<z>
setResource(otherAbd.getResource());<z>
());<z>
));<z>
);<z>
.getResourceDescription());<z>
{<z>
{<z>
true;<z>
other) {<z>
);<z>
false;<z>
Nullable String beanName, @Nullable String candidateName) {<z>
null && candidateName != null &&<z>
(containsBeanDefinition(candidateName) &&<z>
)))));<z>
Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {<z>
;<z>
{<z>
) {<z>
targetType = determineTargetType(beanName, mbd);<z>
if (targetType != null) {<z>
applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);<z>
) {<z>
bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);<z>
!= null);<z>
return bean;<z>
private static void enforceCommentPrefixAliases(AnnotationAttributes attributes) {<z>
commentPrefix = attributes.getString(COMMENT_PREFIX);<z>
);<z>
boolean explicitCommentPrefix = !commentPrefix.isEmpty();<z>
!= 0);<z>
&& explicitCommentPrefixes),<z>
);<z>
{<z>
);<z>
});<z>
(explicitCommentPrefixes) {<z>
for (String prefix : commentPrefixes) {<z>
hasText(prefix, "@SqlConfig(commentPrefixes) must not contain empty prefixes");<z>
.put(COMMENT_PREFIX, commentPrefixes);<z>
);<z>
MultiValueMap<String, String> output) {<z>
)) {<z>
.indexOf('=');<z>
!= -1) {<z>
0, index);<z>
.uriDecode(name, charset);<z>
(name)) {<z>
+ 1);<z>
.commaDelimitedListToStringArray(value)) {<z>
);<z>
input, charset);<z>
{<z>
, "");<z>
Class<T> requiredType,<z>
{<z>
.typeConverterDelegate != null, "No TypeConverterDelegate");<z>
, requiredType, typeDescriptor);<z>
) {<z>
ex);<z>
ex) {<z>
(value, requiredType, ex);<z>
<?> clazz) {<z>
));<z>
null) {<z>
.isDebugEnabled()) {<z>
clazz +<z>
);<z>
;<z>
= new ClassReader(is);<z>
<>(32);<z>
(clazz, map), 0);<z>
return map;<z>
) {<z>
(logger.isDebugEnabled()) {<z>
logger.debug("Exception thrown while reading '.class' file for class [" + clazz +<z>
, ex);<z>
IllegalArgumentException ex) {<z>
)) {<z>
("ASM ClassReader failed to parse class file [" + clazz +<z>
, ex);<z>
;<z>
catch (IOException ex) {<z>
return NO_DEBUG_INFO_MAP;<z>
{<z>
.notNull(postProcessor, "postProcessor is required");<z>
.postProcessors.add(postProcessor);<z>
return this;<z>
) {<z>
.stereotypesProviders = getStereotypesProviders(env);<z>
new TypeHelper(env);<z>
);<z>
.readMetadata());<z>
] array) {<z>
) {<z>
return NULL_STRING;<z>
int length = array.length;<z>
) {<z>
EMPTY_ARRAY;<z>
new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);<z>
array) {<z>
(String.valueOf(b));<z>
;<z>
Throwable {<z>
.proceed();<z>
());<z>
return retVal;<z>
warn(Object message, Throwable exception) {<z>
) {<z>
, exception);<z>
parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) {<z>
getChildNodes();<z>
{<z>
(i);<z>
nodeNameEquals(node, META_ELEMENT)) {<z>
Element metaElement = (Element) node;<z>
metaElement.getAttribute(KEY_ATTRIBUTE);<z>
value = metaElement.getAttribute(VALUE_ATTRIBUTE);<z>
(key, value);<z>
);<z>
attribute);<z>
long getRangeEnd(long length) {<z>
) {<z>
this.lastPos;<z>
1;<z>
message, List<Match> matches) {<z>
mapping : mappingsToCheck) {<z>
match = getMatchingMapping(mapping, message);<z>
) {<z>
(mapping)));<z>
(Set<HttpMethod> declaredMethods) {<z>
isEmpty()) {<z>
))<z>
.equals(method))<z>
collect(Collectors.toSet());<z>
declaredMethods);<z>
GET)) {<z>
);<z>
add(HttpMethod.OPTIONS);<z>
result;<z>
V> next) {<z>
) {<z>
;<z>
next, this.queue);<z>
SymbolTable symbolTable, final Object type) {<z>
instanceof Integer) {<z>
.intValue();<z>
) {<z>
;<z>
, descriptor, 0);<z>
} else {<z>
;<z>
<Object> dependencyConsumer) throws BeansException {<z>
dependency = getIfUnique();<z>
) {<z>
);<z>
catch (ScopeNotActiveException ex) {<z>
parseTransactionAnnotation(AnnotatedElement element) {<z>
jakarta.ejb.TransactionAttribute.class);<z>
ann != null) {<z>
ann);<z>
null;<z>
(<z>
aspectInstanceFactory) {<z>
.notNull(aspectJAdviceMethod, "Advice method must not be null");<z>
;<z>
;<z>
;<z>
aspectJAdviceMethod = aspectJAdviceMethod;<z>
;<z>
aspectInstanceFactory = aspectInstanceFactory;<z>
) {<z>
)) {<z>
size();<z>
.methods.size() == 1) {<z>
methods.contains(RequestMethod.GET)) {<z>
1;<z>
) {<z>
return 1;<z>
;<z>
Function<String, T> computeFunction) {<z>
.notNull(name, "Name must not be null");<z>
.notNull(computeFunction, "Compute function must not be null");<z>
= getAttribute(name);<z>
) {<z>
.apply(name);<z>
Assert.state(value != null,<z>
("Compute function must not return null for attribute named '%s'", name));<z>
, value);<z>
value;<z>
public boolean setRawStatusCode(@Nullable Integer statusCode) {<z>
get() == State.COMMITTED) {<z>
false;<z>
.statusCode = statusCode;<z>
;<z>
Object attributeValue) {<z>
, () -> String.format(<z>
this.displayName));<z>
throws JmsException {<z>
doStart();<z>
catch (JMSException ex) {<z>
throw convertJmsAccessException(ex);<z>
String scheme, @Nullable String fragment,<z>
Nullable String port,<z>
> queryParams,<z>
<String> variableEncoder) {<z>
super(scheme, fragment);<z>
userInfo;<z>
host = host;<z>
this.port = port;<z>
= path;<z>
.queryParams = queryParams;<z>
= encodeState;<z>
;<z>
StompBrokerRelayRegistration setSystemPasscode(String passcode) {<z>
(passcode, "systemPasscode must not be empty");<z>
systemPasscode = passcode;<z>
return this;<z>
Throwable exposedException(Throwable original) {<z>
instanceof ExecutionException) {<z>
cause = original.getCause();<z>
) {<z>
return cause;<z>
return original;<z>
public Object getObject() throws Exception {<z>
singleton) {<z>
{<z>
);<z>
;<z>
;<z>
String filename) {<z>
Assert.hasText(filename, "No filename");<z>
= filename;<z>
this;<z>
, @Nullable Object oldValue,<z>
Nullable Class<T> requiredType) throws IllegalArgumentException {<z>
requiredType));<z>
> parseMimeTypes(String mimeTypes) {<z>
!StringUtils.hasLength(mimeTypes)) {<z>
);<z>
stream()<z>
::hasText)<z>
.map(MimeTypeUtils::parseMimeType)<z>
;<z>
throws Throwable {<z>
switch (method.getName()) {<z>
"equals":<z>
= args[0];<z>
if (proxy == other) {<z>
;<z>
())) {<z>
;<z>
);<z>
otherHandler instanceof SharedConnectionInvocationHandler &&<z>
).factory());<z>
:<z>
);<z>
case "toString":<z>
+ getConnection();<z>
case "setClientID":<z>
;<z>
args[0])) {<z>
;<z>
jakarta.jms.IllegalStateException(<z>
;<z>
"setExceptionListener":<z>
synchronized (connectionMonitor) {<z>
) {<z>
0];<z>
!= this.localExceptionListener) {<z>
.localExceptionListener != null) {<z>
);<z>
(listener != null) {<z>
(listener);<z>
listener;<z>
;<z>
throw new jakarta.jms.IllegalStateException(<z>
;<z>
case "getExceptionListener":<z>
connectionMonitor) {<z>
localExceptionListener != null) {<z>
this.localExceptionListener;<z>
;<z>
case "start":<z>
);<z>
;<z>
:<z>
localStop();<z>
;<z>
:<z>
localStop();<z>
) {<z>
.localExceptionListener != null) {<z>
null) {<z>
localExceptionListener);<z>
= null;<z>
return null;<z>
:<z>
case "createQueueSession":<z>
case "createTopicSession":<z>
AUTO_ACKNOWLEDGE;<z>
ObjectUtils.isEmpty(args)) {<z>
) {<z>
Integer) args[0];<z>
length == 2) {<z>
(Boolean) args[0];<z>
(Integer) args[1];<z>
ackMode);<z>
(), mode);<z>
if (session != null) {<z>
isInstance(session)) {<z>
String msg = "JMS Session does not implement specific domain: " + session;<z>
;<z>
ex) {<z>
("Failed to close newly obtained JMS Session", ex);<z>
jms.IllegalStateException(msg);<z>
return session;<z>
.invoke(getConnection(), args);<z>
ex) {<z>
ex.getTargetException();<z>
ClassNotFoundException {<z>
;<z>
is == null) {<z>
return null;<z>
= FileCopyUtils.copyToByteArray(is);<z>
);<z>
IOException ex) {<z>
("Cannot load resource for class [" + name + "]", ex);<z>
String[] state) {<z>
{<z>
return null;<z>
);<z>
>> doSuspendSynchronization(<z>
TransactionSynchronizationManager synchronizationManager) {<z>
> suspendedSynchronizations = synchronizationManager.getSynchronizations();<z>
)<z>
suspend)<z>
) -> {<z>
);<z>
Mono.just(suspendedSynchronizations);<z>
);<z>
) {<z>
, "WebSocketSession not yet initialized");<z>
this.webSocketSession instanceof NativeWebSocketSession ?<z>
webSocketSession);<z>
(StompEndpointRegistry registry) {<z>
) {<z>
.registerStompEndpoints(registry);<z>
methodVisitor, final boolean visitLineNumbers) {<z>
visitLabel(this);<z>
visitLineNumbers && lineNumber != 0) {<z>
this);<z>
otherLineNumbers != null) {<z>
++i) {<z>
], this);<z>
boolean hasAlias(String name, String alias) {<z>
get(alias);<z>
(registeredName, name) || (registeredName != null<z>
&& hasAlias(name, registeredName));<z>
setApplicationContext(ApplicationContext applicationContext) throws BeansException {<z>
(ViewResolver viewResolver : this.viewResolvers) {<z>
ApplicationContextAware) {<z>
viewResolver).setApplicationContext(applicationContext);<z>
(Runnable task, long delay) {<z>
TimeUnit.MILLISECONDS);<z>
RejectedExecutionException ex) {<z>
+ "] did not accept task: " + task, ex);<z>
Descriptor desc) {<z>
null) {<z>
, getDefaultCurrencyTimeLimit().toString());<z>
, ServerWebExchange exchange) {<z>
(handler instanceof CorsConfigurationSource) {<z>
;<z>
;<z>
{<z>
getTargetDataSource() == null) {<z>
"Property 'targetDataSource' is required");<z>
@Nullable Object other) {<z>
(this == other) {<z>
;<z>
) {<z>
;<z>
.checkInherited);<z>
private void writeComplete() {<z>
newState = new IdleFileState(this);<z>
(this.completed) {<z>
(this.finalPart);<z>
{<z>
();<z>
this.channel);<z>
, List<?> parameters) {<z>
.actualSql = actualSql;<z>
.parameters = parameters;<z>
declaredParameters.size()) {<z>
>();<z>
; i++) {<z>
get(i);<z>
instanceof SqlParameterValue) {<z>
;<z>
i);<z>
declaredParameters.size()) {<z>
throw new InvalidDataAccessApiUsageException(<z>
"]: given " + names.size() +<z>
);<z>
clearCacheIncludingAncestors() {<z>
);<z>
() instanceof ReloadableResourceBundleMessageSource) {<z>
);<z>
(String etag) {<z>
.startsWith("W/\"")) {<z>
;<z>
) {<z>
= etag + "\"";<z>
etag);<z>
;<z>
apply(ServerHttpRequest request) {<z>
(hasForwardedHeaders(request)) {<z>
Builder builder = request.mutate();<z>
removeOnly) {<z>
(true).toUri();<z>
);<z>
);<z>
) {<z>
getRawPath());<z>
builder.contextPath(prefix);<z>
);<z>
request, remoteAddress);<z>
remoteAddress != null) {<z>
);<z>
removeForwardedHeaders(builder);<z>
builder.build();<z>
;<z>
[] aggregateIndex,<z>
, Method rootMethod,<z>
includeInterfaces) {<z>
, aggregateIndex[0]);<z>
null) {<z>
result;<z>
)) {<z>
return null;<z>
= false;<z>
()) {<z>
= processMethodAnnotations(context, aggregateIndex[0],<z>
;<z>
;<z>
) {<z>
;<z>
, sourceClass)) {<z>
) {<z>
0],<z>
;<z>
= true;<z>
null) {<z>
result;<z>
.getModifiers())) {<z>
null;<z>
) {<z>
;<z>
if (includeInterfaces) {<z>
sourceClass.getInterfaces()) {<z>
,<z>
);<z>
(interfacesResult != null) {<z>
interfacesResult;<z>
?> superclass = sourceClass.getSuperclass();<z>
superclass != null) {<z>
context, aggregateIndex,<z>
);<z>
superclassResult != null) {<z>
;<z>
(Throwable ex) {<z>
rootMethod, ex);<z>
;<z>
isLazy(DependencyDescriptor descriptor) {<z>
) {<z>
class);<z>
null && lazy.value()) {<z>
true;<z>
descriptor.getMethodParameter();<z>
(methodParam != null) {<z>
methodParam.getMethod();<z>
getReturnType()) {<z>
.class);<z>
lazy.value()) {<z>
;<z>
false;<z>
(ObjectOutputStream out) throws IOException {<z>
new HashSet<>();<z>
(key, value) -> {<z>
(value instanceof Serializable)) {<z>
.add(key);<z>
});<z>
{<z>
.defaultWriteObject();<z>
.isDebugEnabled()) {<z>
logger.debug("Ignoring non-serializable message headers: " + keysToIgnore);<z>
MessageHeaders(this, keysToIgnore));<z>
void setTypePattern(String typePattern) {<z>
;<z>
.typePattern = typePattern;<z>
this.aspectJTypePatternMatcher =<z>
getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution().<z>
);<z>
{<z>
classes = new ArrayList<>(3);<z>
.add(SessionProxy.class);<z>
if (target instanceof QueueSession) {<z>
.add(QueueSession.class);<z>
(target instanceof TopicSession) {<z>
.class);<z>
SessionProxy.class.getClassLoader(),<z>
);<z>
mergeFrom(Msg other) {<z>
== Msg.getDefaultInstance()) return this;<z>
.hasFoo()) {<z>
0x00000001;<z>
;<z>
;<z>
other.hasBlah()) {<z>
other.getBlah());<z>
));<z>
;<z>
Connection connection) {<z>
this.response = response;<z>
));<z>
adapter);<z>
= connection.inbound();<z>
));<z>
uriComponents, MockHttpServletRequest request) {<z>
{<z>
setPathInfo(null);<z>
;<z>
path : ""));<z>
start() {<z>
(this.lifecycleMonitor) {<z>
)) {<z>
);<z>
(<z>
RootBeanDefinition mbd) {<z>
BeanFactoryUtils.isFactoryDereference(name)) {<z>
if (beanInstance instanceof NullBean) {<z>
beanInstance;<z>
(beanInstance instanceof FactoryBean)) {<z>
));<z>
mbd != null) {<z>
;<z>
;<z>
(!(beanInstance instanceof FactoryBean)) {<z>
beanInstance;<z>
Object object = null;<z>
if (mbd != null) {<z>
;<z>
);<z>
object == null) {<z>
;<z>
null && containsBeanDefinition(beanName)) {<z>
;<z>
;<z>
;<z>
;<z>
, @Nullable String resourceDescription)<z>
BeanDefinitionStoreException {<z>
inputSource, new DescriptiveResource(resourceDescription));<z>
Method method, Object[] args) {<z>
isEqualsMethod(method)) {<z>
[0]);<z>
method)) {<z>
return annotationHashCode();<z>
if (ReflectionUtils.isToStringMethod(method)) {<z>
annotationToString();<z>
{<z>
this.type;<z>
()) != -1) {<z>
;<z>
format(<z>
, method, this.type));<z>
FileTypeMap getFileTypeMap() {<z>
{<z>
this.mappings);<z>
IOException ex) {<z>
(<z>
, ex);<z>
fileTypeMap;<z>
(DataBuffer dataBuffer, ResolvableType targetType,<z>
DecodingException {<z>
.asInputStream());<z>
);<z>
.add((XMLEvent) event));<z>
);<z>
catch (XMLStreamException ex) {<z>
), ex);<z>
(Throwable ex) {<z>
.getCause();<z>
XMLStreamException) {<z>
getMessage(), cause);<z>
);<z>
(dataBuffer);<z>
<T> Mono<T> decode(<z>
, MethodParameter elementType, BindingContext bindingContext,<z>
isRequired) {<z>
), part);<z>
();<z>
()) {<z>
) + "'");<z>
elementType, isRequired, bindingContext, partExchange);<z>
numRequested, int minPort, int maxPort) {<z>
(minPort > 0, "'minPort' must be greater than 0");<z>
(maxPort > minPort, "'maxPort' must be greater than 'minPort'");<z>
;<z>
.isTrue(numRequested > 0, "'numRequested' must be greater than 0");<z>
- minPort) >= numRequested,<z>
);<z>
;<z>
0;<z>
< numRequested) {<z>
findAvailablePort(minPort, maxPort));<z>
{<z>
IllegalStateException(String.format(<z>
);<z>
;<z>
public void setImportMetadata(AnnotationMetadata importMetadata) {<z>
.fromMap(<z>
EnableCaching.class.getName()));<z>
) {<z>
IllegalArgumentException(<z>
;<z>
,<z>
ReactiveMessageHandler messageHandler, RouteMatcher routeMatcher,<z>
RSocketStrategies strategies) {<z>
notNull(dataMimeType, "'dataMimeType' is required");<z>
;<z>
);<z>
requester, "RSocketRequester is required");<z>
"ReactiveMessageHandler is required");<z>
);<z>
"RSocketStrategies is required");<z>
= dataMimeType;<z>
metadataMimeType = metadataMimeType;<z>
metadataExtractor;<z>
requester;<z>
messageHandler = messageHandler;<z>
;<z>
;<z>
protected MediaType handleNoMatch(NativeWebRequest webRequest, String extension)<z>
HttpMediaTypeNotAcceptableException {<z>
= null;<z>
);<z>
{<z>
mimeType);<z>
mediaType)) {<z>
extension);<z>
!= null) {<z>
= superMediaType;<z>
mediaType;<z>
[] interfaces) {<z>
= new InterfaceMaker();<z>
.getPropertyValues();<z>
for (PropertyValue pv : pvs) {<z>
pv.getName();<z>
.findPropertyType(propertyName, interfaces);<z>
capitalize(propertyName);<z>
)});<z>
;<z>
.getInitMethodName() != null) {<z>
]);<z>
new Type[0]);<z>
getDestroyMethodName())) {<z>
0]);<z>
Type[0]);<z>
return maker.create();<z>
> objectFactory) {<z>
= this.threadScope.get();<z>
scopedObject = scope.get(name);<z>
scopedObject == null) {<z>
objectFactory.getObject();<z>
scope.put(name, scopedObject);<z>
;<z>
setBeanClassLoader(ClassLoader classLoader) {<z>
GroovyClassLoader &&<z>
compilerConfiguration == null ||<z>
{<z>
classLoader;<z>
= buildGroovyClassLoader(classLoader);<z>
(ReactiveHttpInputMessage message, BodyExtractor.Context context,<z>
) {<z>
serverResponse()<z>
context.hints()))<z>
));<z>
) {<z>
= this.currentData;<z>
if (prev != null) {<z>
data);<z>
);<z>
"Received new data while current not processed yet."));<z>
.currentData = data;<z>
) {<z>
cancelRemainingTask(task);<z>
decoratedTaskMap.get(task);<z>
) {<z>
;<z>
{<z>
);<z>
{<z>
name, "not found in JNDI environment");<z>
) {<z>
return null;<z>
urlPathHelper) {<z>
;<z>
;<z>
if (this.corsConfigurationSource instanceof UrlBasedCorsConfigurationSource urlConfigSource) {<z>
urlPathHelper);<z>
com.google.protobuf.Message other) {<z>
org.springframework.protobuf.SecondMsg) {<z>
springframework.protobuf.SecondMsg)other);<z>
} else {<z>
;<z>
this;<z>
visitParameterAnnotation(<z>
boolean visible) {<z>
(visible) {<z>
null) {<z>
).length];<z>
return lastRuntimeVisibleParameterAnnotations[parameter] =<z>
.create(<z>
annotationDescriptor, lastRuntimeVisibleParameterAnnotations[parameter]);<z>
else {<z>
(lastRuntimeInvisibleParameterAnnotations == null) {<z>
getArgumentTypes(descriptor).length];<z>
return lastRuntimeInvisibleParameterAnnotations[parameter] =<z>
.create(<z>
);<z>
) {<z>
(<z>
singleOptionalValue(Deferred.class,<z>
(null)),<z>
Deferred<?>) source),<z>
from(source)));<z>
registerReactiveType(<z>
::emptyFlow),<z>
) source),<z>
reactive.ReactiveFlowKt::asFlow);<z>
public static XMLEventWriter getXMLEventWriter(Result result) {<z>
if (result instanceof StAXResult) {<z>
result).getXMLEventWriter();<z>
StaxResult) {<z>
result).getXMLEventWriter();<z>
result + "' is neither StaxResult nor StAXResult");<z>
<?> clazz) {<z>
;<z>
= clazz.getModifiers();<z>
modifiers));<z>
{<z>
!= null) {<z>
= this.contentType;<z>
contains(CHARSET_PREFIX)) {<z>
();<z>
value;<z>
, value, true);<z>
, IOException {<z>
.schedulerFactory;<z>
{<z>
instantiateClass(this.schedulerFactoryClass);<z>
StdSchedulerFactory) {<z>
);<z>
null ||<z>
{<z>
throw new IllegalArgumentException(<z>
"StdSchedulerFactory required for applying Quartz properties: " + schedulerFactory);<z>
return schedulerFactory;<z>
throws SchedulerException {<z>
(bundle);<z>
;<z>
{<z>
ex);<z>
() {<z>
getPatternParser() != null ?<z>
getPatternParser() : PathPatternParser.defaultInstance);<z>
this.options.getContentTypeResolver();<z>
RequestMappingInfo(this.mappingName,<z>
),<z>
methods) ?<z>
null : new RequestMethodsRequestCondition(this.methods),<z>
ObjectUtils.isEmpty(this.params) ?<z>
(this.params),<z>
(this.headers) ?<z>
.headers),<z>
.consumes) && !this.hasContentType ?<z>
headers),<z>
?<z>
,<z>
this.customCondition,<z>
;<z>
) throws SchedulingException {<z>
) {<z>
.isInStandbyMode();<z>
) {<z>
;<z>
;<z>
session) throws Exception {<z>
)) {<z>
debug("New " + session);<z>
.afterConnectionEstablished(session);<z>
{<z>
, "Resource location must not be null");<z>
.startsWith(CLASSPATH_URL_PREFIX)) {<z>
CLASSPATH_URL_PREFIX.length());<z>
.getDefaultClassLoader();<z>
));<z>
if (url == null) {<z>
description = "class path resource [" + path + "]";<z>
throw new FileNotFoundException(description +<z>
;<z>
return url;<z>
;<z>
) {<z>
).toURI().toURL();<z>
catch (MalformedURLException ex2) {<z>
"Resource location [" + resourceLocation +<z>
;<z>
() default "";<z>
[] values() default {};<z>
, long value) {<z>
return result -> {<z>
MockHttpServletResponse response = result.getResponse();<z>
));<z>
(name);<z>
!= null) {<z>
;<z>
Nullable Class<?>... paramTypes) {<z>
clazz, "Class must not be null");<z>
, "Method name must not be null");<z>
) {<z>
, paramTypes);<z>
{<z>
("Expected method not found: " + ex);<z>
= findMethodCandidatesByName(clazz, methodName);<z>
== 1) {<z>
;<z>
(candidates.isEmpty()) {<z>
;<z>
methodName);<z>
) {<z>
) {<z>
getName();<z>
isEndElement()) {<z>
().getName();<z>
throw new IllegalStateException();<z>
configClass) {<z>
configClass.getMetadata();<z>
);<z>
ScopeMetadata scopeMetadata = scopeMetadataResolver.resolveScopeMetadata(configBeanDef);<z>
);<z>
registry);<z>
(configBeanDef, metadata);<z>
;<z>
registry);<z>
(), definitionHolder.getBeanDefinition());<z>
(configBeanName);<z>
)) {<z>
+ configBeanName + "'");<z>
Object obj) {<z>
) {<z>
;<z>
);<z>
endpointClass) {<z>
getId();<z>
);<z>
== null) {<z>
);<z>
(wacId, beanNamesByType);<z>
containsKey(endpointClass)) {<z>
wac.getBeanNamesForType(endpointClass);<z>
names.length == 1) {<z>
]);<z>
endpointClass, NO_VALUE);<z>
) {<z>
new IllegalStateException("Found multiple @ServerEndpoint's of type [" +<z>
.asList(names));<z>
);<z>
equals(beanName) ? null : beanName);<z>
MediaType producible) {<z>
producible = producible.copyQualityValue(acceptable);<z>
.isLessSpecific(producible)) {<z>
;<z>
return acceptable;<z>
(MessageChannel channel, boolean preserveOrder) {<z>
(preserveOrder) {<z>
ExecutorSubscribableChannel.class, channel,<z>
);<z>
ExecutorSubscribableChannel execChannel = (ExecutorSubscribableChannel) channel;<z>
-> i instanceof CallbackInterceptor)) {<z>
new CallbackInterceptor());<z>
{<z>
i instanceof CallbackInterceptor)<z>
).map(execChannel::removeInterceptor);<z>
String> parameters) {<z>
(type, "'type' must not be empty");<z>
, "'subtype' must not be empty");<z>
type);<z>
checkToken(subtype);<z>
toLowerCase(Locale.ENGLISH);<z>
toLowerCase(Locale.ENGLISH);<z>
isEmpty(parameters)) {<z>
(), Locale.ENGLISH);<z>
{<z>
checkParameters(parameter, value);<z>
(parameter, value);<z>
;<z>
= Collections.unmodifiableMap(map);<z>
.emptyMap();<z>
clear(@Nullable PropertyValues pvs) {<z>
<InjectedElement> checkedElements = this.checkedElements;<z>
=<z>
;<z>
isEmpty()) {<z>
: elementsToIterate) {<z>
element.clearPropertySkipping(pvs);<z>
bean, RootBeanDefinition mbd)<z>
{<z>
.getInitMethodName();<z>
, "No init method set");<z>
?<z>
, initMethodName) :<z>
initMethodName));<z>
) {<z>
()) {<z>
+<z>
);<z>
) {<z>
.trace("No default init method named '" + initMethodName +<z>
+ "'");<z>
if (logger.isTraceEnabled()) {<z>
initMethodName + "' on bean with name '" + beanName + "'");<z>
= ClassUtils.getInterfaceMethodIfPossible(initMethod);<z>
);<z>
;<z>
ex) {<z>
;<z>
Runnable task) {<z>
);<z>
);<z>
catch (RejectedExecutionException ex) {<z>
;<z>
boolean isBinderMethodApplicable(HandlerMethod initBinderMethod, WebDataBinder dataBinder) {<z>
initBinderMethod.getMethodAnnotation(InitBinder.class);<z>
state(ann != null, "No InitBinder annotation");<z>
ann.value();<z>
()));<z>
handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,<z>
throws Exception {<z>
if (returnValue != null) {<z>
ModelFactory.getNameForReturnValue(returnValue, returnType);<z>
addAttribute(name, returnValue);<z>
Class<? extends Annotation> annotationType,<z>
<?> fieldType) {<z>
this.annotationType = annotationType;<z>
this.annotationFormatterFactory = annotationFormatterFactory;<z>
;<z>
Object result) {<z>
(result);<z>
result, returnType, this.message);<z>
Throwable ex) {<z>
(ex);<z>
boolean isConditionMatch(MetadataReader metadataReader) {<z>
.conditionEvaluator == null) {<z>
=<z>
.resourcePatternResolver);<z>
.getAnnotationMetadata());<z>
Map<String, CorsConfiguration> corsConfigurations) {<z>
.notNull(corsConfigurations, "corsConfigurations must not be null");<z>
.isEmpty()) {<z>
.patternParser);<z>
source.setCorsConfigurations(corsConfigurations);<z>
source;<z>
.corsConfigurationSource = null;<z>
) {<z>
beanFactory);<z>
.reader = new AnnotatedBeanDefinitionReader(this);<z>
);<z>
> responseType, Object... uriVariables)<z>
RestClientException {<z>
RequestCallback requestCallback = acceptHeaderRequestCallback(responseType);<z>
> responseExtractor = responseEntityExtractor(responseType);<z>
;<z>
Route> allRoutes() {<z>
ArrayList<>();<z>
addAll(staticRoutes());<z>
));<z>
(regexRoute());<z>
;<z>
, "/notfound", "/favicon.ico"));<z>
routes;<z>
throws Exception {<z>
(Payload.class);<z>
)) {<z>
;<z>
Object payload = message.getPayload();<z>
) {<z>
)) {<z>
parameter);<z>
= new BeanPropertyBindingResult(payload, paramName);<z>
ObjectError(paramName, "Payload value must not be empty"));<z>
, parameter, bindingResult);<z>
null;<z>
targetClass = resolveTargetClass(parameter, message);<z>
> payloadClass = payload.getClass();<z>
payloadClass)) {<z>
);<z>
payload;<z>
if (this.converter instanceof SmartMessageConverter smartConverter) {<z>
;<z>
, targetClass);<z>
(payload == null) {<z>
(message, "Cannot convert from [" +<z>
() + "] for " + message);<z>
, parameter, payload);<z>
return payload;<z>
byte[] body,<z>
) {<z>
), statusText, headers, body, charset,<z>
request);<z>
String getContentAsString(Charset fallbackCharset) throws UnsupportedEncodingException {<z>
) {<z>
(getCharacterEncoding());<z>
fallbackCharset);<z>
byteBufferPool,<z>
) {<z>
notNull(worker, "XnioWorker must not be null");<z>
notNull(byteBufferPool, "ByteBufferPool must not be null");<z>
= worker;<z>
this.byteBufferPool = byteBufferPool;<z>
this.builderConsumer = builderConsumer;<z>
) {<z>
(4);<z>
: validationHints) {<z>
?> clazz) {<z>
add(clazz);<z>
groups);<z>
method) {<z>
(method)) {<z>
);<z>
NO_OVERRIDE;<z>
().isInterface() &&<z>
.class)) {<z>
isTraceEnabled()) {<z>
"Method is declared on Advised interface: " + method);<z>
;<z>
{<z>
{<z>
("Found 'equals' method: " + method);<z>
INVOKE_EQUALS;<z>
AopUtils.isHashCodeMethod(method)) {<z>
)) {<z>
;<z>
INVOKE_HASHCODE;<z>
.getTargetClass();<z>
);<z>
;<z>
exposeProxy = this.advised.isExposeProxy();<z>
getTargetSource().isStatic();<z>
.advised.isFrozen();<z>
|| !isFrozen) {<z>
(exposeProxy) {<z>
.isTraceEnabled()) {<z>
method);<z>
;<z>
this.fixedInterceptorMap.containsKey(method)) {<z>
if (logger.isTraceEnabled()) {<z>
+ method);<z>
;<z>
fixedInterceptorOffset);<z>
) {<z>
("Unable to apply any optimizations to advised method: " + method);<z>
AOP_PROXY;<z>
(exposeProxy || !isStatic) {<z>
INVOKE_TARGET;<z>
.getReturnType();<z>
)) {<z>
.isTraceEnabled()) {<z>
"Method return type is assignable from target type and " +<z>
);<z>
INVOKE_TARGET;<z>
if (logger.isTraceEnabled()) {<z>
("Method return type ensures 'this' cannot be returned - " +<z>
+ method);<z>
;<z>
(ServletContext servletContext) {<z>
createRootApplicationContext();<z>
rootAppContext != null) {<z>
ContextLoaderListener listener = new ContextLoaderListener(rootAppContext);<z>
getRootApplicationContextInitializers());<z>
(listener);<z>
.debug("No ContextLoaderListener registered, as " +<z>
;<z>
{<z>
.filters.isEmpty()) {<z>
> filtersToUse = this.filters.stream()<z>
peek(filter -> {<z>
forwardedHeaderTransformer == null) {<z>
) filter;<z>
(filter -> !(filter instanceof ForwardedHeaderTransformer))<z>
);<z>
.filters.clear();<z>
filtersToUse);<z>
String name) {<z>
RequestAttributes attributes = RequestContextHolder.currentRequestAttributes();<z>
;<z>
) {<z>
);<z>
return scopedObject;<z>
return null;<z>
submit(Runnable task) {<z>
, null);<z>
future, TIMEOUT_INDEFINITE);<z>
;<z>
) {<z>
);<z>
null) {<z>
(session, Config.FMT_LOCALE);<z>
) {<z>
return (Locale) localeObject;<z>
return RequestContextUtils.getLocale(this.request);<z>
, String> getUriTemplateVariables(NativeWebRequest request) {<z>
("unchecked")<z>
, String>) request.getAttribute(<z>
.SCOPE_REQUEST);<z>
());<z>
() {<z>
getUserTransaction();<z>
if (ut == null) {<z>
"No JTA UserTransaction available - " +<z>
);<z>
cacheUserTransaction) {<z>
(<z>
null ? this.userTransactionName : DEFAULT_USER_TRANSACTION_NAME);<z>
(ut);<z>
(AnnotatedElement element) {<z>
RequestMapping.class);<z>
Class ?<z>
((Method) element));<z>
requestMapping, condition) : null);<z>
@Nullable Class<?> targetClass,<z>
{<z>
);<z>
{<z>
(txAttr instanceof DefaultTransactionAttribute) {<z>
();<z>
if (methodIdentification == null) {<z>
);<z>
methodIdentification;<z>
HttpServletResponse response, Object delegate)<z>
throws ServletException, IllegalAccessException {<z>
).doSomething(request);<z>
;<z>
getExceptionCacheResolver(<z>
{<z>
null) {<z>
CacheResolver cacheResolver = factory.getExceptionCacheResolver(details);<z>
);<z>
);<z>
) {<z>
);<z>
!result.isInitialized()) {<z>
(result);<z>
;<z>
factory) throws IOException {<z>
filter : JAXB2_TYPE_FILTERS) {<z>
.getClassMetadata().isInterface() ) {<z>
true;<z>
false;<z>
{<z>
(message);<z>
();<z>
true;<z>
Set<Resource> actualResources) throws BeanDefinitionStoreException {<z>
();<z>
null) {<z>
(<z>
location + "]: no ResourceLoader available");<z>
ResourcePatternResolver) {<z>
) resourceLoader).getResources(location);<z>
);<z>
null) {<z>
resources);<z>
(logger.isTraceEnabled()) {<z>
count + " bean definitions from location pattern [" + location + "]");<z>
count;<z>
(IOException ex) {<z>
throw new BeanDefinitionStoreException(<z>
+ location + "]", ex);<z>
);<z>
(resource);<z>
actualResources != null) {<z>
.add(resource);<z>
(logger.isTraceEnabled()) {<z>
+ location + "]");<z>
count;<z>
(ParserContext context, @Nullable Object source) {<z>
containsBeanInHierarchy(context, DispatcherServlet.REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME)) {<z>
beanDef = new RootBeanDefinition(DefaultRequestToViewNameTranslator.class);<z>
.setSource(source);<z>
;<z>
(<z>
DispatcherServlet.REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME, beanDef);<z>
.registerComponent(<z>
beanDef, DispatcherServlet.REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME));<z>
String placeholder, Properties props, int systemPropertiesMode) {<z>
propVal = null;<z>
if (systemPropertiesMode == SYSTEM_PROPERTIES_MODE_OVERRIDE) {<z>
propVal = resolveSystemProperty(placeholder);<z>
{<z>
propVal = resolvePlaceholder(placeholder, props);<z>
== null && systemPropertiesMode == SYSTEM_PROPERTIES_MODE_FALLBACK) {<z>
);<z>
propVal;<z>
protected void initParent(Theme theme) {<z>
(theme.getMessageSource() instanceof HierarchicalMessageSource) {<z>
();<z>
.getParentMessageSource() == null) {<z>
;<z>
(parentTheme != null) {<z>
());<z>
{<z>
lastBytecodeOffset = code.length;<z>
if (opcode == Opcodes.SIPUSH) {<z>
.put12(opcode, operand);<z>
else {<z>
put11(opcode, operand);<z>
null) {<z>
{<z>
;<z>
opcode != Opcodes.NEWARRAY) {<z>
;<z>
{<z>
size;<z>
= size;<z>
(MergedContextConfiguration mergedContextConfiguration) {<z>
synchronized (this.contextCache) {<z>
(mergedContextConfiguration);<z>
() {<z>
length < 2) {<z>
);<z>
.children[1];<z>
servletContext) {<z>
null) {<z>
throw new IllegalStateException(<z>
"check whether you have multiple ContextLoader* definitions in your web.xml!");<z>
.log("Initializing Spring root WebApplicationContext");<z>
.class);<z>
(logger.isInfoEnabled()) {<z>
"Root WebApplicationContext: initialization started");<z>
);<z>
{<z>
this.context = createWebApplicationContext(servletContext);<z>
()) {<z>
() == null) {<z>
servletContext);<z>
(parent);<z>
;<z>
);<z>
getContextClassLoader();<z>
)) {<z>
context;<z>
null) {<z>
(ccl, this.context);<z>
if (logger.isInfoEnabled()) {<z>
- startTime;<z>
);<z>
return this.context;<z>
| Error ex) {<z>
);<z>
.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);<z>
throw ex;<z>
RequestedContentTypeResolver contentTypeResolver,<z>
adapterRegistry) {<z>
);<z>
"ReactiveAdapterRegistry is required");<z>
this.contentTypeResolver = contentTypeResolver;<z>
;<z>
> defaultValue) {<z>
defaultValue);<z>
defaultValue) {<z>
result);<z>
;<z>
{<z>
this.inParameters != null) {<z>
.inParameters.values());<z>
> beanType, String beanName) {<z>
MergedBeanDefinitionPostProcessor processor : getBeanPostProcessorCache().mergedDefinition) {<z>
;<z>
DefaultTransactionStatus status) {<z>
)) {<z>
);<z>
) {<z>
) + "@" + dataHandler.getName();<z>
(contentId, dataHandler);<z>
;<z>
Object key) {<z>
headerName) {<z>
headerName);<z>
.remove(headerName);<z>
;<z>
null;<z>
) {<z>
(headerValue instanceof Number) {<z>
();<z>
instanceof String) {<z>
(String) headerValue);<z>
return null;<z>
{<z>
== other) {<z>
return 0;<z>
.getDelay(TimeUnit.MILLISECONDS);<z>
;<z>
ResolvableType actualType, ResolvableType elementType,<z>
ServerHttpResponse response) {<z>
);<z>
... paths) {<z>
;<z>
.addHandler(handler, paths);<z>
;<z>
registration;<z>
setAsText(String text) throws IllegalArgumentException {<z>
text)) {<z>
setValue(null);<z>
= null;<z>
(!ResourceUtils.isUrl(text)) {<z>
new File(text);<z>
) {<z>
file);<z>
.resourceEditor.setAsText(text);<z>
resourceEditor.getValue();<z>
()) {<z>
());<z>
) {<z>
(<z>
;<z>
setValue(file);<z>
<HandlerExceptionResolver> exceptionResolvers,<z>
ContentNegotiationManager mvcContentNegotiationManager) {<z>
ExceptionHandlerExceptionResolver exceptionHandlerResolver = createExceptionHandlerExceptionResolver();<z>
.setContentNegotiationManager(mvcContentNegotiationManager);<z>
getMessageConverters());<z>
;<z>
);<z>
(jackson2Present) {<z>
exceptionHandlerResolver.setResponseBodyAdvice(<z>
(new JsonViewResponseBodyAdvice()));<z>
.applicationContext != null) {<z>
);<z>
;<z>
.add(exceptionHandlerResolver);<z>
ResponseStatusExceptionResolver();<z>
this.applicationContext);<z>
add(responseStatusResolver);<z>
new DefaultHandlerExceptionResolver());<z>
{<z>
.resultHandlers != null) {<z>
{<z>
.supports(handlerResult)) {<z>
return resultHandler;<z>
());<z>
clear() {<z>
.keyCache.clear();<z>
.conditionCache.clear();<z>
;<z>
] doGetParameterNames(Executable executable) {<z>
();<z>
computeIfAbsent(declaringClass, this::inspectClass);<z>
;<z>
publisher,<z>
{<z>
>(publisher,<z>
fromPublisher(publisher, typeReference));<z>
> requiredType)<z>
throws DataAccessException {<z>
>(requiredType));<z>
(@Nullable Object value) {<z>
;<z>
{<z>
;<z>
instanceof CachePutOperation) {<z>
getUnless();<z>
hasText(unless)) {<z>
evaluationContext = createEvaluationContext(value);<z>
, evaluationContext);<z>
true;<z>
(<z>
, @Nullable String themeName) {<z>
, "HttpServletResponse is required for CookieThemeResolver");<z>
StringUtils.hasText(themeName)) {<z>
THEME_REQUEST_ATTRIBUTE_NAME, themeName);<z>
addCookie(response, themeName);<z>
, getDefaultThemeName());<z>
);<z>
handler) {<z>
;<z>
handler instanceof String) {<z>
ApplicationContext context = getApplicationContext();<z>
;<z>
(String) handler);<z>
handler.getClass();<z>
{<z>
> userType = ClassUtils.getUserClass(handlerType);<z>
.selectMethods(userType,<z>
(method, userType));<z>
(logger.isDebugEnabled()) {<z>
));<z>
(handler, key, value));<z>
String suffix) {<z>
);<z>
.append(prefix);<z>
(' ');<z>
.getRequestURI());<z>
()) {<z>
;<z>
if (queryString != null) {<z>
'?').append(queryString);<z>
)) {<z>
();<z>
client)) {<z>
).append(client);<z>
.getSession(false);<z>
session != null) {<z>
.getId());<z>
user = request.getRemoteUser();<z>
(user != null) {<z>
append(user);<z>
(isIncludeHeaders()) {<z>
).getHeaders();<z>
) != null) {<z>
names = request.getHeaderNames();<z>
names.hasMoreElements()) {<z>
();<z>
)) {<z>
);<z>
append(", headers=").append(headers);<z>
)) {<z>
request);<z>
) {<z>
);<z>
.append(suffix);<z>
.toString();<z>
?> submit(Runnable task) {<z>
== null && this.concurrentExecutor instanceof ExecutorService) {<z>
.submit(task);<z>
(task, null);<z>
future);<z>
return future;<z>
ex) {<z>
throw new TaskRejectedException(<z>
task, ex);<z>
request, final ServletResponse response)<z>
, ServletException {<z>
()) {<z>
, response);<z>
;<z>
currentPosition - 1);<z>
request, response, this);<z>
ExceptionHandlerMethodResolver(Class<?> handlerType) {<z>
(handlerType, EXCEPTION_HANDLER_METHODS)) {<z>
(method)) {<z>
(exceptionType, method);<z>
(String to) throws MailParseException {<z>
helper.setTo(to);<z>
ex) {<z>
ex);<z>
List<View> views) {<z>
stream()<z>
stream())<z>
.toList());<z>
,<z>
Endpoint endpoint)<z>
throws HandshakeFailureException {<z>
(httpRequest);<z>
getHttpServletResponse(httpResponse);<z>
= request.getRequestURL();<z>
;<z>
();<z>
path, endpoint);<z>
));<z>
selectedExtensions);<z>
request);<z>
, endpointConfig, pathParams);<z>
Exception ex) {<z>
HandshakeFailureException(<z>
);<z>
value) {<z>
) {<z>
value == null) {<z>
throw new NullPointerException();<z>
value;<z>
);<z>
else {<z>
setMessage(value);<z>
|= 0x00000002;<z>
;<z>
{<z>
nameMap.values()) {<z>
instanceof DefaultTransactionAttribute dta) {<z>
(this.embeddedValueResolver);<z>
event) {<z>
publisher.publishEvent(event);<z>
(Throwable ex) {<z>
) {<z>
, ex);<z>
public RenderingResponse.Builder cookie(Cookie cookie) {<z>
cookie, "Cookie must not be null");<z>
;<z>
;<z>
public RSocketRequester transports(<z>
>> targetPublisher, LoadbalanceStrategy loadbalanceStrategy) {<z>
();<z>
MimeType metaMimeType = getMetadataMimeType();<z>
(strategies);<z>
(<z>
dataMimeType, strategies);<z>
)<z>
.connector(connector)<z>
loadbalanceStrategy)<z>
;<z>
;<z>
(HttpServletRequest request) {<z>
= HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE;<z>
;<z>
);<z>
String name) {<z>
)) {<z>
;<z>
{<z>
{<z>
.resourceName, null, this.source);<z>
);<z>
name, this.source);<z>
,<z>
V>> queue) {<z>
);<z>
this.hash = hash;<z>
this.nextReference = next;<z>
) {<z>
())) {<z>
();<z>
;<z>
= initRequestUrl();<z>
, @Nullable String stackDescriptor) {<z>
== null) {<z>
(ch) {<z>
case 'Z':<z>
stackDescriptor.equals("Ljava/lang/Boolean")) {<z>
, "java/lang/Boolean");<z>
"booleanValue", "()Z", false);<z>
case 'B':<z>
stackDescriptor.equals("Ljava/lang/Byte")) {<z>
"java/lang/Byte");<z>
"java/lang/Byte", "byteValue", "()B", false);<z>
case 'C':<z>
) {<z>
(CHECKCAST, "java/lang/Character");<z>
, "charValue", "()C", false);<z>
case 'D':<z>
equals("Ljava/lang/Double")) {<z>
, "java/lang/Double");<z>
"doubleValue", "()D", false);<z>
case 'F':<z>
(!stackDescriptor.equals("Ljava/lang/Float")) {<z>
mv.visitTypeInsn(CHECKCAST, "java/lang/Float");<z>
, "java/lang/Float", "floatValue", "()F", false);<z>
:<z>
!stackDescriptor.equals("Ljava/lang/Integer")) {<z>
;<z>
"intValue", "()I", false);<z>
case 'J':<z>
"Ljava/lang/Long")) {<z>
;<z>
, "longValue", "()J", false);<z>
:<z>
{<z>
, "java/lang/Short");<z>
"java/lang/Short", "shortValue", "()S", false);<z>
);<z>
(WebSocketClient client,<z>
Object... uriVariables) {<z>
, uriVariables);<z>
client = client;<z>
this.webSocketHandler = decorateWebSocketHandler(webSocketHandler);<z>
byte[]> message, StompHeaders headers) {<z>
().length == 0) {<z>
handler.handleFrame(headers, null);<z>
headers);<z>
();<z>
(resolvedType == null) {<z>
+ payloadType +<z>
"]");<z>
message, resolvedType);<z>
object == null) {<z>
+<z>
"]");<z>
(headers, object);<z>
public SecondMsg buildPartial() {<z>
);<z>
int from_bitField0_ = bitField0_;<z>
;<z>
0x00000001) == 0x00000001)) {<z>
0x00000001;<z>
;<z>
to_bitField0_;<z>
;<z>
;<z>
int calculateCapacity(CharSequence sequence, Charset charset) {<z>
this.charsetToMaxBytesPerChar<z>
).maxBytesPerChar());<z>
sequence.length() * maxBytesPerChar;<z>
;<z>
reload)<z>
{<z>
)) {<z>
bundleName = toBundleName(baseName, locale);<z>
toResourceName(bundleName, "properties");<z>
loader;<z>
boolean reloadFlag = reload;<z>
InputStream inputStream = null;<z>
) {<z>
classLoader.getResource(resourceName);<z>
null) {<z>
);<z>
if (connection != null) {<z>
setUseCaches(false);<z>
.getInputStream();<z>
);<z>
(inputStream != null) {<z>
String encoding = getDefaultEncoding();<z>
null) {<z>
, encoding)) {<z>
loadBundle(bundleReader);<z>
) {<z>
loadBundle(bundleStream);<z>
null;<z>
, loader, reload);<z>
String[] packages) throws ClassNotFoundException {<z>
className;<z>
= 0;<z>
;<z>
0) {<z>
;<z>
length() - dimensions);<z>
< dimensions; i++) {<z>
'[');<z>
- 2 * dimensions);<z>
? brackets + "L" : "";<z>
(dimensions > 0) ? ";" : "";<z>
className + suffix, false, loader);<z>
{<z>
< packages.length; i++) {<z>
, loader);<z>
ignore) {<z>
{<z>
(Class) primitives.get(className);<z>
c != null) {<z>
;<z>
String) transforms.get(className);<z>
!= null) {<z>
false, loader);<z>
catch (ClassNotFoundException ignore) {<z>
ClassNotFoundException(save);<z>
(@Nullable ClassLoader classLoader) {<z>
parser = PointcutParser<z>
.getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(<z>
);<z>
());<z>
return parser;<z>
Message<P> message) {<z>
.buffer();<z>
byteBuf);<z>
(byteBuf)).then();<z>
new MonoToListenableFutureAdapter<>(sendCompletion);<z>
void closeChannel(@Nullable Channel channel) {<z>
{<z>
.close();<z>
ignored) {<z>
<String, ?> matchingBeans) {<z>
getDependencyComparator();<z>
OrderComparator) {<z>
withSourceProvider(<z>
matchingBeans));<z>
return comparator;<z>
<?> testClass) {<z>
"Class must not be null");<z>
);<z>
= new ArrayList<>();<z>
)) {<z>
.format(<z>
);<z>
null) {<z>
= descriptor.getRootDeclaringClass();<z>
);<z>
(logger.isTraceEnabled()) {<z>
(String.format("Retrieved @ActiveProfiles [%s] for declaring class [%s]",<z>
)));<z>
resolver;<z>
= annotation.resolver();<z>
.class == resolverClass) {<z>
defaultActiveProfilesResolver;<z>
class);<z>
ex) {<z>
String.format("Could not instantiate ActiveProfilesResolver of type [%s] " +<z>
), rootDeclaringClass.getName());<z>
logger.error(msg);<z>
(msg, ex);<z>
resolve(rootDeclaringClass);<z>
)) {<z>
add(0, profiles);<z>
next() : null);<z>
= new LinkedHashSet<>();<z>
(String[] profiles : profileArrays) {<z>
profile : profiles) {<z>
(profile)) {<z>
trim());<z>
.toStringArray(activeProfiles);<z>
ReaderContext(Resource resource, ProblemReporter problemReporter,<z>
) {<z>
;<z>
.problemReporter = problemReporter;<z>
;<z>
sourceExtractor = sourceExtractor;<z>
)<z>
throws IOException, TemplateException {<z>
new StringWriter(1024);<z>
.process(model, result);<z>
();<z>
DefaultTransactionStatus status) {<z>
= (JtaTransactionObject) status.getTransaction();<z>
();<z>
if (jtaStatus != Status.STATUS_NO_TRANSACTION) {<z>
txObject.getUserTransaction().rollback();<z>
(IllegalStateException ex) {<z>
(jtaStatus == Status.STATUS_ROLLEDBACK) {<z>
{<z>
ex);<z>
;<z>
catch (SystemException ex) {<z>
TransactionSystemException("JTA failure on rollback", ex);<z>
{<z>
;<z>
= getLeftOperand().getValueInternal(state);<z>
getValueInternal(state);<z>
.getValue();<z>
();<z>
;<z>
(!(rightValue instanceof Class)) {<z>
.getStartPosition(),<z>
INSTANCEOF_OPERATOR_NEEDS_CLASS_OPERAND,<z>
getName()));<z>
;<z>
leftValue == null) {<z>
;<z>
.getClass()));<z>
type = rightClass;<z>
(rightOperand instanceof TypeReference) {<z>
this.exitTypeDescriptor = "Z";<z>
;<z>
() throws IOException {<z>
(this.path);<z>
== null) {<z>
);<z>
return is;<z>
{<z>
null) {<z>
.getClass();<z>
.endpointProvider != null, "No endpoint set");<z>
endpointProvider.getHandlerType();<z>
) {<z>
{<z>
"(none)";<z>
.getName() + "]" : "");<z>
+ "'" + in;<z>
public final RecordComponentVisitor visitRecordComponent(<z>
descriptor, final String signature) {<z>
recordComponentWriter =<z>
);<z>
) {<z>
;<z>
{<z>
delegate = recordComponentWriter;<z>
recordComponentWriter;<z>
{<z>
(minCount >= 0, "minCount >= 0 is required");<z>
>= minCount, "maxCount >= minCount is required");<z>
minCount = minCount;<z>
;<z>
addPropertyValue(PropertyValue pv) {<z>
size(); i++) {<z>
this.propertyValueList.get(i);<z>
))) {<z>
, currentPv);<z>
setPropertyValueAt(pv, i);<z>
return this;<z>
);<z>
return this;<z>
public void setAutowireCandidateResolver(AutowireCandidateResolver autowireCandidateResolver) {<z>
.notNull(autowireCandidateResolver, "AutowireCandidateResolver must not be null");<z>
instanceof BeanFactoryAware) {<z>
setBeanFactory(this);<z>
autowireCandidateResolver = autowireCandidateResolver;<z>
) {<z>
type instanceof TypeVariable) {<z>
);<z>
) {<z>
resolve();<z>
if (resolved == null) {<z>
null;<z>
();<z>
++) {<z>
))) {<z>
[i];<z>
.variableResolver);<z>
);<z>
null) {<z>
).resolveVariable(variable);<z>
{<z>
= resolveType().resolveVariable(variable);<z>
resolved != null) {<z>
resolved;<z>
(this.variableResolver != null) {<z>
);<z>
null;<z>
() {<z>
);<z>
engine = this.engineSupplier.get();<z>
!= null) {<z>
Assert.isInstanceOf(Invocable.class, engine,<z>
;<z>
;<z>
return engine;<z>
SqlParameterSource paramSource)<z>
DataAccessException {<z>
sql, paramSource, new ColumnMapRowMapper());<z>
Object unmarshalDomSource(DOMSource domSource) throws XmlMappingException {<z>
null) {<z>
());<z>
));<z>
{<z>
{<z>
("NPE while unmarshalling. " +<z>
, ex);<z>
throw ex;<z>
) {<z>
= parameter.getParameterAnnotations();<z>
{<z>
);<z>
{<z>
binder.validate(validationHints);<z>
CacheOperationContext> contexts) {<z>
;<z>
: contexts) {<z>
isConditionPassing(context, result)) {<z>
(context, result);<z>
cached = findInCaches(context, key);<z>
cached != null) {<z>
;<z>
isTraceEnabled()) {<z>
context.getCacheNames());<z>
return null;<z>
addAllInterfaces(Class type, List list) {<z>
superclass = type.getSuperclass();<z>
null) {<z>
.getInterfaces()));<z>
;<z>
;<z>
(HttpServletResponse response,<z>
context, ServletServerHttpRequest request) throws IOException {<z>
new JettyServerHttpResponse(<z>
), getBufferSize(), request);<z>
{<z>
) {<z>
Configuration.class.getName())) {<z>
isOverridable()) {<z>
;<z>
, SQLExceptionTranslator translator) {<z>
(dbName, translator);<z>
if (logger.isDebugEnabled()) {<z>
if (replaced != null) {<z>
replaced + "] for database '" + dbName +<z>
translator + "]");<z>
.getName() +<z>
dbName + "'");<z>
connectHeaders, boolean isClientSession) {<z>
(sessionId, "'sessionId' must not be null");<z>
(connectHeaders, "'connectHeaders' must not be null");<z>
this.sessionId = sessionId;<z>
;<z>
isClientSession;<z>
this.outboundChannel = getClientOutboundChannelForSession(sessionId);<z>
!= null) {<z>
;<z>
{<z>
();<z>
.currentTimeMillis();<z>
.clientSendMessageCount = null;<z>
value) {<z>
= getValue();<z>
.put(this.key, value);<z>
;<z>
<HttpMessageWriter<?>> getCatchAllWriters() {<z>
if (!this.registerDefaults) {<z>
);<z>
>();<z>
()));<z>
return result;<z>
propertyEditor) {<z>
);<z>
!(converter instanceof PropertyEditorRegistry)) {<z>
new IllegalStateException(<z>
);<z>
;<z>
void writeHeaders(<z>
[] payload, Result result) {<z>
@SuppressWarnings("unchecked")<z>
String>> nativeHeaders =<z>
);<z>
(logger.isTraceEnabled()) {<z>
);<z>
nativeHeaders == null) {<z>
STOMP<z>
&& command != StompCommand.CONNECTED);<z>
()) {<z>
)) {<z>
;<z>
equals(command)) &&<z>
{<z>
);<z>
, shouldEscape);<z>
: values) {<z>
result.add(encodedKey);<z>
add(COLON_BYTE);<z>
(encodeHeaderValue(value, shouldEscape));<z>
.add(LINE_FEED_BYTE);<z>
if (command.requiresContentLength()) {<z>
contentLength = payload.length;<z>
UTF_8));<z>
UTF_8));<z>
.add(LINE_FEED_BYTE);<z>
@Nullable String namePrefix) {<z>
.ENGLISH) : "");<z>
names = new HashSet<>();<z>
) {<z>
if (code.startsWith(prefixToUse)) {<z>
names.add(code);<z>
return names;<z>
Marshaller marshaller, Object content) {<z>
.notNull(marshaller, "'marshaller' must not be null");<z>
notNull(content, "'content' must not be null");<z>
marshaller = marshaller;<z>
this.content = content;<z>
) throws SAXNotRecognizedException, SAXNotSupportedException {<z>
(name)) {<z>
namespacesFeature = value;<z>
(NAMESPACE_PREFIXES_FEATURE_NAME.equals(name)) {<z>
.namespacePrefixesFeature = value;<z>
;<z>
(URLConnection con) throws IOException {<z>
);<z>
) {<z>
(HttpURLConnection) con);<z>
, Class<?> genericIfc) {<z>
as(genericIfc);<z>
();<z>
if (generics.length < 2) {<z>
return null;<z>
resolve();<z>
generics[1].resolve();<z>
{<z>
null;<z>
;<z>
> expectedResultType)<z>
throws EvaluationException {<z>
, "EvaluationContext is required");<z>
CompiledExpression compiledAst = this.compiledAst;<z>
if (compiledAst != null) {<z>
.getValue(rootObject, context);<z>
(expectedResultType != null) {<z>
result), expectedResultType);<z>
(T) result;<z>
{<z>
) {<z>
= null;<z>
;<z>
EXCEPTION_RUNNING_COMPILED_EXPRESSION);<z>
.configuration);<z>
);<z>
expressionState);<z>
typedResultValue, expectedResultType);<z>
[] getCallbackKeys() {<z>
];<z>
callbackTypes.length; i++) {<z>
;<z>
;<z>
changeTheme(String themeName) {<z>
;<z>
{<z>
);<z>
.response, themeName);<z>
.theme = null;<z>
T unwrap(T type) {<z>
= null;<z>
SerializableTypeProxy) {<z>
().getType();<z>
unwrapped : type);<z>
) {<z>
patternsList = Arrays.asList(pathPatterns);<z>
>(pathPatterns.length);<z>
;<z>
(String pattern : patternsList) {<z>
.add(pattern);<z>
(versionPrefix + pattern)) {<z>
(versionPrefix + pattern);<z>
, StringUtils.toStringArray(prefixedPatterns));<z>
(AttributeAccessor source) {<z>
, "Source must not be null");<z>
= source.attributeNames();<z>
attributeName : attributeNames) {<z>
));<z>
getFooBytes() {<z>
;<z>
String) {<z>
.google.protobuf.ByteString b =<z>
google.protobuf.ByteString.copyFromUtf8(<z>
;<z>
;<z>
;<z>
{<z>
ByteString) ref;<z>
) {<z>
));<z>
(IOException ex) {<z>
(ex);<z>
ConstraintViolation<Object> violation, BindingResult bindingResult) {<z>
violation.getInvalidValue();<z>
) && !field.contains("[]") &&<z>
contains("."))) {<z>
invalidValue = bindingResult.getRawFieldValue(field);<z>
invalidValue;<z>
resolveIsolationLevel(int isolationLevel) {<z>
{<z>
:<z>
READ_COMMITTED;<z>
case TransactionDefinition.ISOLATION_READ_UNCOMMITTED:<z>
;<z>
.ISOLATION_REPEATABLE_READ:<z>
;<z>
case TransactionDefinition.ISOLATION_SERIALIZABLE:<z>
return IsolationLevel.SERIALIZABLE;<z>
null;<z>
{<z>
, Lazy.class);<z>
{<z>
("value"));<z>
(abd.getMetadata() != metadata) {<z>
, Lazy.class);<z>
(lazy != null) {<z>
"value"));<z>
())) {<z>
.setPrimary(true);<z>
);<z>
if (dependsOn != null) {<z>
getStringArray("value"));<z>
class);<z>
if (role != null) {<z>
.intValue());<z>
class);<z>
if (description != null) {<z>
("value"));<z>
throws JMSException {<z>
getStringProperty(this.typeIdPropertyName);<z>
== null) {<z>
new MessageConversionException(<z>
+ this.typeIdPropertyName + "] on message [" +<z>
getJMSDestination() + "]");<z>
;<z>
) {<z>
);<z>
.forName(typeId, this.beanClassLoader);<z>
.objectMapper.constructType(typeClass);<z>
) {<z>
ex);<z>
private void init() {<z>
(fastClassInfo == null) {<z>
{<z>
== null) {<z>
createInfo;<z>
FastClassInfo();<z>
helper(ci, ci.c1);<z>
;<z>
getIndex(sig1);<z>
);<z>
fci;<z>
;<z>
{<z>
= new SAXResult(getContentHandler());<z>
getLexicalHandler());<z>
);<z>
catch (IOException ex) {<z>
ex);<z>
;<z>
errorHandler != null) {<z>
);<z>
saxException;<z>
request,<z>
) throws Exception {<z>
response);<z>
getDataBinderFactory(handlerMethod);<z>
(handlerMethod, binderFactory);<z>
(handlerMethod);<z>
this.argumentResolvers != null) {<z>
invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);<z>
{<z>
returnValueHandlers);<z>
(binderFactory);<z>
invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);<z>
();<z>
;<z>
, mavContainer, invocableMethod);<z>
.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);<z>
createAsyncWebRequest(request, response);<z>
;<z>
WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);<z>
taskExecutor);<z>
);<z>
this.callableInterceptors);<z>
.deferredResultInterceptors);<z>
.hasConcurrentResult()) {<z>
= asyncManager.getConcurrentResult();<z>
;<z>
.clearConcurrentResult();<z>
.traceDebug(logger, traceOn -> {<z>
LogFormatUtils.formatValue(result, !traceOn);<z>
"]";<z>
;<z>
invocableMethod.wrapConcurrentResult(result);<z>
invokeAndHandle(webRequest, mavContainer);<z>
(asyncManager.isConcurrentHandlingStarted()) {<z>
;<z>
(mavContainer, modelFactory, webRequest);<z>
requestCompleted();<z>
EntityManager target,<z>
exceptionTranslator, @Nullable Boolean jta,<z>
, boolean synchronizedWithTransaction) {<z>
this.target = target;<z>
;<z>
!= null ? jta : isJtaEntityManager());<z>
= containerManaged;<z>
this.synchronizedWithTransaction = synchronizedWithTransaction;<z>
resourcePath, List<? extends Resource> locations,<z>
) {<z>
) &&<z>
resourcePath : null);<z>
, String beanName) throws BeansException {<z>
findLifecycleMetadata(bean.getClass());<z>
;<z>
ex) {<z>
;<z>
.isDebugEnabled()) {<z>
msg, ex.getTargetException());<z>
+ ": " + ex.getTargetException());<z>
ex) {<z>
("Failed to invoke destroy method on bean with name '" + beanName + "'", ex);<z>
{<z>
()) {<z>
isSessionLocallyTransacted(session)) {<z>
(logger.isDebugEnabled()) {<z>
);<z>
(session);<z>
)) {<z>
.recover();<z>
ex2) {<z>
debug("Could not roll back because Session already closed", ex2);<z>
{<z>
logger.error("Application exception overridden by rollback error", ex);<z>
ex2;<z>
{<z>
startsWith("http://xml.org/sax/features/")) {<z>
false;<z>
);<z>
(Annotation annotation) {<z>
(annotation);<z>
i < size(); i++) {<z>
)) {<z>
i).invoke(annotation);<z>
) {<z>
;<z>
true;<z>
Throwable ex) {<z>
.isDebugEnabled()) {<z>
().getSimpleName());<z>
);<z>
this.exceptionHandlerCache.get(beanType);<z>
) {<z>
.exceptionMethodResolverFactory.apply(beanType);<z>
(beanType, resolver);<z>
;<z>
(ex);<z>
if (method != null) {<z>
(), method);<z>
{<z>
;<z>
.isApplicableToBeanType(beanType)) {<z>
);<z>
method = resolver.resolveMethod(ex);<z>
(method != null) {<z>
;<z>
) {<z>
));<z>
(this.argumentResolvers.getResolvers());<z>
("No exception handling method", ex);<z>
;<z>
{<z>
contextMap) {<z>
);<z>
();<z>
ConfigurableBeanFactory otherFactory) {<z>
;<z>
);<z>
);<z>
;<z>
setConversionService(otherFactory.getConversionService());<z>
AbstractBeanFactory otherAbstractFactory) {<z>
;<z>
.customEditors);<z>
typeConverter = otherAbstractFactory.typeConverter;<z>
beanPostProcessors);<z>
otherAbstractFactory.scopes);<z>
getTypeConverter());<z>
[] otherScopeNames = otherFactory.getRegisteredScopeNames();<z>
(String scopeName : otherScopeNames) {<z>
scopeName));<z>
Object handler)<z>
throws Exception {<z>
return true;<z>
LocalSessionFactoryBuilder(<z>
) {<z>
);<z>
, SpringSessionContext.class.getName());<z>
!= null) {<z>
;<z>
).put(AvailableSettings.CONNECTION_HANDLING,<z>
DELAYED_ACQUISITION_AND_HOLD);<z>
resourceLoader.getClassLoader()));<z>
resourceLoader);<z>
@Nullable Object[] args) {<z>
String beanName = "";<z>
1 && args[0] != null) {<z>
);<z>
serviceMappings != null) {<z>
= serviceMappings.getProperty(beanName);<z>
mappedName != null) {<z>
beanName = mappedName;<z>
beanName;<z>
(Element ele, BeanDefinitionParserDelegate delegate) {<z>
(ele, IMPORT_ELEMENT)) {<z>
);<z>
{<z>
ele);<z>
delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {<z>
);<z>
)) {<z>
ele);<z>
{<z>
mm1.isRuntime() ?<z>
.matches(method, targetClass));<z>
(this.mm2.isRuntime() ?<z>
));<z>
;<z>
) &&<z>
classLoader);<z>
("com.fasterxml.jackson.dataformat.xml.XmlMapper", classLoader);<z>
= ClassUtils.isPresent("com.fasterxml.jackson.dataformat.smile.SmileFactory", classLoader);<z>
classLoader);<z>
);<z>
("jakarta.json.bind.Jsonb", classLoader);<z>
ClassUtils.isPresent("kotlinx.serialization.json.Json", classLoader);<z>
new ArrayList<>();<z>
);<z>
;<z>
= new HeadersExtractor();<z>
) {<z>
;<z>
());<z>
));<z>
) {<z>
<>());<z>
) {<z>
);<z>
romePresent) {<z>
AtomFeedHttpMessageConverter());<z>
;<z>
shouldIgnoreXml) {<z>
jackson2XmlPresent) {<z>
);<z>
) {<z>
;<z>
(jackson2Present) {<z>
new MappingJackson2HttpMessageConverter());<z>
if (gsonPresent) {<z>
;<z>
else if (jsonbPresent) {<z>
);<z>
(kotlinSerializationJsonPresent) {<z>
));<z>
if (jackson2SmilePresent) {<z>
());<z>
if (jackson2CborPresent) {<z>
new MappingJackson2CborHttpMessageConverter());<z>
);<z>
void authType(MockHttpServletRequest request) {<z>
"Authorization");<z>
(authorization, ": ");<z>
authSplit != null) {<z>
);<z>
Map<String, ?> attributes) {<z>
value) -> {<z>
value.getClass())) {<z>
.storeAttribute(request, name, value);<z>
});<z>
SubscribableChannel inboundChannel, MessageChannel outboundChannel,<z>
{<z>
.emptyList());<z>
[] batchArgs) {<z>
.length == 0) {<z>
return new int[0];<z>
= getParsedSql(sql);<z>
(parsedSql, batchArgs[0]);<z>
getJdbcOperations().batchUpdate(<z>
getSql(),<z>
) {<z>
ps, int i) throws SQLException {<z>
;<z>
ps);<z>
getBatchSize() {<z>
.length;<z>
;<z>
DataBuffer> body) {<z>
) {<z>
) body)<z>
flatMap(buffer -> {<z>
touchDataBuffer(buffer);<z>
new AtomicBoolean();<z>
doCommit(<z>
) -> {<z>
.fromCallable(() -> buffer)<z>
s -> subscribed.set(true))<z>
;<z>
) {<z>
return Mono.error(ex);<z>
)<z>
) -> {<z>
get()) {<z>
buffer);<z>
});<z>
).clearContentHeaders())<z>
);<z>
(inner)))<z>
;<z>
] getNames(Class[] classes) {<z>
== null)<z>
return null;<z>
;<z>
{<z>
;<z>
;<z>
) {<z>
.map) {<z>
remove(name);<z>
throws Throwable {<z>
(), BEAN_FACTORY_FIELD);<z>
"Unable to find generated BeanFactory field");<z>
args[0]);<z>
).getSuperclass()))) {<z>
obj, args);<z>
return null;<z>
,<z>
) {<z>
(registry, useDefaultFilters, environment,<z>
) registry : null));<z>
,<z>
context, @Nullable Object source) {<z>
StompSubProtocolHandler.class);<z>
);<z>
.getChildElementByTagName(element, "stomp-error-handler");<z>
!= null) {<z>
);<z>
).add("errorHandler", errorHandlerRef);<z>
ConstructorArgumentValues();<z>
0, inChannel);<z>
outChannel);<z>
null);<z>
).addPropertyValue("protocolHandlers", stompHandlerDef);<z>
, context, source);<z>
RuntimeBeanReference(WEB_SOCKET_HANDLER_BEAN_NAME);<z>
"transport");<z>
transportElem != null) {<z>
"message-size")) {<z>
));<z>
{<z>
("send-timeout"));<z>
transportElem.hasAttribute("send-buffer-size")) {<z>
"send-buffer-size"));<z>
)) {<z>
);<z>
(transportElem, "decorator-factories");<z>
) {<z>
factories = extractBeanSubElements(factoriesElement, context);<z>
);<z>
, result);<z>
;<z>
registerBeanDef(factoryBean, context, source));<z>
;<z>
Class<? extends Throwable> exceptionType) {<z>
);<z>
== null) {<z>
;<z>
(exceptionType, method);<z>
null);<z>
{<z>
test(request)) {<z>
if (logger.isTraceEnabled()) {<z>
, this.predicate, request));<z>
handlerFunction);<z>
;<z>
(@Nullable Object other) {<z>
other) {<z>
true;<z>
) {<z>
;<z>
.equals(otherKey.method) &&<z>
));<z>
) throws Exception {<z>
() == null) {<z>
;<z>
argTypes) {<z>
toString(argTypes), method -><z>
) ? method.getParameterCount() == 0 :<z>
.getParameterTypes(), argTypes));<z>
this;<z>
inbound, WebsocketOutbound outbound,<z>
) {<z>
, info, bufferFactory, DEFAULT_FRAME_MAX_SIZE);<z>
, String paramName, Object value)<z>
throws DataAccessException {<z>
, new Object[] {value});<z>
targetType) {<z>
);<z>
source instanceof ByteBuffer buffer) {<z>
targetType));<z>
byteBufferTarget) {<z>
;<z>
);<z>
() {<z>
status instanceof HttpStatus) {<z>
.status;<z>
Integer) this.status);<z>
() {<z>
(HttpHeaders.HOST);<z>
String host = rawHostHeader;<z>
host != null) {<z>
host.trim();<z>
)) {<z>
int indexOfClosingBracket = host.indexOf(']');<z>
) -> "Invalid Host header: " + rawHostHeader);<z>
0, indexOfClosingBracket + 1);<z>
":")) {<z>
host.indexOf(':'));<z>
host;<z>
this.serverName;<z>
<T> type) {<z>
() -> "BeanFactory required for resolution of [" + type + "]");<z>
.beanFactory.getBean(type);<z>
{<z>
+<z>
ex);<z>
NoSuchBeanDefinitionException ex) {<z>
.isDebugEnabled()) {<z>
"] found in application context", ex);<z>
return BeanUtils.instantiateClass(type);<z>
) {<z>
null) {<z>
);<z>
txAttr.getQualifier();<z>
qualifier)) {<z>
);<z>
) {<z>
this.transactionManagerBeanName);<z>
();<z>
{<z>
.get(DEFAULT_TRANSACTION_MANAGER_KEY);<z>
if (defaultTransactionManager == null) {<z>
getBean(TransactionManager.class);<z>
.transactionManagerCache.putIfAbsent(<z>
defaultTransactionManager);<z>
return defaultTransactionManager;<z>
() {<z>
.protobuf.OuterSample.internal_static_Msg_fieldAccessorTable<z>
ensureFieldAccessorsInitialized(<z>
.Builder.class);<z>
public Enumeration<String> getParameterNames() {<z>
LinkedHashSet<>();<z>
.getParameterNames()));<z>
;<z>
return Collections.enumeration(names);<z>
@Nullable MessagePostProcessor postProcessor) {<z>
defaultDestination = getDefaultDestination();<z>
if (defaultDestination != null) {<z>
(defaultDestination, request, targetClass, postProcessor);<z>
postProcessor);<z>
(String name) {<z>
] parameterValues = super.getParameterValues(name);<z>
.get(name);<z>
{<z>
;<z>
getQueryString() == null) {<z>
(formParam);<z>
;<z>
parameterValues));<z>
(formParam);<z>
return StringUtils.toStringArray(result);<z>
@Nullable HttpMethod requestMethod) {<z>
) {<z>
;<z>
== null) {<z>
singletonList(requestMethod);<z>
resolvedMethods : null);<z>
() {<z>
();<z>
null) {<z>
)) {<z>
> clazz;<z>
className = "org.springframework.validation.beanvalidation.OptionalValidatorFactoryBean";<z>
.class.getClassLoader());<z>
{<z>
throw new BeanInitializationException("Failed to resolve default validator class", ex);<z>
BeanUtils.instantiateClass(clazz);<z>
);<z>
return validator;<z>
> message) {<z>
null) {<z>
;<z>
.class);<z>
) {<z>
;<z>
catch (SpelEvaluationException ex) {<z>
()) {<z>
;<z>
catch (Throwable ex) {<z>
);<z>
;<z>
<DestructionAwareBeanPostProcessor> postProcessors) {<z>
)) {<z>
) {<z>
processor.requiresDestruction(bean)) {<z>
true;<z>
false;<z>
, WebFilterChain chain) {<z>
!= HttpMethod.POST) {<z>
chain.filter(exchange);<z>
return exchange.getFormData()<z>
-> {<z>
);<z>
exchange;<z>
.flatMap(chain::filter);<z>
) {<z>
.webSocketHandler == null) {<z>
null;<z>
) {<z>
instanceof StompSubProtocolHandler) {<z>
;<z>
= this.webSocketHandler.getDefaultProtocolHandler();<z>
{<z>
defaultHandler;<z>
;<z>
)<z>
{<z>
.getClass()), outputMessage);<z>
getBlahFieldBuilder() {<z>
null) {<z>
protobuf.SingleFieldBuilder<>(<z>
),<z>
isClean());<z>
blah_ = null;<z>
return blahBuilder_;<z>
static boolean isConfigurationCandidate(AnnotationMetadata metadata) {<z>
if (metadata.isInterface()) {<z>
return false;<z>
candidateIndicators) {<z>
(indicator)) {<z>
return true;<z>
return hasBeanMethods(metadata);<z>
) {<z>
this.directory<z>
::createNewDirectoryIfDeleted)<z>
));<z>
HandlerResult> invoke(<z>
BindingContext bindingContext, Object... providedArgs) {<z>
-> {<z>
value;<z>
();<z>
{<z>
;<z>
);<z>
) {<z>
), getBean(), args);<z>
.getMessage() : "Illegal argument");<z>
);<z>
InvocationTargetException ex) {<z>
error(ex.getTargetException());<z>
catch (Throwable ex) {<z>
, ex));<z>
status = getResponseStatus();<z>
!= null) {<z>
().setStatusCode(status);<z>
;<z>
;<z>
);<z>
isResponseHandled(args, exchange)) {<z>
);<z>
returnType, bindingContext);<z>
(result);<z>
;<z>
void evict(Object entity) throws DataAccessException {<z>
{<z>
entity);<z>
;<z>
);<z>
void executeInternal(JobExecutionContext context) throws JobExecutionException {<z>
;<z>
());<z>
) {<z>
JobExecutionException) {<z>
.getTargetException();<z>
;<z>
(Exception ex) {<z>
;<z>
?> targetClass) {<z>
getUserClass(targetClass) : null);<z>
;<z>
resolvedMethod);<z>
boolean equals(Object other) {<z>
== other) {<z>
true;<z>
.getClass()) {<z>
return false;<z>
;<z>
equals(person.getName());<z>
doReceiveAndExecute(Object invoker, @Nullable Session session,<z>
TransactionStatus status) throws JMSException {<z>
= null;<z>
= null;<z>
= null;<z>
session;<z>
false;<z>
) {<z>
.doGetTransactionalSession(<z>
, true);<z>
);<z>
if (sessionToUse == null) {<z>
conToUse;<z>
sharedConnectionEnabled()) {<z>
getSharedConnection();<z>
;<z>
conToClose = conToUse;<z>
();<z>
;<z>
sessionToUse;<z>
;<z>
{<z>
consumerToUse = createListenerConsumer(sessionToUse);<z>
consumerToClose = consumerToUse;<z>
consumerToUse);<z>
message != null) {<z>
if (logger.isDebugEnabled()) {<z>
) + "] from consumer [" +<z>
+<z>
);<z>
;<z>
!transactional && isExposeListenerSession() &&<z>
obtainConnectionFactory()));<z>
if (exposeResource) {<z>
TransactionSynchronizationManager.bindResource(<z>
LocallyExposedJmsResourceHolder(sessionToUse));<z>
);<z>
) {<z>
) {<z>
(logger.isDebugEnabled()) {<z>
;<z>
status.setRollbackOnly();<z>
ex);<z>
ex instanceof JMSException) {<z>
ex;<z>
{<z>
;<z>
;<z>
(logger.isTraceEnabled()) {<z>
) +<z>
"session [" + sessionToUse + "] did not receive a message");<z>
, sessionToUse);<z>
shouldCommitAfterNoMessageReceived(sessionToUse)) {<z>
;<z>
false;<z>
(consumerToClose);<z>
(sessionToClose);<z>
, getConnectionFactory(), true);<z>
validateValue(<z>
, Errors errors, Object... validationHints) {<z>
+ targetType);<z>
get(int index) {<z>
size();<z>
element = null;<z>
) {<z>
get(index);<z>
) {<z>
;<z>
set(index, element);<z>
; x++) {<z>
.add(null);<z>
createElement(index);<z>
.backingList.add(element);<z>
element;<z>
Object attributeValue) {<z>
, "WebRequest must not be null");<z>
attributeName, "Attribute name must not be null");<z>
.notNull(attributeValue, "Attribute value must not be null");<z>
String storeAttributeName = getAttributeNameInSession(request, attributeName);<z>
WebRequest.SCOPE_SESSION);<z>
(final String stringValue) {<z>
length();<z>
charLength > 65535) {<z>
);<z>
length;<z>
length) {<z>
;<z>
[] currentData = data;<z>
(charLength >>> 8);<z>
currentLength++] = (byte) charLength;<z>
; ++i) {<z>
i);<z>
' && charValue <= '\u007F') {<z>
) charValue;<z>
{<z>
length = currentLength;<z>
, i, 65535);<z>
;<z>
;<z>
{<z>
client.stop();<z>
{<z>
"Failed to stop Jetty WebSocketClient", ex);<z>
String... allowedOriginPatterns) {<z>
this.allowedOriginPatterns.clear();<z>
{<z>
(allowedOriginPatterns));<z>
return this;<z>
) {<z>
boolean matches(Annotation annotation) {<z>
;<z>
(Class<?> type) {<z>
false;<z>
boolean matches(String typeName) {<z>
;<z>
() {<z>
return "No annotation filtering";<z>
(String name, boolean htmlEscape) {<z>
null) {<z>
();<z>
= this.errorsMap.get(name);<z>
) {<z>
.MODEL_KEY_PREFIX + name);<z>
) {<z>
null;<z>
BindException bindException) {<z>
;<z>
EscapedErrors)) {<z>
= new EscapedErrors(errors);<z>
escapedErrors) {<z>
errors = escapedErrors.getSource();<z>
);<z>
;<z>
contextPath(String contextPath) {<z>
hasText(contextPath)) {<z>
("/"), "Context path must start with a '/'");<z>
);<z>
;<z>
return this;<z>
AnnotationVisitor visitTypeAnnotation(<z>
, final boolean visible) {<z>
) {<z>
(typeRef, typePath, descriptor, visible);<z>
null;<z>
ex) {<z>
);<z>
.setRollbackOnly();<z>
;<z>
> submitListenable(Runnable task) {<z>
ListenableFutureTask<>(task, null);<z>
future);<z>
return future;<z>
Message message) throws JMSException {<z>
()) {<z>
) {<z>
warn("Rejecting received message because of the listener container " +<z>
message);<z>
rollbackIfNecessary(session);<z>
new MessageRejectedWhileStoppingException();<z>
invokeListener(session, message);<z>
) {<z>
(session, ex);<z>
ex;<z>
, message);<z>
, Object key) {<z>
);<z>
RuntimeException ex) {<z>
);<z>
return null;<z>
type) {<z>
type);<z>
) {<z>
.serializer(type);<z>
serializerCache.put(type, serializer);<z>
serializer;<z>
, TypeDescriptor sourceType, TypeDescriptor targetType) {<z>
) {<z>
null;<z>
;<z>
().isInstance(source);<z>
)) {<z>
source;<z>
.getElementTypeDescriptor();<z>
{<z>
;<z>
targetType.getType(),<z>
));<z>
(elementDesc == null) {<z>
(sourceCollection);<z>
) {<z>
targetElement = this.conversionService.convert(sourceElement,<z>
elementDesc);<z>
);<z>
targetElement) {<z>
copyRequired = true;<z>
;<z>
> events, Class<?> outputClass) {<z>
(outputClass);<z>
events);<z>
.class)) {<z>
.unmarshal(eventReader);<z>
= unmarshaller.unmarshal(eventReader, outputClass);<z>
();<z>
catch (UnmarshalException ex) {<z>
);<z>
JAXBException ex) {<z>
new CodecException("Invalid JAXB configuration", ex);<z>
) throws Exception {<z>
request.removeAttribute(PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);<z>
;<z>
clearMediaTypesAttribute(request);<z>
request) {<z>
;<z>
.apache.catalina.connector.Request)<z>
(COYOTE_REQUEST_FIELD, requestFacade);<z>
state(connectorRequest != null, "No Tomcat connector request");<z>
getCoyoteRequest();<z>
);<z>
factory,<z>
<Void> completionSink) {<z>
completionSink);<z>
boolean getBooleanValue(ExpressionState state, SpelNodeImpl operand) {<z>
.class);<z>
(value);<z>
;<z>
catch (SpelEvaluationException ee) {<z>
(operand.getStartPosition());<z>
;<z>
(Class<?> fallback) {<z>
= getGenerics();<z>
length];<z>
i++) {<z>
generics[i].resolve(fallback);<z>
return resolvedGenerics;<z>
{<z>
"Already immutable");<z>
>> map = getNativeHeaders();<z>
== null) {<z>
(name) != null) {<z>
);<z>
(name);<z>
) {<z>
(3);<z>
, map);<z>
new ArrayList<>(1);<z>
);<z>
name))) {<z>
;<z>
map.put(name, values);<z>
, IntroductionInterceptor interceptor) {<z>
= interceptor;<z>
;<z>
typePattern);<z>
);<z>
intersection(typePatternFilter, exclusion);<z>
payload, @Nullable MessageHeaders headers) {<z>
);<z>
(super.canConvertTo(payload, headers) ||<z>
(contentType));<z>
o) throws Throwable {<z>
o instanceof Throwable) {<z>
throw (Throwable) o;<z>
;<z>
String beanName, Object singletonObject) throws IllegalStateException {<z>
(beanName, singletonObject);<z>
beanName));<z>
clearByTypeCache();<z>
(StreamSourceChannel channel) {<z>
suspendReads();<z>
;<z>
();<z>
HttpServletRequest request) throws IOException {<z>
)) {<z>
session = request.getSession();<z>
.isInstance(session)) {<z>
new IllegalStateException(<z>
+ "]: " + session);<z>
session;<z>
)) {<z>
.resolvePushBuilder(request, paramType);<z>
.isAssignableFrom(paramType)) {<z>
);<z>
(inputStream)) {<z>
(<z>
"]: " + inputStream);<z>
;<z>
isAssignableFrom(paramType)) {<z>
);<z>
!paramType.isInstance(reader)) {<z>
new IllegalStateException(<z>
() + "]: " + reader);<z>
;<z>
paramType)) {<z>
();<z>
(userPrincipal)) {<z>
IllegalStateException(<z>
) + "]: " + userPrincipal);<z>
return userPrincipal;<z>
HttpMethod.class == paramType) {<z>
valueOf(request.getMethod());<z>
.class == paramType) {<z>
RequestContextUtils.getLocale(request);<z>
else if (TimeZone.class == paramType) {<z>
getTimeZone(request);<z>
TimeZone.getDefault());<z>
) {<z>
TimeZone timeZone = RequestContextUtils.getTimeZone(request);<z>
) : ZoneId.systemDefault());<z>
);<z>
int cardinalityOut) {<z>
) {<z>
0:<z>
case 1:<z>
{<z>
case 0: return REQUEST_FNF_OR_RESPONSE_CONDITION;<z>
: return REQUEST_RESPONSE_CONDITION;<z>
;<z>
"Invalid cardinality: " + cardinalityOut);<z>
2:<z>
;<z>
+ cardinalityIn);<z>
BeanDefinitionOverrideException(<z>
, BeanDefinition existingDefinition) {<z>
,<z>
"] for bean '" + beanName +<z>
;<z>
.beanDefinition = beanDefinition;<z>
this.existingDefinition = existingDefinition;<z>
generate(ClassLoaderData data) {<z>
validate();<z>
superclass != null) {<z>
superclass.getName());<z>
) {<z>
].getName());<z>
);<z>
{<z>
{<z>
;<z>
;<z>
null, "No node");<z>
TokenKind.RPAREN);<z>
expr);<z>
true;<z>
false;<z>
)<z>
AccessException {<z>
allowWrite) {<z>
throw new AccessException("PropertyAccessor for property '" + name +<z>
target + "] does not allow write operations");<z>
state(target != null, "Target must not be null");<z>
));<z>
Object possiblyConvertedNewValue = newValue;<z>
target, name);<z>
{<z>
.getTypeConverter().convertValue(<z>
(newValue), typeDescriptor);<z>
catch (EvaluationException evaluationException) {<z>
evaluationException);<z>
, name, target instanceof Class);<z>
= this.writerCache.get(cacheKey);<z>
instanceof Method) {<z>
(Method) cachedMember;<z>
if (method == null) {<z>
;<z>
method != null) {<z>
= ClassUtils.getInterfaceMethodIfPossible(method);<z>
method;<z>
writerCache.put(cacheKey, cachedMember);<z>
!= null) {<z>
ReflectionUtils.makeAccessible(method);<z>
);<z>
{<z>
);<z>
instanceof Field) {<z>
field = (Field) cachedMember;<z>
(field == null) {<z>
, target);<z>
{<z>
field;<z>
put(cacheKey, cachedMember);<z>
!= null) {<z>
field);<z>
(target, possiblyConvertedNewValue);<z>
Exception ex) {<z>
+ "'", ex);<z>
;<z>
(@Nullable Object other) {<z>
) {<z>
return true;<z>
(other instanceof PathSegment)) {<z>
false;<z>
.value());<z>
(Project project) {<z>
JavaCompile.class)<z>
.COMPILE_JAVA_TASK_NAME))<z>
-> {<z>
;<z>
("UTF-8");<z>
});<z>
JavaCompile.class)<z>
.COMPILE_TEST_JAVA_TASK_NAME)<z>
.equals("compileTestFixturesJava"))<z>
forEach(compileTask -> {<z>
;<z>
).setEncoding("UTF-8");<z>
;<z>
Part>> initMultipartData(ServerHttpRequest request,<z>
ServerCodecConfigurer configurer, String logPrefix) {<z>
();<z>
{<z>
configurer.getReaders().stream()<z>
.MULTIPART_FORM_DATA))<z>
.findFirst()<z>
IllegalStateException("No multipart HttpMessageReader.")))<z>
Hints.LOG_PREFIX_HINT, logPrefix))<z>
EMPTY_MULTIPART_DATA)<z>
;<z>
(InvalidMediaTypeException ex) {<z>
return EMPTY_MULTIPART_DATA;<z>
status) {<z>
) {<z>
STATUS_COMMITTED:<z>
);<z>
.invokeAfterCompletion(<z>
);<z>
STATUS_ROLLEDBACK:<z>
(<z>
this.synchronizations, TransactionSynchronization.STATUS_ROLLED_BACK);<z>
.invokeAfterCompletion(<z>
, TransactionSynchronization.STATUS_UNKNOWN);<z>
() {<z>
activeProfiles) {<z>
isEmpty()) {<z>
doGetActiveProfilesProperty();<z>
StringUtils.hasText(profiles)) {<z>
setActiveProfiles(StringUtils.commaDelimitedListToStringArray(<z>
StringUtils.trimAllWhitespace(profiles)));<z>
this.activeProfiles;<z>
Object value) {<z>
isEmptyString(value) ||<z>
value) ||<z>
TransactionMode.DEFAULT ||<z>
ErrorMode.DEFAULT);<z>
DefaultClientResponseBuilder(ExchangeStrategies strategies) {<z>
);<z>
strategies;<z>
);<z>
<>();<z>
;<z>
,<z>
NativeWebRequest webRequest, WebDataBinderFactory binderFactory) {<z>
;<z>
.value;<z>
parseRoutes(List<Route> routes) {<z>
(route -> {<z>
.add(route.pattern);<z>
(route.matchingPaths);<z>
);<z>
String name) throws SAXNotRecognizedException {<z>
)) {<z>
;<z>
throw new SAXNotRecognizedException(name);<z>
int parameterPosition, int argType, Object argValue)<z>
{<z>
argType, argValue);<z>
RequestPart requestPart) {<z>
= null;<z>
requestPart != null) {<z>
requestPart.name();<z>
StringUtils.hasLength(name)) {<z>
= methodParam.getParameterName();<z>
)) {<z>
throw new IllegalArgumentException("Request part name for argument type [" +<z>
) +<z>
);<z>
;<z>
getTypeConverter() {<z>
{<z>
.getPropertyAccessor();<z>
getSimpleTypeConverter();<z>
DatabaseMetaData databaseMetaData,<z>
String tableName)<z>
{<z>
if (!this.includeSynonyms) {<z>
);<z>
);<z>
= databaseMetaData.getConnection();<z>
== null) {<z>
.info("Unable to include synonyms in table meta-data lookup - no Connection from DatabaseMetaData");<z>
tableName);<z>
).loadClass("oracle.jdbc.OracleConnection");<z>
oracleConClass);<z>
| SQLException ex) {<z>
isInfoEnabled()) {<z>
.info("Unable to include synonyms in table meta-data lookup - no Oracle Connection: " + ex);<z>
databaseMetaData, catalogName, schemaName, tableName);<z>
logger.debug("Including synonyms in table meta-data lookup");<z>
;<z>
originalValueForIncludeSynonyms;<z>
.getClass().getMethod("getIncludeSynonyms");<z>
ReflectionUtils.makeAccessible(getIncludeSynonyms);<z>
con);<z>
("setIncludeSynonyms", boolean.class);<z>
);<z>
TRUE);<z>
(Throwable ex) {<z>
, ex);<z>
databaseMetaData, catalogName, schemaName, tableName);<z>
setIncludeSynonyms.invoke(con, originalValueForIncludeSynonyms);<z>
catch (Throwable ex) {<z>
throw new InvalidDataAccessApiUsageException("Could not reset Oracle Connection", ex);<z>
getDescriptiveType(@Nullable Object value) {<z>
null) {<z>
return null;<z>
);<z>
.isProxyClass(clazz)) {<z>
" implementing ";<z>
"");<z>
: clazz.getInterfaces()) {<z>
());<z>
result.toString();<z>
getTypeName();<z>
{<z>
getLeftOperand())) {<z>
TRUE;<z>
));<z>
) {<z>
if (isTargetFilterLifecycle()) {<z>
delegate.destroy();<z>
getEvaluationContext() {<z>
{<z>
new StandardEvaluationContext();<z>
;<z>
public void setTransactionAttributes(Properties transactionAttributes) {<z>
NameMatchTransactionAttributeSource();<z>
;<z>
;<z>
(NativeWebRequest webRequest, @Nullable String key)<z>
throws HttpMediaTypeNotAcceptableException {<z>
StringUtils.hasText(key)) {<z>
);<z>
{<z>
key, mediaType);<z>
;<z>
= handleNoMatch(webRequest, key);<z>
mediaType != null) {<z>
;<z>
return Collections.singletonList(mediaType);<z>
return MEDIA_TYPE_ALL_LIST;<z>
void init() {<z>
, new PropertyPlaceholderBeanDefinitionParser());<z>
());<z>
AnnotationConfigBeanDefinitionParser());<z>
());<z>
;<z>
, new SpringConfiguredBeanDefinitionParser());<z>
registerBeanDefinitionParser("mbean-export", new MBeanExportBeanDefinitionParser());<z>
);<z>
@Nullable Object extractedValue,<z>
) {<z>
;<z>
); i++) {<z>
.get(i);<z>
.invokeMethod(attribute, annotation);<z>
Object value2;<z>
(extractedValue instanceof TypeMappedAnnotation) {<z>
null);<z>
(attribute, extractedValue);<z>
) {<z>
false;<z>
;<z>
String[] getDependentBeans(String beanName) {<z>
dependentBeanMap.get(beanName);<z>
== null) {<z>
];<z>
{<z>
;<z>
MediaType mediaType) {<z>
"data:");<z>
);<z>
));<z>
('\n');<z>
return this;<z>
(C context, int aggregateIndex, Method source,<z>
AnnotationsProcessor<C, R> processor) {<z>
source, false);<z>
source, annotations);<z>
{<z>
result;<z>
source);<z>
bridgedMethod != source) {<z>
getDeclaredAnnotations(bridgedMethod, true);<z>
; i++) {<z>
bridgedAnnotations[i])) {<z>
bridgedAnnotations[i] = null;<z>
source, bridgedAnnotations);<z>
;<z>
?> findAnnotationDeclaringClass(<z>
, @Nullable Class<?> clazz) {<z>
null) {<z>
null;<z>
)<z>
MergedAnnotation::isDirectlyPresent)<z>
getSource();<z>
{<z>
, ")");<z>
{<z>
(i).toStringAST());<z>
toString();<z>
String... profiles) {<z>
(profiles, "Profile array must not be null");<z>
{<z>
asList(profiles));<z>
(this.activeProfiles) {<z>
clear();<z>
(String profile : profiles) {<z>
;<z>
add(profile);<z>
protected ModelAndView writeToInternal(HttpServletRequest servletRequest, HttpServletResponse servletResponse,<z>
) throws ServletException, IOException {<z>
servletResponse, context);<z>
writeAsync(servletRequest, servletResponse, deferredResult);<z>
;<z>
) {<z>
.findCandidateAdvisors();<z>
.aspectJAdvisorsBuilder != null) {<z>
.buildAspectJAdvisors());<z>
return advisors;<z>
MultipartHttpServletRequest request) {<z>
("cleanedUp") != null) {<z>
"Already cleaned up");<z>
"cleanedUp", Boolean.TRUE);<z>
(String headerName, @Nullable String headerValue) {<z>
{<z>
(headerName, headerValue);<z>
);<z>
String extractPathWithinPattern(String pattern, String path) {<z>
, this.trimTokens, true);<z>
trimTokens, true);<z>
);<z>
;<z>
patternParts.length; segment++) {<z>
];<z>
indexOf('?') > -1) {<z>
pathParts.length; segment++) {<z>
)) {<z>
append(this.pathSeparator);<z>
pathParts[segment]);<z>
true;<z>
();<z>
{<z>
getKotlinClass(clazz));<z>
(primaryCtor == null) {<z>
null;<z>
getJavaConstructor(primaryCtor);<z>
if (constructor == null) {<z>
new IllegalStateException(<z>
());<z>
constructor;<z>
ex) {<z>
;<z>
StringBuffer getRequestURL() {<z>
String scheme = getScheme();<z>
();<z>
getServerPort();<z>
String uri = getRequestURI();<z>
"://").append(server);<z>
&& port != 80) ||<z>
443))) {<z>
).append(port);<z>
(StringUtils.hasText(uri)) {<z>
append(uri);<z>
return url;<z>
EvaluationException {<z>
, "EvaluationContext is required");<z>
= this.compiledAst;<z>
compiledAst != null) {<z>
context);<z>
{<z>
getCompilerMode() == SpelCompilerMode.MIXED) {<z>
compiledAst = null;<z>
);<z>
EXCEPTION_RUNNING_COMPILED_EXPRESSION);<z>
.configuration);<z>
ast.getValue(expressionState);<z>
);<z>
result;<z>
long initialInterval, double multiplier) {<z>
checkMultiplier(multiplier);<z>
initialInterval;<z>
.multiplier = multiplier;<z>
) {<z>
this.headers.getFirst("Content-Encoding");<z>
null);<z>
{<z>
(this.timeoutInProgress || this.errorInProgress) {<z>
logger.debug("Closing Hibernate Session after async request timeout/error");<z>
;<z>
actualType, ResolvableType elementType,<z>
<String, Object> hints) {<z>
Hints.merge(hints,<z>
);<z>
request, allHints);<z>
, Date lastActualExecutionTime, Date lastCompletionTime) {<z>
this.lastScheduledExecutionTime = lastScheduledExecutionTime;<z>
lastActualExecutionTime = lastActualExecutionTime;<z>
lastCompletionTime = lastCompletionTime;<z>
doGetTransactionalSession(<z>
throws JMSException {<z>
, true);<z>
void checkParameters(String parameter, String value) {<z>
(parameter, "'parameter' must not be empty");<z>
value, "'value' must not be empty");<z>
;<z>
(PARAM_CHARSET.equals(parameter)) {<z>
null) {<z>
unquote(value));<z>
{<z>
value);<z>
void interruptIfNecessary() {<z>
= this.currentReceiveThread;<z>
!currentReceiveThread.isInterrupted()) {<z>
interrupt();<z>
Nullable UriComponentsBuilder builder,<z>
controllerType, Method method, Object... args) {<z>
builder);<z>
);<z>
.path(prefix);<z>
controllerType);<z>
(method);<z>
= pathMatcher.combine(typePath, methodPath);<z>
path.startsWith("/")) {<z>
;<z>
;<z>
(builder, method, args);<z>
{<z>
getPropertyValue(o1);<z>
;<z>
v2 instanceof String)) {<z>
(String) v1).toLowerCase();<z>
;<z>
;<z>
) {<z>
compareTo(v2) : -1);<z>
null ? 1 : 0);<z>
catch (RuntimeException ex) {<z>
isDebugEnabled()) {<z>
"]", ex);<z>
return 0;<z>
? result : -result);<z>
Object other) {<z>
if (this == other) {<z>
;<z>
(!(other instanceof AspectJPointcutAdvisor otherAdvisor)) {<z>
return false;<z>
advice.equals(otherAdvisor.advice);<z>
HttpServletRequest request) throws Exception {<z>
String lookupPath = initLookupPath(request);<z>
handler;<z>
) {<z>
RequestPath path = ServletRequestPathUtils.getParsedRequestPath(request);<z>
;<z>
request);<z>
) {<z>
= null;<z>
) {<z>
= getRootHandler();<z>
== null) {<z>
= getDefaultHandler();<z>
if (rawHandler != null) {<z>
(rawHandler instanceof String handlerName) {<z>
);<z>
(rawHandler, request);<z>
, lookupPath, null);<z>
return handler;<z>
getCorePoolSize() {<z>
{<z>
return this.corePoolSize;<z>
)<z>
{<z>
);<z>
String etag) {<z>
(etag)) {<z>
return false;<z>
ifNoneMatch;<z>
();<z>
{<z>
return false;<z>
ifNoneMatch.isEmpty()) {<z>
return false;<z>
etag);<z>
startsWith("W/")) {<z>
.substring(2);<z>
ifNoneMatch) {<z>
)) {<z>
{<z>
;<z>
equals(etag)) {<z>
true;<z>
;<z>
hashCode() {<z>
).hashCode();<z>
.value);<z>
;<z>
;<z>
byte[] b) throws IOException {<z>
this.is.read(b);<z>
, 0, count);<z>
return count;<z>
equals(@Nullable Object other) {<z>
!(other instanceof PathPattern otherPattern)) {<z>
;<z>
()) &&<z>
) &&<z>
otherPattern.caseSensitive);<z>
setApplicationContext(@Nullable ApplicationContext context) {<z>
context);<z>
;<z>
&& viewConfig.getEngine() != null) {<z>
= viewConfig.getEngine();<z>
viewConfig.getEngineSupplier() != null) {<z>
.engineSupplier = viewConfig.getEngineSupplier();<z>
getEngineName() != null) {<z>
.engineName = viewConfig.getEngineName();<z>
!= null) {<z>
);<z>
!= null) {<z>
();<z>
!= null) {<z>
.renderFunction = viewConfig.getRenderFunction();<z>
!= null) {<z>
viewConfig.getCharset());<z>
resourceLoaderPaths == null) {<z>
String resourceLoaderPath = viewConfig.getResourceLoaderPath();<z>
DEFAULT_RESOURCE_LOADER_PATH);<z>
{<z>
();<z>
0;<z>
if (this.engine != null) {<z>
++;<z>
this.engineSupplier != null) {<z>
++;<z>
.engineName != null) {<z>
;<z>
Assert.isTrue(engineCount == 1,<z>
;<z>
{<z>
.engine == null,<z>
);<z>
) {<z>
;<z>
) {<z>
createEngineFromName(this.engineName));<z>
;<z>
!= null) {<z>
.class, this.engine,<z>
;<z>
(<z>
Qualifier("mvcContentNegotiationManager") ContentNegotiationManager contentNegotiationManager) {<z>
registry =<z>
this.applicationContext);<z>
(registry);<z>
!= null) {<z>
.beanNamesForTypeIncludingAncestors(<z>
.class, true, false);<z>
(names.length == 1) {<z>
());<z>
();<z>
);<z>
);<z>
{<z>
composite.setApplicationContext(this.applicationContext);<z>
if (this.servletContext != null) {<z>
);<z>
return composite;<z>
setup() {<z>
();<z>
];<z>
("DirectFieldAccessor")) {<z>
target);<z>
this.target);<z>
customEditor) {<z>
"stringTrimmer":<z>
class, new StringTrimmerEditor(false));<z>
:<z>
Integer.class, false));<z>
case "numberOnNestedPath":<z>
CustomNumberEditor(Integer.class, false));<z>
"numberOnType":<z>
, false));<z>
{<z>
) {<z>
);<z>
header, encoding);<z>
public R2dbcTransactionManager(ConnectionFactory connectionFactory) {<z>
this();<z>
;<z>
);<z>
) {<z>
result = new LinkedHashSet<>();<z>
scheduledTasks) {<z>
.values();<z>
ScheduledTask> tasks : allTasks) {<z>
;<z>
this.registrar.getScheduledTasks());<z>
;<z>
String> expected) {<z>
(expected.size());<z>
(multiValueMap::add);<z>
;<z>
AbstractNamedValueArgumentResolver(@Nullable ConfigurableBeanFactory factory,<z>
) {<z>
(registry);<z>
this.configurableBeanFactory = factory;<z>
null) : null);<z>
minCapacity) {<z>
() != null) {<z>
;<z>
this.index = 0;<z>
{<z>
minCapacity);<z>
(new byte[this.nextBlockSize]);<z>
nextBlockSize *= 2;<z>
, @Nullable Class<?> jsonView)<z>
, MessageConversionException {<z>
jsonView != null) {<z>
);<z>
.objectMapper.writer());<z>
environment) {<z>
{<z>
();<z>
environment);<z>
null);<z>
adaptFromForwardedHeaders(HttpHeaders headers) {<z>
;<z>
forwardedHeader)) {<z>
= FORWARDED_PROTO_PATTERN.matcher(forwardedHeader);<z>
find()) {<z>
(1).trim());<z>
);<z>
)) {<z>
);<z>
);<z>
forwardedHeader);<z>
{<z>
(1).trim());<z>
);<z>
(StringUtils.hasText(protocolHeader)) {<z>
);<z>
);<z>
(isForwardedSslOn(headers)) {<z>
;<z>
(null);<z>
.getFirst("X-Forwarded-Host");<z>
hostHeader)) {<z>
]);<z>
portHeader = headers.getFirst("X-Forwarded-Port");<z>
.hasText(portHeader)) {<z>
)[0]));<z>
) {<z>
IllegalArgumentException("Failed to parse a port from \"forwarded\"-type headers. " +<z>
;<z>
if (this.scheme != null &&<z>
"80".equals(this.port)) ||<z>
this.port)))) {<z>
null);<z>
this;<z>
externalSourceHeaders) {<z>
);<z>
);<z>
();<z>
() {<z>
new DefaultMessageHandlerMethodFactory();<z>
if (beanFactory != null) {<z>
(beanFactory);<z>
afterPropertiesSet();<z>
;<z>
public void onWebSocketConnect(Session session) {<z>
session);<z>
)<z>
.getRequestURI() + " [JettyWebSocketHandlerAdapter]")<z>
;<z>
Annotation> annotationType) {<z>
new ArrayDeque<>();<z>
annotationType, null);<z>
) {<z>
AnnotationTypeMapping mapping = queue.removeFirst();<z>
mapping);<z>
(queue, mapping);<z>
throws JspException {<z>
Param param = new Param();<z>
;<z>
(this.valueSet) {<z>
setValue(this.value);<z>
if (getBodyContent() != null) {<z>
());<z>
this, ParamAware.class);<z>
paramAwareTag == null) {<z>
"The param tag must be a descendant of a tag that supports parameters");<z>
;<z>
return EVAL_PAGE;<z>
String methodName)<z>
{<z>
(), methodName);<z>
{<z>
targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName);<z>
targetMethod;<z>
buildExceptionMessage(JMSException ex) {<z>
();<z>
getLinkedException();<z>
null) {<z>
== null) {<z>
();<z>
.getMessage();<z>
.contains(linkedMessage)) {<z>
"; nested exception is " + linkedEx;<z>
message;<z>
> toListenableFuture(Object returnValue, MethodParameter returnType) {<z>
returnType);<z>
) {<z>
).toListenableFuture(returnValue, returnType);<z>
return null;<z>
throws HttpMediaTypeNotAcceptableException {<z>
.strategies) {<z>
(request);<z>
.equals(MEDIA_TYPE_ALL_LIST)) {<z>
;<z>
;<z>
Object message) {<z>
|| this.logger.isDebugEnabled()) {<z>
message), null, null);<z>
) {<z>
.defaultRetriever) {<z>
defaultRetriever.applicationListeners.remove(listener);<z>
retrieverCache.clear();<z>
) {<z>
managedBean));<z>
if (mr == null) {<z>
throw new InvalidMetadataException(<z>
managedBean));<z>
);<z>
if (mr.isLog()) {<z>
.setField(FIELD_LOG, "true");<z>
))) {<z>
, mr.getLogFile());<z>
.getPersistPolicy())) {<z>
FIELD_PERSIST_POLICY, mr.getPersistPolicy());<z>
mr.getPersistPeriod() >= 0) {<z>
toString(mr.getPersistPeriod()));<z>
(mr.getPersistName())) {<z>
getPersistName());<z>
))) {<z>
;<z>
{<z>
viewName) {<z>
)) {<z>
("redirect:") ? viewName : "redirect:" + viewName;<z>
;<z>
;<z>
ex,<z>
handler) throws IOException {<z>
response);<z>
return new ModelAndView();<z>
Object info) {<z>
.class, info, "MethodInvocationInfo required");<z>
) info;<z>
);<z>
);<z>
);<z>
;<z>
static WebHttpHandlerBuilder applicationContext(ApplicationContext context) {<z>
builder = new WebHttpHandlerBuilder(<z>
, WebHandler.class), context);<z>
webFilters = context<z>
)<z>
.orderedStream()<z>
;<z>
);<z>
WebExceptionHandler> exceptionHandlers = context<z>
WebExceptionHandler.class)<z>
)<z>
());<z>
-> handlers.addAll(exceptionHandlers));<z>
HttpHandlerDecoratorFactory.class)<z>
)<z>
(builder::httpHandlerDecorator);<z>
.sessionManager(<z>
);<z>
(NoSuchBeanDefinitionException ex) {<z>
.codecConfigurer(<z>
class));<z>
{<z>
localeContextResolver(<z>
.class));<z>
ex) {<z>
builder.forwardedHeaderTransformer(<z>
));<z>
) {<z>
builder;<z>
void setAsText(String text) throws IllegalArgumentException {<z>
.CLASSPATH_URL_PREFIX);<z>
("/")) {<z>
);<z>
getScheme() != null) {<z>
nioPathCandidate = false;<z>
normalize());<z>
{<z>
;<z>
) {<z>
.resourceEditor.setAsText(text);<z>
getValue();<z>
resource == null) {<z>
setValue(null);<z>
exists()) {<z>
text).normalize());<z>
);<z>
IOException ex) {<z>
+ resource, ex);<z>
{<z>
adjuster = TemporalAdjusters.lastDayOfMonth();<z>
-> {<z>
result = adjuster.adjustInto(temporal);<z>
;<z>
private JAXBContext createJaxbContextFromContextPath(String contextPath) throws JAXBException {<z>
isDebugEnabled()) {<z>
contextPath + "]");<z>
if (this.jaxbContextProperties != null) {<z>
this.beanClassLoader != null) {<z>
this.jaxbContextProperties);<z>
(),<z>
jaxbContextProperties);<z>
null) {<z>
this.beanClassLoader);<z>
newInstance(contextPath);<z>
(<z>
source,<z>
,<z>
final boolean hasDeprecatedAttribute,<z>
int descriptorIndex,<z>
signatureIndex,<z>
int exceptionsOffset) {<z>
!= symbolTable.getSource()<z>
this.descriptorIndex<z>
signatureIndex != this.signatureIndex<z>
) != 0)) {<z>
return false;<z>
=<z>
0;<z>
(hasSyntheticAttribute != needSyntheticAttribute) {<z>
return false;<z>
0) {<z>
!= 0) {<z>
;<z>
) {<z>
int currentExceptionOffset = exceptionsOffset + 2;<z>
i < numberOfExceptions; ++i) {<z>
]) {<z>
;<z>
;<z>
return true;<z>
response) {<z>
.netty.ChannelOperationsId) {<z>
);<z>
dataBuffer, "Channel id: " + id);<z>
true;<z>
;<z>
> completionSink,<z>
{<z>
(url, negotiation);<z>
sharedInstance;<z>
(channel, info, bufferFactory, completionSink);<z>
UndertowWebSocketHandlerAdapter(session);<z>
.set(adapter);<z>
);<z>
.handle(session)<z>
)<z>
;<z>
String characterEncoding) {<z>
, "'characterEncoding' must not be null");<z>
.characterEncoding = characterEncoding;<z>
characterEncodingSet = true;<z>
(ValueHolder newValue) {<z>
newValue.getName() != null) {<z>
; it.hasNext();) {<z>
= it.next();<z>
currentValue.getName())) {<z>
() instanceof Mergeable mergeable) {<z>
mergeable.isMergeEnabled()) {<z>
currentValue.getValue()));<z>
remove();<z>
(newValue);<z>
Method method) {<z>
))) {<z>
return false;<z>
if (!isOverloaded()) {<z>
true;<z>
getParameterCount()) {<z>
;<z>
);<z>
) {<z>
i);<z>
).contains(identifier)) {<z>
return false;<z>
return true;<z>
HttpInputMessage inputMessage) throws IOException {<z>
();<z>
getCharset(contentType);<z>
(javaType.getRawClass(), contentType);<z>
!= null, "No ObjectMapper for " + javaType);<z>
charset.name()) ||<z>
charset.name()) ||<z>
;<z>
instanceof MappingJacksonInputMessage mappingJacksonInputMessage) {<z>
?> deserializationView = mappingJacksonInputMessage.getDeserializationView();<z>
deserializationView != null) {<z>
(deserializationView).forType(javaType);<z>
(isUnicode) {<z>
inputMessage.getBody());<z>
), charset);<z>
reader);<z>
isUnicode) {<z>
.getBody(), javaType);<z>
charset);<z>
, javaType);<z>
InvalidDefinitionException ex) {<z>
.getType(), ex);<z>
) {<z>
.getOriginalMessage(), ex, inputMessage);<z>
) {<z>
(method, Async.class);<z>
async == null) {<z>
, Async.class);<z>
);<z>
> cache,<z>
) {<z>
allowNullValues);<z>
;<z>
"Cache must not be null");<z>
= name;<z>
= cache;<z>
, String requestUrl) {<z>
int prefixIndex = getLookupPathIndex(request);<z>
suffixIndex = getEndPathIndex(requestUrl);<z>
if (prefixIndex >= suffixIndex) {<z>
null;<z>
substring(0, prefixIndex);<z>
= requestUrl.substring(suffixIndex);<z>
substring(prefixIndex, suffixIndex);<z>
getForLookupPath(lookupPath);<z>
resolvedLookupPath + suffix : null);<z>
public boolean isCompilable() {<z>
executorToCheck = this.cachedExecutor;<z>
executorToCheck == null || executorToCheck.hasProxyTarget() ||<z>
executorToCheck.get() instanceof ReflectiveMethodExecutor)) {<z>
return false;<z>
for (SpelNodeImpl child : this.children) {<z>
if (!child.isCompilable()) {<z>
false;<z>
get();<z>
) {<z>
;<z>
executor.getMethod().getDeclaringClass();<z>
.getPublicDeclaringClass() == null) {<z>
false;<z>
return true;<z>
> accumulatedArguments) {<z>
{<z>
new SpelParseException(this.expressionString,<z>
));<z>
consumeArguments(accumulatedArguments);<z>
TokenKind.RPAREN);<z>
) {<z>
0;<z>
) {<z>
hashCode += condition.hashCode() * 31;<z>
return hashCode;<z>
{<z>
synchronized (this.lifecycleMonitor) {<z>
("Starting...");<z>
this);<z>
.brokerChannel.subscribe(this);<z>
InterceptableChannel) {<z>
);<z>
);<z>
true;<z>
("Started.");<z>
[] args) {<z>
(thisObject, targetObject, args);<z>
catch (ReflectionWorldException ex) {<z>
;<z>
void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) {<z>
).afterConnectionClosed(session, closeStatus);<z>
{<z>
{<z>
"Unhandled exception after connection closed for " + this, ex);<z>
IOException {<z>
(this.filePath);<z>
) {<z>
());<z>
public int hashCode() {<z>
hashCode = getClass().hashCode();<z>
);<z>
nullSafeHashCode(this.targetBeanName);<z>
return hashCode;<z>
(Class<?> clazz) {<z>
result = null;<z>
()) {<z>
()) {<z>
(ifcMethod.getModifiers())) {<z>
result == null) {<z>
;<z>
.add(ifcMethod);<z>
return result;<z>
lhsType, ParameterizedType rhsType) {<z>
(rhsType)) {<z>
return true;<z>
.getActualTypeArguments();<z>
rhsTypeArguments = rhsType.getActualTypeArguments();<z>
{<z>
false;<z>
{<z>
lhsTypeArguments[i];<z>
rhsTypeArguments[i];<z>
!lhsArg.equals(rhsArg) &&<z>
)) {<z>
;<z>
return true;<z>
write(<z>
final ClassWriter classWriter,<z>
] code,<z>
final int codeLength,<z>
final int maxStack,<z>
{<z>
;<z>
ModelAndView handleInternal(HttpServletRequest request,<z>
Exception {<z>
mav;<z>
(request);<z>
{<z>
session = request.getSession(false);<z>
{<z>
WebUtils.getSessionMutex(session);<z>
synchronized (mutex) {<z>
request, response, handlerMethod);<z>
= invokeHandlerMethod(request, response, handlerMethod);<z>
handlerMethod);<z>
)) {<z>
()) {<z>
response, this.cacheSecondsForSessionAttributeHandlers);<z>
response);<z>
return mav;<z>
mp) throws Throwable {<z>
.getOverride(method);<z>
;<z>
null);<z>
.getBeanName())) {<z>
), argsToUse) :<z>
()));<z>
null : bean);<z>
genericReturnType = ResolvableType.forMethodReturnType(method);<z>
.getObject(argsToUse) :<z>
getObject());<z>
RequestPredicate predicate) {<z>
);<z>
;<z>
.append(" => {\n");<z>
this.indent++;<z>
(WebSocketMessage message) throws IOException {<z>
)) {<z>
;<z>
) {<z>
"Sending " + message);<z>
return sendMessage(message);<z>
, AnnotatedTypeMetadata metadata) {<z>
(Profile.class.getName());<z>
) {<z>
attrs.get("value")) {<z>
value))) {<z>
;<z>
false;<z>
;<z>
void write(char ch) {<z>
0) {<z>
;<z>
(0);<z>
this.buffer.append(ch);<z>
addHeader(String name, Object value) {<z>
CONTENT_TYPE.equalsIgnoreCase(name) &&<z>
HttpHeaders.CONTENT_TYPE)) {<z>
value.toString());<z>
HttpHeaders.ACCEPT_LANGUAGE.equalsIgnoreCase(name) &&<z>
containsKey(HttpHeaders.ACCEPT_LANGUAGE)) {<z>
;<z>
value.toString());<z>
();<z>
();<z>
;<z>
(this.locales.isEmpty()) {<z>
;<z>
catch (IllegalArgumentException ex) {<z>
;<z>
(name, value, false);<z>
ResourceResolverChain resolverChain,<z>
ResourceTransformer transformer, @Nullable ResourceTransformerChain chain) {<z>
),<z>
);<z>
resolverChain = resolverChain;<z>
= transformer;<z>
= chain;<z>
void registerRequestDestructionCallback(String name, Runnable callback) {<z>
.notNull(name, "Name must not be null");<z>
callback, "Callback must not be null");<z>
) {<z>
;<z>
ListenableFuture<WebSocketSession> doHandshake(WebSocketHandler webSocketHandler,<z>
, Object... uriVars) {<z>
.encode();<z>
());<z>
)<z>
{<z>
getParameterValues(name));<z>
{<z>
null) {<z>
) value;<z>
conversionServiceToUse = this.conversionService;<z>
null) {<z>
.isAssignableValue(targetType, value)) {<z>
return (T) value;<z>
.getSharedInstance();<z>
convert(value, targetType);<z>
objectWriter, MessageType targetType)<z>
, IOException {<z>
throw new IllegalArgumentException("Unsupported message type [" + targetType +<z>
);<z>
void emitPart(Part part) {<z>
isTraceEnabled()) {<z>
part);<z>
;<z>
boolean supportsEventType(ResolvableType eventType) {<z>
this.declaredEventTypes) {<z>
)) {<z>
;<z>
))) {<z>
();<z>
payloadType)) {<z>
;<z>
hasUnresolvableGenerics();<z>
, boolean inheritable) {<z>
LocaleContext localeContext = getLocaleContext();<z>
null);<z>
{<z>
, timeZone);<z>
locale != null) {<z>
;<z>
null;<z>
setLocaleContext(localeContext, inheritable);<z>
status) {<z>
.getTransaction();<z>
();<z>
.STATUS_NO_TRANSACTION) {<z>
("JTA transaction already completed - probably rolled back");<z>
== Status.STATUS_ROLLEDBACK) {<z>
.rollback();<z>
) {<z>
isDebugEnabled()) {<z>
debug("Rollback failure with transaction already marked as rolled back: " + ex);<z>
"JTA transaction already rolled back (probably due to a timeout)");<z>
txObject.getUserTransaction().commit();<z>
{<z>
throw new UnexpectedRollbackException(<z>
;<z>
ex) {<z>
HeuristicCompletionException(HeuristicCompletionException.STATE_MIXED, ex);<z>
) {<z>
new HeuristicCompletionException(HeuristicCompletionException.STATE_ROLLED_BACK, ex);<z>
catch (IllegalStateException ex) {<z>
ex);<z>
SystemException ex) {<z>
new TransactionSystemException("JTA failure on commit", ex);<z>
static boolean isSameOrigin(HttpRequest request) {<z>
= request.getHeaders();<z>
);<z>
== null) {<z>
return true;<z>
;<z>
host;<z>
;<z>
ServletServerHttpRequest servletServerHttpRequest) {<z>
= servletServerHttpRequest.getServletRequest();<z>
servletRequest.getScheme();<z>
);<z>
servletRequest.getServerPort();<z>
);<z>
();<z>
host = uri.getHost();<z>
();<z>
();<z>
)) &&<z>
&&<z>
;<z>
{<z>
(typeDescriptor != null) {<z>
typeDescriptor.narrow(value);<z>
{<z>
(value);<z>
;<z>
> input, ResolvableType elementType,<z>
Nullable Map<String, Object> hints) {<z>
input);<z>
{<z>
);<z>
clazz);<z>
());<z>
= beanName;<z>
String namespace) {<z>
groovyDslXmlBeanDefinitionReader.createReaderContext(<z>
("Groovy"));<z>
new BeanDefinitionParserDelegate(readerContext);<z>
!= null);<z>
decorating) {<z>
;<z>
.currentBeanDefinition, decorating) {<z>
() {<z>
{<z>
currentBeanDefinition = null;<z>
{<z>
useCache) {<z>
.generate(ClassLoaderData.this);<z>
(gen);<z>
(cachedValue);<z>
result)<z>
throws JMSException {<z>
instanceof JmsResponse) {<z>
(JmsResponse<?>) result;<z>
.resolveDestination(getDestinationResolver(), session);<z>
{<z>
destination;<z>
;<z>
(Element element, BeanDefinition def) {<z>
name = element.getAttribute("error-handler");<z>
name)) {<z>
));<z>
DefaultDataBuffer readPosition(int readPosition) {<z>
"'readPosition' %d must be >= 0", readPosition);<z>
writePosition, "'readPosition' %d must be <= %d",<z>
readPosition, this.writePosition);<z>
this.readPosition = readPosition;<z>
;<z>
> parameters) {<z>
parameters);<z>
name());<z>
;<z>
() {<z>
;<z>
null) {<z>
(this.txManager);<z>
txAspect;<z>
finishRefresh() {<z>
();<z>
);<z>
().onRefresh();<z>
ContextRefreshedEvent(this));<z>
(byte c) {<z>
||<z>
== '+' || c == '-' ||<z>
|| c == '|' || c == '~';<z>
@Nullable TransactionInfo txInfo) {<z>
&& txInfo.getTransactionStatus() != null) {<z>
isTraceEnabled()) {<z>
+ "]");<z>
(txInfo.getTransactionStatus());<z>
{<z>
{<z>
;<z>
{<z>
i);<z>
getEngine() {<z>
sharedEngine)) {<z>
);<z>
null) {<z>
);<z>
);<z>
this.engineName : "");<z>
.scripts) : name);<z>
);<z>
engine == null) {<z>
engineName != null) {<z>
.engineName);<z>
engine = createEngineFromSupplier();<z>
, engine);<z>
engine;<z>
"No shared engine available");<z>
.engine;<z>
Nullable Object other) {<z>
if (this == other) {<z>
return true;<z>
(other instanceof AbstractBeanDefinition that)) {<z>
;<z>
) &&<z>
scope, that.scope) &&<z>
.abstractFlag &&<z>
that.lazyInit &&<z>
.autowireMode &&<z>
&&<z>
dependsOn, that.dependsOn) &&<z>
autowireCandidate &&<z>
this.qualifiers, that.qualifiers) &&<z>
&&<z>
that.nonPublicAccessAllowed &&<z>
== that.lenientConstructorResolution &&<z>
) &&<z>
equalsPropertyValues(that) &&<z>
methodOverrides, that.methodOverrides) &&<z>
that.factoryBeanName) &&<z>
(this.factoryMethodName, that.factoryMethodName) &&<z>
(this.initMethodName, that.initMethodName) &&<z>
.enforceInitMethod &&<z>
, that.destroyMethodName) &&<z>
this.enforceDestroyMethod == that.enforceDestroyMethod &&<z>
synthetic == that.synthetic &&<z>
.role == that.role &&<z>
equals(other));<z>
public void cleanupAttributes(WebRequest request) {<z>
: this.knownAttributeNames) {<z>
(request, attributeName);<z>
public EmbeddedDatabaseBuilder(ResourceLoader resourceLoader) {<z>
.databaseFactory = new EmbeddedDatabaseFactory();<z>
= new ResourceDatabasePopulator();<z>
;<z>
;<z>
{<z>
(statusCode)) {<z>
;<z>
.series())) {<z>
()) != null;<z>
;<z>
static void verifySameInvocation(Invocation expectedInvocation, Invocation actualInvocation,<z>
argumentAdapters) {<z>
getMethod());<z>
= getInvocationArguments(expectedInvocation, argumentAdapters);<z>
, argumentAdapters);<z>
.isEqualTo(actualArguments);<z>
(<z>
, final String descriptor, final boolean visible) {<z>
if (api < Opcodes.ASM5) {<z>
("This feature requires ASM5");<z>
fv != null) {<z>
, descriptor, visible);<z>
return null;<z>
{<z>
);<z>
;<z>
);<z>
;<z>
) {<z>
);<z>
.instantiationStrategy = new CglibSubclassingInstantiationStrategy();<z>
ProducesRequestCondition getMatchingCondition(ServerWebExchange exchange) {<z>
(exchange.getRequest())) {<z>
;<z>
(isEmpty()) {<z>
return this;<z>
);<z>
(!CollectionUtils.isEmpty(result)) {<z>
return new ProducesRequestCondition(result, this);<z>
) {<z>
EMPTY_CONDITION;<z>
UnsupportedMediaTypeStatusException ex) {<z>
null;<z>
getMessage() {<z>
.isEmpty(this.messageExceptions)) {<z>
;<z>
;<z>
String baseMessage = super.getMessage();<z>
{<z>
append(". ");<z>
"Failed messages: ");<z>
++) {<z>
];<z>
append(subEx.toString());<z>
< this.messageExceptions.length - 1) {<z>
("; ");<z>
);<z>
private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,<z>
,<z>
) {<z>
if (importCandidates.isEmpty()) {<z>
&& isChainedImportOnStack(configClass)) {<z>
));<z>
.importStack.push(configClass);<z>
candidate : importCandidates) {<z>
{<z>
();<z>
,<z>
this.registry);<z>
getExclusionFilter();<z>
{<z>
selectorFilter);<z>
) {<z>
;<z>
);<z>
> importSourceClasses = asSourceClasses(importClassNames, exclusionFilter);<z>
, false);<z>
candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {<z>
.loadClass();<z>
registrar =<z>
class,<z>
this.resourceLoader, this.registry);<z>
, currentSourceClass.getMetadata());<z>
.importStack.registerImport(<z>
));<z>
, exclusionFilter);<z>
ex) {<z>
;<z>
) {<z>
new BeanDefinitionStoreException(<z>
+ "]", ex);<z>
this.importStack.pop();<z>
{<z>
(TypeFilter includeFilter : this.includeFilters) {<z>
if (!indexSupportsIncludeFilter(includeFilter)) {<z>
false;<z>
true;<z>
substituteNamedParameters(String sql,<z>
paramSource) {<z>
);<z>
;<z>
<?> message) throws Exception {<z>
NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);<z>
;<z>
Object resolvedName = resolveEmbeddedValuesAndExpressions(namedValueInfo.name);<z>
{<z>
throw new IllegalArgumentException(<z>
"]");<z>
resolvedName.toString());<z>
if (arg == null) {<z>
.defaultValue != null) {<z>
defaultValue);<z>
isOptional()) {<z>
(namedValueInfo.name, nestedParameter, message);<z>
nestedParameter.getNestedParameterType());<z>
!= null) {<z>
resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);<z>
, arg)) {<z>
));<z>
&&<z>
!nestedParameter.isOptional()) {<z>
.name, nestedParameter, message);<z>
namedValueInfo.name, parameter, message);<z>
return arg;<z>
{<z>
<?> messageToUse = message;<z>
) {<z>
messageToUse, channel);<z>
if (resolvedMessage == null) {<z>
).getSimpleName();<z>
if (logger.isDebugEnabled()) {<z>
+ " returned null from preSend, i.e. precluding the send.");<z>
, channel, false, null);<z>
;<z>
resolvedMessage;<z>
;<z>
;<z>
Connection con, @Nullable TransactionDefinition definition)<z>
throws SQLException {<z>
(con, "No Connection specified");<z>
debugEnabled = logger.isDebugEnabled();<z>
&& definition.isReadOnly()) {<z>
) {<z>
"Setting JDBC Connection [" + con + "] read-only");<z>
setReadOnly(true);<z>
) {<z>
ex;<z>
{<z>
("Timeout")) {<z>
ex;<z>
exToCheck.getCause();<z>
.debug("Could not set JDBC Connection read-only", ex);<z>
;<z>
TransactionDefinition.ISOLATION_DEFAULT) {<z>
) {<z>
"Changing isolation level of JDBC Connection [" + con + "] to " +<z>
.getIsolationLevel());<z>
= con.getTransactionIsolation();<z>
)) {<z>
;<z>
));<z>
previousIsolationLevel;<z>
{<z>
;<z>
getClass()) return false;<z>
GenericEventPojo<?>) o;<z>
equals(that.value);<z>
, Throwable ex) {<z>
;<z>
.rollback(status);<z>
RuntimeException ex2) {<z>
("Listener exception overridden by rollback exception", ex);<z>
ex2;<z>
{<z>
logger.error("Listener exception overridden by rollback error", ex);<z>
;<z>
() {<z>
(this.isField) {<z>
) this.member, this.lookupType);<z>
;<z>
int index, TypeDescriptor typeDescriptor) {<z>
= typeConverter;<z>
array;<z>
;<z>
typeDescriptor;<z>
@Nullable Duration timeout) {<z>
);<z>
SseServerResponse(sseConsumer, timeout);<z>
method) {<z>
(method, "Method must not be null");<z>
;<z>
if (result != null) {<z>
result;<z>
return new HttpMethod(method);<z>
, Message<?> requestMessage) {<z>
.sendAndReceive(<z>
requestMessage));<z>
;<z>
JmsException ex) {<z>
(ex);<z>
MethodInvocation invocableClone(Object... arguments) {<z>
this.userAttributes == null) {<z>
userAttributes = new HashMap<>();<z>
();<z>
arguments = arguments;<z>
;<z>
ex) {<z>
(<z>
) + "]: " + ex);<z>
UrlBasedViewResolverRegistration scriptTemplate() {<z>
(!checkBeanOfType(ScriptTemplateConfigurer.class)) {<z>
throw new BeanInitializationException("In addition to a script template view resolver " +<z>
;<z>
;<z>
();<z>
) {<z>
);<z>
.add(resolver);<z>
return registration;<z>
<?> valueType) {<z>
getBindMarkers(identifier);<z>
if (bindMarkers == null) {<z>
valueType);<z>
BindMarker bindMarker : bindMarkers) {<z>
.bindNull(target, valueType);<z>
?> subType, @Nullable String msg) {<z>
;<z>
true;<z>
StringUtils.hasLength(msg)) {<z>
)) {<z>
= msg + " ";<z>
messageWithTypeName(msg, subType);<z>
= false;<z>
{<z>
+ superType);<z>
);<z>
, T mapping) {<z>
);<z>
) : null);<z>
existingHandlerMethod.equals(handlerMethod)) {<z>
new IllegalStateException(<z>
+<z>
+ ": There is already '" +<z>
"' bean method\n" + existingHandlerMethod + " mapped.");<z>
String destinationName, Object request,<z>
, Class<T> targetClass) throws MessagingException {<z>
, headers, targetClass, null);<z>
getValueType(EvaluationContext context) throws EvaluationException {<z>
context, "EvaluationContext is required");<z>
context, this.configuration);<z>
;<z>
null);<z>
> usedParams, boolean includeQueryStringDelimiter)<z>
JspException {<z>
.getCharacterEncoding();<z>
= new StringBuilder();<z>
Param param : params) {<z>
{<z>
() == 0) {<z>
('?');<z>
);<z>
), encoding));<z>
) {<z>
append('=');<z>
getValue(), encoding));<z>
UnsupportedCharsetException ex) {<z>
;<z>
toString();<z>
timeout) {<z>
{<z>
);<z>
) {<z>
run();<z>
sendTask);<z>
;<z>
) {<z>
||<z>
== null) {<z>
;<z>
) > 1) {<z>
c++) {<z>
{<z>
false;<z>
(ReflectiveConstructorExecutor) this.cachedExecutor;<z>
{<z>
;<z>
> constructor = executor.getConstructor();<z>
constructor.getModifiers()) &&<z>
));<z>
Class<?> scriptClass) throws ScriptCompilationException {<z>
);<z>
if (this.groovyObjectCustomizer != null) {<z>
;<z>
if (goo instanceof Script) {<z>
).run();<z>
goo;<z>
) {<z>
ScriptCompilationException(<z>
scriptClass.getName(), ex);<z>
InstantiationException ex) {<z>
(<z>
), ex);<z>
) {<z>
new ScriptCompilationException(<z>
;<z>
) {<z>
new ScriptCompilationException(<z>
ex.getTargetException());<z>
{<z>
instanceof Lifecycle) {<z>
) this.requestUpgradeStrategy).start();<z>
{<z>
(<z>
) {<z>
?> targetClass) {<z>
method.getParameterCount() == 1 &&<z>
;<z>
));<z>
, ParserContext parserContext) {<z>
element);<z>
String defaultServletName = element.getAttribute("default-servlet-name");<z>
defaultServletHandlerDef = new RootBeanDefinition(DefaultServletHttpRequestHandler.class);<z>
.setSource(source);<z>
);<z>
) {<z>
defaultServletName);<z>
().generateBeanName(defaultServletHandlerDef);<z>
;<z>
);<z>
new ManagedMap<>();<z>
;<z>
RootBeanDefinition(SimpleUrlHandlerMapping.class);<z>
;<z>
setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
.add("urlMap", urlMap);<z>
(handlerMappingDef);<z>
);<z>
));<z>
, source);<z>
;<z>
Template getTemplate(Locale locale) throws IOException {<z>
();<z>
null, "'url' not set");<z>
locale);<z>
reset() {<z>
request = null;<z>
;<z>
iterator = null;<z>
throws ServletRequestBindingException {<z>
(name, values);<z>
];<z>
) {<z>
[i]);<z>
parameters;<z>
(String name) {<z>
);<z>
{<z>
getAttribute(name, REQUEST_SCOPE);<z>
(value == null) {<z>
);<z>
(value == null) {<z>
);<z>
value;<z>
matchingContext) {<z>
matchingContext.pathLength) {<z>
false;<z>
pathElements.get(pathIndex);<z>
PathContainer.PathSegment)) {<z>
;<z>
);<z>
!= this.len) {<z>
false;<z>
if (this.caseSensitive) {<z>
len; i++) {<z>
text[i]) {<z>
;<z>
.len; i++) {<z>
) {<z>
false;<z>
++;<z>
if (isNoMorePattern()) {<z>
) {<z>
.remainingPathIndex = pathIndex;<z>
;<z>
(pathIndex == matchingContext.pathLength) {<z>
true;<z>
&&<z>
pathLength &&<z>
(pathIndex));<z>
matchingContext));<z>
(<z>
<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {<z>
.size(),<z>
;<z>
ArgumentsMatchKind.EXACT;<z>
!= null; i++) {<z>
);<z>
i);<z>
if (suppliedArg == null) {<z>
) {<z>
null;<z>
) {<z>
expectedArg)) {<z>
REQUIRES_CONVERSION) {<z>
;<z>
typeConverter.canConvert(suppliedArg, expectedArg)) {<z>
match = ArgumentsMatchKind.REQUIRES_CONVERSION;<z>
;<z>
new ArgumentsMatchInfo(match) : null);<z>
ConfigurationClass(MetadataReader metadataReader, String beanName) {<z>
.notNull(beanName, "Bean name must not be null");<z>
metadataReader.getAnnotationMetadata();<z>
this.resource = metadataReader.getResource();<z>
.beanName = beanName;<z>
, String beanName)<z>
{<z>
= existingBean;<z>
)) {<z>
postProcessBeforeInitialization(result, beanName);<z>
if (current == null) {<z>
return result;<z>
current;<z>
return result;<z>
name, Object value) {<z>
) {<z>
(name, value);<z>
public static HttpHeaders writableHttpHeaders(HttpHeaders headers) {<z>
.notNull(headers, "HttpHeaders must not be null");<z>
) {<z>
HttpHeaders();<z>
: headers);<z>
void parseCollectionElements(<z>
BeanDefinition bd, String defaultElementType) {<z>
elementNodes.getLength(); i++) {<z>
);<z>
(node, DESCRIPTION_ELEMENT)) {<z>
Element) node, bd, defaultElementType));<z>
UriComponentsBuilder pathSegment(String... pathSegments) throws IllegalArgumentException {<z>
addPathSegments(pathSegments);<z>
resetSchemeSpecificPart();<z>
this;<z>
boolean equals(@Nullable Object other) {<z>
{<z>
;<z>
other instanceof MethodOverride that)) {<z>
false;<z>
) &&<z>
, that.source));<z>
String username, String password) throws SQLException {<z>
(<z>
class.getClassLoader(),<z>
>[] {ConnectionProxy.class},<z>
username, password));<z>
<P> handler, ReconnectStrategy strategy) {<z>
Assert.notNull(handler, "TcpConnectionHandler is required");<z>
notNull(strategy, "ReconnectStrategy is required");<z>
stopping) {<z>
handleShuttingDownConnectFailure(handler);<z>
();<z>
)<z>
new ReactorNettyHandler(handler))<z>
connect()<z>
)<z>
::completeExceptionally)<z>
(handler::afterConnectFailure)<z>
(Connection::onDispose)<z>
(Retry.from(signals -> signals<z>
)<z>
))<z>
.repeatWhen(flux -> flux<z>
(count, element) -> count++)<z>
attempt -> reconnect(attempt, strategy)))<z>
subscribe();<z>
;<z>
String viewName, Locale locale) throws Exception {<z>
) {<z>
(viewName, locale);<z>
view != null) {<z>
view;<z>
return null;<z>
) {<z>
{<z>
this.running = true;<z>
instanceof Lifecycle) {<z>
();<z>
() {<z>
if (this.beanFactory == null) {<z>
"ApplicationEventMulticaster cannot retrieve listener beans " +<z>
"because it is not associated with a BeanFactory");<z>
return this.beanFactory;<z>
{<z>
= new StringBuilder();<z>
.id).append("] destination=").<z>
append(this.subscription).<z>
append('\'');<z>
{<z>
.port == null) {<z>
return -1;<z>
("{")) {<z>
new IllegalStateException(<z>
this.port);<z>
return Integer.parseInt(this.port);<z>
initAttributes(ServerWebExchange exchange) {<z>
) {<z>
EMPTY_ATTRIBUTES;<z>
.map(session -><z>
).stream()<z>
getKey()))<z>
)));<z>
ServerHttpRequest request, ServerHttpResponse response,<z>
throws IOException {<z>
();<z>
;<z>
.getHeaders();<z>
{<z>
;<z>
);<z>
return false;<z>
getMethodToUse(request, preFlightRequest);<z>
);<z>
allowMethods == null) {<z>
debug("Reject: HTTP '" + requestMethod + "' is not allowed");<z>
rejectRequest(response);<z>
;<z>
= getHeadersToUse(request, preFlightRequest);<z>
allowHeaders = checkHeaders(config, requestHeaders);<z>
if (preFlightRequest && allowHeaders == null) {<z>
requestHeaders + "' are not allowed");<z>
response);<z>
false;<z>
responseHeaders.setAccessControlAllowOrigin(allowOrigin);<z>
if (preFlightRequest) {<z>
allowMethods);<z>
()) {<z>
setAccessControlAllowHeaders(allowHeaders);<z>
isEmpty(config.getExposedHeaders())) {<z>
);<z>
{<z>
setAccessControlAllowCredentials(true);<z>
null) {<z>
(config.getMaxAge());<z>
();<z>
;<z>
tagWriter) throws JspException {<z>
)) {<z>
;<z>
this.optionSource instanceof Collection) {<z>
renderFromCollection(tagWriter);<z>
Map) {<z>
(tagWriter);<z>
.isEnum()) {<z>
renderFromEnum(tagWriter);<z>
new JspException(<z>
) + "] is not valid for option items");<z>
(String value) {<z>
!QuartzCronField.isQuartzDaysOfMonthField(value)) {<z>
BitsCronField.parseDaysOfMonth(value);<z>
, (field, type) -> {<z>
(QuartzCronField.isQuartzDaysOfMonthField(field)) {<z>
);<z>
field);<z>
});<z>
name, int version) {<z>
{<z>
);<z>
version, cookie.getVersion());<z>
path) {<z>
if (path == null) {<z>
path = "";<z>
path.endsWith(PropertyAccessor.NESTED_PROPERTY_SEPARATOR)) {<z>
.NESTED_PROPERTY_SEPARATOR;<z>
= path;<z>
protected void configureMessageBroker(MessageBrokerRegistry registry) {<z>
(WebSocketMessageBrokerConfigurer configurer : this.configurers) {<z>
);<z>
Method testMethod) {<z>
"The next statement must not be null");<z>
Assert.notNull(testClass, "The test class must not be null");<z>
;<z>
testClass = testClass;<z>
= testMethod;<z>
public ResourceEncoder(int bufferSize) {<z>
MimeTypeUtils.APPLICATION_OCTET_STREAM, MimeTypeUtils.ALL);<z>
);<z>
.bufferSize = bufferSize;<z>
Nullable Object value) {<z>
null && this.nullAsEmptyCollection) {<z>
collectionType, 0));<z>
value) && !alwaysCreateNewCollection())) {<z>
super.setValue(value);<z>
) {<z>
, source.size());<z>
: source) {<z>
(convertElement(elem));<z>
;<z>
.getClass().isArray()) {<z>
(value);<z>
collectionType, length);<z>
) {<z>
);<z>
);<z>
, 1);<z>
value));<z>
setValue(target);<z>
RequestDataValueProcessor getRequestDataValueProcessor() {<z>
getApplicationContext();<z>
context.containsBean(REQUEST_DATA_VALUE_PROCESSOR_BEAN_NAME)) {<z>
, RequestDataValueProcessor.class);<z>
;<z>
ResultMatcher... matchers) throws Exception {<z>
new ExceptionCollector();<z>
{<z>
andExpect(matcher));<z>
exceptionCollector.assertEmpty();<z>
this;<z>
A extends Annotation> TypeMappedAnnotation<A> createIfPossible(<z>
source, Annotation annotation,<z>
logger) {<z>
annotation,<z>
, aggregateIndex, logger);<z>
ServerRequest request) {<z>
))) {<z>
accessControlRequestMethod =<z>
;<z>
accessControlRequestMethod != null) {<z>
accessControlRequestMethod);<z>
();<z>
Predicate<Class<?>> predicate) {<z>
type = parameter.getParameterType();<z>
().getAdapter(type);<z>
!= null) {<z>
adapter, parameter);<z>
;<z>
(type)) {<z>
adapter == null) {<z>
;<z>
;<z>
;<z>
Builder nest(RequestPredicate predicate,<z>
builderConsumer) {<z>
builderConsumer, "Consumer must not be null");<z>
;<z>
accept(nestedBuilder);<z>
;<z>
RouterFunctions.nest(predicate, nestedRoute));<z>
;<z>
> matcher) {<z>
-> {<z>
.getResponse().getHeaders(name);<z>
matcher);<z>
, Object... uriVariables)<z>
throws RestClientException {<z>
;<z>
null, uriVariables);<z>
CloseStatus status) throws IOException {<z>
checkNativeSessionInitialized();<z>
)) {<z>
this);<z>
(status);<z>
(<z>
, URI url) {<z>
(handler, "WebSocketHandler is required");<z>
url, "URL is required");<z>
;<z>
.contains(scheme)) {<z>
("Invalid scheme: '" + scheme + "'");<z>
SettableListenableFuture<>();<z>
new SockJsUrlInfo(url);<z>
));<z>
serverInfo).connect(handler, connectFuture);<z>
catch (Exception exception) {<z>
) {<z>
exception);<z>
setException(exception);<z>
connectFuture;<z>
{<z>
);<z>
) {<z>
);<z>
customizer = this.entityManagerInitializer;<z>
(customizer != null) {<z>
rawEntityManager);<z>
) {<z>
= expression.indexOf('=');<z>
) {<z>
("!");<z>
expression.substring(1) : expression);<z>
.value = null;<z>
'!');<z>
0, separator));<z>
expression.substring(separator + 1));<z>
, Object identifier) {<z>
persistentClass, identifier,<z>
+ "] with identifier [" + identifier + "]: not found",<z>
);<z>
T> changeParser(RouterFunction<T> routerFunction,<z>
PathPatternParser parser) {<z>
);<z>
);<z>
new ChangePathPatternParserVisitor(parser);<z>
routerFunction.accept(visitor);<z>
return routerFunction;<z>
void released() {<z>
;<z>
) && this.currentConnection != null) {<z>
this.currentConnection = null;<z>
Aggregate aggregate, int annotationIndex) {<z>
this.mappingCursors;<z>
{<z>
mapping;<z>
getMapping(annotationIndex, cursors[annotationIndex]);<z>
requiredType)) {<z>
;<z>
[annotationIndex]++;<z>
null);<z>
;<z>
public String toString() {<z>
StringBuilder();<z>
) {<z>
.append(this.type);<z>
!= null) {<z>
"; name=\"");<z>
'\"');<z>
this.filename != null) {<z>
(this.charset)) {<z>
);<z>
)).append('\"');<z>
"; filename*=");<z>
;<z>
) {<z>
;<z>
this.size);<z>
null) {<z>
append("; creation-date=\"");<z>
format(this.creationDate));<z>
('\"');<z>
if (this.modificationDate != null) {<z>
);<z>
.format(this.modificationDate));<z>
'\"');<z>
this.readDate != null) {<z>
;<z>
;<z>
('\"');<z>
);<z>
() {<z>
.clear();<z>
requests.clear();<z>
();<z>
() {<z>
== null) {<z>
this.signature = new MethodSignatureImpl();<z>
return this.signature;<z>
BeanDefinitionHolder definition, ParserContext parserContext) {<z>
) {<z>
strip();<z>
getValue().strip();<z>
().getConstructorArgumentValues();<z>
boolean ref = false;<z>
if (argName.endsWith(REF_SUFFIX)) {<z>
ref = true;<z>
);<z>
argValue);<z>
attr));<z>
(DELIMITER_PREFIX)) {<z>
;<z>
(arg)) {<z>
cvs.addGenericArgumentValue(valueHolder);<z>
index = -1;<z>
(arg);<z>
NumberFormatException ex) {<z>
).error(<z>
"' specifies an invalid integer", attr);<z>
{<z>
(<z>
;<z>
cvs.hasIndexedArgumentValue(index)) {<z>
parserContext.getReaderContext().error(<z>
+" already defined using <constructor-arg>." +<z>
" Only one approach may be used per argument.", attr);<z>
addIndexedArgumentValue(index, valueHolder);<z>
argName);<z>
(containsArgWithName(name, cvs)) {<z>
.getReaderContext().error(<z>
"Constructor argument '" + argName + "' already defined using <constructor-arg>." +<z>
);<z>
));<z>
);<z>
return definition;<z>
void tryCloseWithSockJsTransportError(Throwable error, CloseStatus closeStatus) {<z>
.isDebugEnabled()) {<z>
;<z>
);<z>
) {<z>
debug("Exception from error handling delegate", delegateException);<z>
closeStatus);<z>
Throwable closeException) {<z>
this, closeException);<z>
, List<String> values) {<z>
key);<z>
;<z>
;<z>
DefaultParameterNameDiscoverer() {<z>
NativeDetector.inNativeImage()) {<z>
new KotlinReflectionParameterNameDiscoverer());<z>
new StandardReflectionParameterNameDiscoverer());<z>
new LocalVariableTableParameterNameDiscoverer());<z>
{<z>
getClassLoader();<z>
;<z>
(); i++) {<z>
= nodeList.item(i);<z>
ELEMENT_NODE) {<z>
(node);<z>
{<z>
, classLoader, parserContext);<z>
addIncludeFilter(typeFilter);<z>
localName)) {<z>
, classLoader, parserContext);<z>
typeFilter);<z>
(ClassNotFoundException ex) {<z>
.warning(<z>
(element));<z>
(Exception ex) {<z>
parserContext.getReaderContext().error(<z>
());<z>
(SessionFactory sessionFactory) throws DataAccessResourceFailureException {<z>
.openSession();<z>
setHibernateFlushMode(FlushMode.MANUAL);<z>
session;<z>
) {<z>
);<z>
> customTranslatorClass) {<z>
(customTranslatorClass != null) {<z>
customSqlExceptionTranslator =<z>
).newInstance();<z>
catch (Throwable ex) {<z>
"Unable to instantiate custom translator", ex);<z>
.customSqlExceptionTranslator = null;<z>
(HttpServletRequest request, @Nullable HttpServletResponse response,<z>
@Nullable LocaleContext localeContext) {<z>
null;<z>
null;<z>
localeContext != null) {<z>
();<z>
TimeZoneAwareLocaleContext) {<z>
getTimeZone();<z>
, locale);<z>
;<z>
() {<z>
);<z>
.state(connectionFactory != null, "No ConnectionFactory set");<z>
;<z>
{<z>
);<z>
;<z>
(candidate instanceof TargetClassAware) {<z>
TargetClassAware) candidate).getTargetClass();<z>
) {<z>
());<z>
return result;<z>
{<z>
StringBuilder builder = new StringBuilder("{");<z>
) {<z>
();<z>
.next() : httpMethods);<z>
);<z>
) {<z>
paramsCondition);<z>
.isEmpty()) {<z>
", headers ").append(this.headersCondition);<z>
) {<z>
", consumes ").append(this.consumesCondition);<z>
()) {<z>
append(this.producesCondition);<z>
{<z>
).append(this.customConditionHolder);<z>
'}');<z>
();<z>
, String name, @Nullable Object value) {<z>
;<z>
) {<z>
(name, value);<z>
false);<z>
session != null) {<z>
session.removeAttribute(name);<z>
) {<z>
()];<z>
++) {<z>
= objectErrors.get(i);<z>
);<z>
return errorCodes;<z>
HttpInputMessage beforeBodyRead(HttpInputMessage inputMessage, MethodParameter parameter,<z>
) throws IOException {<z>
inputMessage;<z>
ClientResponse response, Mono<T> body) {<z>
exceptionWrappingFunction(response));<z>
applyStatusHandlers(response);<z>
) : body);<z>
MessageConverter getRequiredMessageConverter() throws IllegalStateException {<z>
;<z>
converter == null) {<z>
);<z>
;<z>
long period) {<z>
ScheduledExecutorService executor = getScheduledExecutor();<z>
0, period, TimeUnit.MILLISECONDS);<z>
) {<z>
"] did not accept task: " + task, ex);<z>
hookOnNext(DataBuffer value) {<z>
) {<z>
();<z>
byteBuffer = value.asByteBuffer();<z>
;<z>
{<z>
"CacheMethodDetails[");<z>
).append(this.method);<z>
append(this.cacheAnnotation);<z>
cacheName).append('\'');<z>
;<z>
toString();<z>
) {<z>
(name);<z>
;<z>
return cookie;<z>
Exception {<z>
{<z>
);<z>
.isEmpty(this.messageConverters)) {<z>
);<z>
) {<z>
= getPatternParser();<z>
== null) {<z>
);<z>
;<z>
);<z>
@Nullable HttpServletRequest request, String requestPath,<z>
> locations, ResourceResolverChain chain) {<z>
request, requestPath);<z>
key, Resource.class);<z>
) {<z>
isTraceEnabled()) {<z>
.trace("Resource resolved from cache");<z>
;<z>
.resolveResource(request, requestPath, locations);<z>
null) {<z>
);<z>
return resource;<z>
, Class<?> requiredType) {<z>
) {<z>
.toString();<z>
.class.isAssignableFrom(requiredType)) {<z>
Number) {<z>
, (Class<Number>) requiredType);<z>
requiredType);<z>
)) {<z>
convert(value, requiredType);<z>
(<z>
value.getClass().getName() +<z>
+ requiredType.getName() + "]");<z>
{<z>
(context).afterTestClass();<z>
;<z>
(String path) {<z>
);<z>
) {<z>
path;<z>
FOLDER_SEPARATOR);<z>
folderIndex > extIndex) {<z>
path;<z>
extIndex);<z>
boolean equals(@Nullable Object other) {<z>
if (this == other) {<z>
;<z>
that)) {<z>
;<z>
equals(other));<z>
(CloseStatus status) throws Exception {<z>
)) {<z>
);<z>
this.heartbeatFuture;<z>
future != null) {<z>
null;<z>
cancel(false);<z>
;<z>
(this, status);<z>
, @Nullable Object... values) throws DataAccessException {<z>
?>>) session -> {<z>
session.getNamedQuery(queryName);<z>
);<z>
) {<z>
.length; i++) {<z>
i]);<z>
queryObject.list();<z>
}));<z>
, Object handler) {<z>
;<z>
.REQUEST_ATTRIBUTE);<z>
)<z>
);<z>
) throws IllegalArgumentException {<z>
text);<z>
getValue();<z>
).toString()) : null);<z>
) {<z>
new IllegalArgumentException(<z>
": " + ex.getMessage());<z>
create) {<z>
);<z>
isInvalid()) {<z>
;<z>
create) {<z>
MockHttpSession(this.servletContext);<z>
this.session;<z>
{<z>
, "readPosition %d must be <= %d",<z>
);<z>
int pos = this.readPosition;<z>
.get(pos);<z>
pos + 1;<z>
b;<z>
) {<z>
getBeanInfo(type, Object.class);<z>
info.getPropertyDescriptors();<z>
{<z>
;<z>
ArrayList(all.length);<z>
all.length; i++) {<z>
[i];<z>
.getReadMethod() != null) ||<z>
null)) {<z>
(pd);<z>
]);<z>
catch (IntrospectionException e) {<z>
throw new CodeGenerationException(e);<z>
className, String methodName) {<z>
i++) {<z>
[i];<z>
())) {<z>
return i;<z>
;<z>
boolean equals(Object o) {<z>
) return true;<z>
o.getClass()) return false;<z>
Pet pet = (Pet) o;<z>
) return false;<z>
return true;<z>
request) {<z>
;<z>
!StringUtils.hasText(urlPath)) {<z>
urlPath = ServletRequestPathUtils.getCachedPathValue(request);<z>
return urlPath;<z>
Object key) {<z>
Mutable mutableHttpFields)) {<z>
("Immutable headers");<z>
(key instanceof String name) {<z>
key);<z>
remove(name);<z>
oldValues;<z>
return null;<z>
SpelNodeImpl eatPossiblyQualifiedId() {<z>
ArrayDeque<>();<z>
();<z>
) {<z>
;<z>
) {<z>
);<z>
= peekToken();<z>
) {<z>
) {<z>
length(), SpelMessage.OOD);<z>
startPos, SpelMessage.NOT_EXPECTED_TOKEN,<z>
).toLowerCase());<z>
.getFirst().getStartPosition(),<z>
[0]));<z>
{<z>
{<z>
.indexedPropertyType = PropertyDescriptorUtils.findIndexedPropertyType(<z>
, this.indexedReadMethod, this.indexedWriteMethod);<z>
(IntrospectionException ex) {<z>
indexedPropertyType;<z>
> action) throws TransactionException {<z>
flatMapMany(context -> {<z>
(this.transactionDefinition);<z>
.flatMapMany(it -> Flux<z>
usingWhen(<z>
(it),<z>
,<z>
,<z>
(),<z>
.transactionManager::rollback)<z>
-><z>
error(ex))));<z>
))<z>
(TransactionContextManager.getOrCreateContextHolder());<z>
(long timeout) {<z>
"Async processing has already completed");<z>
if (isStarted()) {<z>
.getServletRequest();<z>
.getServletResponse();<z>
, servletResponse);<z>
addListener(this);<z>
NO_TIMEOUT_VALUE) {<z>
.asyncContext.setTimeout(timeout);<z>
<T> sourceType) {<z>
{<z>
.source);<z>
Throwable) {<z>
source).getCause();<z>
if (sourceType.isInstance(cause)) {<z>
(cause);<z>
IllegalArgumentException("No source object of the given type available: " + sourceType);<z>
ifc) {<z>
"Advice must not be null");<z>
.advice = advice;<z>
;<z>
processPropertySource(AnnotationAttributes propertySource) throws IOException {<z>
("name");<z>
name)) {<z>
;<z>
);<z>
!StringUtils.hasLength(encoding)) {<z>
= null;<z>
"value");<z>
0, "At least one @PropertySource(value) location is required");<z>
"ignoreResourceNotFound");<z>
> factoryClass = propertySource.getClass("factory");<z>
factory = (factoryClass == PropertySourceFactory.class ?<z>
DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass));<z>
locations) {<z>
location);<z>
resolvedLocation);<z>
);<z>
SocketException ex) {<z>
ignoreResourceNotFound) {<z>
if (logger.isInfoEnabled()) {<z>
;<z>
;<z>
, ClassNotFoundException {<z>
inputStream.defaultReadObject();<z>
declaringClass.getDeclaredField(this.fieldName);<z>
Throwable ex) {<z>
("Could not find original class structure", ex);<z>
sourceType, TypeDescriptor targetType) {<z>
: this.converters) {<z>
converter instanceof ConditionalGenericConverter) ||<z>
).matches(sourceType, targetType)) {<z>
;<z>
return null;<z>
static org.springframework.protobuf.Msg parseFrom(<z>
.google.protobuf.ByteString data,<z>
.ExtensionRegistryLite extensionRegistry)<z>
.protobuf.InvalidProtocolBufferException {<z>
;<z>
message) throws Exception {<z>
;<z>
(parameter, message);<z>
)) {<z>
new MethodArgumentTypeMismatchException(message, parameter, "Actual message type '" +<z>
getDescriptiveType(message) + "' does not match expected type '" +<z>
getQualifiedName(targetMessageType) + "'");<z>
getPayload();<z>
.isInstance(payload)) {<z>
message;<z>
{<z>
message, "Cannot convert from actual payload type '" +<z>
+<z>
+ "' when payload is empty");<z>
parameter, targetPayloadType);<z>
(payload, message.getHeaders());<z>
findTemplateSource(String name) throws IOException {<z>
(logger.isDebugEnabled()) {<z>
.debug("Looking for FreeMarker template with name [" + name + "]");<z>
);<z>
.exists() ? resource : null);<z>
(<z>
("webFluxAdapterRegistry") ReactiveAdapterRegistry reactiveAdapterRegistry,<z>
ServerCodecConfigurer serverCodecConfigurer,<z>
("webFluxConversionService") FormattingConversionService conversionService,<z>
) Validator validator) {<z>
= createRequestMappingHandlerAdapter();<z>
));<z>
setWebBindingInitializer(getConfigurableWebBindingInitializer(conversionService, validator));<z>
(reactiveAdapterRegistry);<z>
new ArgumentResolverConfigurer();<z>
configureArgumentResolvers(configurer);<z>
configurer);<z>
return adapter;<z>
> task) {<z>
executor = getScheduledExecutor();<z>
(task);<z>
;<z>
listenableFuture;<z>
ex) {<z>
executor + "] did not accept task: " + task, ex);<z>
TypedValue getValue() {<z>
value =<z>
.autoGrowNullReferences);<z>
cachedReadAccessor instanceof CompilablePropertyAccessor compilablePropertyAccessor) {<z>
toDescriptor(compilablePropertyAccessor.getPropertyType()));<z>
value;<z>
public FileSystemXmlApplicationContext(<z>
)<z>
throws BeansException {<z>
super(parent);<z>
;<z>
{<z>
refresh();<z>
{<z>
{<z>
(bean instanceof BeanNameAware) {<z>
beanName);<z>
instanceof BeanClassLoaderAware) {<z>
;<z>
(bcl != null) {<z>
(bcl);<z>
if (bean instanceof BeanFactoryAware) {<z>
setBeanFactory(AbstractAutowireCapableBeanFactory.this);<z>
) {<z>
) {<z>
add(key, value);<z>
conversionHint)<z>
{<z>
));<z>
check() throws IllegalStateException {<z>
{<z>
("Pattern access threshold exceeded");<z>
> result) {<z>
)) {<z>
entryPattern + "]");<z>
JarFile jarFile = new JarFile(jarFilePath)) {<z>
{<z>
JarEntry entry = entries.nextElement();<z>
= entry.getName();<z>
entryPath)) {<z>
new UrlResource(<z>
,<z>
ResourceUtils.JAR_URL_SEPARATOR + entryPath));<z>
IOException ex) {<z>
(logger.isWarnEnabled()) {<z>
+ jarFilePath +<z>
;<z>
webRequest, Class<T> requiredType) {<z>
;<z>
nativeRequest == null) {<z>
(<z>
+ webRequest);<z>
return nativeRequest;<z>
Object bean, RootBeanDefinition mbd) {<z>
DisposableBeanAdapter.hasDestroyMethod(bean, mbd) ||<z>
hasDestructionAwareBeanPostProcessors() && DisposableBeanAdapter.hasApplicableProcessors(<z>
.destructionAware))));<z>
ByteBuffer... buffers) {<z>
buffers)) {<z>
ByteBuffer::remaining).sum();<z>
);<z>
buffers).forEach(this::write);<z>
return this;<z>
beanClass, String propertyName) {<z>
, propertyName,<z>
"' is not readable or has an invalid getter method: " +<z>
"Does the return type of the getter match the parameter type of the setter?");<z>
Class<?> targetClass) {<z>
)) {<z>
return null;<z>
.getName();<z>
);<z>
if (attr == null) {<z>
String bestNameMatch = null;<z>
.keySet()) {<z>
isMatch(methodName, mappedName) &&<z>
{<z>
.nameMap.get(mappedName);<z>
mappedName;<z>
return attr;<z>
) throws Exception {<z>
(ex instanceof Exception) {<z>
Exception) ex;<z>
instanceof Error) {<z>
(Error) ex;<z>
);<z>
, XmlMappingException {<z>
) {<z>
(graph, (DOMResult) result);<z>
.isStaxResult(result)) {<z>
;<z>
result instanceof SAXResult) {<z>
, (SAXResult) result);<z>
instanceof StreamResult) {<z>
);<z>
getClass());<z>
() {<z>
();<z>
null) {<z>
= getIsolationLevel();<z>
;<z>
protected void checkIfConfigurationModificationIsAllowed() {<z>
(isCompiled()) {<z>
(<z>
"Configuration cannot be altered once the class has been compiled or used");<z>
body, Charset charset) {<z>
] bytes = body.getBytes(charset);<z>
(bytes);<z>
DefaultDataBufferFactory.sharedInstance.wrap(byteBuffer);<z>
, @Nullable HttpEntity<?> requestEntity,<z>
throws RestClientException {<z>
type = responseType.getType();<z>
(requestEntity, type);<z>
T>> responseExtractor = responseEntityExtractor(type);<z>
responseExtractor, uriVariables));<z>
convertToInternal(<z>
conversionHint) {<z>
= (Message) payload;<z>
);<z>
) {<z>
contentType = PROTOBUF;<z>
getCharset();<z>
(charset == null) {<z>
;<z>
(contentType)) {<z>
ByteArrayOutputStream();<z>
message.writeTo(byteArrayOutputStream);<z>
;<z>
.protobufFormatSupport != null) {<z>
outputStream = new ByteArrayOutputStream();<z>
, outputStream, contentType, charset);<z>
= outputStream.toString(charset);<z>
{<z>
ex.getMessage(), ex);<z>
payload;<z>
> sourceClass) {<z>
if (String.class == targetClass) {<z>
;<z>
;<z>
== null) {<z>
;<z>
(method == null) {<z>
targetClass, "from", sourceClass);<z>
method;<z>
(int autowireMode, boolean dependencyCheck) {<z>
!= AUTOWIRE_BY_NAME && autowireMode != AUTOWIRE_BY_TYPE) {<z>
new IllegalArgumentException("Only constants AUTOWIRE_BY_NAME and AUTOWIRE_BY_TYPE supported");<z>
;<z>
= dependencyCheck;<z>
(Collection<?> value) {<z>
;<z>
value.isEmpty()) {<z>
EMPTY;<z>
"]");<z>
value) {<z>
.add(style(o));<z>
+ result;<z>
boolean allowResize) {<z>
.get();<z>
resizeThreshold);<z>
);<z>
{<z>
restructure(allowResize, ref);<z>
static WebApplicationContext getWebApplicationContext() {<z>
.getRequestAttributes();<z>
requestAttributes == null) {<z>
null;<z>
).getRequest();<z>
attributeName = DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE;<z>
(attributeName);<z>
if (wac == null) {<z>
;<z>
;<z>
{<z>
if (ObjectUtils.isEmpty(params)) {<z>
();<z>
LinkedHashSet<>(params.length);<z>
params) {<z>
(param));<z>
;<z>
trySchedule() {<z>
0) {<z>
schedule();<z>
setFrom(InternetAddress from) throws MessagingException {<z>
, "From address must not be null");<z>
;<z>
setFrom(from);<z>
params, Set<String> usedParams)<z>
JspException {<z>
;<z>
param : params) {<z>
+ URL_TEMPLATE_DELIMITER_SUFFIX;<z>
{<z>
param.getName());<z>
);<z>
replace(uri, template,<z>
(value, encoding) : ""));<z>
catch (UnsupportedCharsetException ex) {<z>
new JspException(ex);<z>
getName() + URL_TEMPLATE_DELIMITER_SUFFIX;<z>
(uri.contains(template)) {<z>
));<z>
.getValue();<z>
uri = StringUtils.replace(uri, template,<z>
;<z>
UnsupportedCharsetException ex) {<z>
(ex);<z>
uri;<z>
, @Nullable Annotation annotation) {<z>
(annotation == null) {<z>
emptySet();<z>
.annotationType()).stream()<z>
().getName())<z>
));<z>
removeJsessionid(String requestUri) {<z>
;<z>
key);<z>
if (index == -1) {<z>
return requestUri;<z>
0, index);<z>
length(); i++) {<z>
i);<z>
'/') {<z>
start + requestUri.substring(i);<z>
return start;<z>
nativeMessage) {<z>
notNull(type, "'type' must not be null");<z>
"'payload' must not be null");<z>
this.type = type;<z>
= payload;<z>
this.nativeMessage = nativeMessage;<z>
{<z>
getSessionFactory() == null) {<z>
throw new IllegalArgumentException("Property 'sessionFactory' is required");<z>
this.beanFactory == null) {<z>
IllegalArgumentException("Property 'beanFactory' is required for 'entityInterceptorBeanName'");<z>
null) {<z>
);<z>
!= null) {<z>
)) {<z>
sfds +<z>
"] of Hibernate SessionFactory for HibernateTransactionManager");<z>
sfds);<z>
public SseBuilder retry(Duration duration) {<z>
(duration, "Duration must not be null");<z>
(duration.toMillis());<z>
return field("retry", millis);<z>
setQosSettings(QosSettings settings) {<z>
settings, "Settings must not be null");<z>
);<z>
;<z>
setPriority(settings.getPriority());<z>
getTimeToLive());<z>
public boolean supportsParameter(MethodParameter parameter) {<z>
webRequest = getWebRequest();<z>
adaptee.resolveArgument(parameter, webRequest);<z>
result == WebArgumentResolver.UNRESOLVED) {<z>
;<z>
, result);<z>
(Exception ex) {<z>
if (logger.isDebugEnabled()) {<z>
());<z>
;<z>
(Class<?> clazz) throws InitializationError {<z>
;<z>
()) {<z>
);<z>
clazz);<z>
this.testContextManager = createTestContextManager(clazz);<z>
void initRequestToViewNameTranslator(ApplicationContext context) {<z>
.viewNameTranslator =<z>
;<z>
logger.isTraceEnabled()) {<z>
getSimpleName());<z>
(logger.isDebugEnabled()) {<z>
;<z>
{<z>
.class);<z>
if (logger.isTraceEnabled()) {<z>
.trace("No RequestToViewNameTranslator '" + REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME +<z>
) + "]");<z>
ServletException {<z>
this.filters) {<z>
.init(config);<z>
{<z>
) {<z>
();<z>
);<z>
getPublicDeclaringClass() {<z>
(!this.computedPublicDeclaringClass) {<z>
this.publicDeclaringClass =<z>
.originalMethod.getDeclaringClass());<z>
true;<z>
return this.publicDeclaringClass;<z>
buildPartial() {<z>
= new Msg(this);<z>
bitField0_;<z>
= 0;<z>
0x00000001) == 0x00000001)) {<z>
0x00000001;<z>
foo_;<z>
from_bitField0_ & 0x00000002) == 0x00000002)) {<z>
0x00000002;<z>
{<z>
= blah_;<z>
else {<z>
();<z>
= to_bitField0_;<z>
;<z>
return result;<z>
void updateSessionReadTime(@Nullable String sessionId) {<z>
{<z>
(sessionId);<z>
info != null) {<z>
);<z>
) {<z>
{<z>
, value);<z>
key);<z>
) {<z>
scripts);<z>
;<z>
public PathPatternParser getPatternParserOrDefault() {<z>
) {<z>
return this.patternParser;<z>
.defaultPatternParser == null) {<z>
;<z>
.defaultPatternParser;<z>
Throwable {<z>
retVal = invocation.proceed();<z>
"No ApplicationEvent class set");<z>
= (ApplicationEvent)<z>
.newInstance(invocation.getThis());<z>
, "No ApplicationEventPublisher available");<z>
;<z>
return retVal;<z>
NativeWebRequest request) {<z>
variables = getUriTemplateVariables(request);<z>
variableValue = variables.get(attributeName);<z>
(StringUtils.hasText(variableValue)) {<z>
return variableValue;<z>
getParameter(attributeName);<z>
) {<z>
parameterValue;<z>
;<z>
(Session session) {<z>
String[] filterNames = getFilterNames();<z>
filterNames != null) {<z>
for (String filterName : filterNames) {<z>
;<z>
() {<z>
;<z>
) {<z>
MediaType.APPLICATION_ATOM_XML_VALUE);<z>
, MediaType.APPLICATION_RSS_XML_VALUE);<z>
jaxb2Present || jackson2XmlPresent) {<z>
;<z>
jackson2Present || gsonPresent) {<z>
, MediaType.APPLICATION_JSON_VALUE);<z>
) {<z>
"application/x-jackson-smile");<z>
jackson2CborPresent) {<z>
.APPLICATION_CBOR_VALUE);<z>
defaultMediaTypes;<z>
customizer,<z>
{<z>
Generator();<z>
.setInterface(keyInterface);<z>
(keyInterface);<z>
) {<z>
);<z>
)) {<z>
: next) {<z>
);<z>
(loader);<z>
create();<z>
,<z>
{<z>
);<z>
.setSuperclass(factoryBean.getClass());<z>
(SpringNamingPolicy.INSTANCE);<z>
;<z>
);<z>
;<z>
) {<z>
;<z>
(ObjenesisException ex) {<z>
"Unable to instantiate enhanced FactoryBean using Objenesis, " +<z>
;<z>
== null) {<z>
.accessibleConstructor(fbClass).newInstance();<z>
{<z>
+<z>
ex);<z>
proxy) -> {<z>
{<z>
beanName);<z>
factoryBean, args);<z>
;<z>
return fbProxy;<z>
beanName, BeanFactory owner) {<z>
.hasMethodOverrides()) {<z>
constructorToUse;<z>
.constructorArgumentLock) {<z>
(Constructor<?>) bd.resolvedConstructorOrFactoryMethod;<z>
constructorToUse == null) {<z>
getBeanClass();<z>
clazz.isInterface()) {<z>
;<z>
constructorToUse = clazz.getDeclaredConstructor();<z>
constructorToUse;<z>
Throwable ex) {<z>
;<z>
(constructorToUse);<z>
owner);<z>
{<z>
getClass())) {<z>
;<z>
Proxy.getInvocationHandler(other);<z>
&&<z>
.xt));<z>
BeanDefinitionStoreException {<z>
.notNull(resources, "Resource array must not be null");<z>
int count = 0;<z>
) {<z>
count += loadBeanDefinitions(resource);<z>
;<z>
{<z>
.copyOfRange(args, start, end);<z>
) {<z>
if (constructorArgs[i] instanceof GString) {<z>
;<z>
constructorArgs[i] instanceof List) {<z>
]);<z>
[i] instanceof Map){<z>
]);<z>
;<z>
void checkCompatible(CompositeMessageCondition other) {<z>
);<z>
i++) {<z>
()) {<z>
getClass())) {<z>
("Mismatched CompositeMessageCondition: " +<z>
;<z>
) {<z>
parserContext);<z>
parserContext);<z>
null) {<z>
);<z>
);<z>
concurrency)) {<z>
("concurrency", concurrency);<z>
.getAttribute(PREFETCH_ATTRIBUTE);<z>
)) {<z>
"prefetchSize", Integer.valueOf(prefetch));<z>
return properties;<z>
result, MethodParameter parameter) {<z>
.getParameterType();<z>
(result == null) {<z>
null;<z>
) {<z>
;<z>
result instanceof CompositeData) {<z>
"from", CompositeData.class);<z>
result);<z>
CompositeData[] array) {<z>
) {<z>
, targetClass);<z>
class.isAssignableFrom(targetClass)) {<z>
elementType =<z>
asCollection().resolveGeneric();<z>
if (elementType != null) {<z>
(array, targetClass, elementType);<z>
TabularData) {<z>
, TabularData.class);<z>
invokeMethod(fromMethod, null, result);<z>
(result instanceof TabularData[] array) {<z>
{<z>
;<z>
class.isAssignableFrom(targetClass)) {<z>
<?> elementType =<z>
).asCollection().resolveGeneric();<z>
(elementType != null) {<z>
, elementType);<z>
(<z>
getName() + "]");<z>
) {<z>
throw new InvocationFailureException(<z>
);<z>
Class<?> clazz) {<z>
{<z>
.matches(clazz)) {<z>
return false;<z>
true;<z>
ContextRefreshedEvent event) {<z>
.applicationContext) {<z>
= true;<z>
, String name) {<z>
Assert.notNull(model, "Model map must not be null");<z>
"Name must not be null");<z>
MODEL_KEY_PREFIX + name);<z>
{<z>
throw new IllegalStateException("BindingResult attribute is not of type BindingResult: " + attr);<z>
(BindingResult) attr;<z>
initAttributes(HttpServletRequest request) {<z>
();<z>
names = request.getAttributeNames();<z>
()) {<z>
;<z>
, request.getAttribute(name));<z>
map;<z>
public String[] getAttributeNames(int scope) {<z>
if (scope == SCOPE_REQUEST) {<z>
()) {<z>
throw new IllegalStateException(<z>
;<z>
request.getAttributeNames());<z>
getSession(false);<z>
!= null) {<z>
.toStringArray(session.getAttributeNames());<z>
ex) {<z>
[0];<z>
{<z>
-> {<z>
= getQueryParams(request);<z>
, matchers.length);<z>
matchers.length; i++) {<z>
i]);<z>
writeTagContent(TagWriter tagWriter) throws JspException {<z>
;<z>
tagWriter);<z>
"hidden");<z>
if (isDisabled()) {<z>
;<z>
, getPropertyEditor());<z>
getName(), value, "hidden"));<z>
);<z>
return SKIP_BODY;<z>
, Class<A> type) {<z>
);<z>
);<z>
(classLoader, SynthesizedAnnotation.class) ?<z>
{type};<z>
newProxyInstance(classLoader, interfaces, handler);<z>
@Nullable Object... args) {<z>
method.invoke(target, args);<z>
{<z>
(ex);<z>
"Should never get here");<z>
, int value) {<z>
;<z>
;<z>
;<z>
{<z>
clientRequest, "ClientRequest must not be null");<z>
.method();<z>
clientRequest.url();<z>
return this.connector<z>
)<z>
-> logRequest(clientRequest))<z>
))<z>
, clientRequest))<z>
(httpResponse -> {<z>
= getLogPrefix(clientRequest, httpResponse);<z>
logPrefix);<z>
return new DefaultClientResponse(<z>
) + " " + url,<z>
);<z>
);<z>
BeanDefinitionCustomizer... customizers) {<z>
for (BeanDefinitionCustomizer customizer : customizers) {<z>
;<z>
return this;<z>
(@Nullable Source source) {<z>
StreamSource streamSource) {<z>
!= null) {<z>
();<z>
{<z>
{<z>
.close();<z>
ex) {<z>
String pattern,<z>
.Builder> builderConsumer) {<z>
, builderConsumer);<z>
) {<z>
);<z>
.scopedObjects.destructionCallbacks.values()) {<z>
();<z>
this.scopedObjects.destructionCallbacks.clear();<z>
.scopedInstances.clear();<z>
configClass, DeferredImportSelector importSelector) {<z>
= new DeferredImportSelectorHolder(configClass, importSelector);<z>
this.deferredImportSelectors == null) {<z>
handler = new DeferredImportSelectorGroupingHandler();<z>
handler.register(holder);<z>
);<z>
);<z>
getPropertyValue(String propertyName) throws BeansException {<z>
AbstractNestablePropertyAccessor nestedPa = getPropertyAccessorForPropertyPath(propertyName);<z>
nestedPa, propertyName));<z>
nestedPa.getPropertyValue(tokens);<z>
protected UUID getUuid() {<z>
) {<z>
.uuid = idGenerator.generateId();<z>
uuid;<z>
] getAttributePrototypes() {<z>
;<z>
(firstAttribute);<z>
= firstField;<z>
null) {<z>
(attributePrototypes);<z>
fieldWriter = (FieldWriter) fieldWriter.fv;<z>
;<z>
{<z>
(attributePrototypes);<z>
(MethodWriter) methodWriter.mv;<z>
RecordComponentWriter recordComponentWriter = firstRecordComponent;<z>
) {<z>
;<z>
recordComponentWriter = (RecordComponentWriter) recordComponentWriter.delegate;<z>
);<z>
int drain(InputStream in) throws IOException {<z>
(in, "No InputStream specified");<z>
[] buffer = new byte[BUFFER_SIZE];<z>
1;<z>
0;<z>
!= -1) {<z>
;<z>
byteCount;<z>
toString() {<z>
[] pvs = getPropertyValues();<z>
) {<z>
(pvs, "; ");<z>
return "PropertyValues: length=0";<z>
A> createIfPossible(<z>
source, @Nullable Object rootAttribute,<z>
{<z>
, rootAttribute,<z>
, aggregateIndex);<z>
ex) {<z>
(ex);<z>
{<z>
.getAnnotationType().getName();<z>
() == 0 ? "annotation " + type :<z>
getName());<z>
+ item, source, ex);<z>
;<z>
Connection connection,<z>
AtomicInteger statementNumber) {<z>
))<z>
flatMap(Result::getRowsUpdated)<z>
;<z>
isDebugEnabled()) {<z>
execution.doOnNext(rowsAffected -><z>
debug(rowsAffected + " returned as update count for SQL: " + statement));<z>
-> {<z>
statement.trim(), "drop");<z>
(continueOnError || (dropStatement && ignoreFailedDrops)) {<z>
(logger.isDebugEnabled()) {<z>
ScriptStatementFailedException.buildErrorMessage(<z>
, resource), ex);<z>
, resource, ex));<z>
empty();<z>
;<z>
, ?> uriVariables)<z>
RestClientException {<z>
;<z>
, requestCallback, headersExtractor(), uriVariables);<z>
: null);<z>
HttpClient> customizer) {<z>
(new HttpClient(), resourceFactory);<z>
(customizer != null) {<z>
;<z>
String statusText,<z>
Charset responseCharset) {<z>
responseBody, responseCharset);<z>
= statusCode;<z>
, Annotation[] annotations,<z>
, AnnotationFilter annotationFilter) {<z>
Assert.notNull(repeatableContainers, "RepeatableContainers must not be null");<z>
Assert.notNull(annotationFilter, "AnnotationFilter must not be null");<z>
source, annotations, repeatableContainers, annotationFilter);<z>
endpointClass, ClientEndpointConfig cec, URI path)<z>
{<z>
throw new UnsupportedOperationException(<z>
"MockServerContainer does not support connectToServer(Class, ClientEndpointConfig, URI)");<z>
InternetAddress[] addresses) throws AddressException {<z>
) {<z>
(address);<z>
throws IllegalArgumentException {<z>
;<z>
) {<z>
IllegalArgumentException(String.format(<z>
));<z>
;<z>
number) {<z>
;<z>
entrySet()) {<z>
.getValue().size();<z>
.size() +<z>
number);<z>
(Object next) {<z>
wrap(next);<z>
ex) {<z>
AopConfigException("Unknown advisor type " + next.getClass() +<z>
;<z>
rowMapper)<z>
throws DataAccessException {<z>
rowMapper);<z>
;<z>
) {<z>
CharSequenceEncoder.allMimeTypes());<z>
encoders.add(new ByteBufferEncoder());<z>
);<z>
;<z>
add(StringDecoder.allMimeTypes());<z>
.add(new ByteBufferDecoder());<z>
decoders.add(new ByteArrayDecoder());<z>
);<z>
Property(<z>
) {<z>
objectType;<z>
readMethod;<z>
.writeMethod = writeMethod;<z>
();<z>
resolveName());<z>
Element element) {<z>
;<z>
))) {<z>
= CacheControl.noCache();<z>
element.getAttribute("no-store"))) {<z>
= CacheControl.noStore();<z>
(element.hasAttribute("max-age")) {<z>
;<z>
.empty();<z>
element.getAttribute("must-revalidate"))) {<z>
);<z>
("no-transform"))) {<z>
();<z>
)) {<z>
;<z>
getAttribute("cache-private"))) {<z>
.cachePrivate();<z>
)) {<z>
proxyRevalidate();<z>
.hasAttribute("s-maxage")) {<z>
.SECONDS);<z>
("stale-while-revalidate")) {<z>
= cacheControl.staleWhileRevalidate(<z>
);<z>
element.hasAttribute("stale-if-error")) {<z>
= cacheControl.staleIfError(<z>
"stale-if-error")), TimeUnit.SECONDS);<z>
return cacheControl;<z>
> resolveArgument(<z>
, ServerWebExchange exchange) {<z>
bindingContext, exchange);<z>
boolean isSetBeanFactory(Method candidateMethod) {<z>
("setBeanFactory") &&<z>
candidateMethod.getParameterCount() == 1 &&<z>
[0] &&<z>
)));<z>
) {<z>
getListenerContainers();<z>
;<z>
: listenerContainers) {<z>
);<z>
Object[] args) throws Throwable {<z>
.getName()) {<z>
"equals":<z>
(proxy == args[0]);<z>
case "hashCode":<z>
proxy);<z>
:<z>
return null;<z>
case "isClosed":<z>
;<z>
"getTargetConnection":<z>
;<z>
:<z>
0]));<z>
"isWrapperFor":<z>
args[0]));<z>
args);<z>
if (retVal instanceof Statement) {<z>
applyStatementSettings(((Statement) retVal));<z>
;<z>
{<z>
;<z>
(PropertyCacheKey other) {<z>
.getName());<z>
if (result == 0) {<z>
.property.compareTo(other.property);<z>
result;<z>
ArgumentsMatchInfo compareArgumentsVarargs(<z>
typeConverter) {<z>
expectedArgTypes),<z>
;<z>
.isArray(),<z>
"Final expected argument should be array type (the varargs parameter)");<z>
EXACT;<z>
1;<z>
null; i++) {<z>
i);<z>
TypeDescriptor expectedArg = expectedArgTypes.get(i);<z>
null) {<z>
) {<z>
;<z>
!expectedArg.equals(suppliedArg)) {<z>
if (suppliedArg.isAssignableTo(expectedArg)) {<z>
if (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {<z>
ArgumentsMatchKind.CLOSE;<z>
{<z>
ArgumentsMatchKind.REQUIRES_CONVERSION;<z>
;<z>
(match == null) {<z>
null;<z>
() == expectedArgTypes.size() &&<z>
equals(<z>
() - 1))) {<z>
1);<z>
();<z>
, "No element type");<z>
.getType();<z>
) {<z>
suppliedArg = suppliedArgTypes.get(i);<z>
) {<z>
isPrimitive()) {<z>
= null;<z>
.getType()) {<z>
varargsParamType, suppliedArg.getType())) {<z>
!= ArgumentsMatchKind.REQUIRES_CONVERSION) {<z>
match = ArgumentsMatchKind.CLOSE;<z>
, TypeDescriptor.valueOf(varargsParamType))) {<z>
;<z>
= null;<z>
);<z>
MediaType mediaType) throws IOException {<z>
this.complete,<z>
failure : ""));<z>
sendInternal(object, mediaType);<z>
(Element element, ParserContext parserContext) {<z>
SpringCachingConfigurer.registerCacheAspect(element, parserContext);<z>
) {<z>
element, parserContext);<z>
start() {<z>
(!isRunning()) {<z>
= true;<z>
sockJsService instanceof Lifecycle) {<z>
start();<z>
HttpServletRequest request) {<z>
contextPath = request.getContextPath();<z>
.startsWith("//")) {<z>
(1);<z>
return contextPath;<z>
(final String name, final Object value) {<z>
++numElementValuePairs;<z>
) {<z>
.addConstantUtf8(name));<z>
{<z>
addConstantUtf8((String) value));<z>
else if (value instanceof Byte) {<z>
);<z>
instanceof Boolean) {<z>
: 0;<z>
symbolTable.addConstantInteger(booleanValue).index);<z>
} else if (value instanceof Character) {<z>
.index);<z>
instanceof Short) {<z>
index);<z>
) {<z>
getDescriptor()));<z>
) {<z>
[]) value;<z>
, byteArray.length);<z>
byteValue : byteArray) {<z>
index);<z>
value instanceof boolean[]) {<z>
= (boolean[]) value;<z>
.put12('[', booleanArray.length);<z>
: booleanArray) {<z>
1 : 0).index);<z>
{<z>
) value;<z>
('[', shortArray.length);<z>
short shortValue : shortArray) {<z>
addConstantInteger(shortValue).index);<z>
char[]) {<z>
value;<z>
put12('[', charArray.length);<z>
: charArray) {<z>
.addConstantInteger(charValue).index);<z>
instanceof int[]) {<z>
= (int[]) value;<z>
, intArray.length);<z>
intArray) {<z>
intValue).index);<z>
]) {<z>
long[]) value;<z>
'[', longArray.length);<z>
(long longValue : longArray) {<z>
).index);<z>
float[]) {<z>
) value;<z>
put12('[', floatArray.length);<z>
floatValue : floatArray) {<z>
addConstantFloat(floatValue).index);<z>
if (value instanceof double[]) {<z>
;<z>
doubleArray.length);<z>
double doubleValue : doubleArray) {<z>
symbolTable.addConstantDouble(doubleValue).index);<z>
{<z>
value);<z>
, symbol.index);<z>
context) {<z>
Context() {<z>
<?>> messageWriters() {<z>
messageWriters();<z>
{<z>
.getRequest());<z>
Map<String, Object> hints() {<z>
LOG_PREFIX_HINT, exchange.getLogPrefix());<z>
return hints;<z>
});<z>
,<z>
> encoder) {<z>
== null) {<z>
null;<z>
.indexOf('{') == -1) {<z>
;<z>
) != -1) {<z>
= sanitizeSource(source);<z>
(source);<z>
();<z>
find()) {<z>
= matcher.group(1);<z>
= getVariableName(match);<z>
uriVariables.getValue(varName);<z>
SKIP_VALUE.equals(varValue)) {<z>
(varValue);<z>
) : Matcher.quoteReplacement(formatted);<z>
;<z>
;<z>
();<z>
(Object lookupKey) {<z>
Integer) {<z>
return lookupKey;<z>
instanceof String constantName) {<z>
startsWith(DefaultTransactionDefinition.PREFIX_ISOLATION)) {<z>
"Only isolation constants allowed");<z>
constants.asNumber(constantName);<z>
IllegalArgumentException(<z>
lookupKey);<z>
condition) {<z>
) {<z>
.beanDefinitionMap) {<z>
.manualSingletonNames)) {<z>
LinkedHashSet<>(this.manualSingletonNames);<z>
.accept(updatedSingletons);<z>
this.manualSingletonNames = updatedSingletons;<z>
)) {<z>
.manualSingletonNames);<z>
QName name, Attributes atts,<z>
<String, String> namespaceMapping) throws XMLStreamException {<z>
;<z>
namespaceMapping);<z>
this.eventWriter.add(<z>
.iterator()));<z>
{<z>
.isEmpty(this.messageReaders)) {<z>
create();<z>
getReaders();<z>
) {<z>
);<z>
if (this.routerFunction != null) {<z>
this.routerFunction, getPathPatternParser());<z>
generateCode(MethodVisitor mv, CodeFlow cf) {<z>
cf.loadEvaluationContext(mv);<z>
).exitTypeDescriptor;<z>
).exitTypeDescriptor;<z>
;<z>
CodeFlow.isPrimitive(rightDesc);<z>
.enterCompilationScope();<z>
).generateCode(mv, cf);<z>
exitCompilationScope();<z>
if (leftPrim) {<z>
, leftDesc.charAt(0));<z>
);<z>
;<z>
;<z>
(rightPrim) {<z>
);<z>
;<z>
'.', '/');<z>
.visitMethodInsn(INVOKESTATIC, operatorClassName, "equalityCheck",<z>
false);<z>
Label notZero = new Label();<z>
Label();<z>
notZero);<z>
);<z>
.visitJumpInsn(GOTO, end);<z>
.visitLabel(notZero);<z>
.visitInsn(ICONST_0);<z>
end);<z>
;<z>
headerName, String... headerValues) {<z>
{<z>
, headerValue);<z>
this;<z>
{<z>
name, "Parameter name must not be null");<z>
(name)) {<z>
;<z>
.initParameters.put(name, value);<z>
return true;<z>
, int index) {<z>
;<z>
(index));<z>
();<z>
);<z>
);<z>
;<z>
();<z>
;<z>
);<z>
.getfield(getCallbackField(index));<z>
(end);<z>
urlPatterns) {<z>
;<z>
(urlPatterns, "urlPatterns cannot be null");<z>
urlPatterns.length > 0) {<z>
new PatternMappingFilterProxy(filter, urlPatterns);<z>
;<z>
);<z>
AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) {<z>
(AGENT_ID_ATTRIBUTE);<z>
.hasText(agentId)) {<z>
;<z>
("agentId", agentId);<z>
bd;<z>
RootBeanDefinition(MBeanServerFactoryBean.class);<z>
"locateExistingServerIfPossible", Boolean.TRUE);<z>
;<z>
parserContext.extractSource(element));<z>
;<z>
T> rowMapper)<z>
throws DataAccessException {<z>
);<z>
Exception {<z>
())) {<z>
ReflectionUtils.rethrowException(ex);<z>
handleUncaughtException(ex, method, params);<z>
) {<z>
) +<z>
;<z>
PropertyValues pvs)<z>
throws Throwable {<z>
) {<z>
Field field = (Field) this.member;<z>
.makeAccessible(field);<z>
, requestingBeanName));<z>
if (checkPropertySkipping(pvs)) {<z>
this.member;<z>
.makeAccessible(method);<z>
;<z>
{<z>
ex.getTargetException();<z>
?> targetClass, @Nullable Object conversionHint) {<z>
.notNull(this.unmarshaller, "Property 'unmarshaller' is required");<z>
);<z>
source);<z>
!targetClass.isInstance(result)) {<z>
TypeMismatchException(result, targetClass);<z>
;<z>
{<z>
;<z>
HandlerFunctionAdapter handlerFunctionAdapter() {<z>
new HandlerFunctionAdapter();<z>
();<z>
{<z>
getTimeout());<z>
;<z>
BeanCreationException(String msg) {<z>
(msg);<z>
beanName = null;<z>
.resourceDescription = null;<z>
targetType) {<z>
(sourceType.getType())) {<z>
), targetType)) {<z>
return false;<z>
true;<z>
Element ele) {<z>
ele, "Element must not be null");<z>
;<z>
> childEles = new ArrayList<>();<z>
) {<z>
nl.item(i);<z>
Element) {<z>
childEles.add((Element) node);<z>
;<z>
T source) {<z>
.hasText(name, "Property source name must contain at least one character");<z>
source, "Property source must not be null");<z>
= name;<z>
= source;<z>
doWithRequest(ClientHttpRequest request) throws IOException {<z>
(this.responseType != null) {<z>
allSupportedMediaTypes = getMessageConverters().stream()<z>
responseType, converter))<z>
.responseType, converter))<z>
()<z>
(Collectors.toList());<z>
MimeTypeUtils.sortBySpecificity(allSupportedMediaTypes);<z>
if (logger.isDebugEnabled()) {<z>
"Accept=" + allSupportedMediaTypes);<z>
.getHeaders().setAccept(allSupportedMediaTypes);<z>
int byteValue2) {<z>
= length;<z>
data.length) {<z>
(2);<z>
currentData = data;<z>
currentLength++] = (byte) byteValue1;<z>
[currentLength++] = (byte) byteValue2;<z>
;<z>
this;<z>
?> type, MethodFilter filter) throws IllegalStateException {<z>
();<z>
this.reflectiveMethodResolver;<z>
null) {<z>
new IllegalStateException(<z>
;<z>
filter);<z>
{<z>
toRequestProducer();<z>
create(sink -> {<z>
=<z>
, context));<z>
;<z>
;<z>
HttpServletRequest request, HttpServletResponse response,<z>
Nullable ModelAndView mv,<z>
throws Exception {<z>
;<z>
exception != null) {<z>
if (exception instanceof ModelAndViewDefiningException) {<z>
"ModelAndViewDefiningException encountered", exception);<z>
);<z>
getHandler() : null);<z>
response, handler, exception);<z>
null);<z>
) {<z>
(mv, request, response);<z>
if (errorView) {<z>
.clearErrorRequestAttributes(request);<z>
isTraceEnabled()) {<z>
trace("No view rendering, null ModelAndView returned.");<z>
).isConcurrentHandlingStarted()) {<z>
mappedHandler != null) {<z>
.triggerAfterCompletion(request, response, null);<z>
Mono<Object> resolveArgument(<z>
exchange) {<z>
exchange.getSession();<z>
getParameterType());<z>
: Mono.from(session));<z>
hashCode() {<z>
(this.getExpression());<z>
this.pointcutDeclarationScope);<z>
;<z>
);<z>
hashCode;<z>
(<z>
<? extends CacheKeyGenerator> candidate) {<z>
if (candidate != CacheKeyGenerator.class) {<z>
);<z>
!= defaults.cacheKeyGenerator()) {<z>
cacheKeyGenerator()));<z>
);<z>
,<z>
>> predicate) {<z>
null);<z>
(<z>
Nullable Throwable cause) {<z>
;<z>
persistentClass = persistentClassName;<z>
this.identifier = identifier;<z>
> typedReaders) {<z>
multipartReader != null) {<z>
(typedReaders, this.multipartReader);<z>
DefaultPartHttpMessageReader();<z>
addCodec(typedReaders, partReader);<z>
;<z>
Nullable Class<?> clazz) {<z>
clazz : Object.class);<z>
.type = this.resolved;<z>
;<z>
= null;<z>
= null;<z>
;<z>
public boolean isBeforeAdvice() {<z>
this.isBeforeAdvice == null) {<z>
;<z>
return this.isBeforeAdvice;<z>
{<z>
;<z>
beanClass);<z>
scope);<z>
);<z>
indexOf(IntPredicate predicate, int fromIndex) {<z>
predicate, "IntPredicate must not be null");<z>
< 0) {<z>
fromIndex = 0;<z>
.byteBuf.writerIndex()) {<z>
;<z>
- fromIndex;<z>
;<z>
public void setDatabaseProductName(String dbName) {<z>
{<z>
SQLErrorCodeSQLExceptionTranslator(dbName);<z>
type, Method bridgeMethod) {<z>
.getParameterTypes());<z>
{<z>
;<z>
, OutputStream os, String header) throws IOException {<z>
{<z>
("XML support disabled");<z>
, os, header);<z>
public WriterFunctionResponse(int statusCode, HttpHeaders headers,<z>
,<z>
> writeFunction) {<z>
.emptyMap());<z>
(writeFunction, "BiFunction must not be null");<z>
.writeFunction = writeFunction;<z>
String htmlEscape(String content) {<z>
out = content;<z>
)) {<z>
) {<z>
getCharacterEncoding());<z>
htmlEscape(content);<z>
out;<z>
Session session) {<z>
= getConnectionFactory();<z>
;<z>
exposeResource) {<z>
.bindResource(<z>
session));<z>
, message);<z>
) {<z>
;<z>
{<z>
poolSizeMonitor) {<z>
return this.maxPoolSize;<z>
delegateProcessing(SmartContextLoader loader, ContextConfigurationAttributes configAttributes) {<z>
{<z>
String.format("Delegating to %s to process context configuration %s.",<z>
name(loader), configAttributes));<z>
loader.processContextConfiguration(configAttributes);<z>
void commitIfNecessary(Session session) throws JMSException {<z>
;<z>
.commit();<z>
.jms.IllegalStateException ex) {<z>
MockHttpServletRequestBuilder accept(MediaType... mediaTypes) {<z>
;<z>
(Arrays.asList(mediaTypes)));<z>
this;<z>
Duration timeout) {<z>
= this.exchanges.remove(requestId);<z>
) -> {<z>
.WEBTESTCLIENT_REQUEST_ID;<z>
+ requestId;<z>
;<z>
(),<z>
getRecorder().getContent(),<z>
(),<z>
,<z>
);<z>
) {<z>
mimeType.getCharset() != null) {<z>
();<z>
();<z>
() {<z>
()<z>
::isDirectlyPresent)<z>
getType().getName())<z>
(LinkedHashSet::new));<z>
P extends Publisher<T>> MultipartInserter withPublisher(<z>
T> elementClass) {<z>
name, publisher, elementClass);<z>
;<z>
, HttpHeaders headers) {<z>
.forEach((headerName, headerValues) -> {<z>
{<z>
.collectionToDelimitedString(headerValues, "; ");<z>
(headerName, headerValue);<z>
) &&<z>
{<z>
) {<z>
headerName, headerValue);<z>
);<z>
createMarshaller(Class<?> clazz) {<z>
(clazz);<z>
.createMarshaller();<z>
);<z>
return marshaller;<z>
) {<z>
(<z>
, ex);<z>
() {<z>
== Boolean.TRUE &&<z>
)) {<z>
throw new IllegalArgumentException(<z>
);<z>
(URI uri) throws MalformedURLException {<z>
, "URI must not be null");<z>
uri = uri;<z>
.url = uri.toURL();<z>
newValue) {<z>
if (newValue instanceof BeanDefinition) {<z>
(BeanDefinition) newValue);<z>
(this, property, newValue);<z>
getMessageSource() throws IllegalStateException {<z>
) {<z>
+<z>
"call 'refresh' before accessing messages via the context: " + this);<z>
.messageSource;<z>
Exception {<z>
);<z>
holder != null) {<z>
holder.getSession();<z>
);<z>
, this.clientInboundChannel);<z>
(holder != null) {<z>
);<z>
checkSessions();<z>
putFrame() {<z>
final int numLocal = currentFrame[1];<z>
[2];<z>
() < Opcodes.V1_6) {<z>
0]).putShort(numLocal);<z>
(3, 3 + numLocal);<z>
numStack);<z>
, 3 + numLocal + numStack);<z>
final int offsetDelta =<z>
stackMapTableNumberOfEntries == 0<z>
currentFrame[0]<z>
0] - previousFrame[0] - 1;<z>
int previousNumlocal = previousFrame[1];<z>
int numLocalDelta = numLocal - previousNumlocal;<z>
Frame.FULL_FRAME;<z>
) {<z>
(numLocalDelta) {<z>
:<z>
:<z>
1:<z>
CHOP_FRAME;<z>
case 0:<z>
;<z>
case 1:<z>
2:<z>
3:<z>
Frame.APPEND_FRAME;<z>
== 1) {<z>
< 63<z>
SAME_LOCALS_1_STACK_ITEM_FRAME<z>
SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;<z>
{<z>
3;<z>
i++) {<z>
previousFrame[frameIndex]) {<z>
Frame.FULL_FRAME;<z>
frameIndex++;<z>
) {<z>
:<z>
);<z>
SAME_LOCALS_1_STACK_ITEM_FRAME:<z>
SAME_LOCALS_1_STACK_ITEM_FRAME + offsetDelta);<z>
3 + numLocal, 4 + numLocal);<z>
SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:<z>
Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)<z>
(offsetDelta);<z>
, 4 + numLocal);<z>
.SAME_FRAME_EXTENDED:<z>
Frame.SAME_FRAME_EXTENDED).putShort(offsetDelta);<z>
CHOP_FRAME:<z>
putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta)<z>
putShort(offsetDelta);<z>
APPEND_FRAME:<z>
)<z>
putShort(offsetDelta);<z>
3 + numLocal);<z>
.FULL_FRAME:<z>
);<z>
, 3 + numLocal);<z>
.putShort(numStack);<z>
+ numLocal, 3 + numLocal + numStack);<z>
, final int bytecodeOffset) {<z>
value, bytecodeOffset);<z>
(hashCode);<z>
null) {<z>
.UNINITIALIZED_TYPE_TAG<z>
entry.hashCode == hashCode<z>
== bytecodeOffset<z>
)) {<z>
entry.index;<z>
entry = entry.next;<z>
return addTypeInternal(<z>
, value, bytecodeOffset, hashCode));<z>
MessageHandlerMethodFactory getMessageHandlerMethodFactory() {<z>
== null) {<z>
= createDefaultJmsHandlerMethodFactory();<z>
messageHandlerMethodFactory;<z>
Nullable MultiValueMap<String, String> params) {<z>
null) {<z>
forEach((key, values) -> {<z>
{<z>
(key, value);<z>
;<z>
this;<z>
,<z>
TypeMismatchException {<z>
,<z>
;<z>
, @Nullable ServerHttpRequest request,<z>
) {<z>
(delegate);<z>
this.request = request;<z>
response = response;<z>
principalMono = principalMono;<z>
{<z>
) {<z>
;<z>
) {<z>
.id().asShortText() +<z>
"-" + logPrefixIndex.incrementAndGet();<z>
null;<z>
protected Object lookupHandler(<z>
HttpServletRequest request) throws Exception {<z>
(lookupPath, request);<z>
{<z>
handler;<z>
null;<z>
pathPatternHandlerMap.keySet()) {<z>
)) {<z>
;<z>
);<z>
matches == null) {<z>
;<z>
1) {<z>
.sort(PathPattern.SPECIFICITY_COMPARATOR);<z>
()) {<z>
("Matching patterns " + matches);<z>
.get(0);<z>
.pathPatternHandlerMap.get(pattern);<z>
handler instanceof String handlerName) {<z>
obtainApplicationContext().getBean(handlerName);<z>
handler, request);<z>
(path.pathWithinApplication());<z>
);<z>
(ServerHttpRequest request) {<z>
(getMethods().isEmpty()) {<z>
;<z>
);<z>
null ? matchRequestMethod(expectedMethod) : null;<z>
) {<z>
getReference(key, Restructure.WHEN_NECESSARY);<z>
.get() : null);<z>
;<z>
clazz, HttpInputMessage inputMessage) throws IOException {<z>
).getContentLength();<z>
=<z>
contentLength : StreamUtils.BUFFER_SIZE);<z>
getBody(), bos);<z>
.toByteArray();<z>
{<z>
list = StringUtils.commaDelimitedListToStringArray(commaSeparatedList);<z>
i < list.length; i++) {<z>
i].toUpperCase();<z>
+ i);<z>
return value;<z>
) {<z>
writeHandler, "'writeHandler' is required");<z>
(new IllegalStateException("Not available with custom write handler."));<z>
= writeHandler;<z>
() {<z>
transaction != null) {<z>
.rollbackOnly = true;<z>
clazz, @Nullable ClassLoader classLoader) {<z>
if (classLoader == null) {<z>
return true;<z>
) == classLoader) {<z>
return true;<z>
(SecurityException ex) {<z>
;<z>
URL determinePersistenceUnitRootUrl(Resource resource) throws IOException {<z>
originalURL = resource.getURL();<z>
(ResourceUtils.isJarURL(originalURL)) {<z>
originalURL);<z>
.toExternalForm();<z>
{<z>
isInfoEnabled()) {<z>
resource.getFilename() +<z>
);<z>
;<z>
())) {<z>
) {<z>
+<z>
;<z>
null;<z>
);<z>
)) {<z>
.length() - 1);<z>
URL(persistenceUnitRoot);<z>
> beanType) {<z>
null ||<z>
!ObjectUtils.isEmpty(BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<z>
, beanType, false, false)));<z>
TransactionSystemException {<z>
()) {<z>
+ "]");<z>
);<z>
ex) {<z>
TransactionSystemException(<z>
"]", ex);<z>
private String resolveExpression(A annotation) {<z>
attributeName : EXPRESSION_ATTRIBUTES) {<z>
AnnotationUtils.getValue(annotation, attributeName);<z>
(val instanceof String str) {<z>
{<z>
str;<z>
new IllegalStateException("Failed to resolve expression: " + annotation);<z>
getRunnableToSchedule(ScheduledExecutorTask task) {<z>
this.continueScheduledExecutionAfterException ?<z>
, TaskUtils.LOG_AND_SUPPRESS_ERROR_HANDLER) :<z>
), TaskUtils.LOG_AND_PROPAGATE_ERROR_HANDLER));<z>
) {<z>
cstruct.isAccessible();<z>
(!flag) {<z>
;<z>
result = cstruct.newInstance(args);<z>
result;<z>
) {<z>
);<z>
e) {<z>
;<z>
{<z>
e.getTargetException());<z>
{<z>
cstruct.setAccessible(flag);<z>
, Locale locale) throws ParseException {<z>
charAt(0))) {<z>
text));<z>
.parse(text);<z>
) {<z>
.outputMessage = new ServletServerHttpResponse(response);<z>
this.deferredResult = deferredResult;<z>
= context.messageConverters();<z>
String viewName, AbstractUrlBasedView view) {<z>
getApplicationContext();<z>
null) {<z>
);<z>
) {<z>
return (View) initialized;<z>
view;<z>
public String toString() {<z>
"ReactorClientHttpResponse{" +<z>
.uri() + "]," +<z>
+ getRawStatusCode() + '}';<z>
HttpServletRequest request) {<z>
request);<z>
LocaleContextResolver) {<z>
;<z>
{<z>
getTimeZone();<z>
;<z>
void invalidate() {<z>
();<z>
this.invalid = true;<z>
;<z>
content) {<z>
= evaluateJsonPath(content);<z>
&& value instanceof List<?> list) {<z>
;<z>
isEmpty());<z>
configurers) {<z>
{<z>
collect(Collectors.toList());<z>
(CollectionUtils.isEmpty(candidates)) {<z>
null;<z>
.size() > 1) {<z>
IllegalStateException(candidates.size() + " implementations of " +<z>
;<z>
);<z>
;<z>
handler, HttpServletRequest request) {<z>
?<z>
new HandlerExecutionChain(handler));<z>
adaptedInterceptors) {<z>
interceptor instanceof MappedInterceptor mappedInterceptor) {<z>
matches(request)) {<z>
.getInterceptor());<z>
chain.addInterceptor(interceptor);<z>
chain;<z>
) {<z>
this.contextObjects)) {<z>
;<z>
();<z>
propertyName) {<z>
);<z>
) {<z>
;<z>
getPropertyValue(propertyName);<z>
true;<z>
) {<z>
;<z>
public static ResultMatcher redirectedUrlPattern(String urlPattern) {<z>
result -> {<z>
"' is not an Ant-style path pattern",<z>
.isPattern(urlPattern));<z>
);<z>
+ urlPattern + "'",<z>
urlPattern, url)));<z>
void setPatternParser(PathPatternParser patternParser) {<z>
(),<z>
);<z>
setPatternParser(patternParser);<z>
)<z>
{<z>
action);<z>
remove() {<z>
) {<z>
("No current Header in iterator");<z>
(this.currentName, 0);<z>
) {<z>
);<z>
removeHeader(index);<z>
,<z>
<ServerResponse> handlerFunction) {<z>
(predicate), handlerFunction);<z>
) throws MailParseException {<z>
cc);<z>
) {<z>
);<z>
> checkNotModified(Instant lastModified, String etag) {<z>
, "LastModified must not be null");<z>
.notNull(etag, "Etag must not be null");<z>
(), lastModified, etag);<z>
String> encoder) {<z>
());<z>
.pathComponents) {<z>
(uriVariables, encoder));<z>
return new PathComponentComposite(expandedComponents);<z>
String getMultipartContentType(String paramOrFileName) {<z>
paramOrFileName);<z>
.getContentType() : null);<z>
) {<z>
"Could not access multipart servlet request", ex);<z>
protected void recoverAfterListenerSetupFailure() {<z>
.recovering = true;<z>
);<z>
);<z>
= false;<z>
= false;<z>
int paramIndex, int sqlType,<z>
scale, @Nullable Object inValue) throws SQLException {<z>
typeNameToUse = typeName;<z>
= sqlType;<z>
inValue;<z>
(inValue instanceof SqlParameterValue parameterValue) {<z>
()) {<z>
+ paramIndex +<z>
());<z>
) {<z>
);<z>
(parameterValue.getTypeName() != null) {<z>
typeNameToUse = parameterValue.getTypeName();<z>
getValue();<z>
()) {<z>
paramIndex +<z>
+<z>
+<z>
(sqlTypeToUse)));<z>
inValueToUse == null) {<z>
paramIndex, sqlTypeToUse, typeNameToUse);<z>
inValueToUse);<z>
) {<z>
();<z>
);<z>
.processor.process(corsConfiguration, exchange);<z>
)) {<z>
);<z>
;<z>
{<z>
{<z>
close();<z>
IOException ignore) {<z>
supportsParameter(MethodParameter param) {<z>
checkParameterTypeNoReactiveWrapper(param, type -><z>
class.isAssignableFrom(type) ||<z>
).length == 0));<z>
<?> type) {<z>
);<z>
(Throwable ex) {<z>
null;<z>
(HttpServletRequest request) {<z>
();<z>
= getMatchingPatterns(path);<z>
matches) : null);<z>
boolean nullSafeNavigation) {<z>
Token t = peekToken();<z>
)) {<z>
;<z>
.state(t != null, "No token");<z>
);<z>
state(expr != null, "No node");<z>
;<z>
, expr));<z>
true;<z>
invocation) throws Throwable {<z>
invocation);<z>
{<z>
invokeUnderTrace(invocation, logger);<z>
);<z>
HttpServletRequest servletRequest,<z>
servletResponse,<z>
Object handler) throws Exception {<z>
WebAsyncManager asyncManager = getWebAsyncManager(servletRequest, servletResponse);<z>
servletRequest);<z>
;<z>
(asyncManager.hasConcurrentResult()) {<z>
);<z>
) handler;<z>
handlerFunction.handle(serverRequest);<z>
(serverResponse != null) {<z>
ServerRequestContext(serverRequest));<z>
return null;<z>
DefaultDataBuffer write(byte b) {<z>
;<z>
int pos = this.writePosition;<z>
;<z>
1;<z>
;<z>
Object convertToInternal(<z>
conversionHint) {<z>
;<z>
<T> valueLoader) {<z>
call();<z>
(Exception ex) {<z>
, valueLoader, ex);<z>
HttpHeaders getHeaders() {<z>
(this.headers == null) {<z>
= new HttpHeaders();<z>
) {<z>
= (String) names.nextElement();<z>
.getHeaders(headerName);<z>
headerValues.hasMoreElements();) {<z>
.nextElement();<z>
.add(headerName, headerValue);<z>
.getContentType();<z>
== null) {<z>
requestContentType = this.servletRequest.getContentType();<z>
StringUtils.hasLength(requestContentType)) {<z>
parseMediaType(requestContentType);<z>
.setContentType(contentType);<z>
.getCharset() == null) {<z>
.getCharacterEncoding();<z>
(requestEncoding)) {<z>
requestEncoding);<z>
();<z>
contentType.getParameters());<z>
.toString());<z>
, params);<z>
.setContentType(mediaType);<z>
(InvalidMediaTypeException ex) {<z>
getContentLength() < 0) {<z>
= this.servletRequest.getContentLength();<z>
-1) {<z>
.setContentLength(requestContentLength);<z>
;<z>
) {<z>
;<z>
metadataMimeType = mimeType;<z>
;<z>
Builder setFooBytes(<z>
value) {<z>
value == null) {<z>
;<z>
;<z>
;<z>
;<z>
return this;<z>
?> returnType) {<z>
) {<z>
{<z>
task.call();<z>
Throwable ex) {<z>
);<z>
executor);<z>
class.isAssignableFrom(returnType)) {<z>
;<z>
class.isAssignableFrom(returnType)) {<z>
task);<z>
{<z>
);<z>
return null;<z>
new IllegalArgumentException(<z>
"Invalid return type for async method (only Future and void supported): " + returnType);<z>
int compareMatchingMediaTypes(ProducesRequestCondition condition1, int index1,<z>
) {<z>
;<z>
!= index2) {<z>
index2 - index1;<z>
1) {<z>
().get(index1);<z>
);<z>
expr2);<z>
compareTo(expr2.getMediaType()));<z>
result;<z>
@Nullable Object conversionHint) {<z>
canConvertTo(payload, headers)) {<z>
;<z>
, conversionHint);<z>
(payloadToUse == null) {<z>
;<z>
mimeType = getDefaultContentType(payloadToUse);<z>
!= null) {<z>
class);<z>
) {<z>
(mimeType != null) {<z>
CONTENT_TYPE, mimeType);<z>
(payloadToUse, accessor.getMessageHeaders());<z>
> builder = MessageBuilder.withPayload(payloadToUse);<z>
{<z>
;<z>
) {<z>
.setHeaderIfAbsent(MessageHeaders.CONTENT_TYPE, mimeType);<z>
.build();<z>
() {<z>
) {<z>
this.responseLock) {<z>
cancelHeartbeat();<z>
{<z>
.config.getHeartbeatTime());<z>
);<z>
heartbeatTask, time);<z>
isTraceEnabled()) {<z>
());<z>
message, String sourceDestination) {<z>
message.getHeaders();<z>
sessionId = SimpMessageHeaderAccessor.getSessionId(headers);<z>
sessionId == null) {<z>
+ message);<z>
null;<z>
;<z>
sourceDestination.substring(prefixEnd);<z>
{<z>
;<z>
SimpMessageHeaderAccessor.getUser(headers);<z>
null);<z>
("%2F"), "Invalid sequence \"%2F\" in user name: " + user);<z>
);<z>
, actualDestination, sourceDestination, sessionIds, user);<z>
urlPathHelper,<z>
, boolean useTrailingSlashMatch) {<z>
, urlPathHelper, pathMatcher, false, useTrailingSlashMatch);<z>
, final Object... args) {<z>
= method -> {<z>
;<z>
;<z>
&& argLength == args.length);<z>
controllerType, selector);<z>
1) {<z>
().next();<z>
size() > 1) {<z>
String.format(<z>
), methods));<z>
methodName + "' with " + args.length +<z>
" arguments found in controller " + controllerType.getName());<z>
String viewName, Exception ex) {<z>
= new ModelAndView(viewName);<z>
null) {<z>
;<z>
;<z>
{<z>
public String removeSemicolonContent(String requestUri) {<z>
;<z>
) {<z>
SendToUser.class);<z>
(), SendTo.class);<z>
(m2.value()))) {<z>
m2);<z>
), SendToUser.class);<z>
.class);<z>
.value()))) {<z>
;<z>
!= null || m2 != null ?<z>
, c2));<z>
> codec) {<z>
(tcpClient, "TcpClient is required");<z>
codec, "ReactorNettyCodec is required");<z>
.tcpClient = tcpClient;<z>
codec = codec;<z>
this.channelGroup = null;<z>
;<z>
null;<z>
int getFirstRootAttributeIndex(Collection<Method> aliases) {<z>
rootAttributes = this.root.getAttributes();<z>
{<z>
(i))) {<z>
;<z>
1;<z>
, Object suspendedResources) {<z>
resourcesHolder = (SuspendedResourcesHolder) suspendedResources;<z>
bindResource(<z>
, resourcesHolder.getEntityManagerHolder());<z>
) {<z>
resourcesHolder.getConnectionHolder());<z>
JspException {<z>
{<z>
().markAsBlockTag();<z>
.append(">");<z>
valueLoader) {<z>
T>(), valueLoader);<z>
ex) {<z>
ex.getCause());<z>
) {<z>
();<z>
HibernateException ex) {<z>
(ex);<z>
(PersistenceException ex) {<z>
{<z>
());<z>
throw ex;<z>
(String... locations) throws BeanDefinitionStoreException {<z>
"Location array must not be null");<z>
= 0;<z>
String location : locations) {<z>
);<z>
;<z>
ParserContext context) {<z>
.extractSource(element);<z>
context, source);<z>
null, context, source);<z>
, context, source);<z>
source);<z>
(resourceHandlerName == null) {<z>
;<z>
);<z>
= element.getAttribute("mapping");<z>
resourceRequestPath)) {<z>
;<z>
;<z>
.put(resourceRequestPath, resourceHandlerName);<z>
(SimpleUrlHandlerMapping.class);<z>
);<z>
handlerMappingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
).add("urlMap", urlMap);<z>
pathMatcherRef).add("urlPathHelper", pathHelperRef);<z>
"order");<z>
1;<z>
;<z>
.registerCorsConfigurations(null, context, source);<z>
;<z>
;<z>
).registerBeanDefinition(beanName, handlerMappingDef);<z>
handlerMappingDef, beanName));<z>
(context, source);<z>
;<z>
psc, PreparedStatementCallback<T> action)<z>
DataAccessException {<z>
(psc, action, true);<z>
@Nullable Object cacheValue) {<z>
== Optional.class &&<z>
)) {<z>
Optional.ofNullable(cacheValue);<z>
return cacheValue;<z>
) throws JMSException {<z>
Session session : this.sessions) {<z>
);<z>
ex) {<z>
ex) {<z>
this.connectionFactory != null) {<z>
);<z>
, this.connectionFactory);<z>
ds != null) {<z>
if (TransactionSynchronizationManager.hasResource(ds)) {<z>
("getTargetDataSource");<z>
ds);<z>
) {<z>
;<z>
(Throwable ex2) {<z>
{<z>
("No working getDataSource method found on ConnectionFactory: " + ex2);<z>
;<z>
protected void handleListenerException(Throwable ex) {<z>
MessageRejectedWhileStoppingException) {<z>
instanceof JMSException) {<z>
;<z>
{<z>
);<z>
("Listener exception after container shutdown", ex);<z>
) {<z>
(getSingletonMutex()) {<z>
;<z>
factoryBeanObjectCache.remove(beanName);<z>
getEndpointId(JmsListener jmsListener) {<z>
hasText(jmsListener.id())) {<z>
());<z>
);<z>
getAndIncrement();<z>
Number asNumber(String code) throws ConstantException {<z>
(code);<z>
(!(obj instanceof Number)) {<z>
, code, "not a Number");<z>
return (Number) obj;<z>
?> clazz, @Nullable MediaType mediaType) {<z>
clazz) : clazz);<z>
(mediaType);<z>
Exception ex) {<z>
;<z>
? extends DataBuffer> body) {<z>
Mono) {<z>
Mono<? extends DataBuffer>) body)<z>
buffer -> {<z>
!= null) {<z>
readableByteCount());<z>
);<z>
0);<z>
then();<z>
body)<z>
(DataBufferUtils::release)<z>
);<z>
<Throwable> predicate,<z>
ServerRequest, ServerResponse> responseProvider) {<z>
);<z>
responseProvider, "ResponseProvider must not be null");<z>
);<z>
;<z>
JoinPoint jp, @Nullable JoinPointMatch jpMatch,<z>
, @Nullable Throwable ex) {<z>
();<z>
;<z>
= 0;<z>
1) {<z>
jp;<z>
;<z>
) {<z>
] = jp.getStaticPart();<z>
;<z>
.argumentBindings)) {<z>
(jpMatch != null) {<z>
] parameterBindings = jpMatch.getParameterBindings();<z>
{<z>
.getName();<z>
);<z>
);<z>
++;<z>
if (this.returningName != null) {<z>
);<z>
= returnValue;<z>
;<z>
if (this.throwingName != null) {<z>
argumentBindings.get(this.throwingName);<z>
ex;<z>
numBound++;<z>
(numBound != this.parameterTypes.length) {<z>
this.parameterTypes.length +<z>
+ " (JoinPointMatch " +<z>
" bound in invocation)");<z>
;<z>
Nullable String value) {<z>
== null) {<z>
;<z>
length();<z>
- 1) == '"') {<z>
;<z>
end--;<z>
) {<z>
value.charAt(i);<z>
|| c == 0x5c || c == 0x7f) {<z>
(<z>
"RFC2616 cookie value cannot have '" + c + "'");<z>
) {<z>
(<z>
"RFC2616 cookie value can only have US-ASCII chars: 0x" + Integer.toHexString(c));<z>
) {<z>
new ArrayList<>();<z>
= this.destinationLookup.get(lookupDestination);<z>
(mappingsByUrl != null) {<z>
addMatchesToCollection(mappingsByUrl, message, matches);<z>
matches.isEmpty()) {<z>
handlerMethods.keySet();<z>
, matches);<z>
isEmpty()) {<z>
.keySet(), lookupDestination, message);<z>
= new MatchComparator(getMappingComparator(message));<z>
(comparator);<z>
(logger.isTraceEnabled()) {<z>
;<z>
= matches.get(0);<z>
> 1) {<z>
secondBestMatch = matches.get(1);<z>
) == 0) {<z>
getMethod();<z>
();<z>
IllegalStateException("Ambiguous handler methods mapped for destination '" +<z>
+ m2 + "}");<z>
handlerMethod, lookupDestination, message);<z>
Nullable String filename,<z>
Nullable Long size, @Nullable ZonedDateTime creationDate,<z>
, @Nullable ZonedDateTime readDate) {<z>
.type = type;<z>
;<z>
;<z>
;<z>
this.size = size;<z>
creationDate;<z>
modificationDate = modificationDate;<z>
= readDate;<z>
Exception {<z>
.notNull(this.applicationContext, "ApplicationContext is required");<z>
this.messageReaders)) {<z>
= ServerCodecConfigurer.create();<z>
= codecConfigurer.getReaders();<z>
== null) {<z>
argumentResolverConfigurer = new ArgumentResolverConfigurer();<z>
(this.reactiveAdapterRegistry == null) {<z>
= ReactiveAdapterRegistry.getSharedInstance();<z>
.methodResolver = new ControllerMethodResolver(this.argumentResolverConfigurer,<z>
.messageReaders);<z>
);<z>
(Locale locale) {<z>
= this.cachedMergedProperties.get(locale);<z>
!= null) {<z>
mergedHolder;<z>
mergedProps = newProperties();<z>
-1;<z>
StringUtils.toStringArray(getBasenameSet());<z>
; i--) {<z>
calculateAllFilenames(basenames[i], locale);<z>
--) {<z>
String filename = filenames.get(j);<z>
);<z>
!= null) {<z>
.getProperties());<z>
getFileTimestamp() > latestTimestamp) {<z>
latestTimestamp = propHolder.getFileTimestamp();<z>
(mergedProps, latestTimestamp);<z>
mergedHolder);<z>
if (existing != null) {<z>
existing;<z>
return mergedHolder;<z>
target, String objectName,<z>
{<z>
);<z>
target;<z>
.autoGrowNestedPaths = autoGrowNestedPaths;<z>
this.autoGrowCollectionLimit = autoGrowCollectionLimit;<z>
final ModuleVisitor visitModule(<z>
) {<z>
return moduleWriter =<z>
new ModuleWriter(<z>
symbolTable.addConstantModule(name).index,<z>
addConstantUtf8(version));<z>
isNumber() {<z>
new AbstractJsonPathRequestMatcher() {<z>
throws IOException, ParseException {<z>
assertValueIsNumber(request.getBodyAsString());<z>
enumValues, String constant) {<z>
enumValues) {<z>
.equalsIgnoreCase(constant)) {<z>
return candidate;<z>
("Constant [" + constant + "] does not exist in enum type " +<z>
.getComponentType().getName());<z>
{<z>
String name = info.name;<z>
{<z>
= parameter.getParameterName();<z>
{<z>
IllegalArgumentException(<z>
.getNestedParameterType().getName() +<z>
"] not specified, and parameter name information not found in class file either.");<z>
new NamedValueInfo(name, info.required,<z>
;<z>
beanFactory)<z>
throws BeansException {<z>
beanName);<z>
SpelNodeImpl operand) {<z>
.getValue(state, Boolean.class);<z>
;<z>
return value;<z>
{<z>
getStartPosition());<z>
;<z>
) {<z>
null);<z>
.load_this();<z>
(BIND_CALLBACKS);<z>
;<z>
length);<z>
);<z>
callbackTypes.length; i++) {<z>
e.dup();<z>
e.push(i);<z>
;<z>
));<z>
e.aastore();<z>
();<z>
e.end_method();<z>
String getMessage() {<z>
StringBuilder sb = new StringBuilder("Parameter conditions ");<z>
= 0;<z>
[] conditions : this.paramConditions) {<z>
(i > 0) {<z>
append(" OR ");<z>
'"');<z>
));<z>
append('"');<z>
++;<z>
sb.append(" not met for actual request parameters: ");<z>
(this.actualParams));<z>
sb.toString();<z>
() {<z>
RequestAttributes attributes = requestAttributesHolder.get();<z>
) {<z>
attributes = inheritableRequestAttributesHolder.get();<z>
;<z>
classes,<z>
<?>>> contextInitializerClasses,<z>
contextLoader) {<z>
, null);<z>
(Map<String, Object> flashAttributes) {<z>
"'flashAttributes' must not be empty");<z>
flashAttr);<z>
this;<z>
public InvocableHandlerMethod getRequestMappingMethod(HandlerMethod handlerMethod) {<z>
(handlerMethod);<z>
requestMappingResolvers);<z>
setReactiveAdapterRegistry(this.reactiveAdapterRegistry);<z>
;<z>
(int maxConcurrentConsumers) {<z>
(maxConcurrentConsumers > 0, "'maxConcurrentConsumers' value must be at least 1 (one)");<z>
lifecycleMonitor) {<z>
maxConcurrentConsumers, this.concurrentConsumers);<z>
StringBuilder sb, String inString, int i) {<z>
if (sb == null) {<z>
);<z>
inString, 0, i);<z>
sb;<z>
) {<z>
;<z>
executorInterceptors.clear();<z>
updateExecutorInterceptorsFor);<z>
{<z>
) {<z>
.constant;<z>
;<z>
();<z>
< childcount; c++) {<z>
++);<z>
;<z>
(keyChild instanceof PropertyOrFieldReference reference) {<z>
getName();<z>
);<z>
);<z>
returnValue.put(key, value);<z>
returnValue);<z>
void visitMethodInsn(<z>
{<z>
Opcodes.SOURCE_DEPRECATED : 0);<z>
opcode == Opcodes.INVOKEINTERFACE);<z>
,<z>
predicate,<z>
A> selector) {<z>
, selector);<z>
missing());<z>
protected Object[] getAdvicesAndAdvisorsForBean(<z>
, String beanName, @Nullable TargetSource targetSource) {<z>
isSupportedBeanName(beanClass, beanName) ?<z>
DO_NOT_PROXY);<z>
filterConfig) throws ServletException {<z>
filterConfig, "FilterConfig must not be null");<z>
filterConfig;<z>
;<z>
pvs.isEmpty()) {<z>
this);<z>
new ServletContextResourceLoader(filterConfig.getServletContext());<z>
= this.environment;<z>
if (env == null) {<z>
);<z>
resourceLoader, env));<z>
);<z>
bw.setPropertyValues(pvs, true);<z>
BeansException ex) {<z>
msg = "Failed to set bean properties on filter '" +<z>
ex.getMessage();<z>
msg, ex);<z>
, ex);<z>
);<z>
(logger.isDebugEnabled()) {<z>
.getFilterName() + "' configured for use");<z>
Object invoke(MethodInvocation mi) throws Throwable {<z>
instanceof ProxyMethodInvocation pmi)) {<z>
"MethodInvocation is not a Spring ProxyMethodInvocation: " + mi);<z>
, this.beanName);<z>
return super.invoke(mi);<z>
service(HttpServletRequest request, HttpServletResponse response)<z>
ServletException, IOException {<z>
!= null, "No HttpRequestHandler available");<z>
setLocale(request.getLocale());<z>
target.handleRequest(request, response);<z>
HttpRequestMethodNotSupportedException ex) {<z>
);<z>
) {<z>
(supportedMethods, ", "));<z>
);<z>
();<z>
) {<z>
"AnnotationMetadata must not be null");<z>
{<z>
) metadata).getIntrospectedClass());<z>
));<z>
metadata;<z>
Nullable String beanName,<z>
ctor, Object... args) {<z>
new UnsupportedOperationException("Method Injection not supported in SimpleInstantiationStrategy");<z>
SqlParameter findParameter(<z>
paramIndex) {<z>
if (declaredParams != null) {<z>
declaredParams) {<z>
equals(declaredParam.getName())) {<z>
declaredParam;<z>
declaredParams.size()) {<z>
paramIndex);<z>
() == null) {<z>
declaredParam;<z>
null;<z>
(ResolvableType actualType, ResolvableType elementType,<z>
ServerHttpResponse response) {<z>
getHints(actualType);<z>
throws ServletException {<z>
{<z>
.delegate == null) {<z>
this.targetBeanName == null) {<z>
.targetBeanName = getFilterName();<z>
);<z>
) {<z>
= initDelegate(wac);<z>
id, LocalSimpUser user) {<z>
;<z>
;<z>
this.id = id;<z>
;<z>
, Object> model, HttpServletRequest request)<z>
throws UnsupportedEncodingException {<z>
();<z>
url = getUrl();<z>
null, "'url' not set");<z>
("/")) {<z>
;<z>
;<z>
enc = this.encodingScheme;<z>
(enc == null) {<z>
);<z>
) {<z>
.DEFAULT_CHARACTER_ENCODING;<z>
) {<z>
request);<z>
, model, variables, enc);<z>
()) {<z>
, request);<z>
exposeModelAttributes) {<z>
model, enc);<z>
toString();<z>
<T> type) {<z>
, "No target Validator set");<z>
(T) this.targetValidator);<z>
catch (ValidationException ex) {<z>
) {<z>
.targetValidator;<z>
throw ex;<z>
public ServerResponse build(<z>
HttpServletResponse, ModelAndView> writeFunction) {<z>
this.cookies, writeFunction);<z>
value, String propertyName) throws TypeMismatchException {<z>
();<z>
getPropertyDescriptor(propertyName);<z>
(pd == null) {<z>
,<z>
propertyName + "' found");<z>
getTypeDescriptor(pd);<z>
) {<z>
new TypeDescriptor(property(pd)));<z>
td);<z>
] destination) {<z>
);<z>
length);<z>
this;<z>
databaseMetaData) throws SQLException {<z>
.supportsCatalogsInProcedureCalls());<z>
SQLException ex) {<z>
) {<z>
());<z>
;<z>
ex) {<z>
()) {<z>
ex.getMessage());<z>
databaseMetaData.storesUpperCaseIdentifiers());<z>
{<z>
) {<z>
.getMessage());<z>
storesLowerCaseIdentifiers());<z>
ex) {<z>
isWarnEnabled()) {<z>
"Error retrieving 'DatabaseMetaData.storesLowerCaseIdentifiers': " + ex.getMessage());<z>
) {<z>
T data = this.currentData;<z>
.currentData = null;<z>
null) {<z>
);<z>
Object managedResource, String managedResourceType)<z>
MBeanException, InstanceNotFoundException, InvalidTargetObjectTypeException {<z>
.getClassLoader();<z>
);<z>
handler) {<z>
pathWithinMapping, request);<z>
;<z>
);<z>
;<z>
ConnectionFactory connectionFactory) {<z>
) {<z>
getBindMarkers(connectionFactory);<z>
bindMarkersFactory != null) {<z>
bindMarkersFactory;<z>
format(<z>
);<z>
Throwable ex) {<z>
{<z>
.trace(<z>
getLogPrefix() + "current \"write\" Publisher failed: " + ex);<z>
;<z>
cancel();<z>
ex);<z>
String configLocation) {<z>
{<z>
new UnsupportedOperationException(<z>
"Do you still have an 'contextConfigLocations' init-param set?");<z>
String debug) {<z>
null) {<z>
, debug);<z>
, HandlerStrategies strategies) {<z>
= toWebHandler(routerFunction, strategies);<z>
.webHandler(webHandler)<z>
(strategies.webFilters()))<z>
strategies.exceptionHandlers()))<z>
))<z>
);<z>
> elementClass) {<z>
(elementClass, "Element class must not be null");<z>
!elementClass.isInterface(), "Element class must not be an interface type");<z>
.getModifiers()), "Element class cannot be an abstract class");<z>
elementClass;<z>
) {<z>
condition = getActivePatternsCondition();<z>
PathPatternsRequestCondition ?<z>
.getPatternValues() :<z>
);<z>
int maxHeadersSize, Charset headersCharset) {<z>
sink = sink;<z>
= boundary;<z>
;<z>
headersCharset = headersCharset;<z>
AtomicReference<>(new PreambleState());<z>
() {<z>
HttpSession session = getSession(true);<z>
"No HttpSession");<z>
session;<z>
{<z>
();<z>
if (defaultDestination != null) {<z>
);<z>
(), message);<z>
) {<z>
brokerRelayRegistration != null) {<z>
brokerRelayRegistration.getMessageHandler(brokerChannel);<z>
(this.preservePublishOrder);<z>
return relay;<z>
;<z>
handleMissingValueAfterConversion(<z>
parameter, NativeWebRequest request) throws Exception {<z>
, parameter, true);<z>
ResolvableMethod build() {<z>
.objectClass, this::isMatch);<z>
;<z>
+ this + formatMethods(methods));<z>
.next());<z>
{<z>
switch (name) {<z>
:<z>
return this.namespacesFeature;<z>
:<z>
.namespacePrefixesFeature;<z>
:<z>
!= null) {<z>
;<z>
;<z>
return super.getFeature(name);<z>
String, Lifecycle> getLifecycleBeans() {<z>
ConfigurableListableBeanFactory beanFactory = getBeanFactory();<z>
);<z>
);<z>
{<z>
String beanNameToRegister = BeanFactoryUtils.transformedBeanName(beanName);<z>
);<z>
BeanFactory.FACTORY_BEAN_PREFIX + beanName : beanName);<z>
(beanFactory.containsSingleton(beanNameToRegister) &&<z>
, beanFactory))) ||<z>
beanNameToCheck, beanFactory)) {<z>
= beanFactory.getBean(beanNameToCheck);<z>
) {<z>
put(beanNameToRegister, (Lifecycle) bean);<z>
beans;<z>
?> eventClass) {<z>
)) {<z>
true;<z>
{<z>
;<z>
moduleSeparatorIndex = classCastMessage.indexOf('/');<z>
(), moduleSeparatorIndex + 1)) {<z>
;<z>
false;<z>
{<z>
)) {<z>
char stackTop = stackDescriptor.charAt(0);<z>
== 'C') {<z>
{<z>
);<z>
{<z>
I2F);<z>
else if (targetDescriptor == 'J') {<z>
(I2L);<z>
if (targetDescriptor == 'I') {<z>
"Cannot get from " + stackTop + " to " + targetDescriptor);<z>
'J') {<z>
if (targetDescriptor == 'D') {<z>
visitInsn(L2D);<z>
== 'F') {<z>
;<z>
if (targetDescriptor == 'J') {<z>
(targetDescriptor == 'I') {<z>
);<z>
);<z>
(stackTop == 'F') {<z>
== 'D') {<z>
.visitInsn(F2D);<z>
== 'F') {<z>
(targetDescriptor == 'J') {<z>
F2L);<z>
(targetDescriptor == 'I') {<z>
mv.visitInsn(F2I);<z>
("Cannot get from " + stackTop + " to " + targetDescriptor);<z>
) {<z>
== 'D') {<z>
(targetDescriptor == 'F') {<z>
;<z>
) {<z>
visitInsn(D2L);<z>
== 'I') {<z>
D2I);<z>
);<z>
) {<z>
;<z>
.millis();<z>
);<z>
) {<z>
);<z>
{<z>
);<z>
(charset, "Charset must not be null");<z>
;<z>
offset;<z>
(this.byteBuffer.hasArray()) {<z>
();<z>
+ index;<z>
];<z>
= 0;<z>
this.byteBuffer.duplicate();<z>
index + length);<z>
(bytes, 0, length);<z>
offset, length, charset);<z>
IdleFileState(WritingFileState state) {<z>
headers = state.headers;<z>
.file = state.file;<z>
= state.channel;<z>
this.byteCount = state.byteCount;<z>
method, Class<?> targetClass) {<z>
mappedNames) {<z>
), mappedName)) {<z>
return true;<z>
;<z>
{<z>
builder.allowBlockingCallsInside(<z>
, "inspectClass");<z>
;<z>
.allowBlockingCallsInside(className, "doTask");<z>
"clear");<z>
, "restructure");<z>
Connection getConnectionFromDriver(Properties props) throws SQLException {<z>
();<z>
);<z>
notNull(driver, "Driver must not be null");<z>
isDebugEnabled()) {<z>
+ "]");<z>
, props);<z>
getRequiredLongParameter(ServletRequest request, String name)<z>
throws ServletRequestBindingException {<z>
.getParameter(name));<z>
createEntityManager() throws IllegalStateException {<z>
();<z>
String, Object> properties = getJpaPropertyMap();<z>
createEntityManager());<z>
?> clazz) {<z>
clazz, "Class must not be null");<z>
();<z>
String suffix : suffixes) {<z>
.hasText(suffix, "Resource suffix must not be empty");<z>
(clazz.getName()) + suffix;<z>
ClassPathResource(resourcePath);<z>
.exists()) {<z>
.CLASSPATH_URL_PREFIX + resourcePath;<z>
) {<z>
format("Detected default resource location \"%s\" for test class [%s]",<z>
));<z>
] {prefixedResourcePath};<z>
.isDebugEnabled()) {<z>
(String.format("Did not detect default resource location for test class [%s]: " +<z>
), classPathResource));<z>
) {<z>
("Could not detect default resource locations for test class [%s]: " +<z>
);<z>
EMPTY_STRING_ARRAY;<z>
executeInternal(HttpHeaders headers) throws IOException {<z>
if (this.body != null) {<z>
);<z>
addHeaders(this.connection, headers);<z>
.connection.connect();<z>
;<z>
{<z>
SimpleClientHttpResponse(this.connection);<z>
) {<z>
insideVariableCapture) {<z>
;<z>
PathElement newPE = null;<z>
.separator();<z>
0) {<z>
pathElementStart == this.variableCaptureStart &&<z>
] == '}') {<z>
this.isCaptureTheRestVariable) {<z>
(<z>
(), separator);<z>
CaptureVariablePathElement(this.pathElementStart, getPathElementText(),<z>
(), separator);<z>
catch (PatternSyntaxException pse) {<z>
new PatternParseException(pse,<z>
pathElementStart) + pse.getIndex(),<z>
);<z>
.pathElementStart,<z>
;<z>
isCaptureTheRestVariable) {<z>
this.pathPatternData,<z>
CAPTURE_ALL_IS_STANDALONE_CONSTRUCT);<z>
new RegexPathElement(this.pathElementStart,<z>
.isCaseSensitive(),<z>
.pathPatternData, separator);<z>
: newRegexSection.getVariableNames()) {<z>
(this.pathElementStart, variableName);<z>
newRegexSection;<z>
wildcard) {<z>
) {<z>
, separator);<z>
getPathElementText(),<z>
);<z>
if (this.singleCharWildcardCount != 0) {<z>
,<z>
isCaseSensitive(), separator);<z>
.pathElementStart, getPathElementText(),<z>
.parser.isCaseSensitive(), separator);<z>
newPE;<z>
static AnnotationAttributes getMergedAnnotationAttributes(<z>
, Class<? extends Annotation> annotationType) {<z>
mergedAnnotation = getAnnotations(element)<z>
;<z>
;<z>
encoding, Matcher<? super NodeList> matcher)<z>
throws Exception {<z>
);<z>
);<z>
);<z>
getRequiredBooleanParameters(ServletRequest request, String name)<z>
ServletRequestBindingException {<z>
.getParameterValues(name));<z>
getDouble(int columnIndex) throws InvalidResultSetAccessException {<z>
);<z>
catch (SQLException se) {<z>
throw new InvalidResultSetAccessException(se);<z>
void extractMatchDetails(<z>
, String lookupPath, HttpServletRequest request) {<z>
PathPattern bestPattern;<z>
, String> uriVariables;<z>
isEmptyPathMapping()) {<z>
.getFirstPattern();<z>
);<z>
pathWithinApplication();<z>
condition.getFirstPattern();<z>
= bestPattern.matchAndExtract(path);<z>
notNull(result, () -><z>
" to match lookupPath " + path);<z>
uriVariables = result.getUriVariables();<z>
);<z>
(BEST_MATCHING_PATTERN_ATTRIBUTE, bestPattern.getPatternString());<z>
(URI_TEMPLATE_VARIABLES_ATTRIBUTE, uriVariables);<z>
throws InterruptedException, ExecutionException, TimeoutException {<z>
curr;<z>
(this.triggerContextMonitor) {<z>
obtainCurrentFuture();<z>
, unit);<z>
) {<z>
"relayHost must not be empty");<z>
.relayHost = relayHost;<z>
;<z>
<T> rowMapper)<z>
throws DataAccessException {<z>
new MapSqlParameterSource(paramMap), rowMapper);<z>
void prepareMethodOverrides() throws BeanDefinitionValidationException {<z>
{<z>
).forEach(this::prepareMethodOverride);<z>
result) {<z>
StAXResult) {<z>
result).getXMLStreamWriter();<z>
(result instanceof StaxResult) {<z>
StaxResult) result).getXMLStreamWriter();<z>
"' is neither StaxResult nor StAXResult");<z>
String... pathSegments) {<z>
String pathSegment : pathSegments) {<z>
(pathSegment)) {<z>
.pathSegments.add(pathSegment);<z>
() throws ResourceException {<z>
) == null) {<z>
new IllegalArgumentException("Property 'resourceAdapter' is required");<z>
== null) {<z>
new IllegalArgumentException("Property 'messageEndpointFactory' is required");<z>
();<z>
(activationSpec == null) {<z>
new IllegalArgumentException("Property 'activationSpec' is required");<z>
null) {<z>
);<z>
getResourceAdapter() != getResourceAdapter()) {<z>
activationSpec +<z>
;<z>
setSecWebSocketExtensions(List<WebSocketExtension> extensions) {<z>
extensions.size());<z>
) {<z>
());<z>
(SEC_WEBSOCKET_EXTENSIONS, toCommaDelimitedString(result));<z>
) {<z>
;<z>
(this.code);<z>
) {<z>
:<z>
'E');<z>
formattedMessage.append(": ");<z>
(this.message, inserts));<z>
return formattedMessage.toString();<z>
{<z>
beanFactory != null, "BeanFactory is required");<z>
(dataSourceName, DataSource.class);<z>
ex) {<z>
throw new DataSourceLookupFailureException(<z>
+ "'", ex);<z>
Nullable int... columnTypes)<z>
SQLException {<z>
0;<z>
for (Object value : values) {<z>
;<z>
null || colIndex > columnTypes.length) {<z>
.TYPE_UNKNOWN, value);<z>
[colIndex - 1], value);<z>
protected boolean isEligibleForEtag(HttpServletRequest request, HttpServletResponse response,<z>
{<z>
(!response.isCommitted() &&<z>
< 300 &&<z>
) {<z>
;<z>
));<z>
false;<z>
(MergedContextConfiguration mergedConfig) {<z>
.hasClasses()) {<z>
.format(<z>
mergedConfig.getTestClass().getName(),<z>
());<z>
error(msg);<z>
;<z>
Nullable Object[] args)<z>
{<z>
{<z>
throw new BeanIsAbstractException(beanName);<z>
ApplicationContext parent) throws BeansException {<z>
(parent);<z>
= new StaticMessageSource();<z>
, this.staticMessageSource);<z>
) {<z>
{<z>
;<z>
return session;<z>
(int writePosition) {<z>
assertIndex(writePosition >= this.readPosition, "'writePosition' %d must be >= %d",<z>
;<z>
.capacity, "'writePosition' %d must be <= %d",<z>
capacity);<z>
.writePosition = writePosition;<z>
return this;<z>
) {<z>
();<z>
, candidateValue)) {<z>
return true;<z>
;<z>
actualValue != boundValue &&<z>
, candidateValue)) {<z>
true;<z>
) {<z>
actualValue;<z>
) {<z>
false;<z>
selected = false;<z>
candidateValue != null) {<z>
).isArray()) {<z>
(boundValue), candidateValue, bindStatus);<z>
collection) {<z>
);<z>
map) {<z>
(map, candidateValue, bindStatus);<z>
) {<z>
(), null);<z>
return selected;<z>
getJaxbContext(Class<?> clazz) {<z>
clazz, key -> {<z>
JAXBContext.newInstance(clazz);<z>
(JAXBException ex) {<z>
HttpMessageConversionException(<z>
, ex);<z>
;<z>
{<z>
= source.trim();<z>
{<z>
return null;<z>
);<z>
{<z>
Boolean.TRUE;<z>
(falseValues.contains(value)) {<z>
.FALSE;<z>
+ source + "'");<z>
) {<z>
int suffixPosition = 0;<z>
i++) {<z>
)) {<z>
false;<z>
suffixPosition != suffix.length()) {<z>
false;<z>
;<z>
) throws Exception {<z>
clazz = ClassUtils.getUserClass(o);<z>
(clazz);<z>
.getContentType(), marshaller);<z>
(o, result);<z>
ex) {<z>
throw ex;<z>
ex) {<z>
.getMessage(), ex);<z>
, String delimiter) {<z>
stream()<z>
)<z>
collect(Collectors.joining(delimiter));<z>
argName, String innerBeanName, BeanDefinition innerBd) {<z>
= null;<z>
, innerBd, this.beanDefinition);<z>
= innerBeanName;<z>
) {<z>
innerBeanName);<z>
actualInnerBeanName, this.beanName);<z>
[] dependsOn = mbd.getDependsOn();<z>
{<z>
) {<z>
dependsOnBean, actualInnerBeanName);<z>
(dependsOnBean);<z>
(actualInnerBeanName, mbd, null);<z>
{<z>
isSynthetic();<z>
, actualInnerBeanName, !synthetic);<z>
(innerBean instanceof NullBean) {<z>
;<z>
innerBean;<z>
(BeansException ex) {<z>
BeanCreationException(<z>
getResourceDescription(), this.beanName,<z>
+<z>
) + "] " : "") +<z>
;<z>
beanName) throws BeansException {<z>
beanName);<z>
= getMergedBeanDefinition(beanName);<z>
BeanWrapperImpl(existingBean);<z>
;<z>
, bw, bd.getPropertyValues());<z>
desc, String name) {<z>
{<z>
?> componentType = type.getComponentType();<z>
) {<z>
(componentType, 1);<z>
.getComponentType(), 0));<z>
array;<z>
componentType, 0);<z>
)) {<z>
null);<z>
);<z>
.class.isAssignableFrom(type)) {<z>
? desc.getMapKeyTypeDescriptor() : null);<z>
), 16);<z>
?> ctor = type.getDeclaredConstructor();<z>
ctor.getModifiers())) {<z>
"Auto-growing not allowed with private constructor: " + ctor);<z>
;<z>
{<z>
, this.nestedPath + name,<z>
, ex);<z>
public String toString() {<z>
result == null) {<z>
.result = buildString();<z>
.result;<z>
checkCompletingThread() {<z>
;<z>
) {<z>
completingThread = null;<z>
return check;<z>
{<z>
{<z>
null;<z>
||<z>
hasPlainJavaAnnotationsOnly(clazz)) {<z>
getDeclaredAnnotation(annotationType);<z>
) {<z>
;<z>
= clazz.getSuperclass();<z>
) {<z>
return null;<z>
annotationType);<z>
))<z>
withNonMergedAttributes()<z>
orElse(null);<z>
Class<?>[] paramTypes) {<z>
this.pointcutDeclarationScope = declarationScope;<z>
paramTypes.length) {<z>
throw new IllegalStateException(<z>
;<z>
pointcutParameterNames = paramNames;<z>
.pointcutParameterTypes = paramTypes;<z>
> delegate) {<z>
.notNull(delegate, "Delegate listener must not be null");<z>
= (ApplicationListener<ApplicationEvent>) delegate;<z>
(this.delegate);<z>
private void addMatchesToCollection(<z>
matches) {<z>
mappingsToCheck) {<z>
);<z>
) {<z>
);<z>
public ObjectError(<z>
arguments, @Nullable String defaultMessage) {<z>
arguments, defaultMessage);<z>
;<z>
objectName;<z>
expression, String message) {<z>
) {<z>
new IllegalArgumentException(message);<z>
byName) {<z>
byName) {<z>
schedulerType);<z>
.beanFactory instanceof ConfigurableBeanFactory) {<z>
this.beanFactory).registerDependentBean(<z>
beanName);<z>
;<z>
else if (beanFactory instanceof AutowireCapableBeanFactory) {<z>
).resolveNamedBean(schedulerType);<z>
beanName != null && beanFactory instanceof ConfigurableBeanFactory) {<z>
;<z>
);<z>
schedulerType);<z>
@Nullable MediaType mediaType) throws IOException {<z>
this.sseMessageConverters) {<z>
data.getClass(), mediaType)) {<z>
outputMessage);<z>
.flush();<z>
;<z>
(Connection con) {<z>
= con;<z>
while (conToUse instanceof ConnectionProxy) {<z>
) conToUse).getTargetConnection();<z>
conToUse;<z>
{<z>
.advice instanceof BeanFactoryAware) {<z>
);<z>
{<z>
:<z>
(source, sourceType, BYTE_ARRAY_TYPE));<z>
null) {<z>
);<z>
ByteBuffer.allocate(bytes.length);<z>
bytes);<z>
.rewind();<z>
(ParamsRequestCondition other, HttpServletRequest request) {<z>
.expressions.size();<z>
) {<z>
return result;<z>
this.expressions));<z>
MultipartCodecs encoder(Encoder<?> encoder) {<z>
));<z>
initTypedWriters();<z>
return this;<z>
,<z>
{<z>
springSynchronization);<z>
this.jtaTransaction = jtaUserTransaction;<z>
bytecodeOffset, final Label[] labels) {<z>
length) {<z>
();<z>
(labels[bytecodeOffset] == null) {<z>
labels[bytecodeOffset] = new Label();<z>
;<z>
> createMap() {<z>
;<z>
merge(result, map));<z>
;<z>
ServletContext servletContext) {<z>
(servletContext == null) {<z>
return null;<z>
);<z>
;<z>
{<z>
;<z>
+ "] is not compatible with [" + mediaType + "]";<z>
exchangeResult.assertWithDiagnostics(() -><z>
actual.isCompatibleWith(mediaType))));<z>
return this.responseSpec;<z>
) {<z>
== other) {<z>
return true;<z>
instanceof ConsumerCacheKey otherKey)) {<z>
return false;<z>
&&<z>
, otherKey.selector) &&<z>
) &&<z>
this.subscription, otherKey.subscription) &&<z>
otherKey.durable);<z>
long parseDateHeader(String name, String value) {<z>
{<z>
new SimpleDateFormat(dateFormat, Locale.US);<z>
.setTimeZone(GMT);<z>
.parse(value).getTime();<z>
{<z>
value + "' for '" + name + "' header");<z>
public MockHttpServletRequestBuilder pathInfo(@Nullable String pathInfo) {<z>
if (StringUtils.hasText(pathInfo)) {<z>
"/"), "Path info must start with a '/'");<z>
.pathInfo = pathInfo;<z>
return this;<z>
annotationType) {<z>
annotations = getDeclaredAnnotations(source, false);<z>
for (Annotation annotation : annotations) {<z>
{<z>
(A) annotation;<z>
;<z>
(List<ClientHttpRequestInterceptor> interceptors) {<z>
Assert.noNullElements(interceptors, "'interceptors' must not contain null elements");<z>
.interceptors != interceptors) {<z>
interceptors.clear();<z>
addAll(interceptors);<z>
;<z>
statusText,<z>
Charset charset) {<z>
);<z>
Node node, String desiredName) {<z>
, "Node must not be null");<z>
);<z>
nodeNameMatch(node, desiredName);<z>
boolean value) throws SAXNotRecognizedException, SAXNotSupportedException {<z>
"http://xml.org/sax/features/")) {<z>
if (value) {<z>
throw new SAXNotSupportedException(name);<z>
);<z>
MethodVisitor mv, CodeFlow cf) {<z>
CachedMethodExecutor executorToCheck = this.cachedExecutor;<z>
) {<z>
IllegalStateException("No applicable cached executor found: " + executorToCheck);<z>
get();<z>
= methodExecutor.getMethod();<z>
method.getModifiers());<z>
();<z>
= null;<z>
== null && !isStaticMethod) {<z>
loadTarget(mv);<z>
{<z>
);<z>
new Label();<z>
Label continueLabel = new Label();<z>
);<z>
);<z>
skipIfNull);<z>
mv.visitLabel(continueLabel);<z>
null && isStaticMethod) {<z>
POP);<z>
if (CodeFlow.isPrimitive(descriptor)) {<z>
, descriptor.charAt(0));<z>
;<z>
)) {<z>
;<z>
.getPublicDeclaringClass();<z>
(publicDeclaringClass != null, "No public declaring class");<z>
'.', '/');<z>
))) {<z>
insertCheckCast(mv, "L" + classDesc);<z>
this.children);<z>
? INVOKEINTERFACE : INVOKEVIRTUAL)),<z>
, CodeFlow.createSignatureDescriptor(method),<z>
.getDeclaringClass().isInterface());<z>
this.exitTypeDescriptor);<z>
.originalPrimitiveExitTypeDescriptor != null) {<z>
insertBoxIfNecessary(mv, this.originalPrimitiveExitTypeDescriptor);<z>
) {<z>
mv.visitLabel(skipIfNull);<z>
public int compareTo(MethodClassKey other) {<z>
other.method.getName());<z>
0) {<z>
());<z>
targetClass != null) {<z>
());<z>
;<z>
void handleMessageFromClient(WebSocketSession session,<z>
{<z>
byte[]>> messages;<z>
byteBuffer;<z>
) {<z>
));<z>
{<z>
).getPayload();<z>
.getId());<z>
null) {<z>
!session.isOpen()) {<z>
"Dropped inbound WebSocket message due to closed session");<z>
);<z>
messages = decoder.decode(byteBuffer);<z>
(messages.isEmpty()) {<z>
if (logger.isTraceEnabled()) {<z>
+<z>
getBufferSize() +<z>
);<z>
{<z>
(logger.isErrorEnabled()) {<z>
+<z>
, ex);<z>
ex, null);<z>
message : messages) {<z>
StompHeaderAccessor headerAccessor =<z>
message, StompHeaderAccessor.class);<z>
(headerAccessor != null, "No StompHeaderAccessor");<z>
);<z>
.STOMP.equals(command);<z>
boolean sent = false;<z>
.setSessionId(session.getId());<z>
);<z>
(session));<z>
{<z>
headerAccessor.setUserChangeCallback(user -> {<z>
.getPrincipal()) {<z>
, user);<z>
});<z>
, headerAccessor.getHeartbeat());<z>
{<z>
headerAccessor.setImmutable();<z>
isTraceEnabled()) {<z>
(message.getPayload()));<z>
(isConnect) {<z>
.incrementConnectCount();<z>
DISCONNECT.equals(command)) {<z>
;<z>
SimpAttributesContextHolder.setAttributesFromMessage(message);<z>
outputChannel.send(message);<z>
{<z>
!= null) {<z>
session);<z>
(isConnect) {<z>
;<z>
SUBSCRIBE.equals(command)) {<z>
;<z>
)) {<z>
message, user));<z>
resetAttributes();<z>
ex) {<z>
isDebugEnabled()) {<z>
getId(), ex);<z>
(logger.isErrorEnabled()) {<z>
isConnect || sent) {<z>
"Failed to send message to MessageChannel in session " + session.getId() +<z>
.getMessage());<z>
, message);<z>
column) throws InvalidResultSetAccessException {<z>
this.resultSetMetaData.getTableName(column);<z>
SQLException se) {<z>
se);<z>
{<z>
(!this.active) {<z>
return null;<z>
;<z>
;<z>
sessionList) {<z>
!sessionList.isEmpty()) {<z>
.removeFirst();<z>
) {<z>
{<z>
("Found cached JMS Session for mode " + mode + ": " +<z>
.getTargetSession() : session));<z>
targetSession = createSession(con, mode);<z>
isDebugEnabled()) {<z>
": " + targetSession);<z>
= getCachedSessionProxy(targetSession, sessionList);<z>
;<z>
int statusCode) {<z>
WebUtils.isIncludeRequest(request)) {<z>
.isDebugEnabled()) {<z>
statusCode);<z>
statusCode);<z>
ERROR_STATUS_CODE_ATTRIBUTE, statusCode);<z>
PropertyValue original, @Nullable Object newValue) {<z>
.notNull(original, "Original must not be null");<z>
= original.getName();<z>
this.value = newValue;<z>
.isOptional();<z>
original.conversionNecessary;<z>
original.resolvedTokens;<z>
(original);<z>
(original);<z>
ServerState serverState) {<z>
contention) {<z>
"noSubscribers":<z>
uniqueIdGenerator.incrementAndGet();<z>
case "sameDestination":<z>
];<z>
:<z>
= serverState.uniqueIdGenerator.getAndIncrement();<z>
length];<z>
);<z>
?> actualClass) {<z>
(Advisor advisor : advisors) {<z>
ia) {<z>
(actualClass)) {<z>
;<z>
return false;<z>
(@Nullable String userInfo) {<z>
;<z>
;<z>
this;<z>
static String formatValue(<z>
replaceNewlinesAndControlCharacters) {<z>
{<z>
;<z>
result;<z>
.nullSafeToString(value);<z>
(Throwable ex) {<z>
);<z>
-1) {<z>
" (truncated)..." : result);<z>
(replaceNewlinesAndControlCharacters) {<z>
).replaceAll("<EOL>");<z>
(result).replaceAll("?");<z>
) {<z>
+ result + "\"";<z>
;<z>
{<z>
String[] parameterNames = getParameterNames();<z>
if (parameterNames != null) {<z>
;<z>
: parameterNames) {<z>
= getValue(parameterName);<z>
(value instanceof SqlParameterValue) {<z>
();<z>
String typeName = getTypeName(parameterName);<z>
typeName == null) {<z>
(parameterName);<z>
sqlType != TYPE_UNKNOWN) {<z>
sqlType);<z>
null) {<z>
valueOf(sqlType);<z>
();<z>
value);<z>
(typeName != null) {<z>
);<z>
(entry);<z>
result.toString();<z>
.getSimpleName();<z>
replaceBooleanOperators(String pcExpr) {<z>
.replace(pcExpr," and "," && ");<z>
, " || ");<z>
);<z>
copyConfigurationFrom(ConfigurableBeanFactory otherFactory) {<z>
copyConfigurationFrom(otherFactory);<z>
otherAutowireFactory) {<z>
otherAutowireFactory.instantiationStrategy;<z>
;<z>
ignoredDependencyTypes);<z>
;<z>
> type, @Nullable MethodFilter filter) {<z>
null) {<z>
<>();<z>
) {<z>
filters.put(type, filter);<z>
filters.remove(type);<z>
line) {<z>
);<z>
.contains(END_COMMENT)) {<z>
line;<z>
;<z>
= line;<z>
) {<z>
, indexOfStartComment);<z>
currLine = line.substring(indexOfStartComment);<z>
= consume(currLine)) != null) {<z>
().startsWith(START_COMMENT)) {<z>
result + currLine;<z>
;<z>
, ServerHttpResponse response) {<z>
.forwardedHeaderTransformer != null) {<z>
= this.forwardedHeaderTransformer.apply(request);<z>
Throwable ex) {<z>
(logger.isDebugEnabled()) {<z>
;<z>
.setStatusCode(HttpStatus.BAD_REQUEST);<z>
.setComplete();<z>
request, response);<z>
, traceOn -><z>
) +<z>
));<z>
return getDelegate().handle(exchange)<z>
-> logResponse(exchange))<z>
exchange, ex))<z>
Mono.defer(response::setComplete));<z>
(<z>
, boolean newSynchronization,<z>
suspendedResources) {<z>
.transaction = transaction;<z>
;<z>
this.newSynchronization = newSynchronization;<z>
readOnly;<z>
this.debug = debug;<z>
this.suspendedResources = suspendedResources;<z>
) {<z>
= contextPath.length();<z>
) == '/') {<z>
"Invalid contextPath: '" + contextPath + "': " +<z>
);<z>
(contextPath)) {<z>
IllegalArgumentException("Invalid contextPath '" + contextPath + "': " +<z>
"'");<z>
charAt(length) != '/') {<z>
"Invalid contextPath '" + contextPath + "': " +<z>
+ fullPath + "'");<z>
throws SQLException {<z>
.inParameterMapper != null) {<z>
con);<z>
== null) {<z>
InvalidDataAccessApiUsageException(<z>
;<z>
CallableStatement cs = null;<z>
!updatableResults) {<z>
(callString);<z>
, resultSetType,<z>
CONCUR_READ_ONLY);<z>
sqlColIndx = 1;<z>
: declaredParameters) {<z>
!declaredParam.isResultsParameter()) {<z>
get(declaredParam.getName());<z>
declaredParam instanceof ResultSetSupportingSqlParameter) {<z>
if (declaredParam instanceof SqlOutParameter) {<z>
getTypeName() != null) {<z>
.getTypeName());<z>
declaredParam.getScale() != null) {<z>
.getScale());<z>
);<z>
(declaredParam.isInputValueProvided()) {<z>
sqlColIndx, declaredParam, inValue);<z>
) {<z>
new InvalidDataAccessApiUsageException(<z>
;<z>
declaredParam, inValue);<z>
++;<z>
return cs;<z>
) {<z>
errorInProgress) {<z>
debug("Closing JPA EntityManager after async request timeout/error");<z>
(this.emHolder.getEntityManager());<z>
String attributeName, @Nullable Object attributeValue) {<z>
(attributeName, "Model attribute name must not be null");<z>
, attributeValue);<z>
;<z>
Throwable exception) {<z>
= resolveMethodByExceptionType(exception.getClass());<z>
null) {<z>
;<z>
(cause != null) {<z>
cause.getClass());<z>
;<z>
{<z>
StringBuilder();<z>
));<z>
getPath())) {<z>
.append(getPath());<z>
)) {<z>
).append(this.domain);<z>
!this.maxAge.isNegative()) {<z>
getSeconds());<z>
.append("; Expires=");<z>
.toMillis() : 0;<z>
;<z>
this.secure) {<z>
sb.append("; Secure");<z>
.httpOnly) {<z>
.append("; HttpOnly");<z>
) {<z>
(this.sameSite);<z>
.toString();<z>
{<z>
.availableCharsets;<z>
{<z>
availableCharsets().values());<z>
.availableCharsets = charsets;<z>
charsets;<z>
int writeByteBuffer(ByteBuffer byteBuffer) throws IOException {<z>
written;<z>
0;<z>
this.channel.write(byteBuffer);<z>
totalWritten += written;<z>
() && written > 0);<z>
return totalWritten;<z>
MediaType> parseMimeTypes() {<z>
class.getResourceAsStream(MIME_TYPES_FILE_NAME);<z>
!= null, MIME_TYPES_FILE_NAME + " not found in classpath");<z>
, StandardCharsets.US_ASCII))) {<z>
result = new LinkedMultiValueMap<>();<z>
;<z>
) != null) {<z>
{<z>
, " \t\n\r\f");<z>
0]);<z>
tokens.length; i++) {<z>
;<z>
(fileExtension, mediaType);<z>
return result;<z>
IOException ex) {<z>
+ MIME_TYPES_FILE_NAME, ex);<z>
session) {<z>
initSessionLock) {<z>
= session;<z>
delegateConnectionEstablished();<z>
().getContent()));<z>
()) {<z>
));<z>
scheduleHeartbeat();<z>
true;<z>
catch (Exception ex) {<z>
.SERVER_ERROR);<z>
void clear() {<z>
() == 0) {<z>
;<z>
(this.initialSize);<z>
references.length * getLoadFactor());<z>
);<z>
();<z>
{<z>
= state.headers;<z>
= state.file;<z>
.channel = state.channel;<z>
this.byteCount = state.byteCount;<z>
destinationResolver) {<z>
new DefaultJmsActivationSpecFactory();<z>
.setDestinationResolver(destinationResolver);<z>
;<z>
String expressionString, int afterPrefixIndex)<z>
throws ParseException {<z>
pos = afterPrefixIndex;<z>
length();<z>
.indexOf(suffix, afterPrefixIndex);<z>
1) {<z>
1;<z>
();<z>
pos < maxlen) {<z>
) {<z>
;<z>
(ch) {<z>
:<z>
case '[':<z>
case '(':<z>
(ch, pos));<z>
case '}':<z>
case ']':<z>
:<z>
) {<z>
, "Found closing '" + ch +<z>
+<z>
theOpenBracketFor(ch) + "'");<z>
;<z>
p.compatibleWithCloseBracket(ch)) {<z>
ch +<z>
p.bracket +<z>
;<z>
case '\'':<z>
'"':<z>
.indexOf(ch, pos + 1);<z>
== -1) {<z>
(expressionString, pos,<z>
"Found non terminating string literal starting at position " + pos);<z>
;<z>
;<z>
()) {<z>
.pop();<z>
, p.pos, "Missing closing '" +<z>
+ "' at position " + p.pos);<z>
isSuffixHere(expressionString, pos, suffix)) {<z>
-1;<z>
return pos;<z>
name) {<z>
= transformedBeanName(name);<z>
|| containsBeanDefinition(beanName)) {<z>
name) || isFactoryBean(name));<z>
= getParentBeanFactory();<z>
originalBeanName(name)));<z>
private GenericReactiveTransaction newReactiveTransaction(<z>
TransactionDefinition definition,<z>
@Nullable Object suspendedResources) {<z>
newTransaction,<z>
!synchronizationManager.isSynchronizationActive(),<z>
.isReadOnly(), debug, suspendedResources);<z>
) throws IllegalArgumentException, IllegalAccessException {<z>
isFactoryBeanMethod(method)) {<z>
.forMethodReturnType(method);<z>
);<z>
{<z>
result = candidate;<z>
this.result.resolve();<z>
;<z>
{<z>
;<z>
getAnnotationAttributes(<z>
Annotation annotation, boolean classValuesAsString) {<z>
getAnnotationAttributes(annotation, classValuesAsString, false);<z>
engineName) {<z>
this.scriptEngineManager;<z>
if (scriptEngineManager == null) {<z>
.getClassLoader());<z>
this.scriptEngineManager = scriptEngineManager;<z>
engineName);<z>
;<z>
return engine;<z>
public void setAsText(String text) throws IllegalArgumentException {<z>
new MethodMapTransactionAttributeSource();<z>
) {<z>
);<z>
text);<z>
getValue();<z>
new TransactionAttributeEditor();<z>
= props.propertyNames();<z>
while (propNames.hasMoreElements()) {<z>
.nextElement();<z>
String value = props.getProperty(name);<z>
setAsText(value);<z>
);<z>
attr);<z>
;<z>
void initServletPropertySources(MutablePropertySources sources,<z>
@Nullable ServletConfig servletConfig) {<z>
, "'propertySources' must not be null");<z>
name = StandardServletEnvironment.SERVLET_CONTEXT_PROPERTY_SOURCE_NAME;<z>
.get(name) instanceof StubPropertySource) {<z>
, new ServletContextPropertySource(name, servletContext));<z>
;<z>
(name) instanceof StubPropertySource) {<z>
, new ServletConfigPropertySource(name, servletConfig));<z>
{<z>
).append('\n');<z>
this.headerLines) {<z>
);<z>
sb.append('\n');<z>
null) {<z>
.append(this.body);<z>
('\u0000');<z>
));<z>
public Object create() {<z>
= false;<z>
;<z>
);<z>
IOException {<z>
{<z>
this.servletRequest);<z>
return this.servletRequest.getInputStream();<z>
{<z>
.notNull(config, "AdvisedSupport must not be null");<z>
) {<z>
);<z>
advised = config;<z>
AdvisedDispatcher(this.advised);<z>
Class<?> targetClass,<z>
txAttr, ReactiveTransactionManager rtm) {<z>
);<z>
|| (KotlinDetector.isSuspendingFunction(method) &&<z>
) {<z>
).flatMap(context -><z>
.flatMap(it -> {<z>
(<z>
just(it),<z>
{<z>
?>) invocation.proceedWithInvocation();<z>
(Throwable ex) {<z>
);<z>
commitTransactionAfterReturning,<z>
),<z>
rollbackTransactionOnCancel)<z>
.onErrorResume(ex -><z>
));<z>
Throwable ex) {<z>
then(Mono.error(ex));<z>
)<z>
.getOrCreateContextHolder());<z>
.currentContext().flatMapMany(context -><z>
it -> {<z>
(<z>
Mono.just(it),<z>
txInfo -> {<z>
proceedWithInvocation());<z>
catch (Throwable ex) {<z>
return Mono.error(ex);<z>
this::commitTransactionAfterReturning,<z>
Mono.empty(),<z>
)<z>
ex -><z>
.error(ex)));<z>
{<z>
);<z>
TransactionContextManager.getOrCreateContext())<z>
()));<z>
{<z>
openConnection();<z>
ResourceUtils.useCachesIfNecessary(con);<z>
);<z>
IOException ex) {<z>
HttpURLConnection) {<z>
con).disconnect();<z>
throw ex;<z>
) throws IOException {<z>
return (getEncoding() != null ?<z>
locale, getEncoding()) :<z>
), locale));<z>
?> leafClass) {<z>
;<z>
(leafClass, methods::add);<z>
.toArray(EMPTY_METHOD_ARRAY);<z>
public void setBeanName(String beanName) {<z>
.hasLength(this.name)) {<z>
;<z>
doStartTag() throws JspException {<z>
getAttribute(REQUEST_CONTEXT_PAGE_ATTRIBUTE);<z>
== null) {<z>
= new JspAwareRequestContext(this.pageContext);<z>
setAttribute(REQUEST_CONTEXT_PAGE_ATTRIBUTE, this.requestContext);<z>
);<z>
{<z>
.getMessage(), ex);<z>
;<z>
) {<z>
getMessage(), ex);<z>
ex.getMessage());<z>
private RuntimeBeanReference registerMessageConverter(<z>
context, @Nullable Object source) {<z>
);<z>
>();<z>
null) {<z>
setSource(source);<z>
) {<z>
).parsePropertySubElement(beanElement, null);<z>
converters.add(object);<z>
))) {<z>
source);<z>
.class));<z>
);<z>
) {<z>
MappingJackson2MessageConverter.class);<z>
);<z>
;<z>
.add("contentTypeResolver", resolverDef);<z>
();<z>
Jackson2ObjectMapperFactoryBean.class);<z>
BeanDefinition.ROLE_INFRASTRUCTURE);<z>
.setSource(source);<z>
);<z>
);<z>
else if (gsonPresent) {<z>
.class));<z>
else if (jsonbPresent) {<z>
);<z>
;<z>
addIndexedArgumentValue(0, converters);<z>
null);<z>
name = MESSAGE_CONVERTER_BEAN_NAME;<z>
(name, messageConverterDef, context, source);<z>
RuntimeBeanReference(name);<z>
parameter) {<z>
> clazz = parameter.getParameterType();<z>
).getAdapter(clazz);<z>
(adapter == null) {<z>
void.class) ? 0 : 1;<z>
{<z>
0;<z>
adapter.isMultiValue() ? 2 : 1;<z>
@Nullable HttpEntity<?> requestEntity,<z>
uriVariables) throws RestClientException {<z>
= responseType.getType();<z>
type);<z>
T>> responseExtractor = responseEntityExtractor(type);<z>
, responseExtractor, uriVariables));<z>
Blackhole bh) {<z>
) {<z>
for (PathPattern pattern : data.patterns) {<z>
pattern.matches(path));<z>
public boolean equals(@Nullable Object other) {<z>
other)) {<z>
false;<z>
methodReplacerBeanName) &&<z>
.typeIdentifiers));<z>
springframework.protobuf.SecondMsg parseFrom(<z>
.google.protobuf.CodedInputStream input,<z>
.ExtensionRegistryLite extensionRegistry)<z>
.IOException {<z>
.parseFrom(input, extensionRegistry);<z>
) {<z>
.headers.get(name);<z>
.getValue() : null);<z>
{<z>
) value).intValue();<z>
{<z>
.parseInt((String) value);<z>
if (value != null) {<z>
+ name + "' is not a Number: " + value);<z>
return -1;<z>
{<z>
this.lookupOnStartup || !this.cache) {<z>
;<z>
(this) {<z>
{<z>
lookup();<z>
;<z>
(NamingException ex) {<z>
("JndiObjectTargetSource failed to obtain new target object", ex);<z>
Properties createProperties() {<z>
CollectionFactory.createStringAdaptingProperties();<z>
(properties));<z>
result;<z>
(String path) {<z>
.startsWith("/")) {<z>
path = path.substring(1);<z>
return new FileSystemContextResource(path);<z>
() {<z>
();<z>
(connectionFactory != null, "No ConnectionFactory set");<z>
return connectionFactory;<z>
) {<z>
?> future = this.taskFuture;<z>
(future != null) {<z>
);<z>
) {<z>
() {<z>
.isEmpty(getLocations())) {<z>
1; i >= 0; i--) {<z>
PathResourceResolver resolver) {<z>
getAllowedLocations())) {<z>
]));<z>
(Element element, XmlReaderContext readerContext) {<z>
element.hasAttribute(SCRIPT_SOURCE_ATTRIBUTE);<z>
.getChildElementsByTagName(element, INLINE_SCRIPT_ELEMENT);<z>
isEmpty()) {<z>
;<z>
return null;<z>
) {<z>
;<z>
isEmpty()) {<z>
elements.get(0);<z>
inlineElement);<z>
element);<z>
;<z>
String source, Charset charset) {<z>
length();<z>
) {<z>
;<z>
notNull(charset, "Charset must not be null");<z>
ByteArrayOutputStream baos = new ByteArrayOutputStream(length);<z>
changed = false;<z>
i++) {<z>
);<z>
ch == '%') {<z>
2 < length) {<z>
source.charAt(i + 1);<z>
charAt(i + 2);<z>
digit(hex1, 16);<z>
.digit(hex2, 16);<z>
-1 || l == -1) {<z>
) + "\"");<z>
4) + l));<z>
+= 2;<z>
changed = true;<z>
(i) + "\"");<z>
(ch);<z>
: source);<z>
<Void> prepareTransactionalConnection(<z>
definition, Object transaction) {<z>
ConnectionFactoryTransactionObject) transaction;<z>
);<z>
isReadOnly()) {<z>
)<z>
::getRowsUpdated)<z>
;<z>
= resolveIsolationLevel(definition.getIsolationLevel());<z>
{<z>
if (logger.isDebugEnabled()) {<z>
"] to " + isolationLevelToUse.asSql());<z>
);<z>
())) {<z>
);<z>
con.setTransactionIsolationLevel(isolationLevelToUse)));<z>
if (con.isAutoCommit()) {<z>
txObject.setMustRestoreAutoCommit(true);<z>
logger.isDebugEnabled()) {<z>
.debug("Switching R2DBC Connection [" + con + "] to manual commit");<z>
;<z>
return prepare;<z>
, boolean readOnly) throws PersistenceException {<z>
FlushMode flushMode = session.getHibernateFlushMode();<z>
{<z>
) {<z>
(FlushMode.MANUAL);<z>
;<z>
)) {<z>
AUTO);<z>
flushMode;<z>
;<z>
SmartMimeMessage(<z>
FileTypeMap defaultFileTypeMap) {<z>
(session);<z>
.defaultEncoding = defaultEncoding;<z>
.defaultFileTypeMap = defaultFileTypeMap;<z>
allowEagerInit) {<z>
allowEagerInit) {<z>
);<z>
<?>, String[]> cache =<z>
? this.allBeanNamesByType : this.singletonBeanNamesByType);<z>
.get(type);<z>
!= null) {<z>
return resolvedBeanNames;<z>
), includeNonSingletons, true);<z>
getBeanClassLoader())) {<z>
.put(type, resolvedBeanNames);<z>
;<z>
throws NotAcceptableStatusException {<z>
.getAccept();<z>
mediaTypes);<z>
: MEDIA_TYPE_ALL_LIST);<z>
InvalidMediaTypeException ex) {<z>
getHeaders().getFirst("Accept");<z>
throw new NotAcceptableStatusException(<z>
ex.getMessage());<z>
metaAnnotation) {<z>
> annotationType = metaAnnotation.annotationType();<z>
AnnotationTypeMapping mapping = source;<z>
!= null) {<z>
annotationType) {<z>
return true;<z>
();<z>
false;<z>
name) {<z>
getWebApplicationContext();<z>
;<z>
= wac.getBeansOfType(RequestMappingInfoHandlerMapping.class);<z>
handlerMethods = null;<z>
RequestMappingInfoHandlerMapping mapping : map.values()) {<z>
handlerMethods = mapping.getHandlerMethodsForMappingName(name);<z>
{<z>
) {<z>
("Mapping not found: " + name);<z>
) != 1) {<z>
handlerMethods);<z>
handlerMethod = handlerMethods.get(0);<z>
getBeanType();<z>
();<z>
;<z>
T>> action) throws DataAccessException {<z>
action, "Callback object must not be null");<z>
ConnectionCloseHolder> connectionMono = getConnection().map(<z>
;<z>
.usingWhen(connectionMono, connectionCloseHolder -> {<z>
(connectionCloseHolder.connection);<z>
);<z>
) {<z>
String sql = getSql(action);<z>
));<z>
(),<z>
::close)<z>
.class,<z>
);<z>
String contextPath, MockHeaders headers,<z>
> cookies, @Nullable Object body,<z>
<String, String> queryParams,<z>
@Nullable Principal principal,<z>
localAddress,<z>
exchange) {<z>
;<z>
.uri = uri;<z>
parse(uri, contextPath);<z>
this.headers = headers;<z>
this.cookies = cookies;<z>
body = body;<z>
attributes = attributes;<z>
;<z>
.pathVariables = pathVariables;<z>
= session;<z>
.principal = principal;<z>
remoteAddress;<z>
;<z>
this.messageReaders = messageReaders;<z>
= exchange;<z>
disableContentCachingIfNecessary(ServletWebRequest webRequest) {<z>
(isRequestNotModified(webRequest)) {<z>
= webRequest.getNativeResponse(HttpServletResponse.class);<z>
Assert.notNull(response, "Expected HttpServletResponse");<z>
.getHeader(HttpHeaders.ETAG))) {<z>
;<z>
.notNull(request, "Expected HttpServletRequest");<z>
HttpServletRequest request,<z>
previousAttributes) {<z>
setLocaleContext(prevLocaleContext, this.threadContextInheritable);<z>
);<z>
Jackson2ObjectMapperBuilder featuresToEnable(Object... featuresToEnable) {<z>
) {<z>
, Boolean.TRUE);<z>
this;<z>
AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,<z>
String annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {<z>
mergedAnnotation = findAnnotations(element)<z>
, null, MergedAnnotationSelectors.firstDirectlyDeclared());<z>
nestedAnnotationsAsMap);<z>
input, String encoding) {<z>
.notNull(input, "Input is required");<z>
);<z>
;<z>
); i++) {<z>
(i);<z>
encoding);<z>
) {<z>
);<z>
.append(character);<z>
();<z>
, @Nullable Integer previousIsolationLevel) {<z>
.notNull(con, "No Connection specified");<z>
!= null) {<z>
.isDebugEnabled()) {<z>
logger.debug("Resetting isolation level of JDBC Connection [" +<z>
;<z>
(previousIsolationLevel);<z>
) {<z>
()) {<z>
+ con + "]");<z>
);<z>
{<z>
);<z>
() {<z>
{<z>
metadataReaderFactory).clearCache();<z>
response) {<z>
webRequest, "WebRequest must not be null");<z>
notNull(response, "HttpServletResponse must not be null");<z>
.startTime = startTime;<z>
webRequest;<z>
;<z>
autodetectConfiguration() throws BeansException {<z>
return BeanFactoryUtils.beanOfTypeIncludingAncestors(<z>
.class, true, false);<z>
ex) {<z>
(<z>
"This bean may be given any name.", ex);<z>
, PropertyEditor editor) {<z>
(oldValue);<z>
Exception ex) {<z>
) {<z>
) + "] does not support setValue call", ex);<z>
);<z>
;<z>
) {<z>
("Incorrect result size: expected " + expectedSize);<z>
expectedSize = expectedSize;<z>
-1;<z>
{<z>
;<z>
MimeMessagePreparator preparator : mimeMessagePreparators) {<z>
);<z>
.prepare(mimeMessage);<z>
add(mimeMessage);<z>
);<z>
MailException ex) {<z>
;<z>
catch (MessagingException ex) {<z>
throw new MailParseException(ex);<z>
Exception ex) {<z>
(ex);<z>
IOException {<z>
original = original;<z>
coding;<z>
);<z>
(<z>
S eventsPublisher) {<z>
(eventsPublisher, "'eventsPublisher' must not be null");<z>
-> {<z>
SSE_TYPE;<z>
TEXT_EVENT_STREAM;<z>
= findWriter(context, elementType, mediaType);<z>
, serverResponse, context, writer);<z>
type, boolean includeNonSingletons, boolean allowEagerInit)<z>
{<z>
assertBeanFactoryActive();<z>
.getBeansOfType(type, includeNonSingletons, allowEagerInit);<z>
FlashMap flashMap, HttpServletRequest request) {<z>
flashMap.getTargetRequestPath();<z>
expectedPath != null) {<z>
getOriginatingRequestUri(request);<z>
requestUri.equals(expectedPath + "/")) {<z>
return false;<z>
> actualParams = getOriginatingRequestParams(request);<z>
);<z>
entrySet()) {<z>
);<z>
== null) {<z>
return false;<z>
getValue()) {<z>
(!actualValues.contains(expectedValue)) {<z>
;<z>
return true;<z>
Collection<String> beanNamesFound) {<z>
": " +<z>
beanNamesFound));<z>
beanNamesFound.size();<z>
this.beanNamesFound = beanNamesFound;<z>
) {<z>
"message-codes-resolver")) {<z>
RuntimeBeanReference(element.getAttribute("message-codes-resolver"));<z>
return null;<z>
String registerWithGeneratedName(BeanDefinition beanDefinition) {<z>
(beanDefinition);<z>
beanDefinition);<z>
return generatedName;<z>
, boolean mustRevalidate) {<z>
{<z>
(response, cacheSeconds, mustRevalidate);<z>
if (cacheSeconds == 0) {<z>
preventCaching(response);<z>
controllerAdvice) {<z>
{<z>
()<z>
basePackage(controllerAdvice.basePackages())<z>
)<z>
(controllerAdvice.assignableTypes())<z>
))<z>
);<z>
.forAnyHandlerType();<z>
() {<z>
.lifecycleMonitor) {<z>
;<z>
String sessionId) {<z>
;<z>
) {<z>
.updateAfterRemovedSession(sessionId, info);<z>
adviceMode) {<z>
switch (adviceMode) {<z>
:<z>
};<z>
:<z>
String[] {ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME};<z>
return null;<z>
(long len) {<z>
) {<z>
throw new IllegalArgumentException("Content-Length exceeds ContentCachingResponseWrapper's maximum (" +<z>
.MAX_VALUE + "): " + len);<z>
int lenInt = (int) len;<z>
) {<z>
.content.resize(lenInt);<z>
.contentLength = lenInt;<z>
List<MediaType> supportedTypes,<z>
ResolvableType bodyType, @Nullable HttpMethod method) {<z>
));<z>
.contentType = contentType;<z>
unmodifiableList(supportedTypes);<z>
this.bodyType = bodyType;<z>
method = method;<z>
Nullable MediaType mediaType,<z>
> hints) {<z>
: DEFAULT_MEDIA_TYPE);<z>
;<z>
getHeaders().setContentType(mediaType);<z>
mediaType, bufferFactory, hints));<z>
() {<z>
return result -> {<z>
);<z>
);<z>
void stopInternal() {<z>
);<z>
(this.tcpClient != null) {<z>
, TimeUnit.MILLISECONDS);<z>
ex) {<z>
);<z>
(Object target) {<z>
target, "Target object must not be null");<z>
ContextLoader.getCurrentWebApplicationContext();<z>
!= null) {<z>
AutowiredAnnotationBeanPostProcessor();<z>
.getAutowireCapableBeanFactory());<z>
);<z>
)) {<z>
("Current WebApplicationContext is not available for processing of " +<z>
": " +<z>
;<z>
public String resolveUrlPath(String url) {<z>
null) {<z>
+<z>
RESOURCE_URL_PROVIDER_ATTR);<z>
;<z>
{<z>
);<z>
String suffix = url.substring(suffixIndex);<z>
(this.indexLookupPath, suffixIndex);<z>
resourceUrlProvider.getForLookupPath(lookupPath);<z>
null) {<z>
this.prefixLookupPath + lookupPath + suffix;<z>
return null;<z>
Runnable callback) {<z>
= obtainSession();<z>
+ name,<z>
);<z>
) throws TransactionException {<z>
;<z>
SimpleTransactionStatus();<z>
);<z>
, ? extends Object> map) {<z>
{<z>
, formatValue(value)));<z>
) throws BeansException {<z>
invocationCount;<z>
;<z>
== null) {<z>
if (logger.isDebugEnabled()) {<z>
("No target for prototype '" + getTargetBeanName() + "' bound to thread: " +<z>
;<z>
);<z>
.set(target);<z>
targetSet) {<z>
;<z>
.hitCount;<z>
return target;<z>
T> elementClass) {<z>
.toMono(elementClass));<z>
onErrorMap(UnsupportedMediaTypeException.class, ERROR_MAPPER)<z>
);<z>
@Nullable ClassLoader classLoader) {<z>
{<z>
(classLoader);<z>
pattern) {<z>
?<z>
path) :<z>
);<z>
Nullable String prefix) throws BeanDefinitionStoreException {<z>
;<z>
keys = rb.getKeys();<z>
()) {<z>
;<z>
, rb.getObject(key));<z>
;<z>
(@Nullable int[] array) {<z>
) {<z>
NULL_STRING;<z>
.length;<z>
) {<z>
return EMPTY_ARRAY;<z>
);<z>
(int i : array) {<z>
(i));<z>
toString();<z>
parseFrom(<z>
google.protobuf.ByteString data)<z>
InvalidProtocolBufferException {<z>
parseFrom(data);<z>
forPayload(<z>
, Consumer<T> consumer) {<z>
PayloadApplicationEvent<T>> listener =<z>
(event.getPayload()));<z>
(phase);<z>
;<z>
method) {<z>
;<z>
initBinderResolvers);<z>
return invocable;<z>
ModelMap getModel() {<z>
{<z>
defaultModel;<z>
null) {<z>
new ModelMap();<z>
;<z>
{<z>
(mbd, beanName, this);<z>
BeanWrapper bw = new BeanWrapperImpl(beanInstance);<z>
(bw);<z>
bw;<z>
catch (Throwable ex) {<z>
throw new BeanCreationException(<z>
, "Instantiation of bean failed", ex);<z>
() {<z>
);<z>
);<z>
();<z>
final String permittedSubclass) {<z>
if (api < Opcodes.ASM9) {<z>
("PermittedSubclasses requires ASM9");<z>
cv != null) {<z>
(permittedSubclass);<z>
getPathWithinApplication(HttpServletRequest request) {<z>
;<z>
String requestUri = getRequestUri(request);<z>
= getRemainingPath(requestUri, contextPath, true);<z>
) {<z>
(path) ? path : "/");<z>
requestUri;<z>
annotationType, Method[] attributeMethods) {<z>
= annotationType;<z>
this.attributeMethods = attributeMethods;<z>
length];<z>
false;<z>
boolean foundNestedAnnotation = false;<z>
length; i++) {<z>
i];<z>
type = method.getReturnType();<z>
() != null) {<z>
true;<z>
getComponentType().isAnnotation())) {<z>
true;<z>
;<z>
isEnum());<z>
foundDefaultValueMethod;<z>
;<z>
visit(String name, Object value) {<z>
instanceof Type) {<z>
();<z>
;<z>
(Visitor visitor) {<z>
this.name,<z>
(this.value != null) ?<z>
value :<z>
.valuePredicate.toString());<z>
boolean wasNull() throws InvalidResultSetAccessException {<z>
.wasNull();<z>
SQLException se) {<z>
throw new InvalidResultSetAccessException(se);<z>
Object value) throws SAXNotRecognizedException, SAXNotSupportedException {<z>
) {<z>
) value;<z>
throw new SAXNotRecognizedException(name);<z>
{<z>
;<z>
.hasNamespaces);<z>
newDocumentBuilder();<z>
(new ByteArrayInputStream(xml));<z>
hasText(encoding)) {<z>
encoding);<z>
;<z>
] array) {<z>
if (array == null) {<z>
NULL_STRING;<z>
length;<z>
length == 0) {<z>
return EMPTY_ARRAY;<z>
StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);<z>
d : array) {<z>
);<z>
return stringJoiner.toString();<z>
, String typeName,<z>
inValue) throws SQLException {<z>
, sqlType, typeName, null, inValue);<z>
String name, byte[] bytes) {<z>
ccl = this.childClassLoader;<z>
() >= CLASSES_DEFINED_LIMIT) {<z>
(this) {<z>
ChildClassLoader currentCcl = this.childClassLoader;<z>
) {<z>
.getParent());<z>
ccl;<z>
;<z>
);<z>
setClobAsAsciiStream(<z>
, int contentLength)<z>
throws SQLException {<z>
(asciiStream != null) {<z>
().createClob();<z>
;<z>
catch (IOException ex) {<z>
;<z>
clob);<z>
, clob);<z>
null);<z>
if (logger.isDebugEnabled()) {<z>
null ?<z>
"Copied ASCII stream into temporary CLOB with length " + contentLength :<z>
"Set CLOB to null");<z>
void destroy() {<z>
delegateToUse = this.delegate;<z>
null) {<z>
delegateToUse);<z>
, String> headers) {<z>
;<z>
, contextPath);<z>
;<z>
httpMethod, ClientHttpRequestFactory requestFactory)<z>
{<z>
uri, httpMethod);<z>
)) {<z>
;<z>
return request;<z>
{<z>
if (args != null) {<z>
throw new UnsupportedOperationException(<z>
"SimpleJndiBeanFactory does not support explicit bean creation arguments");<z>
);<z>
public ArgumentsHolder(int size) {<z>
[size];<z>
];<z>
this.preparedArguments = new Object[size];<z>
, final boolean visible) {<z>
!= null) {<z>
cv.visitAnnotation(descriptor, visible);<z>
null;<z>
Class<?> source,<z>
, AnnotationsProcessor<C, R> processor) {<z>
isWithoutHierarchy(source, searchStrategy)) {<z>
, source, processor);<z>
null;<z>
remaining = Integer.MAX_VALUE;<z>
;<z>
?> root = source;<z>
Object.class && remaining > 0 &&<z>
{<z>
processor.doWithAggregate(context, aggregateIndex);<z>
null) {<z>
return result;<z>
] declaredAnnotations = getDeclaredAnnotations(source, true);<z>
> 0) {<z>
;<z>
length;<z>
.length; i++) {<z>
if (declaredAnnotations[i] != null) {<z>
isRelevant = false;<z>
{<z>
&&<z>
relevantIndex].annotationType()) {<z>
;<z>
] = null;<z>
;<z>
!isRelevant) {<z>
[i] = null;<z>
(context, aggregateIndex, source, declaredAnnotations);<z>
(result != null) {<z>
return result;<z>
= source.getSuperclass();<z>
aggregateIndex++;<z>
Throwable ex) {<z>
.handleIntrospectionFailure(source, ex);<z>
null;<z>
) {<z>
;<z>
RequestMapping.class);<z>
{<z>
+ method.toGenericString());<z>
requestMapping.path();<z>
(paths[0])) {<z>
"/";<z>
) {<z>
"Using first of multiple paths on " + method.toGenericString());<z>
0];<z>
MethodParameter param, ServerWebExchange exchange) {<z>
=<z>
.MATRIX_VARIABLES_ATTRIBUTE);<z>
isEmpty(pathParameters)) {<z>
;<z>
(MatrixVariable.class);<z>
(ann != null, "No MatrixVariable annotation");<z>
String pathVar = ann.pathVar();<z>
null;<z>
) {<z>
if (pathParameters.containsKey(pathVar)) {<z>
;<z>
false;<z>
();<z>
: pathParameters.values()) {<z>
) {<z>
{<z>
.getName();<z>
ServerErrorException(<z>
name +<z>
,<z>
);<z>
;<z>
found = true;<z>
paramValues)) {<z>
return null;<z>
) == 1) {<z>
(0);<z>
;<z>
> HandlerFilterFunction<T, R> ofResponseProcessor(<z>
<R>> responseProcessor) {<z>
Assert.notNull(responseProcessor, "Function must not be null");<z>
(request).flatMap(responseProcessor);<z>
public int newInvokeDynamic(<z>
name,<z>
descriptor,<z>
,<z>
bootstrapMethodArguments) {<z>
addConstantInvokeDynamic(<z>
name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments)<z>
index;<z>
(@Nullable String namePrefix) {<z>
"");<z>
values = new HashSet<>();<z>
value) -> {<z>
{<z>
add(value);<z>
});<z>
values;<z>
{<z>
&& context.isTemplate()) {<z>
, context);<z>
, context);<z>
throws IOException {<z>
data;<z>
) != -1) {<z>
((byte) data);<z>
content) {<z>
;<z>
);<z>
catch (AssertionError ex) {<z>
);<z>
List<?> list) {<z>
, list.isEmpty());<z>
(value == null));<z>
[] argTypes) {<z>
null && argTypes != null) ||<z>
args.length != argTypes.length)) {<z>
InvalidDataAccessApiUsageException("args and argTypes parameters must match");<z>
;<z>
argTypes;<z>
void afterPropertiesSet() {<z>
owningFactory == null) {<z>
"Factory didn't call setBeanFactory before afterPropertiesSet on lifecycle bean");<z>
) {<z>
"Factory didn't call postProcessBeforeInit before afterPropertiesSet on lifecycle bean");<z>
) {<z>
"Factory initialized via declared init method before initializing via afterPropertiesSet");<z>
{<z>
);<z>
;<z>
@Nullable Object other) {<z>
this == other) {<z>
;<z>
) != other.getClass()) {<z>
false;<z>
).requestPath));<z>
{<z>
this == other) {<z>
return true;<z>
MethodMapTransactionAttributeSource otherTas)) {<z>
return false;<z>
.methodMap);<z>
> messageConverters) {<z>
registerDefaults = true;<z>
: this.configurers) {<z>
configureMessageConverters(messageConverters)) {<z>
;<z>
return registerDefaults;<z>
(@Nullable HttpMethod httpMethod) {<z>
(httpMethod == null) {<z>
return null;<z>
.name());<z>
{<z>
);<z>
.contains(RequestMethod.GET)) {<z>
return requestMethodConditionCache.get(HttpMethod.GET);<z>
return null;<z>
setSession(HttpSession session) {<z>
= session;<z>
instanceof MockHttpSession mockSession) {<z>
.access();<z>
BeansException {<z>
[] beanNames = getBeanNamesForType(requiredType);<z>
if (beanNames.length == 1) {<z>
requiredType);<z>
{<z>
throw new NoUniqueBeanDefinitionException(requiredType, beanNames);<z>
;<z>
{<z>
(resource)<z>
::getFilename)<z>
);<z>
Exception {<z>
throw new UnsupportedOperationException(<z>
);<z>
(@Nullable Object value,<z>
{<z>
(value, requiredType, cause);<z>
name;<z>
;<z>
LifecycleElement(Method method) {<z>
) != 0) {<z>
;<z>
this.method = method;<z>
)) ?<z>
());<z>
ResultMatcher hasNoErrors() {<z>
{<z>
);<z>
.getModel().values()) {<z>
instanceof Errors) {<z>
.hasErrors());<z>
<? extends Annotation> annotationType,<z>
> metaAnnotationType) {<z>
(metaAnnotationType == null) {<z>
false;<z>
matches(metaAnnotationType) ||<z>
.hasPlainJavaAnnotationsOnly(annotationType)) {<z>
);<z>
SearchStrategy.INHERITED_ANNOTATIONS,<z>
isPresent(metaAnnotationType);<z>
@Nullable Object other) {<z>
(this == other) {<z>
return true;<z>
other instanceof ChildBeanDefinition that)) {<z>
;<z>
&& super.equals(other));<z>
, Object... args) {<z>
Assert.hasText(expression, "expression must not be null or empty");<z>
String.format(expression, args);<z>
;<z>
{<z>
);<z>
ex) {<z>
) {<z>
"Name must not be empty");<z>
.notNull(value, "Value must not be null");<z>
>(this.attributes);<z>
value);<z>
this.delegate, attributes);<z>
webAppInitializerClasses, ServletContext servletContext)<z>
ServletException {<z>
initializers = Collections.emptyList();<z>
) {<z>
());<z>
<?> waiClass : webAppInitializerClasses) {<z>
) &&<z>
.class.isAssignableFrom(waiClass)) {<z>
WebApplicationInitializer)<z>
());<z>
{<z>
throw new ServletException("Failed to instantiate WebApplicationInitializer class", ex);<z>
(initializers.isEmpty()) {<z>
.log("No Spring WebApplicationInitializer types detected on classpath");<z>
() + " Spring WebApplicationInitializers detected on classpath");<z>
);<z>
(WebApplicationInitializer initializer : initializers) {<z>
);<z>
ServerHttpResponse response,<z>
<Extension> extensions, Endpoint endpoint)<z>
{<z>
= getHttpServletRequest(request);<z>
= getHttpServletResponse(response);<z>
);<z>
) serverContainer.getWebSocketEngine();<z>
;<z>
success;<z>
);<z>
;<z>
tyrusEndpoint);<z>
.getHeaders();<z>
= createRequestContext(servletRequest, path, headers);<z>
= new TyrusUpgradeResponse();<z>
;<z>
());<z>
(success) {<z>
) {<z>
getHeaders());<z>
);<z>
catch (Exception ex) {<z>
engine, tyrusEndpoint);<z>
), ex);<z>
engine, tyrusEndpoint);<z>
if (!success) {<z>
"Unexpected handshake failure: " + request.getURI());<z>
handleEndElement(EndElement endElement) throws SAXException {<z>
!= null) {<z>
endElement.getName();<z>
()) {<z>
(), toQualifiedName(qName));<z>
();) {<z>
);<z>
);<z>
"", "", toQualifiedName(qName));<z>
parseLocaleCookieIfNecessary(HttpServletRequest request) {<z>
LOCALE_REQUEST_ATTRIBUTE_NAME) == null) {<z>
null;<z>
timeZone = null;<z>
= getCookieName();<z>
{<z>
= WebUtils.getCookie(request, cookieName);<z>
cookie != null) {<z>
= cookie.getValue();<z>
;<z>
null;<z>
localePart.indexOf('/');<z>
if (separatorIndex == -1) {<z>
localePart.indexOf(' ');<z>
{<z>
, separatorIndex);<z>
1);<z>
) ? parseLocaleValue(localePart) : null);<z>
{<z>
timeZone = StringUtils.parseTimeZoneString(timeZonePart);<z>
(IllegalArgumentException ex) {<z>
(isRejectInvalidCookies() &&<z>
) {<z>
+<z>
+ "] due to: " + ex.getMessage());<z>
.isDebugEnabled()) {<z>
logger.debug("Ignoring invalid locale cookie '" + cookieName +<z>
+ "] due to: " + ex.getMessage());<z>
(logger.isTraceEnabled()) {<z>
cookie.getValue() + "] into locale '" + locale +<z>
);<z>
setAttribute(LOCALE_REQUEST_ATTRIBUTE_NAME,<z>
: determineDefaultLocale(request)));<z>
.setAttribute(TIME_ZONE_REQUEST_ATTRIBUTE_NAME,<z>
;<z>
() throws Exception {<z>
);<z>
;<z>
targetTypeDesc = TypeDescriptor.forObject(target);<z>
::valueOf)<z>
valueOf));<z>
HttpHeaders getHeaders() {<z>
null) {<z>
return this.readOnlyHeaders;<z>
else if (this.executed) {<z>
this.headers);<z>
return this.readOnlyHeaders;<z>
.headers;<z>
lang.String getFoo() {<z>
ref = foo_;<z>
{<z>
.lang.String) ref;<z>
} else {<z>
com.google.protobuf.ByteString bs =<z>
.google.protobuf.ByteString) ref;<z>
s = bs.toStringUtf8();<z>
isValidUtf8()) {<z>
foo_ = s;<z>
;<z>
managedResource) throws MBeanExportException {<z>
);<z>
objectName;<z>
);<z>
ensureUniqueRuntimeObjectNames) {<z>
;<z>
catch (Throwable ex) {<z>
"]", ex);<z>
;<z>
objectName;<z>
Log getLoggerForInvocation(MethodInvocation invocation) {<z>
{<z>
;<z>
getThis();<z>
, "Target must not be null");<z>
target));<z>
ExecutorService initializeExecutor(<z>
{<z>
= createQueue(this.queueCapacity);<z>
ThreadPoolExecutor executor;<z>
this.taskDecorator != null) {<z>
ThreadPoolExecutor(<z>
, TimeUnit.SECONDS,<z>
queue, threadFactory, rejectedExecutionHandler) {<z>
execute(Runnable command) {<z>
decorate(command);<z>
command) {<z>
(decorated, command);<z>
super.execute(decorated);<z>
executor = new ThreadPoolExecutor(<z>
this.keepAliveSeconds, TimeUnit.SECONDS,<z>
queue, threadFactory, rejectedExecutionHandler);<z>
) {<z>
;<z>
) {<z>
;<z>
= executor;<z>
;<z>
[] delimiter) {<z>
> 0, "Delimiter must not be empty");<z>
delimiter.length) {<z>
:<z>
: new SingleByteMatcher(delimiter));<z>
2:<z>
TwoByteMatcher(delimiter);<z>
return new KnuthMorrisPrattMatcher(delimiter);<z>
) {<z>
|| this.logger.isInfoEnabled()) {<z>
valueOf(message), null, null);<z>
Method getFinder(Class<?> entityClass) {<z>
String finderMethod = "find" + getEntityName(entityClass);<z>
methods;<z>
localOnlyFiltered;<z>
.getDeclaredMethods();<z>
= true;<z>
catch (SecurityException ex) {<z>
);<z>
;<z>
methods) {<z>
getName().equals(finderMethod) &&<z>
equals(entityClass) &&<z>
) {<z>
method;<z>
return null;<z>
generic, ResolvableType... generics) {<z>
;<z>
;<z>
genericTypes, 1, generics.length);<z>
forClassWithGenerics(type, genericTypes);<z>
stompBrokerRelayMessageHandler(AbstractSubscribableChannel clientInboundChannel,<z>
brokerChannel,<z>
,<z>
userDestinationResolver) {<z>
(clientInboundChannel, clientOutboundChannel);<z>
StompBrokerRelayMessageHandler handler = registry.getStompBrokerRelay(brokerChannel);<z>
) {<z>
;<z>
<>(4);<z>
= registry.getUserDestinationBroadcast();<z>
{<z>
(destination, userDestinationMessageHandler);<z>
= registry.getUserRegistryBroadcast();<z>
(destination != null) {<z>
.put(destination, userRegistryMessageHandler);<z>
(subscriptions);<z>
;<z>
return handler;<z>
Object data) {<z>
"'data' must not be null");<z>
);<z>
this;<z>
Exception {<z>
{<z>
return type;<z>
return createUsingReflection(type);<z>
() {<z>
MessageListenerContainer listenerContainer : getListenerContainers()) {<z>
listenerContainer.isRunning()) {<z>
true;<z>
;<z>
getParamConditions() {<z>
new ArrayList<>();<z>
PartialMatch match : this.partialMatches) {<z>
match.hasProducesMatch()) {<z>
.getExpressions();<z>
(set)) {<z>
= 0;<z>
[set.size()];<z>
<String> expression : set) {<z>
();<z>
array);<z>
;<z>
boolean subscriptionShared) {<z>
subscriptionShared = subscriptionShared;<z>
subscriptionShared) {<z>
this.pubSubDomain = true;<z>
target, Object... args) {<z>
length];<z>
] = target;<z>
1, args.length - 1);<z>
;<z>
{<z>
(method.getName()) {<z>
.controllerType;<z>
controllerMethod;<z>
return this.argumentValues;<z>
{<z>
method, obj, args);<z>
controllerMethod = method;<z>
this.argumentValues = args;<z>
);<z>
(initProxy(returnType, this)));<z>
ex) {<z>
throw new IllegalStateException(<z>
, ex);<z>
{<z>
;<z>
uri = null;<z>
path);<z>
path);<z>
> lifecycleBeans, String beanName, boolean autoStartupOnly) {<z>
lifecycleBeans.remove(beanName);<z>
this) {<z>
);<z>
) {<z>
autoStartupOnly);<z>
!bean.isRunning() &&<z>
)) {<z>
)) {<z>
"]");<z>
;<z>
Throwable ex) {<z>
+ "'", ex);<z>
) {<z>
;<z>
Builder path(String path) {<z>
path.startsWith("/"), "The path does not have a leading slash.");<z>
= path;<z>
this;<z>
() {<z>
transactionContext = currentTransactionContext.get();<z>
);<z>
return transactionContext;<z>
, Object> getJpaPropertyMap() {<z>
jpaProperties = new HashMap<>();<z>
(getDatabasePlatform() != null) {<z>
.TARGET_DATABASE, getDatabasePlatform());<z>
(getDatabase());<z>
(targetDatabase != null) {<z>
.TARGET_DATABASE, targetDatabase);<z>
if (isGenerateDdl()) {<z>
jpaProperties.put(PersistenceUnitProperties.DDL_GENERATION,<z>
);<z>
put(PersistenceUnitProperties.DDL_GENERATION_MODE,<z>
);<z>
()) {<z>
.put(PersistenceUnitProperties.CATEGORY_LOGGING_LEVEL_ +<z>
);<z>
toString());<z>
jpaProperties;<z>
<RouterFunction> routerFunctions) {<z>
)) {<z>
"Mapped " + function));<z>
isDebugEnabled()) {<z>
int total = routerFunctions.size();<z>
formatMappingName();<z>
isTraceEnabled()) {<z>
(total > 0) {<z>
);<z>
(message);<z>
> 0) {<z>
logger.debug(message);<z>
Label start) {<z>
{<z>
ByteVector();<z>
lineNumberTableLength;<z>
start.bytecodeOffset);<z>
.putShort(line);<z>
beanClass) {<z>
) ||<z>
));<z>
(Instant now) {<z>
{<z>
) {<z>
sessions.values().iterator();<z>
()) {<z>
.next();<z>
(now)) {<z>
iterator.remove();<z>
;<z>
;<z>
;<z>
public HttpHeaders getHeaders() {<z>
null) {<z>
return this.readOnlyHeaders;<z>
)) {<z>
(this.headers);<z>
readOnlyHeaders;<z>
this.headers;<z>
) {<z>
(!StringUtils.hasLength(mimeType)) {<z>
InvalidMimeTypeException(mimeType, "'mimeType' must not be empty");<z>
"multipart")) {<z>
);<z>
cachedMimeTypes.get(mimeType);<z>
AnnotatedElement element) {<z>
(<z>
, false, false);<z>
{<z>
parseTransactionAnnotation(attributes);<z>
return null;<z>
public RSocketRequester transport(ClientTransport transport) {<z>
);<z>
();<z>
;<z>
initConnector(<z>
metaMimeType, dataMimeType, strategies);<z>
;<z>
, strategies);<z>
Map<String, Object> model,<z>
request) throws Exception {<z>
, value) -> {<z>
null) {<z>
name, value);<z>
;<z>
;<z>
static HttpMethod[] values() {<z>
length];<z>
, values.length);<z>
copy;<z>
other) {<z>
union(<z>
.getClassFilter());<z>
));<z>
return this;<z>
boolean continueOnError, boolean ignoreFailedDrops,<z>
{<z>
.continueOnError = continueOnError;<z>
ignoreFailedDrops = ignoreFailedDrops;<z>
sqlScriptEncoding);<z>
;<z>
List<Advisor> freshAdvisorChain() {<z>
getAdvisors();<z>
advisors.length);<z>
{<z>
if (advisor instanceof PrototypePlaceholderAdvisor pa) {<z>
isDebugEnabled()) {<z>
+ pa.getBeanName() + "'");<z>
null) {<z>
"No BeanFactory available anymore (probably due to " +<z>
"'");<z>
getBean(pa.getBeanName());<z>
Advisor refreshedAdvisor = namedBeanToAdvisor(bean);<z>
.add(refreshedAdvisor);<z>
(advisor);<z>
freshAdvisors;<z>
public EventListenerMethodProcessor() {<z>
shouldIgnoreSpel) {<z>
;<z>
new EventExpressionEvaluator();<z>
?> args) {<z>
= getCallableStatementFactory().newCallableStatementCreator(args);<z>
()) {<z>
args);<z>
1;<z>
: getCallParameters()) {<z>
+<z>
.getName() + "]");<z>
;<z>
);<z>
() {<z>
!= null) {<z>
;<z>
super.getDefaultSchema();<z>
BeanFactory initFactory() throws BeansException {<z>
!= null) {<z>
this.cachedFactory;<z>
applicationContext = obtainApplicationContext();<z>
.location;<z>
== null) {<z>
(DEFAULT_LOCATION);<z>
new GenericWebApplicationContext();<z>
;<z>
getServletContext());<z>
reader = new XmlBeanDefinitionReader(factory);<z>
());<z>
applicationContext));<z>
.loadBeanDefinitions(actualLocation);<z>
();<z>
if (isCache()) {<z>
;<z>
factory;<z>
String toString() {<z>
)<z>
))<z>
.classes))<z>
.nullSafeToString(this.locations))<z>
"inheritLocations", this.inheritLocations)<z>
ObjectUtils.nullSafeToString(this.initializers))<z>
.append("inheritInitializers", this.inheritInitializers)<z>
.name)<z>
, this.contextLoaderClass.getName())<z>
;<z>
] data, int offset) {<z>
;<z>
data.length) {<z>
(data[pos] == ':') {<z>
return pos + 1;<z>
;<z>
;<z>
Type[] bounds) {<z>
== Object.class) {<z>
null;<z>
0];<z>
requestToken() {<z>
upstream() != null &&<z>
isCancelled() &&<z>
> 0 &&<z>
)) {<z>
1);<z>
invokeAfterCompletion(<z>
synchronizations, int completionStatus) {<z>
afterCompletion(completionStatus))<z>
.then();<z>
() {<z>
) == null) {<z>
return null;<z>
;<z>
original,<z>
beanMethodMetadata, String derivedBeanName) {<z>
(original);<z>
= configClass.getMetadata();<z>
.factoryMethodMetadata = beanMethodMetadata;<z>
;<z>
boolean useLongTypeName) {<z>
()) {<z>
(), useLongTypeName);<z>
sb.append("[]");<z>
) : type.getSimpleName());<z>
throws Exception {<z>
(ViewResolver viewResolver : this.viewResolvers) {<z>
InitializingBean) {<z>
viewResolver).afterPropertiesSet();<z>
(String annotationName, boolean classValuesAsString) {<z>
if (this.nestedAnnotationsAsMap) {<z>
getAllAnnotationAttributes(annotationName, classValuesAsString);<z>
AnnotatedElementUtils.getAllAnnotationAttributes(<z>
, false);<z>
Class<?> resolveClass() {<z>
this.type == EmptyType.INSTANCE) {<z>
;<z>
{<z>
<?>) this.type;<z>
if (this.type instanceof GenericArrayType) {<z>
= getComponentType().resolve();<z>
null);<z>
return resolveType().resolve();<z>
MethodParameter returnType,<z>
, NativeWebRequest webRequest)<z>
{<z>
mavContainer.setRequestHandled(true);<z>
;<z>
ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);<z>
returnValue, returnType, inputMessage, outputMessage);<z>
initHandlerMethods() {<z>
!= null) {<z>
.handlers) {<z>
);<z>
;<z>
predicate == null) {<z>
{<z>
getBeanName() + "] Skip auto-detection of message handling methods");<z>
) {<z>
("No ApplicationContext for auto-detection of beans with message handling methods.");<z>
.class)) {<z>
SCOPED_TARGET_NAME_PREFIX)) {<z>
> beanType = null;<z>
= this.applicationContext.getType(beanName);<z>
) {<z>
logger.isDebugEnabled()) {<z>
beanName + "'", ex);<z>
test(beanType)) {<z>
);<z>
(Session session, Destination destination) throws JMSException {<z>
instanceof Topic) {<z>
) {<z>
return (isSubscriptionDurable() ?<z>
)) :<z>
()));<z>
()) {<z>
return session.createDurableSubscriber(<z>
), isPubSubNoLocal());<z>
(), isPubSubNoLocal());<z>
());<z>
List<HttpMessageWriter<?>> writers,<z>
{<z>
));<z>
EntityResponse.Builder<T> cookies(<z>
MultiValueMap<String, Cookie>> cookiesConsumer) {<z>
.accept(this.cookies);<z>
;<z>
) {<z>
= getDefaultDestination();<z>
&& !(defaultDestination instanceof Queue)) {<z>
throw new IllegalStateException(<z>
"'defaultDestination' does not correspond to a Queue. Check configuration of JmsTemplate.");<z>
defaultDestination;<z>
() throws IOException {<z>
this.connection.getErrorStream();<z>
());<z>
;<z>
codec) {<z>
codec instanceof DecoderHttpMessageReader) {<z>
) codec).getDecoder();<z>
(codec instanceof EncoderHttpMessageWriter) {<z>
();<z>
) {<z>
maxInMemorySize;<z>
size != null) {<z>
AbstractDataBufferDecoder) {<z>
codec).setMaxInMemorySize(size);<z>
protobufPresent) {<z>
{<z>
(size);<z>
if (kotlinSerializationJsonPresent) {<z>
instanceof KotlinSerializationJsonDecoder) {<z>
) codec).setMaxInMemorySize(size);<z>
{<z>
{<z>
);<z>
(jaxb2Present && !shouldIgnoreXml) {<z>
codec instanceof Jaxb2XmlDecoder) {<z>
).setMaxInMemorySize(size);<z>
instanceof FormHttpMessageReader) {<z>
) codec).setMaxInMemorySize(size);<z>
ServerSentEventHttpMessageReader) {<z>
.setMaxInMemorySize(size);<z>
instanceof DefaultPartHttpMessageReader) {<z>
).setMaxInMemorySize(size);<z>
Boolean enable = this.enableLoggingRequestDetails;<z>
) {<z>
if (codec instanceof FormHttpMessageReader) {<z>
).setEnableLoggingRequestDetails(enable);<z>
(codec instanceof MultipartHttpMessageReader) {<z>
);<z>
codec instanceof DefaultPartHttpMessageReader) {<z>
).setEnableLoggingRequestDetails(enable);<z>
{<z>
).setEnableLoggingRequestDetails(enable);<z>
{<z>
).setEnableLoggingRequestDetails(enable);<z>
) {<z>
this.codecConsumer.accept(codec);<z>
(codec instanceof MultipartHttpMessageReader) {<z>
getPartReader());<z>
if (codec instanceof MultipartHttpMessageWriter) {<z>
codec).getFormWriter());<z>
{<z>
) codec).getDecoder());<z>
codec instanceof ServerSentEventHttpMessageWriter) {<z>
);<z>
String service, final String... providers) {<z>
service).index);<z>
length);<z>
(String provider : providers) {<z>
(provider).index);<z>
;<z>
JoinPointMatch jpm) {<z>
, jpm);<z>
MetadataEncoder(MimeType metadataMimeType, RSocketStrategies strategies) {<z>
;<z>
"RSocketStrategies is required");<z>
metadataMimeType;<z>
.strategies = strategies;<z>
).equals(<z>
);<z>
= bufferFactory() instanceof NettyDataBufferFactory ?<z>
DEFAULT;<z>
doCommit(DefaultTransactionStatus status) {<z>
.getTransaction();<z>
.isDebug()) {<z>
logger.debug("Committing JPA transaction on EntityManager [" +<z>
).getEntityManager() + "]");<z>
).getTransaction();<z>
.commit();<z>
{<z>
) {<z>
ex.getCause());<z>
null) {<z>
throw dae;<z>
;<z>
{<z>
, getJpaDialect());<z>
parent) {<z>
));<z>
));<z>
.isAutoGrowNestedPaths());<z>
setAutoGrowCollectionLimit(parent.getAutoGrowCollectionLimit());<z>
));<z>
boolean extractVariables) {<z>
pathContainer;<z>
elements();<z>
.pathElements.size();<z>
= extractVariables;<z>
.SecondMsgOrBuilder getBlahOrBuilder() {<z>
(blahBuilder_ != null) {<z>
blahBuilder_.getMessageOrBuilder();<z>
} else {<z>
return blah_;<z>
static PathSegment decodeAndParsePathSegment(String segment) {<z>
UTF_8;<z>
(';');<z>
index == -1) {<z>
.uriDecode(segment, charset);<z>
.from(segment, valueToMatch);<z>
;<z>
index);<z>
, charset);<z>
, parameters);<z>
setThemeName(<z>
String themeName) {<z>
request, THEME_SESSION_ATTRIBUTE_NAME,<z>
));<z>
public static Msg parseDelimitedFrom(<z>
,<z>
ExtensionRegistryLite extensionRegistry)<z>
.IOException {<z>
);<z>
Throwable ex) {<z>
RollbackRuleAttribute winner = null;<z>
deepest = Integer.MAX_VALUE;<z>
.rollbackRules != null) {<z>
rule : this.rollbackRules) {<z>
(ex);<z>
>= 0 && depth < deepest) {<z>
= depth;<z>
= rule;<z>
null) {<z>
ex);<z>
;<z>
void stop() {<z>
()) {<z>
stop();<z>
(Exception ex) {<z>
, ex);<z>
private Mono<?> createAttribute(<z>
BindingContext context, ServerWebExchange exchange) {<z>
(clazz);<z>
;<z>
Nullable DataSource dataSource) {<z>
(con, dataSource);<z>
SQLException ex) {<z>
ex);<z>
Throwable ex) {<z>
);<z>
String formatMockServerResult() {<z>
this.mockServerResult != null ?<z>
"\n" : "");<z>
) throws IllegalStateException {<z>
&& isContextRequired()) {<z>
throw new IllegalStateException(<z>
+ this + "] does not run in an ApplicationContext");<z>
this.applicationContext;<z>
) throws SockJsTransportFailureException {<z>
synchronized (this.responseLock) {<z>
) && !this.heartbeatDisabled) {<z>
);<z>
();<z>
symbolTable,<z>
int access,<z>
name,<z>
final String descriptor,<z>
signature,<z>
final String[] exceptions,<z>
compute) {<z>
;<z>
;<z>
? access | Constants.ACC_CONSTRUCTOR : access;<z>
= symbolTable.addConstantUtf8(name);<z>
= name;<z>
= symbolTable.addConstantUtf8(descriptor);<z>
.descriptor = descriptor;<z>
);<z>
exceptions.length > 0) {<z>
exceptions.length;<z>
numberOfExceptions];<z>
++i) {<z>
[i]).index;<z>
{<z>
= 0;<z>
this.exceptionIndexTable = null;<z>
compute;<z>
) {<z>
>> 2;<z>
ACC_STATIC) != 0) {<z>
argumentsSize;<z>
;<z>
currentLocals = argumentsSize;<z>
();<z>
(firstBasicBlock);<z>
ConnectionFactory connectionFactory) {<z>
CONNECTION_SYNCHRONIZATION_ORDER;<z>
current = connectionFactory;<z>
{<z>
--;<z>
);<z>
order;<z>
HandlerInterceptor adaptInterceptor(Object interceptor) {<z>
(interceptor instanceof HandlerInterceptor handlerInterceptor) {<z>
handlerInterceptor;<z>
else if (interceptor instanceof WebRequestInterceptor webRequestInterceptor) {<z>
webRequestInterceptor);<z>
);<z>
VersionStrategy strategy, String... pathPatterns) {<z>
String pattern : pathPatterns) {<z>
().put(pattern, strategy);<z>
this;<z>
, Class<T> targetClass) {<z>
(text, "Text must not be null");<z>
targetClass, "Target class must not be null");<z>
.trimAllWhitespace(text);<z>
) {<z>
Byte.valueOf(trimmed));<z>
if (Short.class == targetClass) {<z>
;<z>
) {<z>
Integer.valueOf(trimmed));<z>
.class == targetClass) {<z>
.valueOf(trimmed));<z>
if (BigInteger.class == targetClass) {<z>
(trimmed));<z>
.class == targetClass) {<z>
(trimmed);<z>
targetClass) {<z>
(trimmed);<z>
== targetClass || Number.class == targetClass) {<z>
(trimmed);<z>
new IllegalArgumentException(<z>
) + "]");<z>
, Writer writer) {<z>
).toCharArray());<z>
catch (IOException ex) {<z>
ex);<z>
(ResolvableType targetType, @Nullable MimeType targetMimeType) {<z>
(this.objectMapperRegistrations)) {<z>
defaultObjectMapper;<z>
);<z>
entrySet()) {<z>
().isAssignableFrom(targetClass)) {<z>
entrySet()) {<z>
includes(targetMimeType)) {<z>
getValue();<z>
null;<z>
return this.defaultObjectMapper;<z>
() {<z>
return new ToStringCreator(this)<z>
)<z>
.append("name", this.name)<z>
)<z>
)<z>
.append("likesPets", this.likesPets)<z>
favoriteNumber)<z>
toString();<z>
void onMessage(Message message) {<z>
;<z>
catch (Throwable ex) {<z>
(ex);<z>
matchingContext) {<z>
segmentData = null;<z>
{<z>
);<z>
)) {<z>
false;<z>
);<z>
;<z>
(isNoMorePattern()) {<z>
.determineRemainingPath) {<z>
remainingPathIndex = pathIndex;<z>
;<z>
(pathIndex == matchingContext.pathLength) {<z>
return true;<z>
isMatchOptionalTrailingSeparator() &&<z>
&&<z>
== matchingContext.pathLength &&<z>
matchingContext.isSeparator(pathIndex));<z>
0) {<z>
false;<z>
));<z>
void afterPropertiesSet() {<z>
if (getDataSource() == null) {<z>
);<z>
{<z>
) task :<z>
), task.getInitialDelay()));<z>
);<z>
<?> targetClass) {<z>
)) ||<z>
;<z>
MethodOverride mo) throws BeanDefinitionValidationException {<z>
());<z>
{<z>
throw new BeanDefinitionValidationException(<z>
+<z>
) + "]");<z>
== 1) {<z>
);<z>
request) throws Exception {<z>
request);<z>
if (handler == null) {<z>
;<z>
(handler == null) {<z>
return null;<z>
(handler instanceof String handlerName) {<z>
= obtainApplicationContext().getBean(handlerName);<z>
ServletRequestPathUtils.hasCachedPath(request)) {<z>
request);<z>
request);<z>
if (logger.isTraceEnabled()) {<z>
logger.trace("Mapped to " + handler);<z>
equals(request.getDispatcherType())) {<z>
));<z>
)) {<z>
handler, request);<z>
null) {<z>
getCorsConfigurationSource().getCorsConfiguration(request);<z>
config);<z>
(config != null) {<z>
);<z>
executionChain, config);<z>
return executionChain;<z>
) throws NoSuchProviderException {<z>
String protocol = getProtocol();<z>
if (protocol == null) {<z>
= session.getProperty("mail.transport.protocol");<z>
protocol == null) {<z>
protocol = DEFAULT_PROTOCOL;<z>
(protocol);<z>
, DataBufferFactory bufferFactory,<z>
{<z>
()), value);<z>
, null);<z>
{<z>
getBeanName();<z>
: DEFAULT_THREAD_NAME_PREFIX);<z>
new SimpleAsyncTaskExecutor(threadNamePrefix);<z>
RequestMatcher json(String expectedJsonContent, boolean strict) {<z>
return request -> {<z>
= (MockClientHttpRequest) request;<z>
.getBodyAsString(), strict);<z>
Exception ex) {<z>
"Failed to parse expected or actual JSON request content", ex);<z>
final MessageCreator messageCreator) throws JmsException {<z>
execute(session -> {<z>
, destination, messageCreator);<z>
;<z>
false);<z>
name)<z>
{<z>
== null) {<z>
null;<z>
return getRequiredStringParameter(request, name);<z>
(Object value, DataBufferFactory bufferFactory,<z>
<String, Object> hints) {<z>
;<z>
if (mapper == null) {<z>
valueType);<z>
?> jsonView = null;<z>
FilterProvider filters = null;<z>
) {<z>
.getValue();<z>
);<z>
);<z>
mimeType, jsonView, hints);<z>
) {<z>
.with(filters);<z>
;<z>
mimeType);<z>
logValue(hints, value);<z>
{<z>
(generator, value);<z>
();<z>
{<z>
+ ex.getType(), ex);<z>
(JsonProcessingException ex) {<z>
;<z>
ex) {<z>
("Unexpected I/O error while writing to byte array builder", ex);<z>
[] bytes = byteBuilder.toByteArray();<z>
= bufferFactory.allocateBuffer(bytes.length);<z>
write(bytes);<z>
);<z>
return buffer;<z>
();<z>
{<z>
Assert.notEmpty(sessionAttributes, "'sessionAttributes' must not be empty");<z>
;<z>
return this;<z>
void initHeartbeats(StompHeaderAccessor connectedHeaders) {<z>
]> con = getTcpConnection();<z>
state(con != null, "No TcpConnection available");<z>
().getHeartbeat()[0];<z>
;<z>
)[0];<z>
.getHeartbeat()[1];<z>
{<z>
Math.max(clientSendInterval, serverReceiveInterval);<z>
.onWriteInactivity(() -><z>
send(HEARTBEAT_MESSAGE).addCallback(<z>
,<z>
handleTcpConnectionFailure(<z>
ex)), interval);<z>
0 && serverSendInterval > 0) {<z>
) * HEARTBEAT_MULTIPLIER;<z>
con.onReadInactivity(<z>
, null), interval);<z>
trySend() {<z>
) {<z>
true)) {<z>
sendNextMessage();<z>
) {<z>
compareAndSet(this, 1, 0)) {<z>
;<z>
(final SymbolTable symbolTable, final ByteVector output) {<z>
= null;<z>
0;<z>
maxStack = -1;<z>
;<z>
, codeLength, maxStack, maxLocals, output);<z>
public void clearAttributes() {<z>
.hasNext();) {<z>
= it.next();<z>
entry.getKey();<z>
Object value = entry.getValue();<z>
);<z>
) {<z>
));<z>
public String toString() {<z>
);<z>
Annotation ann : getAnnotations()) {<z>
.append(' ');<z>
.append(getResolvableType());<z>
return builder.toString();<z>
{<z>
getObjectClass(this.targetObject);<z>
this.name) &&<z>
!= null &&<z>
equals(contextObjectClass)) {<z>
.cachedWriteAccessor;<z>
.state(accessor != null, "No cached write accessor");<z>
name, newValue);<z>
accessorsToTry = AstUtils.getPropertyAccessorsToTry(<z>
.evaluationContext.getPropertyAccessors());<z>
accessorsToTry) {<z>
targetObject, this.name)) {<z>
.name;<z>
this.cachedWriteTargetType = contextObjectClass;<z>
;<z>
);<z>
{<z>
new SpelEvaluationException(getStartPosition(), ex,<z>
.getMessage());<z>
) {<z>
);<z>
(0);<z>
getPort());<z>
?> getKotlinSerializationJsonEncoder() {<z>
if (this.kotlinSerializationJsonEncoder == null) {<z>
this.kotlinSerializationJsonEncoder = new KotlinSerializationJsonEncoder();<z>
;<z>
length) {<z>
checkIndex(index, length);<z>
.position();<z>
);<z>
.byteBuffer.slice();<z>
.limit(length);<z>
);<z>
);<z>
(Element ele) {<z>
String name = ele.getAttribute(NAME_ATTRIBUTE);<z>
);<z>
valid = true;<z>
(!StringUtils.hasText(name)) {<z>
().error("Name must not be empty", ele);<z>
= false;<z>
{<z>
().error("Alias must not be empty", ele);<z>
= false;<z>
) {<z>
).registerAlias(name, alias);<z>
catch (Exception ex) {<z>
().error("Failed to register alias '" + alias +<z>
ele, ex);<z>
ele));<z>
handler, StandardWebSocketSession wsSession) {<z>
Assert.notNull(handler, "WebSocketHandler must not be null");<z>
notNull(wsSession, "WebSocketSession must not be null");<z>
handler;<z>
;<z>
Annotation annotation) {<z>
(annotation);<z>
-> {<z>
(value.equals(DEFAULT_VALUE_NONE)) {<z>
"NONE");<z>
});<z>
;<z>
boolean hasDestroyMethods() {<z>
<LifecycleElement> checkedDestroyMethods = this.checkedDestroyMethods;<z>
LifecycleElement> destroyMethodsToUse =<z>
!= null ? checkedDestroyMethods : this.destroyMethods);<z>
destroyMethodsToUse.isEmpty();<z>
(<z>
LifecycleOptions lifecycleOptions, BeanInstanceProducer fallbackProducer) {<z>
) {<z>
return new SpringContainedBean<>(<z>
(beanType, AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR, false),<z>
this.beanFactory::destroyBean);<z>
(beanType));<z>
) {<z>
)) {<z>
("Falling back to Hibernate's default producer after bean creation failure for " +<z>
;<z>
;<z>
(RuntimeException ex2) {<z>
if (ex instanceof BeanCreationException) {<z>
if (logger.isDebugEnabled()) {<z>
;<z>
throw ex;<z>
throw ex2;<z>
, MediaType produceType) {<z>
= produceType.copyQualityValue(acceptType);<z>
produceType)) {<z>
;<z>
return acceptType;<z>
{<z>
this.argumentConversionOccurred = ReflectionHelper.convertArguments(<z>
this.originalMethod, this.varargsPosition);<z>
.originalMethod.isVarArgs()) {<z>
ReflectionHelper.setupArgumentsForVarargsInvocation(<z>
, arguments);<z>
;<z>
;<z>
;<z>
Exception ex) {<z>
ex);<z>
<?> candidateParameterType) {<z>
{<z>
joinPointArgumentIndex = 0;<z>
;<z>
false;<z>
getHeaders() {<z>
null) {<z>
extractHeaders(this.message);<z>
;<z>
bean, @Nullable String beanKey) throws MalformedObjectNameException {<z>
(bean instanceof SelfNaming) {<z>
getObjectName();<z>
.namingStrategy.getObjectName(bean, beanKey);<z>
writeCookies(HttpServletResponse servletResponse) {<z>
values().stream()<z>
(Collection::stream)<z>
;<z>
) {<z>
[] notificationAttributes =<z>
.getManagedNotifications(getClassToExpose(managedBean));<z>
] notificationInfos =<z>
[notificationAttributes.length];<z>
) {<z>
= notificationAttributes[i];<z>
);<z>
return notificationInfos;<z>
(WebSocketChannel channel, BufferedBinaryMessage message) {<z>
);<z>
);<z>
);<z>
{<z>
{<z>
Annotation[] fieldAnnotations = this.fieldAnnotations;<z>
) {<z>
fieldAnnotations = this.field.getAnnotations();<z>
fieldAnnotations;<z>
return fieldAnnotations;<z>
);<z>
(Message<?> message) {<z>
.get(MessageHeaders.CONTENT_TYPE);<z>
== null) {<z>
return null;<z>
{<z>
String) headerValue);<z>
(headerValue instanceof MimeType) {<z>
return (MimeType) headerValue;<z>
("Unexpected MimeType value: " + headerValue);<z>
>> multipartFiles, MutablePropertyValues mpvs) {<z>
, values) -> {<z>
{<z>
value = values.get(0);<z>
.isEmpty()) {<z>
mpvs.add(key, value);<z>
values);<z>
);<z>
SearchStrategy searchStrategy) {<z>
{<z>
return true;<z>
isWithoutHierarchy(source, searchStrategy)) {<z>
isBridge()) {<z>
;<z>
length == 0;<z>
;<z>
headers) {<z>
.accept();<z>
()) {<z>
.singletonList(MediaType.ALL);<z>
sortBySpecificity(acceptedMediaTypes);<z>
;<z>
{<z>
;<z>
containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) {<z>
=<z>
;<z>
if (logger.isTraceEnabled()) {<z>
"]");<z>
= new DefaultLifecycleProcessor();<z>
(beanFactory);<z>
defaultProcessor;<z>
LIFECYCLE_PROCESSOR_BEAN_NAME, this.lifecycleProcessor);<z>
(logger.isTraceEnabled()) {<z>
"' bean, using " +<z>
"]");<z>
{<z>
: null);<z>
;<z>
;<z>
static WebApplicationContext getRequiredWebApplicationContext(ServletContext sc) throws IllegalStateException {<z>
getWebApplicationContext(sc);<z>
) {<z>
;<z>
return wac;<z>
destroy() {<z>
destructionCallbacks) {<z>
values()) {<z>
runnable.run();<z>
.destructionCallbacks.clear();<z>
(Function<CachingConfigurer, T> provider) {<z>
{<z>
cachingConfigurer = this.supplier.get();<z>
) : null);<z>
, int length) {<z>
;<z>
= this.byteBuffer.duplicate();<z>
(index);<z>
;<z>
.slice();<z>
void handleNotationDeclaration(NotationDeclaration declaration) throws SAXException {<z>
null) {<z>
), declaration.getSystemId());<z>
static EntityManager createSharedEntityManager(<z>
properties, boolean synchronizedWithTransaction) {<z>
> emIfc = (emf instanceof EntityManagerFactoryInfo ?<z>
class);<z>
,<z>
emIfc}));<z>
protobuf.SecondMsg getBlah() {<z>
blahBuilder_ == null) {<z>
;<z>
} else {<z>
blahBuilder_.getMessage();<z>
{<z>
rowsAffected > this.maxRowsAffected) {<z>
(), this.maxRowsAffected, rowsAffected);<z>
> 0 && rowsAffected != this.requiredRowsAffected) {<z>
.requiredRowsAffected, rowsAffected);<z>
ex) {<z>
ex != null && this.logExceptionStackTrace) {<z>
message, ex);<z>
;<z>
public static EntityManager createApplicationManagedEntityManager(<z>
emfInfo) {<z>
false);<z>
> requestHeaders) {<z>
{<z>
null;<z>
isEmpty()) {<z>
emptyList();<z>
(this.allowedHeaders)) {<z>
;<z>
allowedHeaders.contains(ALL);<z>
());<z>
) {<z>
StringUtils.hasText(requestHeader)) {<z>
= requestHeader.trim();<z>
(allowAnyHeader) {<z>
requestHeader);<z>
{<z>
equalsIgnoreCase(allowedHeader)) {<z>
add(requestHeader);<z>
: result);<z>
beanName) {<z>
;<z>
) || mbd.isPrototype()) {<z>
IllegalArgumentException(<z>
"' does not correspond to an object in a mutable scope");<z>
mbd.getScope();<z>
.get(scopeName);<z>
if (scope == null) {<z>
scopeName + "'");<z>
bean = scope.remove(beanName);<z>
(bean != null) {<z>
(beanName, bean, mbd);<z>
(final Runnable runnable, final long duration) {<z>
null, "No TaskScheduler configured");<z>
);<z>
) -> {<z>
duration) {<z>
.run();<z>
{<z>
{<z>
);<z>
2));<z>
) {<z>
null, dataHolder);<z>
ex) {<z>
throw convertXStreamException(ex, false);<z>
protected void closeEntityManagerAfterFailedBegin(JpaTransactionObject txObject) {<z>
{<z>
getEntityManagerHolder().getEntityManager();<z>
).isActive()) {<z>
().rollback();<z>
(Throwable ex) {<z>
("Could not rollback EntityManager after failed transaction begin", ex);<z>
EntityManagerFactoryUtils.closeEntityManager(em);<z>
(null, false);<z>
moveToNextElement(XMLStreamReader streamReader) throws XMLStreamException {<z>
int event = streamReader.getEventType();<z>
.START_ELEMENT && event != XMLStreamReader.END_DOCUMENT) {<z>
= streamReader.next();<z>
event;<z>
{<z>
.done = true;<z>
) {<z>
subscription.cancel();<z>
JtaTransactionManager(UserTransaction userTransaction, TransactionManager transactionManager) {<z>
;<z>
Assert.notNull(userTransaction, "UserTransaction must not be null");<z>
, "TransactionManager must not be null");<z>
userTransaction = userTransaction;<z>
transactionManager;<z>
handler) {<z>
completion = Sinks.empty();<z>
Mono.deferContextual(<z>
-> {<z>
.isDebugEnabled()) {<z>
;<z>
= handler.getSubProtocols();<z>
DefaultConfigurator(requestHeaders);<z>
(<z>
), completion, configurator);<z>
, protocols);<z>
.connectToServer(endpoint, config, url);<z>
);<z>
(Exception ex) {<z>
(ex);<z>
boundedElastic());<z>
{<z>
AbstractJsonPathRequestMatcher() {<z>
IOException, ParseException {<z>
);<z>
) {<z>
contentNegotiationManager == null) {<z>
build();<z>
|| this.viewResolvers.isEmpty()) {<z>
"No ViewResolvers configured");<z>
boolean namespaceAware)<z>
{<z>
= DocumentBuilderFactory.newInstance();<z>
.setNamespaceAware(namespaceAware);<z>
!= XmlValidationModeDetector.VALIDATION_NONE) {<z>
);<z>
VALIDATION_XSD) {<z>
;<z>
setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);<z>
{<z>
ParserConfigurationException(<z>
+<z>
"Upgrade to Apache Xerces (or Java 1.5) for full XSD support.");<z>
ex);<z>
;<z>
factory;<z>
, String subscriptionId, MethodParameter returnType) {<z>
create(SimpMessageType.MESSAGE);<z>
) != null) {<z>
getHeaderInitializer().initHeaders(accessor);<z>
sessionId != null) {<z>
accessor.setSessionId(sessionId);<z>
setSubscriptionId(subscriptionId);<z>
setHeader(AbstractMessageSendingTemplate.CONVERSION_HINT_HEADER, returnType);<z>
(true);<z>
accessor.getMessageHeaders();<z>
() {<z>
this.registerDefaults) {<z>
Collections.emptyList();<z>
;<z>
));<z>
;<z>
)));<z>
(nettyByteBufPresent) {<z>
new NettyByteBufEncoder()));<z>
ResourceHttpMessageWriter());<z>
CharSequenceEncoder.textPlainOnly()));<z>
if (protobufPresent) {<z>
this.protobufEncoder != null ?<z>
)));<z>
return writers;<z>
{<z>
String aspectId = aspectElement.getAttribute(ID);<z>
);<z>
aspectId, aspectName));<z>
);<z>
;<z>
;<z>
declareParents.size(); i++) {<z>
i);<z>
parserContext));<z>
();<z>
false;<z>
; i++) {<z>
item(i);<z>
if (isAdviceNode(node, parserContext)) {<z>
(!adviceFoundAlready) {<z>
;<z>
!StringUtils.hasText(aspectName)) {<z>
).error(<z>
parseState.snapshot());<z>
(new RuntimeBeanReference(aspectName));<z>
(<z>
node, parserContext, beanDefinitions, beanReferences);<z>
add(advisorDefinition);<z>
createAspectComponentDefinition(<z>
, beanDefinitions, beanReferences, parserContext);<z>
;<z>
getChildElementsByTagName(aspectElement, POINTCUT);<z>
) {<z>
);<z>
;<z>
;<z>
regex, char[] completePattern) {<z>
StringBuilder patternBuilder = new StringBuilder();<z>
= new String(regex);<z>
;<z>
end = 0;<z>
)) {<z>
)));<z>
();<z>
(match)) {<z>
.append('.');<z>
)) {<z>
".*");<z>
start();<z>
!= '.') {<z>
this.wildcardCount++;<z>
{<z>
int colonIdx = match.indexOf(':');<z>
(colonIdx == -1) {<z>
patternBuilder.append(DEFAULT_VARIABLE_PATTERN);<z>
(1);<z>
)) {<z>
, completePattern,<z>
.ILLEGAL_DOUBLE_CAPTURE, variableName);<z>
variableName);<z>
() - 1);<z>
'(');<z>
(variablePattern);<z>
.append(')');<z>
= match.substring(1, colonIdx);<z>
{<z>
completePattern,<z>
.ILLEGAL_DOUBLE_CAPTURE, variableName);<z>
;<z>
matcher.end();<z>
);<z>
(this.caseSensitive) {<z>
());<z>
, Pattern.CASE_INSENSITIVE);<z>
.Message jmsMessage) {<z>
> headers = new HashMap<>();<z>
();<z>
{<z>
CORRELATION_ID, correlationId);<z>
Exception ex) {<z>
debug("Failed to read JMSCorrelationID property - skipping", ex);<z>
();<z>
if (destination != null) {<z>
);<z>
(Exception ex) {<z>
;<z>
= jmsMessage.getJMSDeliveryMode();<z>
.DELIVERY_MODE, deliveryMode);<z>
ex) {<z>
.debug("Failed to read JMSDeliveryMode property - skipping", ex);<z>
= jmsMessage.getJMSExpiration();<z>
, expiration);<z>
(Exception ex) {<z>
ex);<z>
String messageId = jmsMessage.getJMSMessageID();<z>
) {<z>
JmsHeaders.MESSAGE_ID, messageId);<z>
(Exception ex) {<z>
logger.debug("Failed to read JMSMessageID property - skipping", ex);<z>
getJMSPriority());<z>
catch (Exception ex) {<z>
debug("Failed to read JMSPriority property - skipping", ex);<z>
Destination replyTo = jmsMessage.getJMSReplyTo();<z>
null) {<z>
.put(JmsHeaders.REPLY_TO, replyTo);<z>
Exception ex) {<z>
"Failed to read JMSReplyTo property - skipping", ex);<z>
);<z>
Exception ex) {<z>
("Failed to read JMSRedelivered property - skipping", ex);<z>
);<z>
{<z>
.put(JmsHeaders.TYPE, type);<z>
ex) {<z>
debug("Failed to read JMSType property - skipping", ex);<z>
.getJMSTimestamp());<z>
catch (Exception ex) {<z>
("Failed to read JMSTimestamp property - skipping", ex);<z>
jmsPropertyNames = jmsMessage.getPropertyNames();<z>
{<z>
(jmsPropertyNames.hasMoreElements()) {<z>
.nextElement().toString();<z>
String headerName = this.toHeaderName(propertyName);<z>
.getObjectProperty(propertyName));<z>
) {<z>
(logger.isDebugEnabled()) {<z>
logger.debug("Error occurred while mapping JMS property '" + propertyName +<z>
;<z>
JMSException ex) {<z>
if (logger.isDebugEnabled()) {<z>
.debug("Error occurred while mapping from JMS properties to MessageHeaders", ex);<z>
MessageHeaders(headers);<z>
@Nullable Map<String, Object> attributes,<z>
, @Nullable InetSocketAddress remoteAddress) {<z>
attributes, localAddress, remoteAddress, null);<z>
) {<z>
();<z>
{<z>
(fallbackPattern);<z>
)) {<z>
resolvedFallbackPatterns.add(resolvedFallbackPattern);<z>
= getFormatter(annotation, fieldType);<z>
TemporalAccessor>) fieldType,<z>
annotation);<z>
org.springframework.protobuf.SecondMsg other) {<z>
.getDefaultInstance()) return this;<z>
hasBlah()) {<z>
(other.getBlah());<z>
.mergeUnknownFields(other.getUnknownFields());<z>
this;<z>
(ServerWebExchange exchange, Throwable ex) {<z>
getRequest();<z>
);<z>
;<z>
)) {<z>
(request), ex);<z>
.empty();<z>
)) {<z>
lostClientLogger.isTraceEnabled()) {<z>
.trace(logPrefix + "Client went away", ex);<z>
{<z>
debug(logPrefix + "Client went away: " + ex +<z>
DISCONNECTED_CLIENT_LOG_CATEGORY + "')");<z>
;<z>
(request) +<z>
getStatusCode() + ")");<z>
ex);<z>
, String beanName) {<z>
).instantiationAware) {<z>
beanName);<z>
{<z>
result;<z>
return null;<z>
() {<z>
getURL().toURI();<z>
ex) {<z>
);<z>
{<z>
)) {<z>
.objectSourceClass;<z>
.startsWith("java")) {<z>
getClassLoader()));<z>
(ClassNotFoundException ex) {<z>
, ex);<z>
));<z>
() {<z>
(), "No handlers");<z>
lifecycleMonitor) {<z>
this);<z>
running = true;<z>
GenericBeanDefinition createObjectMapperFactoryDefinition(@Nullable Object source) {<z>
GenericBeanDefinition beanDefinition = new GenericBeanDefinition();<z>
class);<z>
(source);<z>
BeanDefinition.ROLE_INFRASTRUCTURE);<z>
;<z>
, Class<?> implementationClass) {<z>
Assert.notNull(methodParameter, "MethodParameter must not be null");<z>
);<z>
);<z>
methodParameter.getParameterType();<z>
forInstance(Object instance) {<z>
Assert.notNull(instance, "Instance must not be null");<z>
if (instance instanceof ResolvableTypeProvider) {<z>
();<z>
) {<z>
type;<z>
getClass());<z>
{<z>
) {<z>
.randomUUID().toString());<z>
{<z>
;<z>
databaseConfigurer.configureConnectionProperties(<z>
.databaseName);<z>
dataSource = this.dataSourceFactory.getDataSource();<z>
()) {<z>
instanceof SimpleDriverDataSource simpleDriverDataSource) {<z>
("Starting embedded database: url='%s', username='%s'",<z>
;<z>
;<z>
if (this.databasePopulator != null) {<z>
databasePopulator, this.dataSource);<z>
{<z>
shutdownDatabase();<z>
throw ex;<z>
private void pushPathElement(PathElement newPathElement) {<z>
) {<z>
null) {<z>
.headPE = newPathElement;<z>
currentPE = newPathElement;<z>
SeparatorPathElement) {<z>
.prev;<z>
null) {<z>
= newPathElement;<z>
null;<z>
.next = newPathElement;<z>
prev = peBeforeSeparator;<z>
this.currentPE = newPathElement;<z>
IllegalStateException("Expected SeparatorPathElement but was " + this.currentPE);<z>
null) {<z>
headPE = newPathElement;<z>
newPathElement;<z>
currentPE != null) {<z>
next = newPathElement;<z>
prev = this.currentPE;<z>
this.currentPE = newPathElement;<z>
;<z>
name, Object value) {<z>
hasLength(name, "'name' must not be empty");<z>
, "'value' must not be null");<z>
.put(name, value);<z>
Object[] args) throws Throwable {<z>
()) {<z>
"equals":<z>
]);<z>
case "hashCode":<z>
System.identityHashCode(proxy);<z>
()) {<z>
getTransactionalSession(<z>
;<z>
null) {<z>
(session);<z>
()) {<z>
session = ConnectionFactoryUtils.getTransactionalQueueSession(<z>
,<z>
isSynchedLocalTransactionAllowed());<z>
if (session != null) {<z>
);<z>
.getReturnType()) {<z>
.getTransactionalTopicSession(<z>
.target,<z>
isSynchedLocalTransactionAllowed());<z>
(session != null) {<z>
);<z>
target, args);<z>
) {<z>
);<z>
, final int numDimensions) {<z>
length;<z>
symbolTable.addConstantClass(descriptor);<z>
);<z>
if (currentBasicBlock != null) {<z>
compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {<z>
execute(<z>
, numDimensions, descSymbol, symbolTable);<z>
else {<z>
- numDimensions;<z>
Object arguments) throws JspException {<z>
(arguments instanceof String) {<z>
argumentSeparator);<z>
else if (arguments instanceof Object[]) {<z>
Object[]) arguments;<z>
else if (arguments instanceof Collection) {<z>
arguments).toArray();<z>
) {<z>
] {arguments};<z>
;<z>
ResponseCookie> getCookies() {<z>
{<z>
(this.originalResponse.cookies());<z>
.cookies;<z>
?>[] valueMaps) {<z>
.length];<z>
++) {<z>
i]);<z>
;<z>
MailParseException {<z>
helper.setTo(to);<z>
catch (MessagingException ex) {<z>
MailParseException(ex);<z>
void invokeModelAttributeMethods(NativeWebRequest request, ModelAndViewContainer container)<z>
Exception {<z>
{<z>
);<z>
getMethodAnnotation(ModelAttribute.class);<z>
"No ModelAttribute annotation");<z>
containsAttribute(ann.name())) {<z>
)) {<z>
name());<z>
modelMethod.invokeForRequest(request, container);<z>
{<z>
) {<z>
)) {<z>
+<z>
);<z>
);<z>
) {<z>
);<z>
{<z>
addAttribute(returnValueName, returnValue);<z>
classLoader) throws ClassNotFoundException {<z>
getBeanClassName();<z>
{<z>
;<z>
);<z>
.beanClass = resolvedClass;<z>
return resolvedClass;<z>
isMoreSpecific(MimeType other) {<z>
, "Other must not be null");<z>
(other instanceof MediaType otherMediaType) {<z>
= getQualityValue();<z>
();<z>
quality1 > quality2) {<z>
;<z>
(quality1 < quality2) {<z>
return false;<z>
;<z>
boundary, DataBufferFactory bufferFactory) {<z>
-> {<z>
;<z>
write((byte)'-');<z>
buffer.write((byte)'-');<z>
boundary);<z>
);<z>
((byte)'-');<z>
buffer.write((byte)'\r');<z>
);<z>
return buffer;<z>
);<z>
synchronized void setScript(String script) {<z>
hasText(script, "Script must not be empty");<z>
script.equals(this.script);<z>
script;<z>
(Message message) throws JMSException, MessageConversionException {<z>
;<z>
return convertToObject(message, targetJavaType);<z>
) {<z>
new MessageConversionException("Failed to convert JSON message content", ex);<z>
(Errors errors) {<z>
getObjectName())) {<z>
("Errors object needs to have same object name");<z>
getAllErrors());<z>
) {<z>
= getParticipateAttributeName();<z>
(participateAttributeName, WebRequest.SCOPE_REQUEST);<z>
if (count == null) {<z>
return false;<z>
> 1) {<z>
- 1, WebRequest.SCOPE_REQUEST);<z>
participateAttributeName, WebRequest.SCOPE_REQUEST);<z>
;<z>
, int startIndex) {<z>
placeholderPrefix.length();<z>
= 0;<z>
()) {<z>
{<z>
if (withinNestedPlaceholder > 0) {<z>
;<z>
();<z>
index;<z>
) {<z>
++;<z>
simplePrefix.length();<z>
++;<z>
;<z>
int indexOf(String name) {<z>
{<z>
getName().equals(name)) {<z>
return i;<z>
return -1;<z>
parseDaysOfWeek(String value) {<z>
value = replaceOrdinals(value, DAYS);<z>
.isQuartzDaysOfWeekField(value)) {<z>
(value);<z>
, (field, type) -> {<z>
(field)) {<z>
);<z>
);<z>
;<z>
DataAccessException {<z>
(populator, "DatabasePopulator must not be null");<z>
, "DataSource must not be null");<z>
= DataSourceUtils.getConnection(dataSource);<z>
populate(connection);<z>
, dataSource)) {<z>
();<z>
connection, dataSource);<z>
{<z>
;<z>
catch (Throwable ex) {<z>
);<z>
NettyInbound inbound, NettyOutbound outbound) {<z>
{<z>
logger.isDebugEnabled()) {<z>
+ conn.address());<z>
);<z>
);<z>
codec, completionSink);<z>
.afterConnected(connection));<z>
;<z>
.receiveObject()<z>
(Message.class)<z>
.publishOn(scheduler, PUBLISH_ON_BUFFER_SIZE)<z>
(<z>
this.connectionHandler::handleMessage,<z>
::handleFailure,<z>
::afterConnectionClosed);<z>
.asMono();<z>
() throws TransactionSystemException {<z>
;<z>
;<z>
;<z>
{<z>
?<z>
());<z>
(handlerType != null) {<z>
;<z>
= MethodIntrospector.selectMethods(userType,<z>
) method -> {<z>
);<z>
) {<z>
"Invalid mapping on handler class [" +<z>
, ex);<z>
;<z>
{<z>
, methods));<z>
else if (mappingsLogger.isDebugEnabled()) {<z>
, methods));<z>
-> {<z>
);<z>
registerHandlerMethod(handler, invocableMethod, mapping);<z>
;<z>
leftOperand, @Nullable Object rightOperand)<z>
{<z>
);<z>
removeSingletonIfCreatedForTypeCheckOnly(String beanName) {<z>
this.alreadyCreated.contains(beanName)) {<z>
removeSingleton(beanName);<z>
return true;<z>
;<z>
element, ParserContext parserContext) {<z>
{<z>
= parserContext.extractSource(element);<z>
new RootBeanDefinition("org.springframework.cache.annotation.AnnotationCacheOperationSource");<z>
);<z>
setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
);<z>
new RootBeanDefinition(CacheInterceptor.class);<z>
setSource(eleSource);<z>
.ROLE_INFRASTRUCTURE);<z>
;<z>
(element, interceptorDef);<z>
parseKeyGenerator(element, interceptorDef);<z>
));<z>
.registerWithGeneratedName(interceptorDef);<z>
RootBeanDefinition(BeanFactoryCacheOperationSourceAdvisor.class);<z>
;<z>
;<z>
;<z>
);<z>
.hasAttribute("order")) {<z>
"order"));<z>
.CACHE_ADVISOR_BEAN_NAME, advisorDef);<z>
;<z>
);<z>
new BeanComponentDefinition(interceptorDef, interceptorName));<z>
;<z>
);<z>
(<z>
[] pathPatterns, HandlerInterceptor... interceptors) {<z>
pathPatterns, interceptors);<z>
;<z>
(Connection connection) throws JMSException {<z>
getClientId();<z>
null) {<z>
clientId);<z>
{<z>
;<z>
) {<z>
);<z>
this.targetBeanName);<z>
targetClass;<z>
(WebFilter filter) {<z>
filter, "WebFilter must not be null");<z>
);<z>
return this;<z>
T query(<z>
T> rse)<z>
DataAccessException {<z>
notNull(rse, "ResultSetExtractor must not be null");<z>
.debug("Executing prepared SQL query");<z>
psc, new PreparedStatementCallback<T>() {<z>
T doInPreparedStatement(PreparedStatement ps) throws SQLException {<z>
;<z>
pss != null) {<z>
ps);<z>
();<z>
;<z>
JdbcUtils.closeResultSet(rs);<z>
pss instanceof ParameterDisposer) {<z>
);<z>
, true);<z>
Class<?>[] types) {<z>
;<z>
= new String[typesCount];<z>
{<z>
(types[p]);<z>
;<z>
(T delegate, String id, HandshakeInfo info,<z>
{<z>
delegate, id, info, bufferFactory);<z>
();<z>
;<z>
this.handlerCompletionSink = null;<z>
response)<z>
throws ServletException, IOException {<z>
);<z>
.defaultServletName);<z>
null) {<z>
IllegalStateException("A RequestDispatcher could not be located for the default servlet '" +<z>
);<z>
.forward(request, response);<z>
void hookOnComplete() {<z>
completed.set(true);<z>
{<z>
();<z>
boolean result) {<z>
synchronized (this) {<z>
{<z>
= result;<z>
? this.receiptCallbacks : this.receiptLostCallbacks);<z>
.receiptId);<z>
null) {<z>
(true);<z>
values) throws DataAccessException {<z>
result = executeWithNativeSession(session -> {<z>
);<z>
);<z>
(values != null) {<z>
i < values.length; i++) {<z>
]);<z>
.executeUpdate();<z>
});<z>
);<z>
;<z>
(Locale locale) {<z>
)) {<z>
new SimpleDateFormat(this.pattern, locale);<z>
.iso != ISO.NONE) {<z>
.iso);<z>
null) {<z>
.iso);<z>
pattern);<z>
setTimeZone(UTC);<z>
;<z>
this.stylePattern)) {<z>
(0);<z>
= getStylePatternForChar(1);<z>
1) {<z>
timeStyle, locale);<z>
-1) {<z>
return DateFormat.getDateInstance(dateStyle, locale);<z>
if (timeStyle != -1) {<z>
getTimeInstance(timeStyle, locale);<z>
.stylePattern + "'");<z>
(this.style, locale);<z>
enableAspectJWeaving(<z>
LoadTimeWeaver weaverToUse, @Nullable ClassLoader beanClassLoader) {<z>
null) {<z>
{<z>
InstrumentationLoadTimeWeaver(beanClassLoader);<z>
;<z>
addTransformer(<z>
ClassPreProcessorAgentAdapter()));<z>
Object requiredType, boolean directOnly) {<z>
.annotations) {<z>
type = annotation.getType();<z>
requiredType)) {<z>
return true;<z>
if (!directOnly) {<z>
(AnnotationTypeMappings mappings : this.mappings) {<z>
) {<z>
get(i);<z>
requiredType)) {<z>
;<z>
false;<z>
client, URI uri, HttpMethod method) {<z>
client = client;<z>
uri;<z>
method = method;<z>
) {<z>
profile)) {<z>
"Invalid profile [" + profile + "]: must contain text");<z>
) {<z>
+ profile + "]: must not begin with ! operator");<z>
public void visitEnd() {<z>
<?> componentType = getComponentType();<z>
elements.size());<z>
);<z>
() {<z>
, Type type) {<z>
.equals(type)) {<z>
);<z>
;<z>
false;<z>
) {<z>
(source == null) {<z>
null;<z>
(targetType)) {<z>
;<z>
) source;<z>
sourceCollection.isEmpty()) {<z>
null;<z>
;<z>
elementTypeDescriptor(firstElement), targetType);<z>
public void init() {<z>
("config", new ConfigBeanDefinitionParser());<z>
new AspectJAutoProxyBeanDefinitionParser());<z>
("scoped-proxy", new ScopedProxyBeanDefinitionDecorator());<z>
new SpringConfiguredBeanDefinitionParser());<z>
] tokenizePattern(String pattern) {<z>
= null;<z>
cachePatterns = this.cachePatterns;<z>
()) {<z>
get(pattern);<z>
if (tokenized == null) {<z>
;<z>
() >= CACHE_TURNOFF_THRESHOLD) {<z>
deactivatePatternCache();<z>
return tokenized;<z>
)) {<z>
tokenizedPatternCache.put(pattern, tokenized);<z>
return tokenized;<z>
String[] selectImports(AnnotationMetadata importingClassMetadata) {<z>
), AdviceModeImportSelector.class);<z>
.state(annType != null, "Unresolvable type argument for AdviceModeImportSelector");<z>
attributesFor(importingClassMetadata, annType);<z>
null) {<z>
new IllegalArgumentException(String.format(<z>
importingClassMetadata.getClassName()));<z>
= attributes.getEnum(getAdviceModeAttributeName());<z>
String[] imports = selectImports(adviceMode);<z>
{<z>
throw new IllegalArgumentException("Unknown AdviceMode: " + adviceMode);<z>
imports;<z>
() throws IllegalStateException {<z>
();<z>
) {<z>
"Transaction synchronization is not active");<z>
)) {<z>
emptyList();<z>
;<z>
sort(sortedSynchs);<z>
Collections.unmodifiableList(sortedSynchs);<z>
.springframework.protobuf.SecondMsg value) {<z>
(blahBuilder_ == null) {<z>
(value == null) {<z>
;<z>
;<z>
;<z>
{<z>
value);<z>
|= 0x00000002;<z>
this;<z>
@Nullable Object other) {<z>
(this == other) {<z>
;<z>
other instanceof MethodCacheKey otherKey)) {<z>
false;<z>
this.parameterTypes, otherKey.parameterTypes));<z>
String trimAllWhitespace(String str) {<z>
{<z>
str;<z>
.length();<z>
(str.length());<z>
; i++) {<z>
= str.charAt(i);<z>
c)) {<z>
(c);<z>
return sb.toString();<z>
rollbackOnly) {<z>
) {<z>
();<z>
{<z>
)) {<z>
{<z>
throw new IllegalStateException("No BeanFactory available anymore (probably due to serialization) " +<z>
;<z>
.endsWith(GLOBAL_SUFFIX) &&<z>
) {<z>
"Target required after globals");<z>
{<z>
name.endsWith(GLOBAL_SUFFIX)) {<z>
beanFactory instanceof ListableBeanFactory)) {<z>
AopConfigException(<z>
);<z>
(ListableBeanFactory) this.beanFactory,<z>
GLOBAL_SUFFIX.length()));<z>
Object advice;<z>
isSingleton(name)) {<z>
(name);<z>
);<z>
);<z>
advisorChainInitialized = true;<z>
String requestPath) {<z>
(requestPath);<z>
{<z>
.group(1);<z>
('-') + 1) : match);<z>
null;<z>
{<z>
;<z>
APPLICATION_JSON, Collections.emptyMap())<z>
::consume)<z>
).block();<z>
public final AnnotationVisitor visitTypeAnnotation(<z>
final boolean visible) {<z>
visible) {<z>
return lastRuntimeVisibleTypeAnnotation =<z>
(<z>
typePath, descriptor, lastRuntimeVisibleTypeAnnotation);<z>
{<z>
lastRuntimeInvisibleTypeAnnotation =<z>
(<z>
, descriptor, lastRuntimeInvisibleTypeAnnotation);<z>
>... paramTypes)<z>
NoSuchMethodException {<z>
method, paramTypes);<z>
) {<z>
() {<z>
request) {<z>
));<z>
FilterChain chain)<z>
throws IOException, ServletException {<z>
getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE);<z>
((HttpServletRequest) request);<z>
);<z>
.setParsedRequestPath(previousRequestPath, request);<z>
String signatureString) {<z>
++) {<z>
, i);<z>
{<z>
.excludedPatterns.length; j++) {<z>
(signatureString, j);<z>
if (excluded) {<z>
return false;<z>
;<z>
false;<z>
<String, Object> hints,<z>
separator) {<z>
logValue(hints, value);<z>
value);<z>
();<z>
InvalidDefinitionException ex) {<z>
getType(), ex);<z>
catch (JsonProcessingException ex) {<z>
ex.getOriginalMessage(), ex);<z>
IOException ex) {<z>
new IllegalStateException("Unexpected I/O error while writing to byte array builder", ex);<z>
);<z>
;<z>
int offset;<z>
length;<z>
&& bytes[0] == ' ') {<z>
1;<z>
.length - 1;<z>
= 0;<z>
bytes.length;<z>
separator.length);<z>
bytes, offset, length);<z>
write(separator);<z>
hints, logger);<z>
buffer;<z>
AspectComponentDefinition createAspectComponentDefinition(<z>
<BeanDefinition> beanDefs,<z>
beanRefs, ParserContext parserContext) {<z>
(new BeanDefinition[0]);<z>
0]);<z>
extractSource(aspectElement);<z>
beanRefArray, source);<z>
(@Nullable Collection<String> prefixes) {<z>
(CollectionUtils.isEmpty(prefixes)) {<z>
return prefixes;<z>
>(prefixes.size());<z>
) {<z>
{<z>
;<z>
(prefix);<z>
result;<z>
{<z>
) {<z>
;<z>
= new String[destinations.length];<z>
i < destinations.length; i++) {<z>
valueResolver.resolveStringValue(destinations[i]);<z>
result;<z>
Nullable String name, @Nullable PatternsRequestCondition patterns,<z>
params,<z>
consumes,<z>
Nullable RequestCondition<?> custom) {<z>
new BuilderConfiguration());<z>
applySessionBindingInterceptor(WebAsyncManager asyncManager, String key) {<z>
= asyncManager.getCallableInterceptor(key);<z>
) {<z>
return false;<z>
(AsyncRequestInterceptor) cpi).bindSession();<z>
true;<z>
protected void applyStatusCode() {<z>
Integer status = super.getRawStatusCode();<z>
{<z>
(status);<z>
resolvePlaceholders(String text) {<z>
null) {<z>
);<z>
(text, this.nonStrictHelper);<z>
void createApiDiffTask(String baselineVersion, Project project) {<z>
project)) {<z>
);<z>
);<z>
.DOCUMENTATION_GROUP);<z>
)));<z>
;<z>
.getAsFile()));<z>
;<z>
setPackageIncludes(PACKAGE_INCLUDES);<z>
setOnlyModified(true);<z>
apiDiff.setIgnoreMissingClasses(true);<z>
"@kotlin.Metadata"));<z>
baselineVersion, project));<z>
getByName("jar"));<z>
String scope) {<z>
.notNull(scope, "Scope to search for cannot be null");<z>
scope.equals(SCOPE_REQUEST)) {<z>
;<z>
)) {<z>
PageContext.SESSION_SCOPE;<z>
if (scope.equals(SCOPE_APPLICATION)) {<z>
APPLICATION_SCOPE;<z>
return PageContext.PAGE_SCOPE;<z>
ServerHttpRequest request, ServerHttpResponse response,<z>
{<z>
getHeaders());<z>
()) {<z>
" with headers=" + headers);<z>
.GET != request.getMethod()) {<z>
response.setStatusCode(HttpStatus.METHOD_NOT_ALLOWED);<z>
GET));<z>
)) {<z>
));<z>
return false;<z>
))) {<z>
);<z>
return false;<z>
contains("upgrade")) {<z>
response);<z>
;<z>
if (!isWebSocketVersionSupported(headers)) {<z>
, response);<z>
return false;<z>
if (!isValidOrigin(request)) {<z>
.setStatusCode(HttpStatus.FORBIDDEN);<z>
return false;<z>
= headers.getSecWebSocketKey();<z>
(wsKey == null) {<z>
)) {<z>
);<z>
;<z>
return false;<z>
catch (IOException ex) {<z>
new HandshakeFailureException(<z>
request.getURI(), ex);<z>
, wsHandler);<z>
);<z>
.getSupportedExtensions(request);<z>
filterRequestedExtensions(request, requested, supported);<z>
attributes);<z>
()) {<z>
"Upgrading to WebSocket, subProtocol=" + subProtocol + ", extensions=" + extensions);<z>
user, wsHandler, attributes);<z>
return true;<z>
other) {<z>
== other) {<z>
;<z>
{<z>
false;<z>
.headers);<z>
<Void> prepareForCommit(TransactionSynchronizationManager synchronizationManager,<z>
{<z>
);<z>
(String beanName, RootBeanDefinition mbd, BeanWrapper bw,<z>
) {<z>
();<z>
null ? customConverter : bw);<z>
BeanDefinitionValueResolver valueResolver =<z>
, mbd, converter);<z>
.getParameterTypes();<z>
length];<z>
argIndex < argsToResolve.length; argIndex++) {<z>
argIndex];<z>
MethodParameter.forExecutable(executable, argIndex);<z>
if (argValue == autowiredArgumentMarker) {<z>
;<z>
) {<z>
.resolveValueIfNecessary("constructor argument", argValue);<z>
(argValue instanceof String) {<z>
mbd);<z>
argIndex];<z>
, methodParam);<z>
ex) {<z>
new UnsatisfiedDependencyException(<z>
, new InjectionPoint(methodParam),<z>
"Could not convert argument value of type [" + ObjectUtils.nullSafeClassName(argValue) +<z>
);<z>
return resolvedArgs;<z>
?> submit(Runnable task) {<z>
);<z>
(task);<z>
catch (RejectedExecutionException ex) {<z>
;<z>
setTransactionManager(Object transactionManager) {<z>
if (transactionManager instanceof TransactionFactory) {<z>
= (TransactionFactory) transactionManager;<z>
TransactionManager) {<z>
new SimpleTransactionFactory((TransactionManager) transactionManager);<z>
+ transactionManager +<z>
;<z>
) {<z>
queryParams.clear();<z>
) {<z>
(params);<z>
return this;<z>
CodeFlow cf) {<z>
this.cachedExecutor);<z>
(executor != null, "No cached executor");<z>
);<z>
'/');<z>
, classDesc);<z>
(DUP);<z>
.children.length - 1];<z>
);<z>
);<z>
createSignatureDescriptor(constructor), false);<z>
exitTypeDescriptor);<z>
public boolean equals(@Nullable Object other) {<z>
this == other) {<z>
;<z>
equals(other)) {<z>
return false;<z>
other;<z>
.getField()) &&<z>
)) &&<z>
isBindingFailure());<z>
{<z>
AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();<z>
;<z>
) {<z>
);<z>
return context;<z>
getAnnotatedMethods(String annotationName) {<z>
= new LinkedHashSet<>(4);<z>
declaredMethods) {<z>
isAnnotated(annotationName)) {<z>
);<z>
unmodifiableSet(result);<z>
getMergedBeanDefinition(String name) throws BeansException {<z>
transformedBeanName(name);<z>
instanceof ConfigurableBeanFactory) {<z>
()).getMergedBeanDefinition(beanName);<z>
return getMergedLocalBeanDefinition(beanName);<z>
mc, @Nullable MethodFilter mf) {<z>
(clazz, false);<z>
methods) {<z>
)) {<z>
mc.doWith(method);<z>
(IllegalAccessException ex) {<z>
"': " + ex);<z>
.class)) {<z>
.getSuperclass(), mc, mf);<z>
isInterface()) {<z>
()) {<z>
mc, mf);<z>
final void visit(<z>
final int version,<z>
,<z>
final String name,<z>
String signature,<z>
,<z>
final String[] interfaces) {<z>
= version;<z>
.accessFlags = access;<z>
);<z>
!= null) {<z>
.signatureIndex = symbolTable.addConstantUtf8(signature);<z>
.index;<z>
interfaces.length > 0) {<z>
interfaces.length;<z>
[interfaceCount];<z>
interfaceCount; ++i) {<z>
).index;<z>
{<z>
MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES;<z>
<?> testClass) {<z>
cacheAwareContextLoaderDelegate = createCacheAwareContextLoaderDelegate();<z>
Class<? extends BootstrapContext> clazz = null;<z>
extends BootstrapContext>) ClassUtils.forName(<z>
.getClassLoader());<z>
(<z>
class);<z>
) {<z>
"Instantiating BootstrapContext using constructor [%s]", constructor));<z>
constructor, testClass, cacheAwareContextLoaderDelegate);<z>
) {<z>
);<z>
HttpServletRequest request)<z>
{<z>
(getViewerPreferences());<z>
) {<z>
);<z>
initMethods) {<z>
);<z>
) {<z>
(methodIdentifier);<z>
(element);<z>
.isTraceEnabled()) {<z>
) + "]: " + element);<z>
size());<z>
: this.destroyMethods) {<z>
();<z>
!beanDefinition.isExternallyManagedDestroyMethod(methodIdentifier)) {<z>
methodIdentifier);<z>
checkedDestroyMethods.add(element);<z>
) {<z>
;<z>
.checkedInitMethods = checkedInitMethods;<z>
.checkedDestroyMethods = checkedDestroyMethods;<z>
,<z>
) {<z>
();<z>
byteCount);<z>
.asByteBuffer());<z>
);<z>
DataBufferUtils.release(dataBuffer);<z>
) {<z>
hints) + "Read " + byteCount + " bytes");<z>
;<z>
newState) {<z>
, newState)) {<z>
logger.isTraceEnabled()) {<z>
;<z>
;<z>
;<z>
oldState +<z>
+ newState + "; current state:"<z>
());<z>
return false;<z>
(@Nullable Object other) {<z>
== other) {<z>
true;<z>
(!(other instanceof PeriodicTrigger otherTrigger)) {<z>
;<z>
this.initialDelay == otherTrigger.initialDelay &&<z>
period);<z>
Object bean, String beanName) {<z>
;<z>
beanName, pvs);<z>
catch (Throwable ex) {<z>
;<z>
pvs;<z>
params) throws DataAccessException {<z>
(params);<z>
;<z>
checkRowsAffected(rowsAffected);<z>
rowsAffected;<z>
anAdvisor) {<z>
if (anAdvisor instanceof AspectJPrecedenceInformation) {<z>
(AspectJPrecedenceInformation) anAdvisor;<z>
;<z>
) {<z>
return (AspectJPrecedenceInformation) advice;<z>
return null;<z>
Class<?> aspectClass, String aspectName) {<z>
;<z>
currClass = aspectClass;<z>
> ajType = null;<z>
(currClass != Object.class) {<z>
);<z>
if (ajTypeToCheck.isAspect()) {<z>
= ajTypeToCheck;<z>
();<z>
if (ajType == null) {<z>
() + "' is not an @AspectJ aspect");<z>
.getDeclarePrecedence().length > 0) {<z>
;<z>
.aspectClass = ajType.getJavaClass();<z>
= ajType;<z>
).getKind()) {<z>
:<z>
perClausePointcut = Pointcut.TRUE;<z>
PERTARGET:<z>
:<z>
= new AspectJExpressionPointcut();<z>
.setLocation(aspectClass.getName());<z>
findPerClause(aspectClass));<z>
(aspectClass);<z>
= ajexp;<z>
case PERTYPEWITHIN:<z>
aspectClass)));<z>
AopConfigException(<z>
+ aspectClass);<z>
Object value, Class<?> paramType) {<z>
(value == null) {<z>
(paramType)) {<z>
Boolean.FALSE;<z>
{<z>
+<z>
"for the corresponding primitive type.");<z>
;<z>
Object> getEncodeHints(ResolvableType actualType, ResolvableType elementType,<z>
ServerHttpRequest request, ServerHttpResponse response) {<z>
();<z>
{<z>
().get(name);<z>
if (values != null) {<z>
null);<z>
name);<z>
public HttpClientErrorException(<z>
@Nullable Charset responseCharset) {<z>
, body, responseCharset);<z>
, Matcher<? super String> matcher) {<z>
();<z>
{<z>
(name);<z>
;<z>
);<z>
.responseSpec;<z>
() {<z>
null,<z>
;<z>
(ServerContainer) this.servletContext.getAttribute(<z>
;<z>
null,<z>
"Attribute 'jakarta.websocket.server.ServerContainer' not found in ServletContext");<z>
{<z>
(this.asyncSendTimeout);<z>
(this.maxSessionIdleTimeout != null) {<z>
serverContainer.setDefaultMaxSessionIdleTimeout(this.maxSessionIdleTimeout);<z>
) {<z>
.setDefaultMaxTextMessageBufferSize(this.maxTextMessageBufferSize);<z>
(this.maxBinaryMessageBufferSize != null) {<z>
(this.maxBinaryMessageBufferSize);<z>
(Class<?> clazz) throws IOException {<z>
{<z>
<?>) this.source);<z>
;<z>
locale) throws Exception {<z>
);<z>
return true;<z>
{<z>
;<z>
catch (ParseException ex) {<z>
throw new ApplicationContextException(<z>
"]", ex);<z>
IOException ex) {<z>
(<z>
"]", ex);<z>
public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {<z>
.getFilename();<z>
)) {<z>
this.standardXmlBeanDefinitionReader.loadBeanDefinitions(encodedResource);<z>
logger.isTraceEnabled()) {<z>
"Loading Groovy bean definitions from " + encodedResource);<z>
SuppressWarnings("serial")<z>
{<z>
... args) {<z>
;<z>
;<z>
{<z>
setVariable(String name, Object value) {<z>
if (currentBeanDefinition != null) {<z>
;<z>
, value);<z>
beans);<z>
countBefore = getRegistry().getBeanDefinitionCount();<z>
), binding);<z>
, "beans");<z>
(Throwable ex) {<z>
(),<z>
()), null, ex));<z>
() - countBefore;<z>
) {<z>
;<z>
;<z>
void resolve() {<z>
new Throwable().getStackTrace();<z>
;<z>
sourceMethodName = null;<z>
boolean found = false;<z>
) {<z>
String className = element.getClassName();<z>
(className)) {<z>
found = true;<z>
{<z>
;<z>
;<z>
(sourceClassName);<z>
);<z>
(Object other) {<z>
if (this == other) {<z>
;<z>
{<z>
return false;<z>
, otherPerson.name) &&<z>
someDouble, otherPerson.someDouble) &&<z>
;<z>
, final int access) {<z>
if (api < Opcodes.ASM5) {<z>
REQUIRES_ASM5);<z>
!= null) {<z>
name, access);<z>
?>... actualInterfaces)<z>
{<z>
synchronized (this.scriptClassMonitor) {<z>
<?> scriptClassToExecute;<z>
wasModifiedForTypeCheck = false;<z>
) {<z>
object;<z>
this.cachedResult = null;<z>
;<z>
()) {<z>
this.scriptClass = getGroovyClassLoader().parseClass(<z>
;<z>
(this.scriptClass)) {<z>
scriptSource, this.scriptClass);<z>
null);<z>
return result;<z>
this.scriptResultClass = this.scriptClass;<z>
scriptClass;<z>
);<z>
ex) {<z>
= null;<z>
null;<z>
, ex);<z>
className) {<z>
.hasLength(className, "Class name must not be empty");<z>
lastIndexOf(PACKAGE_SEPARATOR);<z>
indexOf(CGLIB_CLASS_SEPARATOR);<z>
{<z>
length();<z>
+ 1, nameEndIndex);<z>
= shortName.replace(NESTED_CLASS_SEPARATOR, PACKAGE_SEPARATOR);<z>
;<z>
void setReplyTo(String replyTo) throws MailParseException {<z>
helper.setReplyTo(replyTo);<z>
(MessagingException ex) {<z>
);<z>
locale) {<z>
defaultMessage = resolvable.getDefaultMessage();<z>
] codes = resolvable.getCodes();<z>
) {<z>
&&<z>
()) {<z>
return defaultMessage;<z>
{<z>
defaultMessage;<z>
.getArguments(), locale);<z>
null);<z>
throws EvaluationException {<z>
state);<z>
getValue());<z>
;<z>
ResolvableType elementType, @Nullable MediaType mediaType) {<z>
{<z>
) {<z>
true;<z>
{<z>
{<z>
;<z>
;<z>
deleteRecursively(@Nullable Path root) throws IOException {<z>
root == null) {<z>
return false;<z>
root)) {<z>
;<z>
new SimpleFileVisitor<Path>() {<z>
Path file, BasicFileAttributes attrs) throws IOException {<z>
;<z>
.CONTINUE;<z>
dir, IOException exc) throws IOException {<z>
dir);<z>
return FileVisitResult.CONTINUE;<z>
});<z>
true;<z>
routeMatcher) {<z>
).equals("a/a");<z>
);<z>
pattern : patterns) {<z>
&& !pattern.startsWith("/")) {<z>
pattern;<z>
pattern);<z>
;<z>
boolean required, @Nullable String defaultValue) {<z>
.name = name;<z>
;<z>
= defaultValue;<z>
servletConfig) {<z>
servletConfig;<z>
!= null && this.servletContext == null) {<z>
());<z>
protected ServletServerHttpResponse createResponse(HttpServletResponse response,<z>
request) throws IOException {<z>
), getBufferSize(), request);<z>
, String> params) {<z>
null) {<z>
.queryParams.addAll(params);<z>
;<z>
;<z>
, HttpContext context) {<z>
httpClient = client;<z>
request;<z>
this.httpContext = context;<z>
>> ClientRequest.Builder body(<z>
publisher, ParameterizedTypeReference<S> typeReference) {<z>
;<z>
this;<z>
ResultSet rs) throws SQLException {<z>
rowSet = newCachedRowSet();<z>
(rs);<z>
(rowSet);<z>
] getAnnotations(AnnotatedElement annotatedElement) {<z>
(), annotatedElement);<z>
ex) {<z>
;<z>
;<z>
public ConnectionFactory getConnectionFactory(String connectionFactoryName)<z>
{<z>
return this.connectionFactory;<z>
ClientHttpRequest request, ExchangeStrategies strategies) {<z>
HttpHeaders requestHeaders = request.getHeaders();<z>
.isEmpty()) {<z>
headers.entrySet().stream()<z>
))<z>
entry -> requestHeaders<z>
)));<z>
> requestCookies = request.getCookies();<z>
!this.cookies.isEmpty()) {<z>
values) -> values.forEach(value -> {<z>
, value);<z>
requestCookies.add(name, cookie);<z>
));<z>
.httpRequestConsumer != null) {<z>
httpRequestConsumer.accept(request);<z>
request, new BodyInserter.Context() {<z>
HttpMessageWriter<?>> messageWriters() {<z>
messageWriters();<z>
ServerHttpRequest> serverRequest() {<z>
return Optional.empty();<z>
hints() {<z>
);<z>
);<z>
throws IOException {<z>
;<z>
) == null) {<z>
);<z>
;<z>
.getBody());<z>
) {<z>
) {<z>
getInsertString() + " with: " + values);<z>
, getInsertTypes());<z>
Context context) {<z>
getResponse());<z>
.getLastModified());<z>
();<z>
) {<z>
).setComplete();<z>
writeToInternal(exchange, context);<z>
void registerAllEndpoints() {<z>
!= null, "No JmsListenerEndpointRegistry set");<z>
{<z>
descriptor : this.endpointDescriptors) {<z>
(<z>
.endpoint, resolveContainerFactory(descriptor));<z>
startImmediately = true;<z>
initRouteMatcher() {<z>
AntPathMatcher();<z>
);<z>
pathMatcher);<z>
CacheOperationInvocationContext<CachePutOperation> context, Object value) {<z>
;<z>
resolveCache(context);<z>
, key, value);<z>
] array) {<z>
if (array == null) {<z>
;<z>
;<z>
) {<z>
;<z>
hash;<z>
private void emitDefaultConstructor(ClassEmitter ce) {<z>
Object> declaredConstructor;<z>
;<z>
(NoSuchMethodException e) {<z>
e);<z>
().transform(declaredConstructor);<z>
Constants.ACC_PUBLIC);<z>
;<z>
.dup();<z>
constructor.getSignature();<z>
.super_invoke_constructor(sig);<z>
e.return_value();<z>
end_method();<z>
{<z>
(this.theme == null) {<z>
RequestContextUtils.getTheme(this.request);<z>
theme == null) {<z>
);<z>
this.theme;<z>
newType) {<z>
(oldType == null) {<z>
;<z>
(newType)) {<z>
return oldType;<z>
?> nextType = newType;<z>
{<z>
if (nextType.isAssignableFrom(oldType)) {<z>
nextType;<z>
getSuperclass();<z>
.getAllInterfacesForClassAsSet(newType)) {<z>
{<z>
;<z>
return Object.class;<z>
public MethodParameter(MethodParameter original) {<z>
(original, "Original must not be null");<z>
.executable;<z>
this.parameterIndex = original.parameterIndex;<z>
;<z>
.nestingLevel;<z>
typeIndexesPerLevel;<z>
;<z>
= original.parameterType;<z>
= original.genericParameterType;<z>
parameterAnnotations;<z>
parameterNameDiscoverer = original.parameterNameDiscoverer;<z>
this.parameterName = original.parameterName;<z>
) {<z>
;<z>
{<z>
);<z>
class == parent) {<z>
child;<z>
;<z>
, Class<?>> typeIdMappings) {<z>
;<z>
.forEach((id, clazz) -> {<z>
id, clazz);<z>
(clazz, id);<z>
;<z>
TextMessage message, WebSocketSession wsSession) throws Exception {<z>
;<z>
payload)) {<z>
] messages;<z>
getMessageCodec().decode(payload);<z>
Exception ex) {<z>
logger.error("Broken data received. Terminating WebSocket connection abruptly", ex);<z>
BAD_DATA);<z>
messages != null) {<z>
messages);<z>
String headerName) {<z>
get(headerName);<z>
values != null) {<z>
<>();<z>
(String value : values) {<z>
) {<z>
.matcher(value);<z>
matcher.find()) {<z>
)) {<z>
(matcher.group());<z>
1));<z>
.isEmpty()) {<z>
new IllegalArgumentException(<z>
;<z>
return result;<z>
return Collections.emptyList();<z>
{<z>
newInstance();<z>
);<z>
());<z>
)) {<z>
;<z>
;<z>
);<z>
XMLStreamException ex) {<z>
(<z>
ex, inputMessage);<z>
, String value) {<z>
assertWithDiagnostics(() -> {<z>
(name);<z>
name).getValue());<z>
);<z>
responseSpec;<z>
(<z>
missingAfterConversion) {<z>
super("", missingAfterConversion);<z>
.cookieName = cookieName;<z>
parameter;<z>
{<z>
;<z>
sessions) {<z>
.setUser(this);<z>
afterDeserialization();<z>
{<z>
() == Void.TYPE) {<z>
;<z>
targetType)) {<z>
;<z>
isAssignableFrom(sourceType.getType())) {<z>
sourceType.getType(), null);<z>
);<z>
();<z>
.getType());<z>
processContextConfiguration(ContextConfigurationAttributes configAttributes) {<z>
) {<z>
;<z>
Object getObject(int columnIndex) throws InvalidResultSetAccessException {<z>
getObject(columnIndex);<z>
se) {<z>
(se);<z>
void bindExplicitArguments(int numArgumentsLeftToBind) {<z>
"No argument names available");<z>
);<z>
;<z>
!= numExpectedArgumentNames) {<z>
IllegalStateException("Expecting to find " + numExpectedArgumentNames +<z>
.length + " arguments.");<z>
= this.parameterTypes.length - numArgumentsLeftToBind;<z>
{<z>
], i);<z>
null) {<z>
.returningName)) {<z>
IllegalStateException("Returning argument name '" + this.returningName +<z>
"' was not bound in advice arguments");<z>
.argumentBindings.get(this.returningName);<z>
index];<z>
)[index];<z>
if (this.throwingName != null) {<z>
{<z>
.throwingName +<z>
;<z>
this.throwingName);<z>
.getParameterTypes()[index];<z>
(this.argumentNames, argumentIndexOffset);<z>
(<z>
requestCallback) {<z>
);<z>
(() -> {<z>
);<z>
<List<ByteBuffer>>>> future =<z>
.ofPublisher());<z>
)<z>
);<z>
}));<z>
actualParams) {<z>
result = new StringBuilder();<z>
hasNext();) {<z>
;<z>
entry.getValue()));<z>
(it.hasNext()) {<z>
(", ");<z>
;<z>
) {<z>
class);<z>
size() + "' while size of expected list is '" +<z>
);<z>
+ modelName + "' is not equal to the expected list.",<z>
;<z>
) {<z>
this == other) {<z>
true;<z>
() != other.getClass()) {<z>
;<z>
DataSize) other;<z>
this.bytes == otherSize.bytes);<z>
{<z>
listeners != null) {<z>
: this.listeners) {<z>
;<z>
@Nullable V value) {<z>
= new ArrayList<>(1);<z>
values.add(value);<z>
, values);<z>
> writeToInternal(ServerWebExchange exchange, Context context) {<z>
, new BodyInserter.Context() {<z>
() {<z>
;<z>
> serverRequest() {<z>
));<z>
> hints() {<z>
.LOG_PREFIX_HINT, exchange.getLogPrefix());<z>
;<z>
;<z>
mediaType) {<z>
parameterizedType)) {<z>
.isAssignableFrom(c));<z>
?> rawType)) {<z>
false;<z>
.class.isAssignableFrom(rawType))) {<z>
;<z>
{<z>
false;<z>
getActualTypeArguments()[0];<z>
typeArgumentClass)) {<z>
false;<z>
(typeArgumentClass);<z>
void unregister(T mapping) {<z>
.lock();<z>
;<z>
(registration == null) {<z>
()) {<z>
);<z>
mappings != null) {<z>
));<z>
(mappings.isEmpty()) {<z>
path);<z>
);<z>
.remove(registration.getHandlerMethod());<z>
;<z>
mappings) {<z>
ignoredMethodMappings = new HashMap<>();<z>
); en.hasMoreElements();) {<z>
);<z>
beanKey));<z>
Arrays.asList(methodNames)));<z>
getCache(String name) {<z>
.get(name);<z>
{<z>
.cacheMap) {<z>
.cacheMap.get(name);<z>
null) {<z>
;<z>
;<z>
;<z>
public void afterPropertiesSet() {<z>
();<z>
.argumentResolvers == null) {<z>
getDefaultArgumentResolvers();<z>
new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);<z>
this.returnValueHandlers == null) {<z>
();<z>
HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);<z>
, EncodedResource resource)<z>
{<z>
, ResourcePropertiesPersister.INSTANCE);<z>
{<z>
.notNull(code, "Code must not be null");<z>
.ENGLISH);<z>
fieldCache.get(codeToUse);<z>
if (val == null) {<z>
, "not found");<z>
;<z>
public String getIncludedUrl() {<z>
size();<z>
count <= 1,<z>
-> "More than 1 URL included - check getIncludedUrls instead: " + this.includedUrls);<z>
) : null);<z>
String etag) {<z>
(etag)) {<z>
;<z>
) {<z>
return etag;<z>
"\"";<z>
) {<z>
CONTENT_TYPE_PROPERTY.equals(propertyName)) {<z>
;<z>
return super.toHeaderName(propertyName);<z>
{<z>
.headers;<z>
(headers == null) {<z>
= new HttpHeaders();<z>
names()) {<z>
) {<z>
;<z>
this.headers = headers;<z>
;<z>
headerDoesNotExist(String name) {<z>
{<z>
().get(name);<z>
(headerValues != null) {<z>
fail("Expected header <" + name + "> not to exist, but it exists with values: " +<z>
);<z>
(String relativeUrl) {<z>
url = getContextPath() + relativeUrl;<z>
this.response != null) {<z>
(url);<z>
return url;<z>
> reactiveType, boolean multiValue, boolean noValue,<z>
{<z>
, true);<z>
(MockMvc mockMvc) {<z>
;<z>
;<z>
));<z>
<T> providedMessage) {<z>
notNull(providedMessage, "Message must not be null");<z>
);<z>
providedMessage = providedMessage;<z>
new MessageHeaderAccessor(providedMessage);<z>
{<z>
null) {<z>
;<z>
());<z>
();<z>
Object swap(Object newTarget) throws IllegalArgumentException {<z>
);<z>
.target;<z>
.target = newTarget;<z>
return old;<z>
> attributes) {<z>
if (attributes != null) {<z>
this.staticAttributes.putAll(attributes);<z>
(<z>
) {<z>
, null, headers, status, request);<z>
DataBuffer> T retain(T dataBuffer) {<z>
(dataBuffer instanceof PooledDataBuffer) {<z>
).retain();<z>
return dataBuffer;<z>
{<z>
{<z>
.close();<z>
{<z>
, ex);<z>
{<z>
ex);<z>
(Constructor<?> ctor, String attributeName,<z>
exchange) {<z>
.getParameterCount() == 0) {<z>
));<z>
exchange, null, attributeName);<z>
map(bindValues -> {<z>
);<z>
getParameterTypes();<z>
args = new Object[paramTypes.length];<z>
;<z>
fieldMarkerPrefix = binder.getFieldMarkerPrefix();<z>
< paramNames.length; i++) {<z>
;<z>
> paramType = paramTypes[i];<z>
bindValues.get(paramName);<z>
) {<z>
(fieldDefaultPrefix != null) {<z>
bindValues.get(fieldDefaultPrefix + paramName);<z>
value == null && fieldMarkerPrefix != null) {<z>
{<z>
;<z>
;<z>
, i);<z>
== null && methodParam.isOptional()) {<z>
() : null);<z>
methodParam);<z>
BeanUtils.instantiateClass(ctor, args);<z>
});<z>
@Nullable String value) {<z>
) {<z>
key, value);<z>
key);<z>
beanName) {<z>
getCacheKey(beanClass, beanName);<z>
{<z>
) {<z>
return null;<z>
shouldSkip(beanClass, beanName)) {<z>
Boolean.FALSE);<z>
return null;<z>
getCustomTargetSource(beanClass, beanName);<z>
(targetSource != null) {<z>
) {<z>
.targetSourcedBeans.add(beanName);<z>
beanName, targetSource);<z>
;<z>
, proxy.getClass());<z>
proxy;<z>
null;<z>
{<z>
;<z>
catch (SQLException se) {<z>
);<z>
{<z>
!= null) {<z>
();<z>
if (hasNamespacesFeature()) {<z>
(), toQualifiedName(qName));<z>
); i++) {<z>
;<z>
{<z>
;<z>
(prefix);<z>
, "", toQualifiedName(qName));<z>
, Locale locale) {<z>
this.cachedFilenames.get(basename);<z>
) {<z>
;<z>
null) {<z>
return filenames;<z>
<>(7);<z>
addAll(calculateFilenamesForLocale(basename, locale));<z>
defaultLocale = getDefaultLocale();<z>
.equals(locale)) {<z>
;<z>
for (String fallbackFilename : fallbackFilenames) {<z>
) {<z>
fallbackFilename);<z>
);<z>
if (localeMap == null) {<z>
();<z>
(basename, localeMap);<z>
!= null) {<z>
= existing;<z>
(locale, filenames);<z>
return filenames;<z>
{<z>
mv, cf);<z>
getLeftOperand().exitTypeDescriptor;<z>
;<z>
, "No exit type descriptor");<z>
charAt(0);<z>
;<z>
this.children.length > 1) {<z>
);<z>
;<z>
= getRightOperand().exitTypeDescriptor;<z>
exitCompilationScope();<z>
insertNumericUnboxOrPrimitiveTypeCoercion(mv, rightDesc, targetDesc);<z>
{<z>
'I':<z>
);<z>
'J':<z>
mv.visitInsn(LSUB);<z>
'F':<z>
visitInsn(FSUB);<z>
case 'D':<z>
DSUB);<z>
(<z>
+ this.exitTypeDescriptor + "'");<z>
(targetDesc) {<z>
case 'I':<z>
mv.visitInsn(INEG);<z>
'J':<z>
LNEG);<z>
case 'F':<z>
FNEG);<z>
case 'D':<z>
);<z>
IllegalStateException(<z>
"'");<z>
cf.pushDescriptor(this.exitTypeDescriptor);<z>
) {<z>
jndiName = DEFAULT_USER_TRANSACTION_NAME;<z>
);<z>
(logger.isDebugEnabled()) {<z>
+ "]");<z>
= true;<z>
;<z>
{<z>
) {<z>
);<z>
;<z>
Mono<Void> triggerBeforeCommit(TransactionSynchronizationManager synchronizationManager,<z>
) {<z>
isNewSynchronization()) {<z>
return TransactionSynchronizationUtils.triggerBeforeCommit(<z>
, status.isReadOnly());<z>
empty();<z>
, final CallMetaDataContext context) {<z>
dataSource, databaseMetaData -> {<z>
);<z>
= context.isAccessCallParameterMetaData();<z>
)) {<z>
supportedDatabaseProductsForFunctions.contains(databaseProductName)) {<z>
()) {<z>
logger.info(databaseProductName + " is not one of the databases fully supported for function calls " +<z>
supportedDatabaseProductsForFunctions);<z>
{<z>
"Metadata processing disabled - you must specify all parameters explicitly");<z>
= false;<z>
supportedDatabaseProductsForProcedures.contains(databaseProductName)) {<z>
) {<z>
info(databaseProductName + " is not one of the databases fully supported for procedure calls " +<z>
;<z>
(accessProcedureColumnMetaData) {<z>
);<z>
false;<z>
CallMetaDataProvider provider;<z>
("Oracle".equals(databaseProductName)) {<z>
databaseMetaData);<z>
(databaseProductName)) {<z>
PostgresCallMetaDataProvider((databaseMetaData));<z>
("Apache Derby".equals(databaseProductName)) {<z>
);<z>
(databaseProductName)) {<z>
new Db2CallMetaDataProvider((databaseMetaData));<z>
if ("HDB".equals(databaseProductName)) {<z>
new HanaCallMetaDataProvider((databaseMetaData));<z>
)) {<z>
new SqlServerCallMetaDataProvider((databaseMetaData));<z>
)) {<z>
));<z>
= new GenericCallMetaDataProvider(databaseMetaData);<z>
)) {<z>
).getName());<z>
databaseMetaData);<z>
{<z>
,<z>
getProcedureName());<z>
provider;<z>
});<z>
catch (MetaDataAccessException ex) {<z>
throw new DataAccessResourceFailureException("Error retrieving database meta-data", ex);<z>
) {<z>
if (this.target == null) {<z>
() + "'");<z>
this.target);<z>
{<z>
ApplicationContext context = obtainApplicationContext();<z>
!context.containsBean(viewName)) {<z>
null;<z>
)) {<z>
isDebugEnabled()) {<z>
;<z>
;<z>
.class);<z>
collection) {<z>
();<z>
) {<z>
IllegalStateException(<z>
;<z>
;<z>
== null) {<z>
throw new IllegalStateException(<z>
);<z>
value;<z>
) {<z>
); i++) {<z>
(i);<z>
;<z>
contains(attribute)) {<z>
);<z>
format(<z>
describe(target)));<z>
() {<z>
) {<z>
;<z>
);<z>
> mappingFunction) {<z>
key);<z>
{<z>
;<z>
{<z>
return oldKeyValue;<z>
key = oldKey;<z>
.targetMap.computeIfAbsent(key, mappingFunction);<z>
public String getSubtypeSuffix() {<z>
);<z>
) > suffixIndex) {<z>
1);<z>
return null;<z>
{<z>
;<z>
enabled && populator != null) {<z>
populator, this.dataSource);<z>
HandlerMethodReturnValueHandler> initReturnValueHandlers() {<z>
= new ArrayList<>();<z>
ListenableFutureReturnValueHandler());<z>
(new CompletableFutureReturnValueHandler());<z>
(reactorPresent) {<z>
;<z>
=<z>
.brokerTemplate, true);<z>
headerInitializer);<z>
);<z>
SubscriptionMethodReturnValueHandler subscriptionHandler =<z>
.clientMessagingTemplate);<z>
setHeaderInitializer(this.headerInitializer);<z>
(subscriptionHandler);<z>
;<z>
);<z>
headerInitializer);<z>
handlers.add(sendToHandler);<z>
handlers;<z>
peerCertificates) {<z>
, "No SSL certificates");<z>
;<z>
this.peerCertificates = peerCertificates;<z>
<String, CorsConfiguration> configMap) {<z>
corsConfigurations.clear();<z>
{<z>
);<z>
(Publisher<? extends ResourceRegion> publisher,<z>
hints) {<z>
regionEncoder.encode(<z>
, hints);<z>
;<z>
void setMaxMessagesPerTask(int maxMessagesPerTask) {<z>
maxMessagesPerTask != 0, "'maxMessagesPerTask' must not be 0");<z>
this.lifecycleMonitor) {<z>
.maxMessagesPerTask = maxMessagesPerTask;<z>
(Message<?> message) {<z>
.getHeaders().get(LOOKUP_DESTINATION_HEADER);<z>
{<z>
return null;<z>
()) {<z>
;<z>
List<String> matches = null;<z>
this.patterns) {<z>
, destination)) {<z>
null) {<z>
;<z>
pattern);<z>
.isEmpty(matches)) {<z>
return null;<z>
destination));<z>
), this.routeMatcher);<z>
public DefaultServerEndpointConfig(String path, Endpoint endpoint) {<z>
.hasText(path, "path must not be empty");<z>
);<z>
= path;<z>
.endpoint = endpoint;<z>
TypedValue getValueInternal(ExpressionState state) throws EvaluationException {<z>
);<z>
lvalue = operand.getValueRef(state);<z>
lvalue.getValue();<z>
operandValue = operandTypedValue.getValue();<z>
TypedValue returnValue = operandTypedValue;<z>
;<z>
Number op1) {<z>
BigDecimal bigDecimal) {<z>
operandTypedValue.getTypeDescriptor());<z>
Double) {<z>
());<z>
{<z>
.getTypeDescriptor());<z>
else if (op1 instanceof BigInteger bigInteger) {<z>
, operandTypedValue.getTypeDescriptor());<z>
op1 instanceof Long) {<z>
, operandTypedValue.getTypeDescriptor());<z>
Integer) {<z>
());<z>
) {<z>
getTypeDescriptor());<z>
instanceof Byte) {<z>
.getTypeDescriptor());<z>
1.0d, operandTypedValue.getTypeDescriptor());<z>
(newValue == null) {<z>
getValue(), 1);<z>
catch (SpelEvaluationException ex) {<z>
() == SpelMessage.OPERATOR_NOT_SUPPORTED_BETWEEN_TYPES) {<z>
SpelEvaluationException(operand.getStartPosition(),<z>
));<z>
ex;<z>
.getValue());<z>
SpelEvaluationException see) {<z>
) {<z>
),<z>
);<z>
throw see;<z>
this.postfix) {<z>
;<z>
returnValue;<z>
) {<z>
.pos;<z>
.pos++;<z>
.pos]));<z>
start, this.pos);<z>
this.pos - start) == 3) {<z>
String(subarray).toUpperCase();<z>
Arrays.binarySearch(ALTERNATIVE_OPERATOR_NAMES, asString);<z>
(idx >= 0) {<z>
), start, subarray);<z>
));<z>
send(Publisher<WebSocketMessage> messages) {<z>
)) {<z>
;<z>
this.sendProcessor = sendProcessor;<z>
-> {<z>
messages.subscribe(sendProcessor);<z>
(subscriber);<z>
;<z>
;<z>
) throws EvaluationException {<z>
;<z>
getValue();<z>
children.length - 1].exitTypeDescriptor;<z>
result;<z>
> newInstance(<z>
conversionService) {<z>
newInstance(requiredType);<z>
;<z>
return rowMapper;<z>
>> RequestHeadersSpec<?> body(<z>
) {<z>
fromPublisher(publisher, elementTypeRef);<z>
;<z>
) throws MBeanExportException {<z>
(managedResource, "Managed resource must not be null");<z>
notNull(objectName, "ObjectName must not be null");<z>
{<z>
);<z>
getClass().getName());<z>
objectName);<z>
mbean, objectName);<z>
JMException ex) {<z>
throw new UnableToRegisterMBeanException(<z>
+ objectName + "]", ex);<z>
Class<T> beanClass,<z>
) {<z>
, supplier, customizers);<z>
classLoader, @Nullable Object source,<z>
>> consumer) {<z>
(SpringAsmInfo.ASM_VERSION);<z>
.classLoader = classLoader;<z>
this.source = source;<z>
.annotationType = annotationType;<z>
consumer;<z>
throws IOException {<z>
.buffer);<z>
);<z>
) {<z>
allocateBuffer(read);<z>
0, read);<z>
return dataBuffer;<z>
1) {<z>
return EOF_BUFFER;<z>
return null;<z>
{<z>
(this.concurrencyLimit == NO_CONCURRENCY) {<z>
IllegalStateException(<z>
"Currently no invocations allowed - concurrency limit set to NO_CONCURRENCY");<z>
.concurrencyLimit > 0) {<z>
isDebugEnabled();<z>
this.monitor) {<z>
= false;<z>
this.concurrencyLimit) {<z>
interrupted) {<z>
new IllegalStateException("Thread was interrupted while waiting for invocation access, " +<z>
);<z>
debug) {<z>
("Concurrency count " + this.concurrencyCount +<z>
concurrencyLimit + " - blocking");<z>
wait();<z>
{<z>
Thread.currentThread().interrupt();<z>
;<z>
) {<z>
debug("Entering throttle at concurrency count " + this.concurrencyCount);<z>
;<z>
{<z>
;<z>
();<z>
)) {<z>
();<z>
httpFields.getValues(name);<z>
.hasMoreElements()) {<z>
values.nextElement();<z>
value);<z>
responseHeaders;<z>
modelName) {<z>
.model.get(modelName);<z>
(modelObject == null) {<z>
getAttribute(modelName);<z>
;<z>
public ServerResponse.BodyBuilder cookie(ResponseCookie cookie) {<z>
.notNull(cookie, "ResponseCookie must not be null");<z>
getName(), cookie);<z>
this;<z>
Nullable String nameSuffix) {<z>
ENGLISH) : "");<z>
> names = new HashSet<>();<z>
: this.fieldCache.keySet()) {<z>
endsWith(suffixToUse)) {<z>
);<z>
;<z>
> annotationType) {<z>
.notNull(annotationType, "'annotationType' must not be null");<z>
= annotationType;<z>
.getName();<z>
(Resource resource) {<z>
= resource.getDescription();<z>
) {<z>
+ "@" + System.identityHashCode(resource);<z>
return name;<z>
ClassLoader classLoader) {<z>
scriptEngineManager;<z>
null) {<z>
(classLoader);<z>
scriptEngineManager;<z>
= this.globalBindings;<z>
null) {<z>
(bindings);<z>
value) {<z>
{<z>
BindingResult.MODEL_KEY_PREFIX)) {<z>
attributeName;<z>
) get(bindingResultKey);<z>
!= value) {<z>
remove(bindingResultKey);<z>
?> rowMapper) {<z>
parameterName, rowMapper);<z>
()) {<z>
+ "]: " + parameterName);<z>
, T builder) {<z>
element.getAttribute("cache");<z>
;<z>
cache)) {<z>
(cache.trim());<z>
(localCaches != null) {<z>
.setCacheNames(localCaches);<z>
(), element);<z>
;<z>
.keyGenerator));<z>
, this.cacheManager));<z>
condition));<z>
())) {<z>
throw new IllegalStateException("Invalid cache advice configuration on '" +<z>
toString() + "'. Both 'key' and 'keyGenerator' attributes have been set. " +<z>
;<z>
return builder;<z>
{<z>
long l1 = readInt(offset);<z>
= readInt(offset + 4) & 0xFFFFFFFFL;<z>
<< 32) | l0;<z>
ResponseEntity<Void>> toBodilessEntity() {<z>
this.responseMono.flatMap(response -><z>
>empty()))<z>
.releaseBody()<z>
WRAP_EXCEPTION_PREDICATE, exceptionWrappingFunction(response))<z>
entity))<z>
Object producer, Class<?> elementClass) {<z>
);<z>
);<z>
getClass());<z>
;<z>
), ResolvableType.forClass(elementClass));<z>
this;<z>
public ReflectiveLoadTimeWeaver(@Nullable ClassLoader classLoader) {<z>
.notNull(classLoader, "ClassLoader must not be null");<z>
classLoader;<z>
getMethodIfAvailable(<z>
ADD_TRANSFORMER_METHOD_NAME, ClassFileTransformer.class);<z>
null) {<z>
IllegalStateException(<z>
"] does NOT provide an " +<z>
"'addTransformer(ClassFileTransformer)' method.");<z>
= addTransformerMethod;<z>
(<z>
(), GET_THROWAWAY_CLASS_LOADER_METHOD_NAME);<z>
(getThrowawayClassLoaderMethod == null) {<z>
.isDebugEnabled()) {<z>
getName() + "] does NOT provide a " +<z>
;<z>
getThrowawayClassLoaderMethod = getThrowawayClassLoaderMethod;<z>
, String domain) {<z>
-> {<z>
);<z>
domain, cookie.getDomain());<z>
) {<z>
;<z>
()) {<z>
param.getValue();<z>
.getAllParameters().length - 1 &&<z>
)) {<z>
(CollectionUtils.arrayToList(value));<z>
parameters.add(value);<z>
.toArray());<z>
public String getLogPrefix() {<z>
(LOG_ID_ATTRIBUTE);<z>
if (this.logId != value) {<z>
value;<z>
: "";<z>
.logPrefix;<z>
void clearResources() {<z>
) {<z>
synchronized (sharedConnectionMonitor) {<z>
this.consumer);<z>
this.session);<z>
.consumer);<z>
this.session);<z>
(this.consumer != null) {<z>
{<z>
--;<z>
;<z>
;<z>
getBrokerRegistry(<z>
, AbstractSubscribableChannel clientOutboundChannel) {<z>
this.brokerRegistry == null) {<z>
;<z>
registry);<z>
brokerRegistry = registry;<z>
brokerRegistry;<z>
other) {<z>
this == other) {<z>
return true;<z>
.equals(other)) {<z>
false;<z>
.TRUE;<z>
;<z>
ClassFilterAwareUnionMethodMatcher cfa) {<z>
cf1;<z>
cf2;<z>
));<z>
<Route> regexRoute() {<z>
(<z>
Route("/blog/{year:\\\\d+}/{month:\\\\d+}/{day:\\\\d+}/{slug}",<z>
,<z>
,<z>
),<z>
new Route("/user/{name:[a-z]+}",<z>
"/user/example", "/user/spring")<z>
(String property) {<z>
.hasLength(property)) {<z>
= "";<z>
isToggleAscendingOnProperty()) {<z>
property) || !this.ascending);<z>
.property = property;<z>
HttpHeaders parseHeaders() {<z>
this.buffers.isEmpty()) {<z>
HttpHeaders.EMPTY;<z>
.buffers);<z>
buffers.clear();<z>
toString(MultipartParser.this.headersCharset);<z>
(joined);<z>
(HEADER_ENTRY_SEPARATOR);<z>
result = new HttpHeaders();<z>
lines) {<z>
.indexOf(':');<z>
) {<z>
.substring(0, idx);<z>
);<z>
) {<z>
1);<z>
value);<z>
return result;<z>
private SpelNodeImpl eatDottedNode() {<z>
t = takeToken();<z>
);<z>
||<z>
maybeEatSelection(nullSafeNavigation)) {<z>
();<z>
) == null) {<z>
.startPos, SpelMessage.OOD);<z>
toString(peekToken()));<z>
) {<z>
("name", "juergen");<z>
;<z>
new GenericApplicationContext();<z>
;<z>
SCOPE_PROTOTYPE);<z>
;<z>
.add("country", "#{systemProperties.country}");<z>
, rbd);<z>
);<z>
JMSException {<z>
.get();<z>
) {<z>
threadCredentials.username, threadCredentials.password);<z>
);<z>
{<z>
!this.event.isStartElement()) {<z>
new IllegalStateException();<z>
int count = 0;<z>
getAttributes();<z>
hasNext()) {<z>
= (Attribute) attributes.next();<z>
== index) {<z>
;<z>
;<z>
);<z>
Resource location) {<z>
);<z>
(location, "'location' must not be null");<z>
= PathPatternParser.defaultInstance.parse(pattern);<z>
= location;<z>
MethodVisitor mv, CodeFlow cf) {<z>
Label();<z>
;<z>
);<z>
mv, cf);<z>
(mv);<z>
();<z>
IFEQ, elseTarget);<z>
.visitLdcInsn(1);<z>
,endOfIf);<z>
;<z>
enterCompilationScope();<z>
);<z>
mv);<z>
;<z>
endOfIf);<z>
.exitTypeDescriptor);<z>
inputStream,<z>
, @Nullable MediaType mediaType, ReactiveHttpOutputMessage outputMessage,<z>
> hints) {<z>
return Mono.from(inputStream)<z>
.flatMap(map -> {<z>
map, mediaType)) {<z>
outputMessage, mediaType, hints);<z>
("unchecked")<z>
) map);<z>
, elementType, mediaType, outputMessage, hints);<z>
);<z>
TemplateLoader getAggregateTemplateLoader(List<TemplateLoader> templateLoaders) {<z>
size()) {<z>
0:<z>
"No FreeMarker TemplateLoaders specified");<z>
return null;<z>
:<z>
templateLoaders.get(0);<z>
;<z>
;<z>
enclosingClassLoader, boolean defaultExcludes) {<z>
;<z>
;<z>
{<z>
{<z>
excludePackage(excludedPackage);<z>
source) {<z>
)) {<z>
.class);<z>
(source);<z>
.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
beanDef);<z>
.THEME_RESOLVER_BEAN_NAME));<z>
containerEle, ParserContext parserContext,<z>
commonContainerProperties, PropertyValues specificContainerProperties) {<z>
RootBeanDefinition();<z>
("org.springframework.jms.config.DefaultJcaListenerContainerFactory");<z>
);<z>
).addPropertyValues(specificContainerProperties);<z>
factoryDef;<z>
contentHandler, @Nullable LexicalHandler lexicalHandler)<z>
XmlMappingException {<z>
;<z>
);<z>
saxWriter, null);<z>
S, T> converter) {<z>
);<z>
);<z>
.comparator = comparator;<z>
this.converter = converter;<z>
, String destination, Object payload,<z>
@Nullable MessagePostProcessor postProcessor)<z>
{<z>
(user, "User must not be null");<z>
"%2F"), "Invalid sequence \"%2F\" in user name: " + user);<z>
"/", "%2F");<z>
: "/" + destination;<z>
destination, payload, headers, postProcessor);<z>
protected ServletServerHttpResponse createResponse(HttpServletResponse response,<z>
ServletServerHttpRequest request) throws IOException {<z>
TomcatServerHttpResponse(<z>
(), request);<z>
{<z>
.cachedFormat;<z>
(messageFormat == null) {<z>
.locale);<z>
cachedFormat = messageFormat;<z>
return messageFormat;<z>
Object> resolveArgument(<z>
exchange) {<z>
getArgumentResolver(parameter);<z>
if (resolver == null) {<z>
new IllegalArgumentException("Unsupported parameter type [" +<z>
.getName() + "]. supportsParameter should be called first.");<z>
exchange);<z>
getSingleGeneric(ResolvableType resolvableType) {<z>
length == 1,<z>
"Expected 1 type argument on generic interface [" + resolvableType +<z>
length);<z>
.getGeneric().resolve();<z>
{<z>
, databaseMetaData -> {<z>
);<z>
;<z>
)) {<z>
(<z>
;<z>
("PostgreSQL".equals(databaseProductName)) {<z>
;<z>
if ("Apache Derby".equals(databaseProductName)) {<z>
DerbyTableMetaDataProvider(databaseMetaData);<z>
databaseProductName)) {<z>
HsqlTableMetaDataProvider(databaseMetaData);<z>
new GenericTableMetaDataProvider(databaseMetaData);<z>
logger.isDebugEnabled()) {<z>
));<z>
(databaseMetaData);<z>
if (context.isAccessTableColumnMetaData()) {<z>
provider.initializeWithTableColumnMetaData(databaseMetaData,<z>
);<z>
provider;<z>
);<z>
catch (MetaDataAccessException ex) {<z>
DataAccessResourceFailureException("Error retrieving database meta-data", ex);<z>
<K, V> generator) {<z>
"Cache size limit must not be negative");<z>
Assert.notNull(generator, "Generator function must not be null");<z>
;<z>
.generator = generator;<z>
spouse1, TestBean spouse2, IndexedTestBean other) {<z>
;<z>
spouse2 = spouse2;<z>
other = other;<z>
super Void> subscriber) {<z>
rsWriteResultLogger.isTraceEnabled()) {<z>
+ "got subscriber " + subscriber);<z>
().subscribe(this, subscriber);<z>
public void resetConnection() {<z>
this.connectionMonitor) {<z>
);<z>
this.target = null;<z>
this.connection = null;<z>
servletContext) {<z>
= getCharset();<z>
).name();<z>
;<z>
();<z>
=<z>
path != null ? path : ""));<z>
(request, this.parentBuilder);<z>
();<z>
"");<z>
);<z>
);<z>
content(request, charset);<z>
(request, uriComponents);<z>
;<z>
request);<z>
;<z>
request);<z>
;<z>
uriComponents);<z>
request);<z>
request.setProtocol("HTTP/1.1");<z>
.setQueryString(uriComponents.getQuery());<z>
scheme = uriComponents.getScheme();<z>
!= null ? scheme : "");<z>
request.setPathInfo(null);<z>
);<z>
, @Nullable RSocket rsocket,<z>
strategies) {<z>
!= null || rsocket != null, "RSocketClient or RSocket is required");<z>
Assert.notNull(dataMimeType, "'dataMimeType' is required");<z>
"'metadataMimeType' is required");<z>
Assert.notNull(strategies, "RSocketStrategies is required");<z>
;<z>
;<z>
dataMimeType = dataMimeType;<z>
metadataMimeType;<z>
;<z>
);<z>
{<z>
);<z>
;<z>
setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
return beanDefinition;<z>
updateFrom(Collection<Method> aliases) {<z>
;<z>
int size = 0;<z>
int last = -1;<z>
i++) {<z>
);<z>
) {<z>
;<z>
{<z>
{<z>
);<z>
.assigned[last] = mirrorSet;<z>
this.assigned[i] = mirrorSet;<z>
;<z>
!= null) {<z>
);<z>
;<z>
;<z>
EMPTY_MIRROR_SETS);<z>
variables,<z>
PathPattern pattern) {<z>
variables);<z>
put(RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE,<z>
pathVariables));<z>
mergePatterns(<z>
).get(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE),<z>
);<z>
;<z>
attributeErrorCount(String name, int expectedCount) {<z>
result -> {<z>
(result);<z>
(mav, name);<z>
,<z>
errors.getErrorCount());<z>
msg) {<z>
Assert.notNull(code, "Code must not be null");<z>
, "Locale must not be null");<z>
.notNull(msg, "Message must not be null");<z>
msg, locale));<z>
.isDebugEnabled()) {<z>
code + "] and Locale [" + locale + "]");<z>
{<z>
.mediaTypes == null) {<z>
;<z>
.clear();<z>
this.mediaTypes.putAll(mediaTypes);<z>
, ClientHttpResponse response) throws IOException {<z>
= getErrorHandler();<z>
hasError(response);<z>
isDebugEnabled()) {<z>
getRawStatusCode();<z>
HttpStatus.resolve(code);<z>
code));<z>
(IOException ex) {<z>
if (hasError) {<z>
url, method, response);<z>
rootObject, @Nullable Class<T> desiredResultType)<z>
{<z>
Object value = getValue(context,rootObject);<z>
), desiredResultType);<z>
<String> getMetaAnnotationTypes(String annotationName) {<z>
, MergedAnnotation::isDirectlyPresent);<z>
if (!annotation.isPresent()) {<z>
return Collections.emptySet();<z>
), SearchStrategy.INHERITED_ANNOTATIONS).stream()<z>
).getName())<z>
);<z>
, ClassNotFoundException {<z>
defaultReadObject();<z>
(this.methodName, this.parameterTypes);<z>
catch (NoSuchMethodException ex) {<z>
);<z>
public ConfigurableObjectInputStream(<z>
{<z>
;<z>
= classLoader;<z>
.acceptProxyClasses = acceptProxyClasses;<z>
{<z>
) {<z>
getOrder();<z>
;<z>
int counter) {<z>
placeholders.size()) {<z>
();<z>
;<z>
{<z>
getMapValueTypeDescriptor() != null) {<z>
.forObject(newValue),<z>
this.mapEntryDescriptor.getMapValueTypeDescriptor());<z>
, newValue);<z>
(ObjectInputStream ois) throws IOException, ClassNotFoundException {<z>
defaultReadObject();<z>
.proxyClassLoader = ClassUtils.getDefaultClassLoader();<z>
key, int hash, Restructure restructure) {<z>
) {<z>
;<z>
0) {<z>
;<z>
= this.references;<z>
);<z>
];<z>
);<z>
public StubMvcResult(MockHttpServletRequest request,<z>
,<z>
interceptors,<z>
,<z>
,<z>
,<z>
response) {<z>
;<z>
this.handler = handler;<z>
.interceptors = interceptors;<z>
resolvedException = resolvedException;<z>
;<z>
flashMap = flashMap;<z>
this.response = response;<z>
(PropertyAccessException ex, BindingResult bindingResult) {<z>
field = ex.getPropertyName();<z>
field != null, "No field in exception");<z>
getErrorCode(), field);<z>
field);<z>
();<z>
rejectedValue)) {<z>
(ObjectUtils.toObjectArray(rejectedValue));<z>
true,<z>
);<z>
;<z>
(error);<z>
{<z>
this.bufferedOutput.toByteArray();<z>
() < 0) {<z>
;<z>
(headers, bytes);<z>
.bufferedOutput = new ByteArrayOutputStream(0);<z>
result;<z>
@Nullable String beanName, BeanFactory owner,<z>
?> ctor, Object... args) {<z>
()) {<z>
BeanUtils.instantiateClass(ctor, args);<z>
, ctor, args);<z>
(<z>
includeNonSingletons, boolean allowEagerInit) {<z>
, "ListableBeanFactory must not be null");<z>
);<z>
if (lbf instanceof HierarchicalBeanFactory hbf) {<z>
.getParentBeanFactory() instanceof ListableBeanFactory) {<z>
= beanNamesForTypeIncludingAncestors(<z>
(), type, includeNonSingletons, allowEagerInit);<z>
;<z>
;<z>
text) throws IllegalArgumentException {<z>
StringUtils.hasLength(text)) {<z>
null);<z>
) {<z>
);<z>
isUnicodeCharacterSequence(text)) {<z>
);<z>
text.length() == 1) {<z>
setValue(text.charAt(0));<z>
IllegalArgumentException("String [" + text + "] with length " +<z>
) + " cannot be converted to char type: neither Unicode nor single character");<z>
, @Nullable TaskDecorator taskDecorator, Runnable runnable)<z>
throws RejectedExecutionException{<z>
(runnable) : runnable);<z>
public WebContentInterceptor(PathPatternParser parser) {<z>
(false);<z>
patternParser = parser;<z>
{<z>
= 0;<z>
.remoteRegistries.values()) {<z>
;<z>
userCount += this.localRegistry.getUserCount();<z>
;<z>
propertySources) {<z>
.addLast(<z>
()));<z>
propertySources.addLast(<z>
(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));<z>
translateException(String task, SQLException ex) {<z>
translate(task, null, ex);<z>
null) {<z>
;<z>
return super.translateException(task, ex);<z>
clientOutboundChannelExecutor() {<z>
getClientOutboundChannelRegistration().taskExecutor();<z>
();<z>
setThreadNamePrefix("clientOutboundChannel-");<z>
return executor;<z>
> getRollbackRules() {<z>
this.rollbackRules == null) {<z>
();<z>
;<z>
() {<z>
== null) {<z>
();<z>
);<z>
.requestUri;<z>
afterConcurrentHandlingStarted(WebRequest request) {<z>
{<z>
TransactionSynchronizationManager.unbindResource(obtainEntityManagerFactory());<z>
<Runnable> callbacks) {<z>
for (Runnable runnable : callbacks) {<z>
.run();<z>
) {<z>
HttpHeaders getHeaders() {<z>
if (this.readOnlyHeaders != null) {<z>
return this.readOnlyHeaders;<z>
.COMMITTED) {<z>
headers);<z>
return this.readOnlyHeaders;<z>
this.headers;<z>
HttpServletRequest request) {<z>
, "No ContentNegotiationManager set");<z>
;<z>
.resolveMediaTypes(webRequest);<z>
<MediaType> producibleMediaTypes = getProducibleMediaTypes(request);<z>
> compatibleMediaTypes = new LinkedHashSet<>();<z>
MediaType acceptable : acceptableMediaTypes) {<z>
MediaType producible : producibleMediaTypes) {<z>
) {<z>
producible));<z>
>(compatibleMediaTypes);<z>
);<z>
return selectedMediaTypes;<z>
{<z>
isDebugEnabled()) {<z>
());<z>
;<z>
? extends AnnotationMirror> getAllAnnotationMirrors(Element e) {<z>
).getAllAnnotationMirrors(e);<z>
catch (Exception ex) {<z>
emptyList();<z>
(ObjectWriter writer, @Nullable MimeType mimeType,<z>
> hints) {<z>
writer;<z>
ServletContext servletContext) {<z>
();<z>
.hasMoreElements()) {<z>
nextElement();<z>
{<z>
;<z>
attrValue instanceof DisposableBean) {<z>
);<z>
{<z>
()) {<z>
+<z>
ex);<z>
(<z>
) {<z>
{<z>
value);<z>
;<z>
) {<z>
, htmlEscape);<z>
(Throwable ex) {<z>
;<z>
{<z>
)<z>
{<z>
(header);<z>
matcher.group(1) : null);<z>
sameSite));<z>
(LinkedMultiValueMap::new,<z>
), cookie),<z>
);<z>
ReactiveAdapterRegistry adapterRegistry,<z>
boolean useDefaultResolution) {<z>
;<z>
useDefaultResolution = useDefaultResolution;<z>
) {<z>
return (this.pathPattern != null ?<z>
.lookupPathContainer).getUriVariables() :<z>
);<z>
<?>... paramTypes) {<z>
getMethod(methodName, paramTypes);<z>
(NoSuchMethodException ex) {<z>
;<z>
void setPreferredLocales(List<Locale> locales) {<z>
(locales, "Locale list must not be empty");<z>
clear();<z>
;<z>
();<z>
length) throws SAXException {<z>
));<z>
XMLStreamException ex) {<z>
SAXException(<z>
ex);<z>
elementTypeRef) {<z>
.notNull(elementTypeRef, "ParameterizedTypeReference must not be null");<z>
response -><z>
(elementTypeRef)));<z>
(Object o) {<z>
(this == o) {<z>
return true;<z>
(o instanceof Pojo) {<z>
= (Pojo) o;<z>
.bar.equals(other.bar);<z>
false;<z>
(@Nullable List<?> beans) {<z>
!= null) {<z>
{<z>
ObjectUtils.getIdentityHexString(bean);<z>
name, bean);<z>
[] findAllClassPathResources(String location) throws IOException {<z>
path = location;<z>
("/")) {<z>
1);<z>
Resource> result = doFindAllClassPathResources(path);<z>
isTraceEnabled()) {<z>
location + "] to resources " + result);<z>
Resource[0]);<z>
extends Part> parts,<z>
ReactiveHttpOutputMessage outputMessage,<z>
> hints) {<z>
();<z>
);<z>
;<z>
()) {<z>
getLogPrefix(hints) + "Encoding Publisher<Part>");<z>
parts)<z>
, part, outputMessage.bufferFactory()))<z>
)))<z>
release);<z>
) {<z>
buffer, hints, logger));<z>
);<z>
mediaType) {<z>
(STREAMING_TIMEOUT_VALUE) {<z>
protected void extendResponse(ServerHttpResponse outputMessage) {<z>
;<z>
() {<z>
doFinally();<z>
.tagWriter = null;<z>
.pageContext.removeAttribute(LIST_VALUE_PAGE_ATTRIBUTE);<z>
String requestedPath) throws IOException {<z>
requestedPath)) {<z>
overrides.get(requestedPath);<z>
overriddenLocation != null ?<z>
EMPTY_URL_ENUMERATION);<z>
(requestedPath);<z>
matcher) {<z>
-> {<z>
getResponse();<z>
response), matcher);<z>
{<z>
) {<z>
.super.getAllAnnotationAttributes(annotationName, classValuesAsString);<z>
getAllAnnotationAttributes(this.introspectedMethod,<z>
);<z>
ctor) {<z>
ctor.getDeclaringClass())) {<z>
;<z>
= ReflectJvmMapping.getKotlinFunction(ctor);<z>
.getParameters()) : null);<z>
ex) {<z>
return null;<z>
) {<z>
(objectMapper, "ObjectMapper must not be null");<z>
objectMapper;<z>
configurePrettyPrint();<z>
T> task) {<z>
== null && this.concurrentExecutor instanceof ExecutorService) {<z>
.submit(task);<z>
FutureTask<>(task);<z>
;<z>
future;<z>
catch (RejectedExecutionException ex) {<z>
new TaskRejectedException(<z>
concurrentExecutor + "] did not accept task: " + task, ex);<z>
{<z>
1;<z>
().getDateHeader(headerName);<z>
catch (IllegalArgumentException ex) {<z>
;<z>
!= null) {<z>
);<z>
(separatorIndex != -1) {<z>
headerValue.substring(0, separatorIndex);<z>
(datePart);<z>
return dateValue;<z>
destination, @Nullable String messageSelector)<z>
{<z>
;<z>
{<z>
) {<z>
;<z>
+ bootstrapMethods.length;<z>
{<z>
;<z>
private ModelAndView getModelAndView(ModelAndViewContainer mavContainer,<z>
modelFactory, NativeWebRequest webRequest) throws Exception {<z>
mavContainer);<z>
{<z>
;<z>
ModelMap model = mavContainer.getModel();<z>
.getStatus());<z>
) {<z>
getView());<z>
RedirectAttributes) {<z>
) model).getFlashAttributes();<z>
= webRequest.getNativeRequest(HttpServletRequest.class);<z>
{<z>
(request).putAll(flashAttributes);<z>
;<z>
AbstractSubscribableChannel clientOutboundChannel(TaskExecutor clientOutboundChannelExecutor) {<z>
= new ExecutorSubscribableChannel(clientOutboundChannelExecutor);<z>
));<z>
;<z>
{<z>
;<z>
return channel;<z>
Unmarshaller unmarshaller) {<z>
marshaller, "Marshaller must not be null");<z>
, "Unmarshaller must not be null");<z>
.marshaller = marshaller;<z>
;<z>
) {<z>
);<z>
;<z>
(ctor == null) {<z>
);<z>
);<z>
args);<z>
Exception ex) {<z>
getBeanClass(),<z>
"]", ex);<z>
;<z>
] {NoOp.INSTANCE,<z>
.owner),<z>
this.owner)});<z>
return instance;<z>
, int index1,<z>
int index2) {<z>
result = 0;<z>
{<z>
index2 - index1;<z>
if (index1 != -1) {<z>
().get(index1);<z>
.getExpressionsToCompare().get(index2);<z>
);<z>
expr2.getMediaType());<z>
;<z>
public StompBrokerRelayMessageHandler(SubscribableChannel inboundChannel, MessageChannel outboundChannel,<z>
Collection<String> destinationPrefixes) {<z>
, outboundChannel, brokerChannel, destinationPrefixes);<z>
, @Nullable String value) {<z>
) {<z>
key, value);<z>
public void incrementAndValidate() {<z>
matchedRequestCount++;<z>
).getMaxCount()) {<z>
"No more calls expected.");<z>
public Object getIfAvailable() throws BeansException {<z>
.optional) {<z>
descriptor, this.beanName);<z>
(this.descriptor) {<z>
{<z>
false;<z>
beanName, null, null);<z>
ex) {<z>
;<z>
Nullable Map<String, Object> headers,<z>
throws MessagingException {<z>
postProcessor);<z>
destination, message);<z>
) {<z>
(!this.active) {<z>
;<z>
getAopProxyFactory().createAopProxy(this);<z>
T> void metadataToExtract(<z>
) {<z>
, mapper);<z>
public UnsatisfiedDependencyException(<z>
BeansException ex) {<z>
);<z>
;<z>
) {<z>
, value -> {<z>
< MAX_PATTERNS, "Max size for pattern cache exceeded.");<z>
(pattern);<z>
});<z>
pathWithinApplication();<z>
, path) : null);<z>
registry,<z>
{<z>
new ConditionContextImpl(registry, environment, resourceLoader);<z>
public RequestParamMethodArgumentResolver(<z>
useDefaultResolution) {<z>
);<z>
this.useDefaultResolution = useDefaultResolution;<z>
RestClientException {<z>
headersExtractor();<z>
headersExtractor, uriVariables);<z>
emptySet());<z>
void suspend() {<z>
(this.holderActive) {<z>
sessionFactory);<z>
.disconnect();<z>
factory) {<z>
));<z>
childElements) {<z>
element));<z>
.addPropertyValue("children", children);<z>
{<z>
convert(obj, String.class);<z>
(value != null) {<z>
;<z>
path, HttpServletRequest request) {<z>
isEmpty()) {<z>
);<z>
{<z>
= getUrlPathHelper().getRequestUri(request);<z>
) + 1) + path;<z>
= StringUtils.cleanPath(path);<z>
return path;<z>
int compareTo(PatternsRequestCondition other, ServerWebExchange exchange) {<z>
= this.patterns.iterator();<z>
.getPatterns().iterator();<z>
) {<z>
;<z>
result != 0) {<z>
;<z>
)) {<z>
1;<z>
.hasNext()) {<z>
return 1;<z>
0;<z>
DataSource getDataSource(SessionFactory sessionFactory) {<z>
);<z>
) {<z>
.invokeMethod(getProperties, sessionFactory);<z>
null) {<z>
);<z>
{<z>
) dataSourceValue;<z>
instanceof SessionFactoryImplementor sfi) {<z>
.getService(ConnectionProvider.class);<z>
{<z>
);<z>
{<z>
isDebugEnabled()) {<z>
+ ex);<z>
;<z>
, EvaluationContext evalContext)<z>
EvaluationException {<z>
getValue();<z>
if (value != null) {<z>
=<z>
(), evalContext.getPropertyAccessors());<z>
) {<z>
(evalContext, value, name)) {<z>
return true;<z>
) {<z>
return false;<z>
) {<z>
== 0) {<z>
;<z>
length();<z>
typePathLength);<z>
putByte(0);<z>
;<z>
) {<z>
c = typePath.charAt(typePathIndex++);<z>
if (c == '[') {<z>
ARRAY_ELEMENT, 0);<z>
(c == '.') {<z>
;<z>
} else if (c == '*') {<z>
.put11(WILDCARD_BOUND, 0);<z>
{<z>
int typeArg = c - '0';<z>
< typePathLength) {<z>
++);<z>
c <= '9') {<z>
;<z>
else if (c == ';') {<z>
else {<z>
);<z>
typeArg);<z>
{<z>
;<z>
2);<z>
new TypePath(output.data, 0);<z>
{<z>
notNull(bean, "Bean is required");<z>
);<z>
;<z>
;<z>
messageSource = messageSource;<z>
= ClassUtils.getUserClass(bean);<z>
.method = method;<z>
.bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);<z>
ReflectionUtils.makeAccessible(this.bridgedMethod);<z>
.parameters = initMethodParameters();<z>
;<z>
method);<z>
) {<z>
.leaveMutable) {<z>
setImmutable();<z>
this.headers;<z>
public String toString() {<z>
getSubscriptionId() +<z>
headers.getDestination() +<z>
) + "', handler=" + getHandler() + "]";<z>
boolean replaceHeader) {<z>
) {<z>
());<z>
true;<z>
equalsIgnoreCase(name)) {<z>
Number) value).intValue() :<z>
;<z>
;<z>
name)) {<z>
= value.toString();<z>
headers = new HttpHeaders();<z>
.CONTENT_LANGUAGE, contentLanguages);<z>
;<z>
Locale.getDefault());<z>
CONTENT_LANGUAGE, contentLanguages, true);<z>
;<z>
{<z>
parse(value.toString());<z>
(replaceHeader) {<z>
cookie);<z>
cookie);<z>
true;<z>
;<z>
isDisconnectedClientError(Throwable ex) {<z>
getMessage();<z>
!= null) {<z>
.toLowerCase();<z>
("connection reset by peer")) {<z>
return true;<z>
);<z>
String value) {<z>
hash(Symbol.CONSTANT_UTF8_TAG, value);<z>
= get(hashCode);<z>
!= null) {<z>
Symbol.CONSTANT_UTF8_TAG<z>
entry.hashCode == hashCode<z>
.value.equals(value)) {<z>
;<z>
entry.next;<z>
).putUTF8(value);<z>
, hashCode)).index;<z>
array) {<z>
) {<z>
;<z>
INITIAL_HASH;<z>
(char element : array) {<z>
MULTIPLIER * hash + element;<z>
return hash;<z>
() {<z>
;<z>
.addAll(super.keySet());<z>
;<z>
int multipartMode) throws MessagingException {<z>
{<z>
:<z>
null, null);<z>
MULTIPART_MODE_MIXED:<z>
(MULTIPART_SUBTYPE_MIXED);<z>
.setContent(mixedMultipart);<z>
mixedMultipart);<z>
case MULTIPART_MODE_RELATED:<z>
= new MimeMultipart(MULTIPART_SUBTYPE_RELATED);<z>
(relatedMultipart);<z>
setMimeMultiparts(relatedMultipart, relatedMultipart);<z>
case MULTIPART_MODE_MIXED_RELATED:<z>
MimeMultipart rootMixedMultipart = new MimeMultipart(MULTIPART_SUBTYPE_MIXED);<z>
mimeMessage.setContent(rootMixedMultipart);<z>
);<z>
= new MimeBodyPart();<z>
setContent(nestedRelatedMultipart);<z>
;<z>
);<z>
("Only multipart modes MIXED_RELATED, RELATED and NO supported");<z>
{<z>
) {<z>
;<z>
return expectation;<z>
) {<z>
null;<z>
NoSuchBeanDefinitionException(ResolvableType type) {<z>
type + "' available");<z>
.beanName = null;<z>
type;<z>
lookupEntityManagerFactory() {<z>
(getServletContext());<z>
String emfBeanName = getEntityManagerFactoryBeanName();<z>
getPersistenceUnitName();<z>
emfBeanName)) {<z>
;<z>
wac.containsBean(DEFAULT_ENTITY_MANAGER_FACTORY_BEAN_NAME)) {<z>
, EntityManagerFactory.class);<z>
.findEntityManagerFactory(wac, puName);<z>
, @Nullable Object conversionHint) {<z>
, targetClass)) {<z>
;<z>
;<z>
@Nullable Object parent) {<z>
mergeEnabled) {<z>
);<z>
null) {<z>
return this;<z>
List)) {<z>
);<z>
);<z>
parent);<z>
(this);<z>
return merged;<z>
inString) {<z>
StringBuilder sb = null;<z>
++) {<z>
;<z>
(c == '\\') {<z>
);<z>
;<z>
if (c == ':') {<z>
= getStringBuilder(sb, inString, i);<z>
("\\c");<z>
== '\n') {<z>
;<z>
;<z>
else if (c == '\r') {<z>
getStringBuilder(sb, inString, i);<z>
.append("\\r");<z>
(sb != null){<z>
c);<z>
: inString);<z>
List<OriginPattern> combinePatterns(<z>
> other) {<z>
{<z>
Collections.emptyList());<z>
== null) {<z>
return other;<z>
) {<z>
return ALL_PATTERN_LIST;<z>
size());<z>
addAll(source);<z>
combined.addAll(other);<z>
);<z>
sessionId, String subscriptionId) {<z>
_destination, sessionIdToSubscriptionIds) -> {<z>
clone();<z>
sessionIdToSubscriptionIds, sessionId, subscriptionId);<z>
;<z>
;<z>
Nullable String password) throws JMSException {<z>
;<z>
.hasLength(username)) {<z>
return target.createConnection(username, password);<z>
target.createConnection();<z>
{<z>
= beanFactory;<z>
{<z>
;<z>
? super String> matcher) {<z>
{<z>
);<z>
matcher);<z>
) throws NoSuchBeanDefinitionException {<z>
name);<z>
Object beanInstance = getSingleton(beanName, false);<z>
{<z>
if (beanInstance instanceof FactoryBean) {<z>
());<z>
name);<z>
;<z>
)) {<z>
parentBeanFactory.isSingleton(originalBeanName(name));<z>
(beanName);<z>
if (mbd.isSingleton()) {<z>
) {<z>
isFactoryDereference(name)) {<z>
;<z>
FACTORY_BEAN_PREFIX + beanName);<z>
isSingleton();<z>
);<z>
;<z>
onError(Class<? extends Throwable> exceptionType,<z>
, ServerRequest, ServerResponse> responseProvider) {<z>
notNull(exceptionType, "ExceptionType must not be null");<z>
;<z>
;<z>
registerBeanDefinition(String beanName, BeanDefinition beanDefinition)<z>
{<z>
beanDefinition);<z>
property) {<z>
(containsBean(property)) {<z>
;<z>
(property)) {<z>
(property);<z>
throw new NoSuchBeanDefinitionException(property);<z>
matchMediaType(List<MediaType> acceptedMediaTypes) {<z>
for (MediaType acceptedMediaType : acceptedMediaTypes) {<z>
acceptedMediaType)) {<z>
true;<z>
return false;<z>
createAnnotationMethodMessageHandler(<z>
, AbstractSubscribableChannel clientOutboundChannel,<z>
{<z>
SimpAnnotationMethodMessageHandler(<z>
);<z>
IOException {<z>
tf : this.excludeFilters) {<z>
(metadataReader, getMetadataReaderFactory())) {<z>
return false;<z>
: this.includeFilters) {<z>
match(metadataReader, getMetadataReaderFactory())) {<z>
);<z>
;<z>
(Matcher<? super String> matcher) {<z>
-> {<z>
mav = result.getModelAndView();<z>
) {<z>
;<z>
mav.getViewName(), matcher);<z>
Object key, CallableProcessingInterceptor interceptor) {<z>
);<z>
interceptor, "CallableProcessingInterceptor is required");<z>
put(key, interceptor);<z>
> expectedType) {<z>
model = mav.getModel();<z>
;<z>
obj == null) {<z>
("Model attribute with name '" + modelName + "' is null");<z>
.getName() + "' but rather of type '" +<z>
)));<z>
;<z>
resource, @Nullable String separator,<z>
blockCommentEndDelimiter) throws IOException {<z>
)) {<z>
lnr, commentPrefixes, separator, blockCommentEndDelimiter);<z>
(MethodParameter methodParam) {<z>
methodParam.getNestedParameterType();<z>
isAssignableFrom(paramType)){<z>
).resolveGeneric();<z>
null) {<z>
;<z>
return null;<z>
setBeanFactory(BeanFactory beanFactory) {<z>
if (beanFactory instanceof ConfigurableListableBeanFactory) {<z>
).ignoreDependencyType(MetaClass.class);<z>
{<z>
"Bean instance must not be null");<z>
.getAnnotation(Configurable.class);<z>
buildWiringInfo(beanInstance, annotation) : null);<z>
, @Nullable String namePrefix) throws ConstantException {<z>
) : "");<z>
{<z>
).equals(value)) {<z>
();<z>
, prefixToUse, value);<z>
applicationContext) {<z>
;<z>
this.beanFactory == null) {<z>
= applicationContext;<z>
ex,<z>
handler) throws Exception {<z>
values) -><z>
name, value)));<z>
, ex.getReason(), response);<z>
] content) {<z>
= content;<z>
.inputStream = null;<z>
= null;<z>
public NoSuchBeanDefinitionException(String name) {<z>
name + "' available");<z>
;<z>
.resolvableType = null;<z>
determineTimeout(TransactionDefinition definition) {<z>
TIMEOUT_DEFAULT) {<z>
;<z>
ZERO;<z>
(String beanName) {<z>
= this.prototypesCurrentlyInCreation.get();<z>
if (curVal == null) {<z>
.set(beanName);<z>
(curVal instanceof String) {<z>
);<z>
add((String) curVal);<z>
beanName);<z>
this.prototypesCurrentlyInCreation.set(beanNameSet);<z>
curVal;<z>
beanName);<z>
setContainingClass(Class<?> containingClass) {<z>
containingClass = containingClass;<z>
;<z>
this.methodParameter != null) {<z>
.methodParameter.withContainingClass(containingClass);<z>
, String subPattern)<z>
IOException {<z>
URLConnection con = rootDirURL.openConnection();<z>
jarFile;<z>
;<z>
String rootEntryPath;<z>
boolean closeJarFile;<z>
jarCon) {<z>
jarCon);<z>
getJarFile();<z>
.getJarFileURL().toExternalForm();<z>
.getJarEntry();<z>
);<z>
= !jarCon.getUseCaches();<z>
);<z>
);<z>
(separatorIndex == -1) {<z>
;<z>
1) {<z>
);<z>
(separatorIndex + 2);<z>
);<z>
= new JarFile(urlFile);<z>
urlFile;<z>
= "";<z>
;<z>
ex) {<z>
(logger.isDebugEnabled()) {<z>
"]");<z>
);<z>
)) {<z>
+ "]");<z>
)) {<z>
= rootEntryPath + "/";<z>
);<z>
) {<z>
.nextElement();<z>
.getName();<z>
.startsWith(rootEntryPath)) {<z>
(rootEntryPath.length());<z>
.match(subPattern, relativePath)) {<z>
));<z>
;<z>
closeJarFile) {<z>
();<z>
void throwException(boolean matchFilter) {<z>
count = exceptionCounter.getAndIncrement();<z>
matchFilter) {<z>
count + ")");<z>
")");<z>
<ReactiveTransactionInfo> createTransactionIfNecessary(ReactiveTransactionManager tm,<z>
TransactionAttribute txAttr, final String joinpointIdentification) {<z>
() == null) {<z>
) {<z>
getName() {<z>
joinpointIdentification;<z>
attrToUse = txAttr;<z>
.empty());<z>
)).switchIfEmpty(<z>
);<z>
getSharedInstance() {<z>
DefaultConversionService cs = sharedInstance;<z>
(cs == null) {<z>
) {<z>
cs = sharedInstance;<z>
null) {<z>
new DefaultConversionService();<z>
cs;<z>
cs;<z>
(<z>
String etag) {<z>
1;<z>
{<z>
lastModified.toEpochMilli();<z>
new CheckNotModifiedResponse();<z>
= new ServletWebRequest(servletRequest, response);<z>
checkNotModified(etag, lastModifiedTimestamp)) {<z>
.status).<z>
(response.headers))<z>
.build());<z>
);<z>
ServerState serverState, Requests request, Blackhole blackhole) {<z>
;<z>
.findDestination, serverState.findMessage));<z>
request.unsubscribe);<z>
serverState.findMessage));<z>
setNamingPolicy(NamingPolicy namingPolicy) {<z>
(namingPolicy == null)<z>
INSTANCE;<z>
.namingPolicy = namingPolicy;<z>
?> close() throws BindException {<z>
().hasErrors()) {<z>
());<z>
).getModel();<z>
HttpInputMessage inputMessage)<z>
IOException, HttpMessageNotReadableException {<z>
getHeaders().getContentType();<z>
contentType));<z>
jsonText);<z>
catch (SerializationException ex) {<z>
, ex, inputMessage);<z>
headers, Object status) {<z>
, headers);<z>
, "HttpStatus must not be null");<z>
this.status = status;<z>
Object vfsResource) {<z>
vfsResource);<z>
{<z>
"Cannot get resource name", ex);<z>
<Object, Object> createInstance() {<z>
{<z>
("'sourceMap' is required");<z>
null;<z>
!= null) {<z>
instantiateClass(this.targetMapClass);<z>
this.sourceMap.size());<z>
;<z>
Class<?> valueType = null;<z>
{<z>
).asMap();<z>
resolveGeneric(0);<z>
valueType = mapType.resolveGeneric(1);<z>
{<z>
TypeConverter converter = getBeanTypeConverter();<z>
: this.sourceMap.entrySet()) {<z>
getKey(), keyType);<z>
entry.getValue(), valueType);<z>
, convertedValue);<z>
this.sourceMap);<z>
return result;<z>
TypedValue getValueInternal(ExpressionState state) throws EvaluationException {<z>
getActiveContextObject(), state.getEvaluationContext(),<z>
;<z>
this.cachedReadAccessor;<z>
accessorToUse instanceof CompilablePropertyAccessor accessor) {<z>
(accessor.getPropertyType()));<z>
return tv;<z>
, final String metaDataMethodName)<z>
throws MetaDataAccessException {<z>
) extractDatabaseMetaData(dataSource,<z>
dbmd -> {<z>
.invoke(dbmd);<z>
{<z>
"No method named '" + metaDataMethodName +<z>
"]", ex);<z>
) {<z>
MetaDataAccessException(<z>
+ metaDataMethodName + "'", ex);<z>
ex) {<z>
ex.getTargetException() instanceof SQLException) {<z>
.getTargetException();<z>
MetaDataAccessException(<z>
+ "' failed", ex);<z>
});<z>
EvaluationException {<z>
constant != null) {<z>
this.constant;<z>
getChildCount();<z>
= new ArrayList<>(childCount);<z>
< childCount; c++) {<z>
(c).getValue(expressionState));<z>
new TypedValue(returnValue);<z>
void throwIfNotNullSafe(List<TypeDescriptor> argumentTypes) {<z>
(!this.nullSafe) {<z>
throw new SpelEvaluationException(getStartPosition(),<z>
.METHOD_CALL_ON_NULL_OBJECT_NOT_ALLOWED,<z>
name, argumentTypes));<z>
getLastSession() {<z>
;<z>
) {<z>
result).getDelegate();<z>
return result;<z>
<T> list) {<z>
(isEmpty(list)) {<z>
;<z>
(0);<z>
value) {<z>
instanceof MultipartFile multipartFile) {<z>
(this.charsetName != null ?<z>
(), this.charsetName) :<z>
(multipartFile.getBytes()));<z>
(IOException ex) {<z>
, ex);<z>
value);<z>
value) {<z>
-> {<z>
result.getResponse();<z>
;<z>
{<z>
));<z>
;<z>
conversionHint);<z>
)) {<z>
return payload;<z>
(payload instanceof byte[]) {<z>
(view != null) {<z>
;<z>
(byte[]) payload, javaType);<z>
{<z>
toString());<z>
toString(), javaType);<z>
(IOException ex) {<z>
getMessage(), ex);<z>
() {<z>
readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();<z>
;<z>
(RuntimeException | Error ex) {<z>
);<z>
;<z>
.beforeCompletionCalled = true;<z>
);<z>
{<z>
super(other);<z>
annotationType;<z>
.displayName;<z>
.validated;<z>
public JettyClientHttpRequest(Request jettyRequest, DataBufferFactory bufferFactory) {<z>
jettyRequest;<z>
bufferFactory = bufferFactory;<z>
abortOnCancel(true);<z>
{<z>
.frozen, "Cannot add Connection because JmsResourceHolder is frozen");<z>
(connection, "Connection must not be null");<z>
connections.contains(connection)) {<z>
;<z>
, Method writeMethod)<z>
{<z>
);<z>
readMethod;<z>
.writeMethod = writeMethod;<z>
;<z>
name, String value) {<z>
HttpHeaders.CONTENT_LENGTH.equals(name)) {<z>
, value);<z>
) {<z>
uri, "'uri' must not be null");<z>
uri;<z>
this;<z>
void handleInitialRequest(ServerHttpRequest request, ServerHttpResponse response,<z>
SockJsException {<z>
.getURI();<z>
);<z>
getPrincipal();<z>
.getLocalAddress();<z>
) {<z>
();<z>
) {<z>
) {<z>
response = response;<z>
= frameFormat;<z>
request.getAsyncRequestControl(response);<z>
.asyncRequestControl = control;<z>
);<z>
disableShallowEtagHeaderFilter(request);<z>
delegateConnectionEstablished();<z>
true);<z>
isActive();<z>
catch (Throwable ex) {<z>
SERVER_ERROR);<z>
"Failed to open session", getId(), ex);<z>
Object> readMono(<z>
Map<String, Object> hints) {<z>
.class) {<z>
.getBody();<z>
Object.class);<z>
UnsupportedOperationException(<z>
"ServerSentEventHttpMessageReader only supports reading stream of events as a Flux"));<z>
) {<z>
(!expression) {<z>
, args);<z>
;<z>
void clearMetadataCache() {<z>
;<z>
;<z>
();<z>
(Object factoryBean, Class<?> interfaceType,<z>
ConfigurableBeanFactory beanFactory, String beanName) {<z>
(<z>
{interfaceType},<z>
args) -> {<z>
args == null) {<z>
(beanName);<z>
, args);<z>
);<z>
createBeanWrapper() {<z>
{<z>
"'");<z>
(this.target);<z>
?> constructor) {<z>
StringBuilder stringBuilder = new StringBuilder();<z>
'(');<z>
.getParameterTypes();<z>
?> parameter : parameters) {<z>
appendDescriptor(parameter, stringBuilder);<z>
(")V").toString();<z>
{<z>
(this.children.length < 2) {<z>
toStringAST();<z>
.toStringAST();<z>
() {<z>
null) {<z>
callbacks, false);<z>
validateCallbackTypes = true;<z>
{<z>
{<z>
);<z>
filter = ALL_ZERO;<z>
contextClass, @Nullable MediaType mediaType) {<z>
) {<z>
return false;<z>
> rawType)) {<z>
false;<z>
rawType))) {<z>
return false;<z>
().length != 1) {<z>
;<z>
getActualTypeArguments()[0];<z>
instanceof Class<?> typeArgumentClass)) {<z>
return false;<z>
(XmlRootElement.class) ||<z>
.class)) && canRead(mediaType);<z>
final TransportRequest transportRequest,<z>
XhrClientSockJsSession sockJsSession,<z>
> connectFuture) {<z>
new ClientCallback<>() {<z>
(final ClientExchange exchange) {<z>
() {<z>
ClientExchange result) {<z>
();<z>
.getResponseCode() != 200) {<z>
response.getResponseCode());<z>
(result.getConnection());<z>
(status, "Unexpected XHR receive status"));<z>
(<z>
result.getConnection(), url, headers,<z>
, connectFuture);<z>
.getResponseChannel());<z>
{<z>
.getResponseHeaders()));<z>
StreamSinkChannel channel = result.getRequestChannel();<z>
();<z>
(!channel.flush()) {<z>
null));<z>
resumeWrites();<z>
{<z>
getConnection());<z>
(exc);<z>
public void failed(IOException exc) {<z>
);<z>
exc);<z>
);<z>
{<z>
(exc);<z>
void onFailure(Throwable failure) {<z>
{<z>
()) {<z>
sockJsSession.afterTransportClosed(null);<z>
;<z>
1006, failure.getMessage()));<z>
MultiValueMap<K, V> values) {<z>
entry : values.entrySet()) {<z>
), entry.getValue());<z>
(String resourceUrlPath,<z>
locations, ResourceResolverChain chain) {<z>
;<z>
(key, String.class);<z>
null) {<z>
isTraceEnabled()) {<z>
logger.trace("Path resolved from cache");<z>
resolvedUrlPath;<z>
chain.resolveUrlPath(resourceUrlPath, locations);<z>
(resolvedUrlPath != null) {<z>
.cache.put(key, resolvedUrlPath);<z>
return resolvedUrlPath;<z>
) {<z>
("java.class.path");<z>
: StringUtils.delimitedListToStringArray(<z>
)) {<z>
new File(path).getAbsolutePath();<z>
(':');<z>
1) {<z>
filePath);<z>
replace(filePath, "#", "%23");<z>
UrlResource(ResourceUtils.JAR_URL_PREFIX +<z>
+ filePath + ResourceUtils.JAR_URL_SEPARATOR);<z>
) {<z>
);<z>
MalformedURLException ex) {<z>
isDebugEnabled()) {<z>
path +<z>
);<z>
(Exception ex) {<z>
(logger.isDebugEnabled()) {<z>
);<z>
public DefaultAdvisorAdapterRegistry() {<z>
new MethodBeforeAdviceAdapter());<z>
;<z>
(new ThrowsAdviceAdapter());<z>
{<z>
(this.lifecycleMonitor) {<z>
)) {<z>
serverName = getClass().getSimpleName();<z>
;<z>
this.running = false;<z>
);<z>
.start();<z>
();<z>
;<z>
(Throwable ex) {<z>
new IllegalStateException(ex);<z>
;<z>
AnnotationAttributes attr) {<z>
AnnotationUtils.VALUE);<z>
(value == null) {<z>
throw new IllegalStateException("Value annotation must have a value attribute");<z>
return value;<z>
getCachedConsumer(Destination dest, @Nullable String selector,<z>
, boolean durable) throws JMSException {<z>
, subscription, durable);<z>
);<z>
) {<z>
(logger.isTraceEnabled()) {<z>
consumer);<z>
{<z>
if (noLocal == null) {<z>
?<z>
selector) :<z>
);<z>
= (durable ?<z>
selector, noLocal) :<z>
);<z>
(dest, selector);<z>
if (logger.isDebugEnabled()) {<z>
dest + "]: " + consumer);<z>
.cachedConsumers.put(cacheKey, consumer);<z>
);<z>
(JndiCallback<T> contextCallback) throws NamingException {<z>
ctx = getContext();<z>
.doInContext(ctx);<z>
ctx);<z>
JspException {<z>
getMultiple();<z>
) {<z>
.toString();<z>
parseBoolean(stringValue));<z>
return forceMultiple();<z>
visitInnerClass(<z>
int access) {<z>
{<z>
outerName, innerName, access);<z>
(MethodParameter returnType) {<z>
returnValueHandlers) {<z>
) {<z>
;<z>
return null;<z>
) {<z>
boolean result = isWritePossible();<z>
{<z>
"isWritePossible false");<z>
{<z>
;<z>
{<z>
scheme = other.scheme;<z>
.ssp;<z>
other.userInfo;<z>
.host;<z>
port;<z>
= other.pathBuilder.cloneBuilder();<z>
);<z>
;<z>
;<z>
.encodeTemplate = other.encodeTemplate;<z>
;<z>
> initBinderResolvers(<z>
adapterRegistry,<z>
{<z>
.emptyList()).stream()<z>
instanceof SyncHandlerMethodArgumentResolver)<z>
)<z>
.collect(Collectors.toList());<z>
(HttpServerRequest request) throws URISyntaxException {<z>
);<z>
().get(HttpHeaderNames.HOST);<z>
(header != null) {<z>
portIndex;<z>
("[")) {<z>
.indexOf(']'));<z>
indexOf(':');<z>
1) {<z>
header.substring(0, portIndex),<z>
), null, null, null);<z>
) {<z>
, portIndex);<z>
null, null);<z>
localAddress = request.hostAddress();<z>
(localAddress != null, "No host address available");<z>
, localAddress.getHostString(),<z>
;<z>
) throws Exception {<z>
();<z>
.getRequiredTestMethod();<z>
;<z>
{<z>
().getRequestDataValueProcessor();<z>
;<z>
request instanceof HttpServletRequest) {<z>
request, name, value, type);<z>
;<z>
beanEle, MethodOverrides overrides) {<z>
.getChildNodes();<z>
); i++) {<z>
.item(i);<z>
(node, LOOKUP_METHOD_ELEMENT)) {<z>
Element ele = (Element) node;<z>
(NAME_ATTRIBUTE);<z>
(BEAN_ELEMENT);<z>
(methodName, beanRef);<z>
.setSource(extractSource(ele));<z>
);<z>
{<z>
.advisorBeanNamePrefix == null) {<z>
;<z>
() {<z>
) {<z>
.elements.size() - 1);<z>
this.node;<z>
byteBuffer) {<z>
while (true) {<z>
tryConsumeEndOfLine(byteBuffer)) {<z>
) {<z>
+ " sessions, " + getTcpClientInfo() +<z>
) ? " (available)" : " (not available)") +<z>
() + ")-CONNECTED(" +<z>
")");<z>
(final String descriptor) {<z>
firstDescriptorChar = descriptor.charAt(0);<z>
'(') {<z>
- 1);<z>
== 'D') {<z>
pop(2);<z>
} else {<z>
1);<z>
getDefaultValue(NamedValueInfo namedValueInfo, MethodParameter parameter,<z>
{<z>
fromSupplier(() -> {<z>
;<z>
{<z>
namedValueInfo.defaultValue);<z>
isOptional()) {<z>
name, parameter, exchange);<z>
getNestedParameterType());<z>
, exchange);<z>
;<z>
return value;<z>
;<z>
IOException {<z>
);<z>
!= null) {<z>
.get().countDown();<z>
();<z>
) throws Throwable {<z>
get();<z>
(mi);<z>
;<z>
);<z>
> doScan(String... basePackages) {<z>
Assert.notEmpty(basePackages, "At least one base package must be specified");<z>
<>();<z>
for (String basePackage : basePackages) {<z>
BeanDefinition> candidates = findCandidateComponents(basePackage);<z>
) {<z>
candidate);<z>
.getScopeName());<z>
, this.registry);<z>
if (candidate instanceof AbstractBeanDefinition) {<z>
candidate, beanName);<z>
if (candidate instanceof AnnotatedBeanDefinition) {<z>
) candidate);<z>
candidate)) {<z>
);<z>
.registry);<z>
definitionHolder);<z>
;<z>
beanDefinitions;<z>
required, boolean eager) {<z>
methodParameter);<z>
.declaringClass = methodParameter.getDeclaringClass();<z>
{<z>
();<z>
getParameterTypes();<z>
.parameterIndex = methodParameter.getParameterIndex();<z>
);<z>
= required;<z>
this.eager = eager;<z>
value(String name, String expectedValue) {<z>
return result -> {<z>
name);<z>
, cookie.getValue());<z>
channel) {<z>
);<z>
session);<z>
adapter);<z>
);<z>
session)<z>
)<z>
;<z>
sink) {<z>
) {<z>
(this.barrier == Integer.MAX_VALUE) {<z>
.asStartElement().getName();<z>
) {<z>
;<z>
.barrier = this.elementDepth;<z>
elementDepth++;<z>
elementDepth > this.barrier) {<z>
null, "No XMLEvent List");<z>
);<z>
()) {<z>
.elementDepth--;<z>
elementDepth == this.barrier) {<z>
;<z>
, "No XMLEvent List");<z>
events);<z>
void visitEnd() {<z>
(cv != null) {<z>
;<z>
void afterConnectionEstablished(WebSocketSession session) throws Exception {<z>
this.provider.getHandler();<z>
, handler);<z>
.afterConnectionEstablished(session);<z>
?>[] resolveTypeArguments() {<z>
);<z>
if (resolved == null) {<z>
IllegalStateException("ConvertingEncoderDecoderSupport's generic types T and M " +<z>
;<z>
resolved;<z>
toString() {<z>
ToStringCreator(this)<z>
this.dataSource)<z>
.transactionManager)<z>
.transactionMode)<z>
"encoding", this.encoding)<z>
, this.separator)<z>
this.commentPrefixes)<z>
"blockCommentStartDelimiter", this.blockCommentStartDelimiter)<z>
.append("blockCommentEndDelimiter", this.blockCommentEndDelimiter)<z>
, this.errorMode)<z>
();<z>
beanKey) throws MalformedObjectNameException {<z>
);<z>
>();<z>
managedBean.getClass()));<z>
.getIdentityHexString(managedBean));<z>
, keys);<z>
> converters) {<z>
) {<z>
class, MediaType.TEXT_PLAIN)) {<z>
;<z>
() + 1);<z>
StringHttpMessageConverter(StandardCharsets.UTF_8));<z>
addAll(converters);<z>
return result;<z>
readDocumentFromString(String documentContent) {<z>
(new StringReader(documentContent));<z>
doLoadDocument(is, getResource());<z>
) {<z>
, ex);<z>
MediaType acceptedMediaType) {<z>
().keySet()) {<z>
getParameter(name);<z>
getParameter(name);<z>
)) {<z>
return false;<z>
return true;<z>
entity) throws DataAccessException {<z>
nonNull(executeWithNativeSession(session -> {<z>
);<z>
save(entity);<z>
);<z>
<Object> resolveArgument(<z>
{<z>
();<z>
(parameter.getParameterType());<z>
) : Mono.from(principal));<z>
void enqueue(@Nullable DataBuffer buf) {<z>
.previous.getAndSet(buf);<z>
) {<z>
);<z>
other) {<z>
) {<z>
other.name;<z>
if (this.name != null) {<z>
name;<z>
;<z>
locale) {<z>
= resolveCode(code, locale);<z>
) {<z>
) {<z>
);<z>
return null;<z>
request) {<z>
;<z>
.size());<z>
());<z>
for (Part part : parts) {<z>
.CONTENT_DISPOSITION);<z>
;<z>
;<z>
if (filename != null) {<z>
) && filename.endsWith("?=")) {<z>
decode(filename);<z>
;<z>
());<z>
;<z>
ex) {<z>
);<z>
) {<z>
= memoizedSerializedSize;<z>
1) return size;<z>
0;<z>
) == 0x00000001)) {<z>
.protobuf.CodedOutputStream<z>
getFooBytes());<z>
{<z>
com.google.protobuf.CodedOutputStream<z>
.computeMessageSize(2, blah_);<z>
();<z>
size;<z>
size;<z>
{<z>
uriPath == null) {<z>
return this.uri;<z>
;<z>
null) {<z>
;<z>
) {<z>
append("//");<z>
) {<z>
);<z>
) != null) {<z>
());<z>
!= -1) {<z>
);<z>
this.uriPath)) {<z>
;<z>
.getRawQuery() != null) {<z>
getRawQuery());<z>
getRawFragment() != null) {<z>
uri.getRawFragment());<z>
URI(uriBuilder.toString());<z>
catch (URISyntaxException ex) {<z>
+ "\"", ex);<z>
MergedAnnotation<A> of(<z>
@Nullable ClassLoader classLoader, @Nullable Object source,<z>
String, ?> attributes) {<z>
;<z>
readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {<z>
);<z>
= LogFactory.getLog(getClass());<z>
(DataSource dataSource) {<z>
int order = CONNECTION_SYNCHRONIZATION_ORDER;<z>
;<z>
while (currDs instanceof DelegatingDataSource) {<z>
;<z>
.getTargetDataSource();<z>
order;<z>
getType() {<z>
== null) {<z>
);<z>
) {<z>
.getClass();<z>
;<z>
@Nullable String prefix) {<z>
equals(prefix)) {<z>
defaultNamespaceUri = "";<z>
prefix != null) {<z>
= this.prefixToNamespaceUri.remove(prefix);<z>
null) {<z>
(namespaceUri);<z>
null) {<z>
(prefix);<z>
if (prefixes.isEmpty()) {<z>
namespaceUri);<z>
{<z>
!isRunning()) {<z>
;<z>
{<z>
) getWebSocketClient()).start();<z>
String[] classNames, String beanKey) {<z>
classNames.length];<z>
length; x++) {<z>
);<z>
()) {<z>
(<z>
] + "] mapped to bean key [" + beanKey + "] is no interface");<z>
x] = cls;<z>
return classes;<z>
message) throws Exception {<z>
(message instanceof TextMessage) {<z>
);<z>
BinaryMessage) {<z>
BinaryMessage) message);<z>
{<z>
, (PongMessage) message);<z>
+ message);<z>
) throws JMSException {<z>
.getTransacted()) {<z>
) {<z>
JmsUtils.commitIfNecessary(session);<z>
!= null && isClientAcknowledge(session)) {<z>
message.acknowledge();<z>
Writer targetWriter, @Nullable HttpServletResponse response) {<z>
targetWriter instanceof JspWriter) {<z>
) targetWriter;<z>
return new MockJspWriter(response, targetWriter);<z>
registerNewClinit(ClinitAdder clinitAdder) {<z>
if (this.clinitAdders == null) {<z>
);<z>
add(clinitAdder);<z>
throws IllegalStateException {<z>
;<z>
(formerNestedPath);<z>
(NoSuchElementException ex) {<z>
);<z>
Method method) {<z>
] params = method.getParameterTypes();<z>
StringBuilder();<z>
append('(');<z>
: params) {<z>
);<z>
;<z>
method.getReturnType()));<z>
return sb.toString();<z>
{<z>
);<z>
unless;<z>
sync = b.sync;<z>
initializeContainer(DefaultMessageListenerContainer container) {<z>
if (this.taskExecutor != null) {<z>
;<z>
{<z>
.transactionManager);<z>
(this.cacheLevel != null) {<z>
;<z>
) {<z>
setCacheLevelName(this.cacheLevelName);<z>
this.concurrency != null) {<z>
this.concurrency);<z>
(this.maxMessagesPerTask != null) {<z>
this.maxMessagesPerTask);<z>
.receiveTimeout != null) {<z>
.receiveTimeout);<z>
!= null) {<z>
setBackOff(this.backOff);<z>
this.recoveryInterval != null) {<z>
logger.info("Ignoring recovery interval in DefaultJmsListenerContainerFactory in favor of BackOff");<z>
{<z>
.setRecoveryInterval(this.recoveryInterval);<z>
{<z>
servlet4Present) {<z>
Servlet4Delegate.skipServletPathDetermination(request);<z>
return false;<z>
<T> T getNativeResponse(ServerHttpResponse response) {<z>
if (response instanceof AbstractServerHttpResponse) {<z>
.getNativeResponse();<z>
if (response instanceof ServerHttpResponseDecorator) {<z>
ServerHttpResponseDecorator) response).getDelegate());<z>
IllegalArgumentException(<z>
.getName());<z>
<P> codec) {<z>
"host is required");<z>
"ReactorNettyCodec is required");<z>
DefaultChannelGroup(ImmediateEventExecutor.INSTANCE);<z>
.create("tcp-client-loop");<z>
;<z>
= codec;<z>
TcpClient.create(this.poolResources)<z>
).port(port)<z>
(this.loopResources, false)<z>
channel()));<z>
resolveAsyncMetadata() {<z>
this.hasAsyncValues, "No asynchronous values to resolve");<z>
ArrayList<>();<z>
metadataEntries.forEach(entry -> {<z>
v = entry.value();<z>
Mono.just(v));<z>
});<z>
values -> {<z>
values.length);<z>
length; i++) {<z>
{<z>
).mimeType()));<z>
;<z>
});<z>
Object o) {<z>
);<z>
15) ^ 0xffffcd7d;<z>
>>> 10);<z>
+= (hash << 3);<z>
>> 6);<z>
) + (hash << 14);<z>
^= (hash >>> 16);<z>
return hash;<z>
> collection, int index, String name,<z>
) {<z>
{<z>
();<z>
autoGrowCollectionLimit) {<z>
().resolveGeneric();<z>
(elementType != null) {<z>
++) {<z>
);<z>
Charset defaultCharset) {<z>
("text", "plain", defaultCharset));<z>
notNull(defaultCharset, "Default Charset must not be null");<z>
;<z>
() {<z>
.newPageSet = false;<z>
getPageCount()) {<z>
= getPageCount() - 1;<z>
page;<z>
throws JspException {<z>
.startTag("input");<z>
String id = resolveId();<z>
"id", id);<z>
(tagWriter, "name", getName());<z>
(tagWriter);<z>
;<z>
;<z>
));<z>
null) {<z>
null, "Label id is required");<z>
;<z>
("for", id);<z>
.appendValue(convertToDisplayString(resolvedLabel));<z>
();<z>
SKIP_BODY;<z>
addWebFluxConfigurers(List<WebFluxConfigurer> configurers) {<z>
(!CollectionUtils.isEmpty(configurers)) {<z>
.delegates.addAll(configurers);<z>
{<z>
"AsyncWebRequest must not be null");<z>
.asyncWebRequest = asyncWebRequest;<z>
removeAttribute(<z>
.WEB_ASYNC_MANAGER_ATTRIBUTE, RequestAttributes.SCOPE_REQUEST));<z>
build() {<z>
.routerFunctions.isEmpty()) {<z>
("No routes registered. Register a route with GET(), POST(), etc.");<z>
.routerFunctions);<z>
.isEmpty()) {<z>
return result;<z>
ServerResponse> filter =<z>
.errorHandlers.stream())<z>
reduce(HandlerFilterFunction::andThen)<z>
new);<z>
filter);<z>
Nullable Object eleSource) {<z>
=<z>
"org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource");<z>
.setSource(eleSource);<z>
);<z>
(element, sourceDef, true);<z>
CacheNamespaceHandler.parseKeyGenerator(element, sourceDef);<z>
return sourceDef;<z>
ReactiveHttpInputMessage> toFlux(ResolvableType elementType) {<z>
-><z>
(inputMessage, context, elementType,<z>
, elementType, reader),<z>
, ex),<z>
skipBodyAsFlux(inputMessage));<z>
public static DelegatingErrorHandlingRunnable decorateTaskWithErrorHandler(<z>
boolean isRepeatingTask) {<z>
instanceof DelegatingErrorHandlingRunnable) {<z>
) task;<z>
);<z>
task, eh);<z>
aggregates) {<z>
requiredType = requiredType;<z>
;<z>
this.aggregateCursor = 0;<z>
annotationIndex) {<z>
mapping;<z>
);<z>
this.requiredType)) {<z>
mapping;<z>
[annotationIndex]++;<z>
while (mapping != null);<z>
;<z>
?> contextClass, HttpInputMessage inputMessage)<z>
{<z>
type, contextClass)), inputMessage);<z>
defaults, CacheRemove ann) {<z>
cacheName());<z>
CacheResolverFactory cacheResolverFactory =<z>
cacheResolverFactory());<z>
, ann.cacheKeyGenerator());<z>
, cacheName);<z>
);<z>
;<z>
, byte[] boundary) throws IOException {<z>
;<z>
;<z>
);<z>
(os);<z>
nullSafeToString(@Nullable char[] array) {<z>
(array == null) {<z>
;<z>
length = array.length;<z>
(length == 0) {<z>
;<z>
new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);<z>
c : array) {<z>
c) + '\'');<z>
;<z>
{<z>
super.afterPropertiesSet();<z>
!isLazyInit()) {<z>
getExceptionTranslator();<z>
dataSource, String incrementerName, String columnName) {<z>
dataSource, incrementerName);<z>
columnName, "Column name must not be null");<z>
.columnName = columnName;<z>
HttpRequestHandler, String> mappings,<z>
, HandshakeHandler handshakeHandler,<z>
HandshakeInterceptor[] interceptors, String path) {<z>
WebSocketHttpRequestHandler httpHandler =<z>
new WebSocketHttpRequestHandler(webSocketHandler, handshakeHandler);<z>
isEmpty(interceptors)) {<z>
asList(interceptors));<z>
(httpHandler, path);<z>
(boolean useDefaultFilters) {<z>
includeFilters.clear();<z>
clear();<z>
) {<z>
registerDefaultFilters();<z>
() {<z>
(this.threadPoolExecutor == null) {<z>
;<z>
return this.threadPoolExecutor.getActiveCount();<z>
String sessionId, @Nullable String userName,<z>
long processingTimeMillis) {<z>
super(source);<z>
;<z>
.userName = userName;<z>
processingTimeMillis = processingTimeMillis;<z>
() {<z>
(this.triggerContextMonitor) {<z>
isDone();<z>
{<z>
new FileUpload(new DiskFileItemFactory());<z>
fileUpload.parseRequest(new UploadContext() {<z>
request.getBodyAsBytes();<z>
public String getCharacterEncoding() {<z>
);<z>
getContentType() {<z>
(HttpHeaders.CONTENT_TYPE);<z>
public InputStream getInputStream() {<z>
this.body);<z>
) {<z>
return this.body.length;<z>
;<z>
;<z>
) {<z>
.getFieldName(),<z>
) : fileItem.get()));<z>
;<z>
) {<z>
"Failed to parse multipart request", ex);<z>
{<z>
function ? this.parameterType == DatabaseMetaData.functionReturn :<z>
parameterType == DatabaseMetaData.procedureColumnReturn ||<z>
);<z>
) {<z>
.create(SimpMessageType.UNSUBSCRIBE);<z>
;<z>
setSubscriptionId(subscriptionId);<z>
"", accessor.getMessageHeaders());<z>
JspException {<z>
{<z>
;<z>
"type", "hidden");<z>
.DEFAULT_FIELD_MARKER_PREFIX + getName();<z>
("name", name);<z>
, "hidden"));<z>
);<z>
) {<z>
(attributes.isEmpty()) {<z>
();<z>
);<z>
SchedulerException {<z>
{<z>
schedulerName) : findDefaultScheduler());<z>
registerListeners();<z>
();<z>
IllegalStateException {<z>
(this.lastTaskInfo == null) {<z>
IllegalStateException("No tasks run: can't get last task interval");<z>
;<z>
private void releaseCachedItem() {<z>
(this) {<z>
= this.item;<z>
{<z>
(DataBuffer) item);<z>
item = null;<z>
() {<z>
(this.prettyPrint != null) {<z>
(SerializationFeature.INDENT_OUTPUT, this.prettyPrint);<z>
String> value) {<z>
this.key);<z>
this.key, value);<z>
return previousValues;<z>
private boolean isWildcardChar(char c) {<z>
: WILDCARD_CHARS) {<z>
) {<z>
return true;<z>
;<z>
Jackson2ObjectMapperBuilder autoDetectGettersSetters(boolean autoDetectGettersSetters) {<z>
;<z>
.put(MapperFeature.AUTO_DETECT_SETTERS, autoDetectGettersSetters);<z>
(MapperFeature.AUTO_DETECT_IS_GETTERS, autoDetectGettersSetters);<z>
;<z>
scriptSourceLocator) {<z>
scriptSourceLocator, "'scriptSourceLocator' must not be empty");<z>
this.scriptSourceLocator = scriptSourceLocator;<z>
null;<z>
V get(K key) {<z>
{<z>
.generator.apply(key);<z>
.get(key);<z>
null) {<z>
this.sizeLimit) {<z>
cached;<z>
.lock();<z>
(key)) {<z>
key);<z>
return cached;<z>
readLock().unlock();<z>
).lock();<z>
(key);<z>
cached != null) {<z>
key)) {<z>
queue.offer(key);<z>
;<z>
.apply(key);<z>
.size == this.sizeLimit) {<z>
queue.poll();<z>
!= null) {<z>
;<z>
offer(key);<z>
put(key, value);<z>
;<z>
value;<z>
();<z>
predicate) {<z>
return value -> {<z>
);<z>
(status));<z>
, Object request, Class<T> targetClass,<z>
MessagePostProcessor postProcessor) {<z>
destination = resolveDestination(destinationName);<z>
, postProcessor);<z>
computeMethodInfoSize() {<z>
{<z>
+ sourceLength;<z>
;<z>
code.length > 0) {<z>
(code.length > 65535) {<z>
throw new MethodTooLargeException(<z>
descriptor, code.length);<z>
addConstantUtf8(Constants.CODE);<z>
getExceptionTableSize(firstHandler);<z>
stackMapTableEntries != null) {<z>
Opcodes.V1_6;<z>
? Constants.STACK_MAP_TABLE : "StackMap");<z>
;<z>
{<z>
;<z>
+= 8 + lineNumberTable.length;<z>
localVariableTable != null) {<z>
(Constants.LOCAL_VARIABLE_TABLE);<z>
8 + localVariableTable.length;<z>
!= null) {<z>
.LOCAL_VARIABLE_TYPE_TABLE);<z>
.length;<z>
if (lastCodeRuntimeVisibleTypeAnnotation != null) {<z>
computeAnnotationsSize(<z>
.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);<z>
{<z>
(<z>
RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);<z>
if (firstCodeAttribute != null) {<z>
computeAttributesSize(<z>
, maxStack, maxLocals);<z>
(numberOfExceptions > 0) {<z>
);<z>
;<z>
, signatureIndex);<z>
.computeAnnotationsSize(<z>
);<z>
null) {<z>
computeParameterAnnotationsSize(<z>
,<z>
visibleAnnotableParameterCount == 0<z>
.length<z>
: visibleAnnotableParameterCount);<z>
if (lastRuntimeInvisibleParameterAnnotations != null) {<z>
(<z>
,<z>
invisibleAnnotableParameterCount == 0<z>
length<z>
);<z>
{<z>
;<z>
defaultValue.length;<z>
(parameters != null) {<z>
METHOD_PARAMETERS);<z>
.length;<z>
if (firstAttribute != null) {<z>
;<z>
size;<z>
, String dependentBeanName) {<z>
= canonicalName(beanName);<z>
.dependentBeanMap) {<z>
Set<String> dependentBeans =<z>
>(8));<z>
(dependentBeanName)) {<z>
) {<z>
Set<String> dependenciesForBean =<z>
));<z>
(canonicalName);<z>
SAXNotSupportedException {<z>
)) {<z>
;<z>
throw new SAXNotRecognizedException(name);<z>
ParameterizedTypeReference<T> elementTypeRef) {<z>
Assert.notNull(elementTypeRef, "ParameterizedTypeReference must not be null");<z>
(response -><z>
elementTypeRef)));<z>
addInterface(Class<?> ifc) {<z>
, "Interface must not be null");<z>
.isInterface()) {<z>
getName() + "] must be an interface");<z>
.add(ifc);<z>
(@Nullable Type responseType) {<z>
{<z>
logger);<z>
.delegate = null;<z>
getAllParameters(Object... values) {<z>
!= values.length) {<z>
+<z>
+ values.length + " value(s)");<z>
>();<z>
); i++) {<z>
(values[i]));<z>
]);<z>
<String, Object> expectedModel) {<z>
);<z>
equals(expectedModel.keySet())) {<z>
StringBuilder sb = new StringBuilder("Keyset of expected model does not match.\n");<z>
(), sb);<z>
;<z>
new StringBuilder();<z>
, mavValue) -> {<z>
;<z>
(!assertionValue.equals(mavValue)) {<z>
.append(<z>
mavValue).append("'\n");<z>
;<z>
) {<z>
0, "Values of expected model do not match.\n");<z>
.toString());<z>
] args, MethodProxy mp) throws Throwable {<z>
.getMethodOverrides().getOverride(method);<z>
state(ro != null, "ReplaceOverride not found");<z>
MethodReplacer.class);<z>
.reimplement(obj, method, args);<z>
(<z>
{<z>
RuntimeBeanReference beanRef;<z>
if (element.hasAttribute("content-negotiation-manager")) {<z>
.getAttribute("content-negotiation-manager");<z>
name);<z>
);<z>
(source);<z>
BeanDefinition.ROLE_INFRASTRUCTURE);<z>
;<z>
= CONTENT_NEGOTIATION_MANAGER_BEAN_NAME;<z>
().registerBeanDefinition(name, factoryBeanDef);<z>
(new BeanComponentDefinition(factoryBeanDef, name));<z>
;<z>
return beanRef;<z>
void raiseNoMatchingBeanFound(<z>
throws BeansException {<z>
descriptor);<z>
resolvableType,<z>
descriptor.getAnnotations()));<z>
int byteValue, final int shortValue) {<z>
int currentLength = length;<z>
{<z>
(3);<z>
= data;<z>
[currentLength++] = (byte) byteValue;<z>
> 8);<z>
[currentLength++] = (byte) shortValue;<z>
;<z>
this;<z>
{<z>
event = reader.peek();<z>
))) {<z>
throw new IllegalStateException("XMLEventReader not at start of document or element");<z>
{<z>
+ ex.getMessage());<z>
reader;<z>
> ContainedBean<B> getBean(<z>
fallbackProducer) {<z>
> bean;<z>
lifecycleOptions.canUseCachedReferences()) {<z>
(beanType);<z>
bean == null) {<z>
(beanType, lifecycleOptions, fallbackProducer);<z>
.put(beanType, bean);<z>
fallbackProducer);<z>
>) bean;<z>
, JavaType targetJavaType)<z>
IOException {<z>
.getText();<z>
(body, targetJavaType);<z>
(boolean ready) {<z>
ready && rsWriteLogger.isTraceEnabled()) {<z>
.trace(getLogPrefix() + "Ready to send");<z>
ready;<z>
(<z>
?> message) {<z>
MethodParameter returnType = handlerMethod.getReturnType();<z>
returnValue, returnType, message);<z>
rs) throws SQLException, DataAccessException {<z>
!rs.next()) {<z>
();<z>
rs);<z>
(rs.next()) {<z>
);<z>
) {<z>
"Could not stream LOB content", ex);<z>
return null;<z>
] descriptors, int maxDistance) {<z>
candidates = new ArrayList<>();<z>
) {<z>
!= null) {<z>
();<z>
maxDistance) {<z>
candidates.add(possibleAlternative);<z>
(candidates);<z>
candidates);<z>
ResolvableType getResolvableType() {<z>
= this.resolvableType;<z>
{<z>
= (this.field != null ?<z>
, this.containingClass) :<z>
);<z>
resolvableType = resolvableType;<z>
return resolvableType;<z>
setConcurrency(String concurrency) {<z>
separatorIndex = concurrency.indexOf('-');<z>
separatorIndex != -1) {<z>
.length(), 10));<z>
);<z>
{<z>
("Invalid concurrency value [" + concurrency + "]: only " +<z>
"scale from zero up to the number of consumers according to the maximum value.");<z>
) {<z>
{<z>
();<z>
return this.definition;<z>
public void setup() {<z>
();<z>
ArrayList<>(this.elementCount);<z>
this.elementMaxSize - this.elementMinSize;<z>
) {<z>
) + "d", 1));<z>
[] args, ServerWebExchange exchange) {<z>
null || exchange.isNotModified()) {<z>
;<z>
args) {<z>
|| arg instanceof ServerWebExchange) {<z>
return true;<z>
return false;<z>
{<z>
) {<z>
);<z>
(this.shutdownHook != null) {<z>
.removeShutdownHook(this.shutdownHook);<z>
{<z>
<? extends Annotation> annotationType) {<z>
this.qualifierTypes) {<z>
isAnnotationPresent(qualifierType)) {<z>
true;<z>
return false;<z>
void setSessionContext(SessionAttributesHandler attributesHandler, WebSession session) {<z>
saveModelOperation = () -> {<z>
)) {<z>
);<z>
;<z>
Object o) {<z>
== o) {<z>
;<z>
o instanceof HttpMethod other) {<z>
(other.name);<z>
return false;<z>
{<z>
SpelNodeImpl expr = eatProductExpression();<z>
TokenKind.INC)) {<z>
= takeToken();<z>
;<z>
(t, rhExpr);<z>
.kind == TokenKind.PLUS) {<z>
.endPos, expr, rhExpr);<z>
t.kind == TokenKind.MINUS) {<z>
endPos, expr, rhExpr);<z>
expr;<z>
executeOngoingLoop() throws JMSException {<z>
= false;<z>
= true;<z>
while (active) {<z>
lifecycleMonitor) {<z>
interrupted = false;<z>
false;<z>
&& !isRunning()) {<z>
if (interrupted) {<z>
IllegalStateException("Thread was interrupted while waiting for " +<z>
"a restart of the listener container, but container is still stopped");<z>
!wasWaiting) {<z>
();<z>
;<z>
lifecycleMonitor.wait();<z>
{<z>
interrupt();<z>
interrupted = true;<z>
wasWaiting) {<z>
;<z>
) {<z>
= false;<z>
(active) {<z>
() || messageReceived);<z>
;<z>
(@Nullable String expression) {<z>
null) {<z>
false;<z>
StringUtils.tokenizeToStringArray(expression, " ");<z>
(fields)) {<z>
false;<z>
(expression, fields);<z>
;<z>
(IllegalArgumentException ex) {<z>
return false;<z>
throws JMSException {<z>
synchronized (this.lifecycleMonitor) {<z>
this.concurrentConsumers; i++) {<z>
);<z>
metaDataCatalogNameToUse(@Nullable String catalogName) {<z>
isSupportsCatalogsInProcedureCalls()) {<z>
catalogName);<z>
;<z>
, String error, String sessionId) {<z>
(HttpStatus.INTERNAL_SERVER_ERROR);<z>
StandardCharsets.UTF_8));<z>
(IOException ex) {<z>
("Failed to send error: " + error, sessionId, ex);<z>
, Throwable ex) {<z>
) != null) {<z>
)) {<z>
+ txInfo.getJoinpointIdentification() +<z>
+ ex);<z>
rollbackOn(ex)) {<z>
-> {<z>
"Application exception overridden by rollback exception", ex);<z>
ex2 instanceof TransactionSystemException) {<z>
).initApplicationException(ex);<z>
ex2;<z>
getReactiveTransaction()).onErrorMap(ex2 -> {<z>
logger.error("Application exception overridden by commit exception", ex);<z>
TransactionSystemException) {<z>
ex);<z>
;<z>
.empty();<z>
{<z>
(actual)<z>
ElementSelectors.byNameAndText))<z>
ignoreComments()<z>
checkForSimilar()<z>
build();<z>
boolean readMessageSize(DataBuffer input) {<z>
this.offset == 0) {<z>
(input.readableByteCount() == 0) {<z>
false;<z>
.read();<z>
firstByte & 0x80) == 0) {<z>
.messageBytesToRead = firstByte;<z>
return true;<z>
messageBytesToRead = firstByte & 0x7f;<z>
;<z>
< 32) {<z>
; this.offset += 7) {<z>
() == 0) {<z>
return false;<z>
int b = input.read();<z>
;<z>
0x80) == 0) {<z>
;<z>
;<z>
{<z>
{<z>
return false;<z>
input.read();<z>
) == 0) {<z>
.offset = 0;<z>
return true;<z>
this.offset = 0;<z>
("Cannot parse message size: malformed varint");<z>
ReactorNettyCodec<P> codec) {<z>
"ReactorNettyCodec is required");<z>
ImmediateEventExecutor.INSTANCE);<z>
.create("tcp-client-loop");<z>
("tcp-client-pool", 10000);<z>
this.codec = codec;<z>
tcpClient = clientConfigurer.apply(TcpClient<z>
(this.poolResources)<z>
, false)<z>
())));<z>
, String path) {<z>
Assert.notNull(servletContext, "Cannot resolve ServletContextResource without ServletContext");<z>
;<z>
, "Path is required");<z>
);<z>
{<z>
pathToUse;<z>
;<z>
void processLocalProperty(PropertyTokenHolder tokens, PropertyValue pv) {<z>
getLocalPropertyHandler(tokens.actualName);<z>
null || !ph.isWritable()) {<z>
pv.isOptional()) {<z>
(logger.isDebugEnabled()) {<z>
.actualName +<z>
;<z>
this.suppressNotWritablePropertyException) {<z>
createNotWritablePropertyException(tokens.canonicalName);<z>
;<z>
getValue();<z>
originalValue;<z>
) {<z>
pv.isConverted()) {<z>
();<z>
()) {<z>
();<z>
Exception ex) {<z>
instanceof PrivilegedActionException) {<z>
();<z>
.isDebugEnabled()) {<z>
"Could not read previous value of property '" +<z>
+ tokens.canonicalName + "'", ex);<z>
convertForProperty(<z>
toTypeDescriptor());<z>
).conversionNecessary = (valueToApply != originalValue);<z>
setValue(valueToApply);<z>
ex) {<z>
;<z>
{<z>
new PropertyChangeEvent(<z>
;<z>
) instanceof ClassCastException) {<z>
(), ex.getTargetException());<z>
;<z>
{<z>
= cause.getCause();<z>
MethodInvocationException(propertyChangeEvent, cause);<z>
Exception ex) {<z>
PropertyChangeEvent pce = new PropertyChangeEvent(<z>
;<z>
MethodInvocationException(pce, ex);<z>
registerBeanDefinition(String beanName, BeanDefinition beanDefinition)<z>
throws BeanDefinitionStoreException {<z>
.hasText(beanName, "Bean name must not be empty");<z>
Assert.notNull(beanDefinition, "BeanDefinition must not be null");<z>
(beanDefinition instanceof AbstractBeanDefinition) {<z>
);<z>
ex) {<z>
(), beanName,<z>
, ex);<z>
beanDefinitionMap.get(beanName);<z>
existingDefinition != null) {<z>
) {<z>
;<z>
beanDefinition.getRole()) {<z>
()) {<z>
"Overriding user-defined bean definition for bean '" + beanName +<z>
"]");<z>
{<z>
.isDebugEnabled()) {<z>
"Overriding bean definition for bean '" + beanName +<z>
+<z>
);<z>
.isTraceEnabled()) {<z>
+<z>
+<z>
);<z>
put(beanName, beanDefinition);<z>
hasBeanCreationStarted()) {<z>
this.beanDefinitionMap) {<z>
beanDefinition);<z>
;<z>
this.beanDefinitionNames);<z>
);<z>
;<z>
);<z>
beanDefinitionMap.put(beanName, beanDefinition);<z>
beanDefinitionNames.add(beanName);<z>
;<z>
this.frozenBeanDefinitionNames = null;<z>
|| containsSingleton(beanName)) {<z>
beanName);<z>
if (isConfigurationFrozen()) {<z>
();<z>
mv, CodeFlow cf) {<z>
this.children) {<z>
(mv, cf);<z>
;<z>
afterPropertiesSet() throws PersistenceException {<z>
JpaVendorAdapter jpaVendorAdapter = getJpaVendorAdapter();<z>
if (jpaVendorAdapter != null) {<z>
{<z>
.getPersistenceProvider();<z>
PersistenceUnitInfo pui = getPersistenceUnitInfo();<z>
.getJpaPropertyMap(pui) :<z>
jpaVendorAdapter.getJpaPropertyMap());<z>
)) {<z>
value) -> {<z>
.jpaPropertyMap.containsKey(key)) {<z>
key, value);<z>
);<z>
this.entityManagerFactoryInterface == null) {<z>
;<z>
this.entityManagerFactoryInterface, this.beanClassLoader)) {<z>
class;<z>
(this.entityManagerInterface == null) {<z>
.entityManagerInterface = jpaVendorAdapter.getEntityManagerInterface();<z>
this.entityManagerInterface, this.beanClassLoader)) {<z>
this.entityManagerInterface = EntityManager.class;<z>
.jpaDialect == null) {<z>
.getJpaDialect();<z>
AsyncTaskExecutor bootstrapExecutor = getBootstrapExecutor();<z>
(bootstrapExecutor != null) {<z>
submit(this::buildNativeEntityManagerFactory);<z>
buildNativeEntityManagerFactory();<z>
;<z>
MethodParameter parameter, ServerWebExchange exchange) {<z>
getSession()<z>
getAttribute(name) != null)<z>
));<z>
computeExitTypeDescriptor() {<z>
[1].exitTypeDescriptor != null &&<z>
].exitTypeDescriptor != null) {<z>
1].exitTypeDescriptor;<z>
children[2].exitTypeDescriptor;<z>
, rightDescriptor)) {<z>
leftDescriptor;<z>
this.exitTypeDescriptor = "Ljava/lang/Object";<z>
int suppliedParamCount, int declaredInParamCount) {<z>
suppliedParamCount < declaredInParamCount) {<z>
(suppliedParamCount + " parameters were supplied, but " +<z>
getName() + "]");<z>
)) {<z>
new InvalidDataAccessApiUsageException(suppliedParamCount + " parameters were supplied, but " +<z>
;<z>
void setBeanName(String name) {<z>
{<z>
name);<z>
name + "'");<z>
public MutateBuilder(RequestMappingInfo other) {<z>
name;<z>
;<z>
;<z>
methodsCondition = other.methodsCondition;<z>
other.paramsCondition;<z>
;<z>
.consumesCondition = other.consumesCondition;<z>
this.producesCondition = other.producesCondition;<z>
this.customConditionHolder = other.customConditionHolder;<z>
;<z>
Label pushSuccessors(final Label listOfLabelsToProcess) {<z>
newListOfLabelsToProcess = listOfLabelsToProcess;<z>
outgoingEdge = outgoingEdges;<z>
) {<z>
isJsrTarget =<z>
nextEdge;<z>
outgoingEdge.successor.nextListElement == null) {<z>
successor.nextListElement = newListOfLabelsToProcess;<z>
.successor;<z>
outgoingEdge.nextEdge;<z>
;<z>
) throws JMSException {<z>
) {<z>
== null) {<z>
;<z>
.connection;<z>
) {<z>
{<z>
.set(attributes);<z>
();<z>
> paramMap, KeyHolder generatedKeyHolder) throws DataAccessException {<z>
validateNamedParameters(paramMap);<z>
= getParsedSql();<z>
= new MapSqlParameterSource(paramMap);<z>
NamedParameterUtils.substituteNamedParameters(parsedSql, paramSource);<z>
paramSource, getDeclaredParameters());<z>
generatedKeyHolder);<z>
checkRowsAffected(rowsAffected);<z>
;<z>
, String> headers,<z>
Type type) {<z>
(body, headers);<z>
method = method;<z>
this.url = url;<z>
;<z>
private void handleCandidateWriteMethod(Method method) throws IntrospectionException {<z>
();<z>
propertyNameFor(method);<z>
];<z>
PropertyDescriptor existingPd = findExistingPropertyDescriptor(propertyName, propertyType);<z>
nParams == 1) {<z>
(existingPd == null) {<z>
(propertyName, null, method));<z>
method);<z>
) {<z>
== null) {<z>
(<z>
method));<z>
existingPd instanceof IndexedPropertyDescriptor) {<z>
;<z>
this.propertyDescriptors.remove(existingPd);<z>
SimpleIndexedPropertyDescriptor(<z>
), null, method));<z>
;<z>
{<z>
);<z>
) {<z>
("No file extension associated with content coding " + coding);<z>
extension;<z>
<?> getClassForValue(Object value) {<z>
> valueClass = value.getClass();<z>
isProxyClass(valueClass)) {<z>
;<z>
ifc : ifcs) {<z>
ClassUtils.isJavaLanguageInterface(ifc)) {<z>
return ifc;<z>
valueClass.getDeclaringClass() == null) {<z>
.getSuperclass();<z>
return valueClass;<z>
ApplicationContext applicationContext, ServletContext servletContext,<z>
) {<z>
, contentNegotiationManager, null);<z>
T data, ResolvableType dataType,<z>
String, Object> hints) {<z>
null) {<z>
);<z>
) -> {<z>
, mediaType, factory);<z>
);<z>
, dataType, mediaType, hints);<z>
logger);<z>
just(startBuffer, dataBuffer, endBuffer);<z>
);<z>
concat(String path1, String path2) {<z>
));<z>
) == getSeparator());<z>
path1EndsWithSeparator && path2StartsWithSeparator) {<z>
);<z>
path2StartsWithSeparator) {<z>
;<z>
return path1 + getSeparator() + path2;<z>
mediaType) {<z>
) {<z>
;<z>
.getStreamingMediaTypes()) {<z>
&& matchParameters(mediaType, streamingMediaType)) {<z>
true;<z>
return false;<z>
throws Throwable {<z>
.targetSource.getTarget();<z>
.invoke(target, args);<z>
, method, retVal);<z>
if (target != null) {<z>
(target);<z>
public void setBeanFactory(BeanFactory beanFactory) throws BeansException {<z>
) == null) {<z>
)) {<z>
"Cannot retrieve EntityManagerFactory by persistence unit name " +<z>
);<z>
));<z>
) {<z>
).toString());<z>
.append(" {");<z>
nextSetBit(0);<z>
1) {<z>
);<z>
);<z>
1) {<z>
;<z>
);<z>
i+1);<z>
.append('}');<z>
();<z>
P publisher, Class<T> elementClass) {<z>
);<z>
notNull(publisher, "'publisher' must not be null");<z>
);<z>
;<z>
, builder);<z>
builder;<z>
around(ProceedingJoinPoint pjp) throws Throwable {<z>
;<z>
.aroundAdviceFired();<z>
return ret;<z>
void setAsText(String text) throws IllegalArgumentException {<z>
{<z>
StringUtils.commaDelimitedListToStringArray(text);<z>
?>[classNames.length];<z>
) {<z>
= classNames[i].trim();<z>
;<z>
);<z>
null);<z>
, SqlParameterSource paramSource) {<z>
int[parsedSql.getTotalParameterCount()];<z>
;<z>
{<z>
paramName = paramNames.get(i);<z>
] = paramSource.getSqlType(paramName);<z>
;<z>
, @Nullable MessageHeaders headers) {<z>
(headers != null) {<z>
);<z>
null && accessor.isMutable()) {<z>
payload, accessor.getMessageHeaders());<z>
;<z>
{<z>
getActivationSpecConfig();<z>
if (config != null) {<z>
config.isPubSubDomain();<z>
;<z>
applyCookies() {<z>
.values()) {<z>
cookies) {<z>
.SET_COOKIE, cookie.toString());<z>
importMetadata) {<z>
.enableTx = AnnotationAttributes.fromMap(<z>
);<z>
enableTx == null) {<z>
throw new IllegalArgumentException(<z>
;<z>
targetListClass) {<z>
targetListClass == null) {<z>
);<z>
)) {<z>
new IllegalArgumentException("'targetListClass' must implement [java.util.List]");<z>
this.targetListClass = targetListClass;<z>
mediaType) {<z>
type, contextClass));<z>
return canRead(mediaType);<z>
Exception ex) {<z>
return false;<z>
)<z>
{<z>
;<z>
.debug("Executing SQL update and returning generated keys");<z>
return updateCount(execute(psc, ps -> {<z>
.executeUpdate();<z>
);<z>
generatedKeys.clear();<z>
.getGeneratedKeys();<z>
{<z>
String, Object>> rse =<z>
);<z>
(keys)));<z>
closeResultSet(keys);<z>
()) {<z>
);<z>
rows;<z>
, true));<z>
{<z>
(this == other) {<z>
;<z>
(!(other instanceof Property otherProperty)) {<z>
return false;<z>
) &&<z>
name) &&<z>
&&<z>
writeMethod, otherProperty.writeMethod));<z>
ResourcePatternResolver resourcePatternResolver, DataSourceLookup dataSourceLookup) {<z>
notNull(resourcePatternResolver, "ResourceLoader must not be null");<z>
;<z>
resourcePatternResolver;<z>
;<z>
, ?> beans) {<z>
= new IdentityHashMap<>();<z>
);<z>
instancesToBeanNames);<z>
{<z>
host = host;<z>
if (host != null) {<z>
();<z>
return this;<z>
) {<z>
)) {<z>
().getFirst("Sec-WebSocket-Version");<z>
.formatValue(<z>
+ version +<z>
1, true));<z>
HttpStatus.UPGRADE_REQUIRED);<z>
set(WebSocketHttpHeaders.SEC_WEBSOCKET_VERSION,<z>
(getSupportedVersions()));<z>
) {<z>
null) {<z>
ContentNegotiationConfigurer(this.servletContext);<z>
.mediaTypes(getDefaultMediaTypes());<z>
configureContentNegotiation(configurer);<z>
contentNegotiationManager = configurer.buildContentNegotiationManager();<z>
;<z>
{<z>
.toStringValue;<z>
value == null) {<z>
;<z>
;<z>
.append('.');<z>
methodName);<z>
.descriptor);<z>
'(');<z>
) {<z>
0) {<z>
(',');<z>
.getClassName());<z>
.append(')');<z>
);<z>
value;<z>
value;<z>
public HttpHandlerAsyncListener(<z>
,<z>
String logPrefix) {<z>
= requestAsyncListener;<z>
.responseAsyncListener = responseAsyncListener;<z>
= handlerDisposeTask;<z>
;<z>
.logPrefix = logPrefix;<z>
IllegalStateException {<z>
beanClassObject = this.beanClass;<z>
== null) {<z>
"No bean class specified on bean definition");<z>
(beanClassObject instanceof Class)) {<z>
IllegalStateException(<z>
"] has not been resolved into an actual Class");<z>
) beanClassObject;<z>
public Builder clear() {<z>
;<z>
;<z>
0x00000001);<z>
{<z>
.getDefaultInstance();<z>
{<z>
clear();<z>
(bitField0_ & ~0x00000002);<z>
return this;<z>
{<z>
) >= this.pathPatternLength) {<z>
false;<z>
{<z>
false;<z>
;<z>
+ 3] == separator) {<z>
this.pos, this.pathPatternData,<z>
NO_MORE_DATA_EXPECTED_AFTER_CAPTURE_THE_REST);<z>
;<z>
(Supplier<? extends CharSequence> messageSupplier) {<z>
) {<z>
(LogMessage.of(messageSupplier));<z>
<String>> values() {<z>
.headers.getHeaderNames().stream()<z>
headers::get)<z>
));<z>
(Map<String, ?> args) {<z>
;<z>
args);<z>
;<z>
) {<z>
) == null) {<z>
IllegalArgumentException("Property 'sessionFactory' is required");<z>
void afterPropertiesSet() {<z>
(this.useGlobalResources) {<z>
connectionProvider == null,<z>
"'useGlobalResources' is mutually exclusive with explicitly configured resources");<z>
HttpResources.get();<z>
this.globalResourcesConsumer != null) {<z>
accept(httpResources);<z>
= httpResources;<z>
httpResources;<z>
this.loopResources == null) {<z>
.manageLoopResources = true;<z>
();<z>
this.connectionProvider == null) {<z>
manageConnectionProvider = true;<z>
= this.connectionProviderSupplier.get();<z>
public Date nextExecutionTime(TriggerContext triggerContext) {<z>
);<z>
triggerContext.lastCompletionTime();<z>
) {<z>
);<z>
) {<z>
;<z>
period);<z>
(RequestMappingInfo other) {<z>
!= null) {<z>
String separator = RequestMappingInfoHandlerMethodMappingNamingStrategy.SEPARATOR;<z>
+ other.name;<z>
this.name != null) {<z>
return this.name;<z>
name;<z>
pvs, Object bean, String beanName) {<z>
), pvs);<z>
(bean, beanName, pvs);<z>
catch (BeanCreationException ex) {<z>
ex;<z>
ex) {<z>
, "Injection of autowired dependencies failed", ex);<z>
return pvs;<z>
Mono<ServerResponse> build(<z>
Mono<Void>> writeFunction) {<z>
new WriterFunctionResponse(<z>
));<z>
public void afterPropertiesSet() {<z>
) {<z>
);<z>
.target instanceof String) {<z>
"'target' needs to be a bean reference, not a bean name as value");<z>
(this.proxyClassLoader == null) {<z>
proxyClassLoader = ClassUtils.getDefaultClassLoader();<z>
;<z>
this.preInterceptors != null) {<z>
{<z>
;<z>
createMainInterceptor()));<z>
if (this.postInterceptors != null) {<z>
this.postInterceptors) {<z>
this.advisorAdapterRegistry.wrap(interceptor));<z>
copyFrom(this);<z>
createTargetSource(this.target);<z>
(targetSource);<z>
this.proxyInterfaces != null) {<z>
proxyFactory.setInterfaces(this.proxyInterfaces);<z>
isProxyTargetClass()) {<z>
);<z>
null) {<z>
(targetClass, this.proxyClassLoader));<z>
;<z>
.getProxy(this.proxyClassLoader);<z>
public Type getType() {<z>
this.result;<z>
result == null) {<z>
.getType());<z>
this.result = result;<z>
index] : (Type) result);<z>
private MessageHeaders createHeaders(<z>
responseRef) {<z>
= new MessageHeaderAccessor();<z>
setLeaveMutable(true);<z>
;<z>
ROUTE_KEY, "");<z>
()) {<z>
).equals(MetadataExtractor.ROUTE_KEY)) {<z>
));<z>
route);<z>
), entry.getValue());<z>
headers.setContentType(this.dataMimeType);<z>
FRAME_TYPE_HEADER, frameType);<z>
RSocketRequesterMethodArgumentResolver.RSOCKET_REQUESTER_HEADER, this.requester);<z>
null) {<z>
, responseRef);<z>
.DATA_BUFFER_FACTORY_HEADER,<z>
));<z>
;<z>
(final Class<?> clazz) {<z>
))) {<z>
return this.emptyLifecycleMetadata;<z>
new ArrayList<>();<z>
new ArrayList<>();<z>
;<z>
);<z>
>();<z>
.doWithLocalMethods(targetClass, method -> {<z>
this.initAnnotationType)) {<z>
;<z>
element);<z>
) {<z>
);<z>
.isAnnotationPresent(this.destroyAnnotationType)) {<z>
method));<z>
if (logger.isTraceEnabled()) {<z>
+ "]: " + method);<z>
;<z>
);<z>
.addAll(currDestroyMethods);<z>
targetClass = targetClass.getSuperclass();<z>
;<z>
destroyMethods.isEmpty() ? this.emptyLifecycleMetadata :<z>
));<z>
,<z>
Object, Publisher<?>> toPublisherFunction,<z>
> fromPublisherFunction) {<z>
);<z>
"'toPublisherFunction' is required");<z>
);<z>
descriptor = descriptor;<z>
this.toPublisherFunction = toPublisherFunction;<z>
= fromPublisherFunction;<z>
Method method) {<z>
;<z>
);<z>
method.isVarArgs()) {<z>
- 1;<z>
this.varargsPosition = null;<z>
) {<z>
(this.keySet == null) {<z>
this.delegate.keySet());<z>
this.keySet;<z>
{<z>
) instanceof NettyDataBufferFactory) {<z>
bufferFactory()).wrap(byteBuf);<z>
byteBuf.nioBuffer());<z>
();<z>
;<z>
] getArguments(ExpressionState state) throws EvaluationException {<z>
)];<z>
length; i++) {<z>
getValueInternal(state).getValue();<z>
;<z>
<Void> bind(ServerWebExchange exchange) {<z>
getValuesToBind(exchange)<z>
-> doBind(new MutablePropertyValues(values)))<z>
;<z>
setUseTrailingSlashMatch(boolean useTrailingSlashMatch) {<z>
this.useTrailingSlashMatch = useTrailingSlashMatch;<z>
if (getPatternParser() != null) {<z>
setMatchOptionalTrailingSeparator(useTrailingSlashMatch);<z>
sendErrorMessage(WebSocketSession session, Throwable error) {<z>
= StompHeaderAccessor.create(StompCommand.ERROR);<z>
;<z>
);<z>
));<z>
) {<z>
ex);<z>
CloseStatus.PROTOCOL_ERROR);<z>
catch (IOException ex) {<z>
(SubscribableChannel clientInboundChannel,<z>
[] destinationPrefixes) {<z>
, "'clientInboundChannel' must not be null");<z>
;<z>
.clientInboundChannel = clientInboundChannel;<z>
;<z>
?<z>
emptyList());<z>
void validateMirrorSet(MirrorSet mirrorSet) {<z>
Method firstAttribute = mirrorSet.get(0);<z>
;<z>
() - 1; i++) {<z>
= mirrorSet.get(i);<z>
Object mirrorDefaultValue = mirrorAttribute.getDefaultValue();<z>
== null || mirrorDefaultValue == null) {<z>
String.format(<z>
, AttributeMethods.describe(mirrorAttribute)));<z>
nullSafeEquals(firstDefaultValue, mirrorDefaultValue)) {<z>
throw new AnnotationConfigurationException(String.format(<z>
AttributeMethods.describe(mirrorAttribute)));<z>
public static byte[] generateMultipartBoundary() {<z>
;<z>
(11) + 30];<z>
< boundary.length; i++) {<z>
nextInt(BOUNDARY_CHARS.length)];<z>
;<z>
(CacheOperation.Builder builder) {<z>
(!this.initialized) {<z>
);<z>
if (annotation != null) {<z>
this.cacheNames = annotation.cacheNames();<z>
this.keyGenerator = annotation.keyGenerator();<z>
();<z>
);<z>
this.initialized = true;<z>
) {<z>
cacheNames);<z>
&&<z>
this.keyGenerator)) {<z>
this.keyGenerator);<z>
hasText(builder.getCacheResolver())) {<z>
StringUtils.hasText(this.cacheResolver)) {<z>
setCacheResolver(this.cacheResolver);<z>
.hasText(this.cacheManager)) {<z>
cacheManager);<z>
messageConverter, @Nullable Validator validator,<z>
boolean useDefaultResolution) {<z>
Assert.notNull(messageConverter, "MessageConverter must not be null");<z>
converter = messageConverter;<z>
this.validator = validator;<z>
.useDefaultResolution = useDefaultResolution;<z>
() throws IOException {<z>
isReady()) {<z>
dataBuffer = readFromInputStream();<z>
EOF_BUFFER) {<z>
();<z>
dataBuffer = null;<z>
return dataBuffer;<z>
null;<z>
{<z>
this == other) {<z>
;<z>
{<z>
false;<z>
other).value());<z>
BeanWrapper instantiateUsingFactoryMethod(<z>
] explicitArgs) {<z>
beanName, mbd, explicitArgs);<z>
void logWriteFrameFailure(Throwable ex) {<z>
(indicatesDisconnectedClient(ex)) {<z>
disconnectedClientLogger.isTraceEnabled()) {<z>
);<z>
)) {<z>
debug("Looks like the client has gone away: " + ex +<z>
" (For a full stack trace, set the log category '" + DISCONNECTED_CLIENT_LOG_CATEGORY +<z>
"' to TRACE level.)");<z>
("Terminating connection after failure to send message to client", ex);<z>
applicationContext) {<z>
(<z>
);<z>
beans.isEmpty()) {<z>
());<z>
(mappings);<z>
;<z>
;<z>
) throws BeansException {<z>
isTraceEnabled()) {<z>
+ this);<z>
(this.beanDefinitionNames);<z>
{<z>
;<z>
!bd.isLazyInit()) {<z>
{<z>
= getBean(FACTORY_BEAN_PREFIX + beanName);<z>
(bean instanceof FactoryBean<?> factory) {<z>
&&<z>
());<z>
if (isEagerInit) {<z>
);<z>
getBean(beanName);<z>
: beanNames) {<z>
;<z>
singletonInstance instanceof SmartInitializingSingleton smartSingleton) {<z>
this.getApplicationStartup().start("spring.beans.smart-initialize")<z>
;<z>
smartSingleton.afterSingletonsInstantiated();<z>
;<z>
returnValue, MethodParameter returnType) {<z>
returnType);<z>
handler instanceof AsyncHandlerMethodReturnValueHandler &&<z>
));<z>
{<z>
parseResult = parse(message);<z>
) {<z>
;<z>
.getUser();<z>
parseResult.getSourceDestination();<z>
new HashSet<>();<z>
: parseResult.getSessionIds()) {<z>
();<z>
getTargetDestination(<z>
sessionId, user);<z>
null) {<z>
add(targetDestination);<z>
= parseResult.getSubscribeDestination();<z>
, user);<z>
(Object key) {<z>
String name = (String) key;<z>
;<z>
;<z>
;<z>
Annotation annotation) {<z>
Assert.notNull(annotation, "Annotation must not be null");<z>
annotationType != null) {<z>
this.annotationType, annotation);<z>
(<z>
, AspectJExpressionPointcut pointcut, AspectInstanceFactory aif) {<z>
aspectJBeforeAdviceMethod, pointcut, aif);<z>
ServerHttpResponse response,<z>
sessionManager, ServerCodecConfigurer codecConfigurer,<z>
localeContextResolver) {<z>
localeContextResolver, null);<z>
encodeEntry(Object value, MimeType mimeType) {<z>
if (value instanceof ByteBuf) {<z>
asDataBuffer((ByteBuf) value);<z>
ResolvableType type = ResolvableType.forInstance(value);<z>
encoder(type, mimeType);<z>
mimeType + "'");<z>
.emptyMap());<z>
invoke(MethodInvocation mi) throws Throwable {<z>
;<z>
mi.proceed();<z>
this.multiple;<z>
(final MethodInvocation invocation) throws Throwable {<z>
invocation.getMethod();<z>
= () -> {<z>
return invocation.proceed();<z>
catch (Throwable ex) {<z>
throw new CacheOperationInvoker.ThrowableWrapper(ex);<z>
;<z>
.state(target != null, "Target must not be null");<z>
, invocation.getArguments());<z>
catch (CacheOperationInvoker.ThrowableWrapper th) {<z>
.getOriginal();<z>
UrlPathHelper getUrlPathHelperOrDefault() {<z>
!= null) {<z>
return this.urlPathHelper;<z>
(this.defaultUrlPathHelper == null) {<z>
defaultUrlPathHelper = new UrlPathHelper();<z>
;<z>
public void addRelatedCause(Throwable ex) {<z>
this.relatedCauses == null) {<z>
relatedCauses = new ArrayList<>();<z>
;<z>
method, Object[] args) throws Throwable {<z>
{<z>
"equals":<z>
proxy == args[0]);<z>
case "hashCode":<z>
System.identityHashCode(proxy);<z>
case "getTargetConnection":<z>
;<z>
"unwrap":<z>
)) {<z>
return proxy;<z>
case "isWrapperFor":<z>
0]).isInstance(proxy)) {<z>
true;<z>
if (!hasTargetConnection()) {<z>
switch (method.getName()) {<z>
case "toString":<z>
() + "]";<z>
:<z>
{<z>
;<z>
"setAutoCommit":<z>
(Boolean) args[0];<z>
return null;<z>
:<z>
.transactionIsolation != null) {<z>
transactionIsolation;<z>
:<z>
];<z>
return null;<z>
:<z>
return this.readOnly;<z>
:<z>
readOnly = (Boolean) args[0];<z>
null;<z>
case "getHoldability":<z>
return this.holdability;<z>
"setHoldability":<z>
holdability = (Integer) args[0];<z>
return null;<z>
"commit":<z>
"rollback":<z>
return null;<z>
case "getWarnings":<z>
case "clearWarnings":<z>
;<z>
"close":<z>
.closed = true;<z>
null;<z>
"isClosed":<z>
closed;<z>
closed) {<z>
;<z>
(method), args);<z>
ex) {<z>
getTargetException();<z>
{<z>
{<z>
.getNestedParameterType())) {<z>
RequestParam.class);<z>
hasText(requestParam.name()));<z>
;<z>
.class)) {<z>
false;<z>
.nestedIfOptional();<z>
if (MultipartResolutionDelegate.isMultipartArgument(parameter)) {<z>
;<z>
) {<z>
isSimpleProperty(parameter.getNestedParameterType());<z>
false;<z>
public void setContentLength(int len) {<z>
.size()) {<z>
this.content.resize(len);<z>
len;<z>
throws Throwable {<z>
InjectedElement> checkedElements = this.checkedElements;<z>
InjectedElement> elementsToIterate =<z>
injectedElements);<z>
()) {<z>
: elementsToIterate) {<z>
, beanName, pvs);<z>
, HttpCookie> initCookies() {<z>
>();<z>
) {<z>
);<z>
(name, cookie.getValue());<z>
name, httpCookie);<z>
;<z>
public void validate() throws BeanDefinitionValidationException {<z>
);<z>
== null) {<z>
throw new BeanDefinitionValidationException("'parentName' must be set in ChildBeanDefinition");<z>
Object...args) {<z>
GroovyBeanDefinitionWrapper current = this.currentBeanDefinition;<z>
<?> callable = null;<z>
Object> constructorArgs = null;<z>
ObjectUtils.isEmpty(args)) {<z>
int index = args.length;<z>
index - 1];<z>
) {<z>
= (Closure<?>) lastArg;<z>
;<z>
index);<z>
new GroovyBeanDefinitionWrapper(null, type, constructorArgs);<z>
{<z>
currentBeanDefinition);<z>
);<z>
.currentBeanDefinition = current;<z>
{<z>
) {<z>
.timeCreated);<z>
() - this.timeLastActive);<z>
(BeanFactory beanFactory) {<z>
{<z>
;<z>
throws IllegalStateException {<z>
);<z>
== null) {<z>
throw new IllegalStateException(<z>
"No 'defaultDestination' or 'defaultDestinationName' specified. Check configuration of JmsTemplate.");<z>
name;<z>
{<z>
)) {<z>
"Closing cached Session: " + this.target);<z>
{<z>
close();<z>
)) {<z>
close();<z>
.cachedProducers.clear();<z>
;<z>
;<z>
data, DataBuffer metadata) {<z>
|| metadata instanceof NettyDataBuffer ?<z>
asByteBuf(metadata)) :<z>
, asByteBuffer(metadata));<z>
hasCachePut(CacheOperationContexts contexts) {<z>
.class);<z>
);<z>
: cachePutContexts) {<z>
) {<z>
.add(context);<z>
catch (VariableNotAvailableException ex) {<z>
());<z>
AnnotatedElement source,<z>
, R> processor) {<z>
= processor.doWithAggregate(context, 0);<z>
result != null ? result : processor.doWithAnnotations(<z>
)));<z>
Throwable ex) {<z>
);<z>
return null;<z>
String destination, StompFrameHandler handler) {<z>
StompHeaders headers = new StompHeaders();<z>
(destination);<z>
);<z>
) {<z>
METHOD_NOT_ALLOWED, "Request method '" + method + "' not supported");<z>
notNull(method, "'method' is required");<z>
(supportedMethods == null) {<z>
emptySet();<z>
= method;<z>
<>(supportedMethods));<z>
isCancelled() {<z>
.triggerContextMonitor) {<z>
();<z>
A> annotationType,<z>
A>> predicate) {<z>
get(annotationType, predicate, null);<z>
uri, HttpHeaders headers) {<z>
;<z>
method;<z>
this.uri = uri;<z>
.headers = headers;<z>
{<z>
level = 0;<z>
= 0;<z>
];<z>
i++) {<z>
source.charAt(i);<z>
== '{') {<z>
++;<z>
) {<z>
--;<z>
)) {<z>
chars[lastCharIndex++] = c;<z>
lastCharIndex);<z>
> save(ServerWebExchange exchange, WebSession session) {<z>
(exchange);<z>
{<z>
isEmpty()) {<z>
)) {<z>
logger.debug("WebSession expired or has been invalidated");<z>
;<z>
empty();<z>
{<z>
;<z>
();<z>
DataSourceLookupFailureException {<z>
);<z>
= this.dataSources.get(dataSourceName);<z>
null) {<z>
DataSourceLookupFailureException(<z>
+ "' registered");<z>
return dataSource;<z>
dataHolder) {<z>
(graph, streamWriter, dataHolder);<z>
{<z>
convertXStreamException(ex, true);<z>
);<z>
catch (Exception ex) {<z>
);<z>
public boolean equals(@Nullable Object other) {<z>
this == other) {<z>
return true;<z>
(other instanceof AbstractWebSocketMessage)) {<z>
return false;<z>
other;<z>
, otherMessage.payload);<z>
getCloseSuppressingConnectionProxy(Connection target) {<z>
Connection) Proxy.newProxyInstance(<z>
class.getClassLoader(),<z>
class},<z>
CloseSuppressingInvocationHandler(target));<z>
HttpMediaTypeNotSupportedException ex,<z>
Nullable Object handler) throws IOException {<z>
;<z>
{<z>
.toString(mediaTypes));<z>
.equals("PATCH")) {<z>
, MediaType.toString(mediaTypes));<z>
);<z>
ModelAndView();<z>
delegate, Trigger trigger, Clock clock,<z>
executor, ErrorHandler errorHandler) {<z>
;<z>
trigger;<z>
);<z>
.executor = executor;<z>
public void close() {<z>
hasNext();) {<z>
Runnable runnable = it.next();<z>
;<z>
(<z>
{<z>
value == null) {<z>
;<z>
{<z>
(String) value;<z>
if (cs != null) {<z>
STRING_TYPE_DESCRIPTOR);<z>
value.toString();<z>
void run() {<z>
this.inputMessage;<z>
(message);<z>
) {<z>
(message);<z>
(message, null);<z>
) {<z>
, ex);<z>
(ex instanceof MessagingException) {<z>
ex;<z>
+ " in " + this.messageHandler;<z>
, description, ex);<z>
err) {<z>
;<z>
;<z>
(message, ex2);<z>
ex2;<z>
public final void compile() throws InvalidDataAccessApiUsageException {<z>
()) {<z>
() == null) {<z>
throw new InvalidDataAccessApiUsageException("Property 'sql' is required");<z>
afterPropertiesSet();<z>
) {<z>
());<z>
();<z>
= true;<z>
isDebugEnabled()) {<z>
) + "] compiled");<z>
protected void flush() throws IOException {<z>
responseChannel;<z>
if (channel != null) {<z>
) {<z>
(getLogPrefix() + "flush");<z>
flush();<z>
forFallbackMatch() {<z>
return new DependencyDescriptor(this) {<z>
public boolean fallbackMatchAllowed() {<z>
return true;<z>
) {<z>
MethodParameter param) {<z>
param.nestedIfOptional();<z>
{<z>
nested();<z>
);<z>
= param.getContainingClass();<z>
(genericParameterType, contextClass);<z>
targetClass;<z>
Nullable String reason, HttpServletResponse response)<z>
IOException {<z>
reason)) {<z>
sendError(statusCode);<z>
String resolvedReason = (this.messageSource != null ?<z>
reason, LocaleContextHolder.getLocale()) :<z>
;<z>
);<z>
();<z>
? extends Annotation> container,<z>
Annotation> repeatable) {<z>
new ExplicitRepeatableContainer(this, repeatable, container);<z>
, MessageChannel outboundChannel,<z>
> destinationPrefixes) {<z>
"'inboundChannel' must not be null");<z>
(outboundChannel, "'outboundChannel' must not be null");<z>
, "'brokerChannel' must not be null");<z>
.clientInboundChannel = inboundChannel;<z>
clientOutboundChannel = outboundChannel;<z>
.brokerChannel = brokerChannel;<z>
;<z>
destinationPrefixes);<z>
, String name) throws AccessException {<z>
{<z>
return false;<z>
clazz : target.getClass());<z>
name, target instanceof Class);<z>
) {<z>
true;<z>
;<z>
null) {<z>
new Property(type, null, method);<z>
TypeDescriptor typeDescriptor = new TypeDescriptor(property);<z>
method = ClassUtils.getInterfaceMethodIfPossible(method);<z>
.put(cacheKey, method);<z>
.put(cacheKey, typeDescriptor);<z>
return true;<z>
);<z>
) {<z>
(cacheKey, field);<z>
(field));<z>
;<z>
return false;<z>
(RequestContext requestContext) {<z>
, requestContext.getLocale());<z>
.getTimeZone();<z>
) {<z>
Config.FMT_TIME_ZONE, timeZone);<z>
messageSource = getJstlAwareMessageSource(<z>
(), requestContext.getMessageSource());<z>
());<z>
;<z>
setContentType(@Nullable MimeType mimeType) {<z>
{<z>
, "'Content-Type' cannot contain wildcard type '*'");<z>
);<z>
);<z>
(CONTENT_TYPE, null);<z>
AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,<z>
annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {<z>
<?> mergedAnnotation = getAnnotations(element)<z>
;<z>
mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);<z>
(<z>
className, Class<?> classBeingRedefined,<z>
[] classfileBuffer) {<z>
{<z>
currentlyTransforming) {<z>
;<z>
this.currentlyTransforming = true;<z>
= this.classTransformer.transform(<z>
, className, classBeingRedefined, protectionDomain, classfileBuffer);<z>
&& logger.isDebugEnabled()) {<z>
.getClass().getName() +<z>
"] transformed class [" + className + "]; bytes in=" +<z>
length + "; bytes out=" + transformed.length);<z>
transformed;<z>
ex) {<z>
(logger.isErrorEnabled()) {<z>
+ "] with " +<z>
ex);<z>
className + "]", ex);<z>
) {<z>
(logger.isWarnEnabled()) {<z>
.warn("Error weaving class [" + className + "] with transformer of class [" +<z>
() + "]", ex);<z>
"Could not weave class [" + className + "]", ex);<z>
.currentlyTransforming = false;<z>
NumberFormat getNumberFormat(Locale locale) {<z>
.getInstance(locale);<z>
instanceof DecimalFormat decimalFormat)) {<z>
.pattern != null) {<z>
format);<z>
format;<z>
);<z>
) {<z>
.applyPattern(this.pattern);<z>
return decimalFormat;<z>
(CompositeRequestCondition other, ServerWebExchange exchange) {<z>
()) {<z>
0;<z>
(isEmpty()) {<z>
;<z>
if (other.isEmpty()) {<z>
;<z>
(other);<z>
i++) {<z>
;<z>
) {<z>
result;<z>
return 0;<z>
BeansException {<z>
{<z>
return (Interceptor) this.entityInterceptor;<z>
) {<z>
== null) {<z>
("Cannot get entity interceptor via bean name if no bean factory set");<z>
entityInterceptor;<z>
;<z>
;<z>
private MethodArgumentResolutionException getUnexpectedPayloadError(<z>
actualType) {<z>
parameter,<z>
;<z>
applyHeaders() {<z>
);<z>
;<z>
= getHeaders().getContentType();<z>
) {<z>
getFirst(HttpHeaders.CONTENT_TYPE);<z>
;<z>
!= null) {<z>
setContentType(contentType.toString());<z>
getCharset() : null);<z>
() == null && charset != null) {<z>
);<z>
;<z>
contentLength != -1) {<z>
.setContentLengthLong(contentLength);<z>
void initBinder(WebDataBinder binder) {<z>
autoGrowNestedPaths);<z>
directFieldAccess) {<z>
binder.initDirectFieldAccess();<z>
this.messageCodesResolver != null) {<z>
setMessageCodesResolver(this.messageCodesResolver);<z>
{<z>
.setBindingErrorProcessor(this.bindingErrorProcessor);<z>
null && binder.getTarget() != null &&<z>
{<z>
.setValidator(this.validator);<z>
(this.conversionService != null) {<z>
.setConversionService(this.conversionService);<z>
if (this.propertyEditorRegistrars != null) {<z>
(PropertyEditorRegistrar propertyEditorRegistrar : this.propertyEditorRegistrars) {<z>
;<z>
Nullable Map<String, ?> attributes) {<z>
if (attributes != null) {<z>
{<z>
(!containsKey(key)) {<z>
, value);<z>
});<z>
;<z>
() {<z>
getCacheManager() == null) {<z>
());<z>
.afterPropertiesSet();<z>
() {<z>
dataSource == null) {<z>
();<z>
(this.dataSource);<z>
{<z>
);<z>
);<z>
getExchange().transformUrl(url);<z>
Class<?> getPropertyType() {<z>
this.propertyType == null) {<z>
;<z>
IntrospectionException ex) {<z>
propertyType;<z>
T getStrategy(Class<T> strategyType) {<z>
strategy : getStrategies()) {<z>
if (strategyType.isInstance(strategy)) {<z>
;<z>
return null;<z>
bean) {<z>
, "Bean must not be null");<z>
this.beanOrName = bean;<z>
isSingleton = true;<z>
;<z>
));<z>
this.beanType);<z>
null;<z>
response) {<z>
ServletWebRequest servletWebRequest =<z>
));<z>
();<z>
responseHeaders.getETag();<z>
.getLastModified();<z>
.getMethod() == HttpMethod.HEAD) {<z>
ETAG);<z>
responseHeaders.remove(HttpHeaders.LAST_MODIFIED);<z>
return servletWebRequest.checkNotModified(etag, lastModifiedTimestamp);<z>
(Map<?, ?> map) {<z>
;<z>
map.values()) {<z>
element instanceof RuntimeBeanReference) {<z>
containsRuntimeRefs = true;<z>
if (containsRuntimeRefs) {<z>
>();<z>
putAll(map);<z>
return managedMap;<z>
map;<z>
> getJackson2JsonEncoder() {<z>
{<z>
;<z>
;<z>
{<z>
.startsWith(DefaultTransactionDefinition.PREFIX_ISOLATION)) {<z>
);<z>
));<z>
{<z>
= path.length();<z>
indexOf('?');<z>
) {<z>
= queryIndex;<z>
hashIndex = path.indexOf('#');<z>
hashIndex > 0) {<z>
;<z>
suffixIndex;<z>
XMLEvent event) {<z>
{<z>
isStartElement()) {<z>
1 ? 0 : this.byteCount;<z>
.elementDepth++;<z>
)) {<z>
.elementDepth--;<z>
: this.byteCount;<z>
) {<z>
CollectionUtils.isEmpty(mediaTypes)) {<z>
.forEach((key, value) -><z>
;<z>
ComposablePointcut(Pointcut pointcut) {<z>
pointcut, "Pointcut must not be null");<z>
this.classFilter = pointcut.getClassFilter();<z>
.methodMatcher = pointcut.getMethodMatcher();<z>
<String>>> entrySet() {<z>
new AbstractSet<>() {<z>
iterator() {<z>
();<z>
() {<z>
HttpComponentsHeadersAdapter.this.size();<z>
Validator validator) {<z>
assertValidators(validator);<z>
validators.clear();<z>
{<z>
(validator);<z>
appendValue(String value) throws JspException {<z>
()) {<z>
);<z>
);<z>
this.writer.append(value);<z>
Nullable HttpServletRequest request, String requestPath,<z>
Resource> locations, ResourceResolverChain chain) {<z>
, locations);<z>
if (resolved == null) {<z>
);<z>
webJarResourcePath != null) {<z>
;<z>
return resolved;<z>
public ContextConfigurationAttributes(<z>
inheritLocations,<z>
,<z>
ContextLoader> contextLoaderClass) {<z>
null,<z>
;<z>
propertyName, @Nullable Method readMethod,<z>
)<z>
IntrospectionException {<z>
, null, null, null, null);<z>
.readMethod = readMethod;<z>
;<z>
);<z>
this.indexedReadMethod = indexedReadMethod;<z>
indexedWriteMethod;<z>
this.indexedPropertyType = PropertyDescriptorUtils.findIndexedPropertyType(<z>
, indexedReadMethod, indexedWriteMethod);<z>
, EntityManagerFactory emf) {<z>
instanceof EntityManagerFactoryInfo emfInfo) {<z>
jpaDialect = emfInfo.getJpaDialect();<z>
jpaDialect != null) {<z>
cleanupTransaction(transactionData);<z>
(<z>
] patterns, @Nullable PathPatternParser parser) {<z>
(patterns)) {<z>
;<z>
return Arrays.stream(patterns)<z>
))<z>
]::new);<z>
(HttpStatus status) {<z>
"HttpStatus must not be null");<z>
status = status.value();<z>
this;<z>
startPos, int endPos, int radix) {<z>
parseInt(numberToken, radix);<z>
);<z>
catch (NumberFormatException ex) {<z>
;<z>
exchange, Resource resource) {<z>
null && this.nextChain != null ?<z>
this.nextChain) :<z>
));<z>
execute(final String sql) throws DataAccessException {<z>
)) {<z>
sql + "]");<z>
{<z>
public Object doInStatement(Statement stmt) throws SQLException {<z>
sql);<z>
null;<z>
() {<z>
return sql;<z>
);<z>
Map<String, Object> hints) {<z>
.resolve()) {<z>
, data.length() - 1);<z>
decoder == null) {<z>
CodecException("No SSE decoder configured and the data is not String.");<z>
.UTF_8);<z>
= DefaultDataBufferFactory.sharedInstance.wrap(bytes);<z>
;<z>
UriComponentsBuilder builder,<z>
Object... args) {<z>
methodName, args);<z>
controllerType, method, args);<z>
HttpServletResponse response, Object handler)<z>
Exception {<z>
.setAttribute(RESOURCE_URL_PROVIDER_ATTR, this.resourceUrlProvider);<z>
{<z>
);<z>
;<z>
HttpServletRequest request) {<z>
new AttributesPreservingRequest(request);<z>
) -> {<z>
executionChain.getInterceptorList()) {<z>
interceptor instanceof CorsConfigurationSource) {<z>
getCorsConfiguration(wrappedRequest);<z>
instanceof CorsConfigurationSource) {<z>
getCorsConfiguration(wrappedRequest);<z>
;<z>
);<z>
) {<z>
[] classBuffer = classFileBuffer;<z>
<< 24)<z>
offset + 1] & 0xFF) << 16)<z>
] & 0xFF) << 8)<z>
0xFF);<z>
protected ReflectiveMethodInvocation(<z>
] arguments,<z>
<Object> interceptorsAndDynamicMethodMatchers) {<z>
proxy;<z>
target = target;<z>
= targetClass;<z>
(method);<z>
arguments);<z>
;<z>
<?>... generics) {<z>
"Class must not be null");<z>
"Generics array must not be null");<z>
new ResolvableType[generics.length];<z>
{<z>
forClass(generics[i]);<z>
clazz, resolvableGenerics);<z>
BeanDefinition newDefinition, BeanDefinition existingDefinition) {<z>
existingDefinition instanceof ScannedGenericBeanDefinition) ||<z>
(existingDefinition.getSource())) ||<z>
;<z>
type) throws BeansException {<z>
this.beanFactory == null) {<z>
new IllegalStateException("No BeanFactory configured - " +<z>
);<z>
beanFactory, type);<z>
{<z>
null;<z>
= request.getServletContext();<z>
= WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);<z>
.class);<z>
) {<z>
new SessionFlashMapManager());<z>
DataAccessException {<z>
(action, "Callback object must not be null");<z>
;<z>
false;<z>
);<z>
ex) {<z>
);<z>
if (session == null) {<z>
openSession();<z>
);<z>
= true;<z>
(session);<z>
sessionToExpose =<z>
) ? session : createSessionProxy(session));<z>
doInHibernate(sessionToExpose);<z>
HibernateException ex) {<z>
(ex);<z>
ex) {<z>
) instanceof HibernateException) {<z>
);<z>
;<z>
(RuntimeException ex) {<z>
;<z>
isNew) {<z>
SessionFactoryUtils.closeSession(session);<z>
);<z>
void beforeFirst() throws InvalidResultSetAccessException {<z>
beforeFirst();<z>
SQLException se) {<z>
new InvalidResultSetAccessException(se);<z>
insertOptimalLoad(MethodVisitor mv, int value) {<z>
< 6) {<z>
value);<z>
value < Byte.MAX_VALUE) {<z>
mv.visitIntInsn(BIPUSH, value);<z>
Short.MAX_VALUE) {<z>
visitIntInsn(SIPUSH, value);<z>
mv.visitLdcInsn(value);<z>
(String functionName) {<z>
);<z>
(true);<z>
this;<z>
(TransactionManager transactionManager) {<z>
if (transactionManager instanceof UserTransaction) {<z>
return (UserTransaction) transactionManager;<z>
;<z>
void ensureSpringRulesAreNotPresent(Class<?> testClass) {<z>
) {<z>
String.format(<z>
, testClass.getName()));<z>
), () -> String.format(<z>
.getName()));<z>
{<z>
== null) {<z>
);<z>
resourcePatternResolver;<z>
(HttpServletRequest servletRequest) throws Exception {<z>
) {<z>
this.messageConverters);<z>
route(request).orElse(null);<z>
request, handlerFunction);<z>
return handlerFunction;<z>
null;<z>
IOException {<z>
);<z>
path == null) {<z>
"Required request attribute '" +<z>
+ "' is not set");<z>
;<z>
path)) {<z>
;<z>
isInvalidEncodedPath(path)) {<z>
;<z>
;<z>
);<z>
(request, path, getLocations());<z>
if (resource != null) {<z>
request, resource);<z>
resource;<z>
public void visitLocalVariable(<z>
,<z>
final String descriptor,<z>
final String signature,<z>
Label start,<z>
final Label end,<z>
final int index) {<z>
if (mv != null) {<z>
start, end, index);<z>
> MergedAnnotation<T> getAnnotation(String attributeName,<z>
) throws NoSuchElementException {<z>
(<z>
);<z>
String factoryMethodName) {<z>
= new BeanDefinitionBuilder(new RootBeanDefinition());<z>
beanClass);<z>
beanDefinition.setFactoryMethodName(factoryMethodName);<z>
;<z>
,<z>
TyrusWebSocketEngine engine)<z>
{<z>
new ServerEndpointRegistration(endpointPath, endpoint);<z>
(protocol));<z>
setExtensions(extensions);<z>
;<z>
exchange) {<z>
ProduceMediaTypeExpression> result = null;<z>
{<z>
match(exchange)) {<z>
;<z>
add(expression);<z>
result;<z>
Session session, EndpointConfig config) {<z>
.sessionFactory.apply(session);<z>
null, "No delegate session");<z>
(String.class, message -> {<z>
);<z>
.getType(), webSocketMessage);<z>
);<z>
(ByteBuffer.class, message -> {<z>
WebSocketMessage webSocketMessage = toMessage(message);<z>
webSocketMessage);<z>
});<z>
addMessageHandler(PongMessage.class, message -> {<z>
webSocketMessage = toMessage(message);<z>
;<z>
;<z>
.handle(this.delegateSession)<z>
.getRequestURI() + " [StandardWebSocketHandlerAdapter]")<z>
);<z>
JobDetail... jobDetails) {<z>
jobDetails));<z>
, String beanName) throws BeansException {<z>
if (bean instanceof LoadTimeWeaverAware) {<z>
;<z>
) {<z>
!= null,<z>
;<z>
getBean(<z>
LoadTimeWeaver.class);<z>
) bean).setLoadTimeWeaver(ltw);<z>
bean;<z>
String getShortLogMessage(Object payload) {<z>
(getMessageType() == null) {<z>
);<z>
getBaseLogMessage();<z>
CollectionUtils.isEmpty(getSessionAttributes())) {<z>
(']');<z>
(getShortPayloadLogMessage(payload));<z>
.toString();<z>
headers) {<z>
);<z>
.serverInfoCache.get(infoUrl);<z>
(info == null) {<z>
.currentTimeMillis();<z>
infoUrl, headers);<z>
= System.currentTimeMillis() - start;<z>
= new ServerInfo(response, infoRequestTime);<z>
;<z>
return info;<z>
PropertyAccessException getPropertyAccessException(String propertyName) {<z>
for (PropertyAccessException pae : this.propertyAccessExceptions) {<z>
.getPropertyName())) {<z>
pae;<z>
null;<z>
, Locale locale) throws Exception {<z>
) {<z>
locale);<z>
viewName, locale);<z>
(cacheKey);<z>
(view == null) {<z>
(this.viewCreationCache) {<z>
(cacheKey);<z>
if (view == null) {<z>
;<z>
.cacheUnresolved) {<z>
= UNRESOLVED_VIEW;<z>
(view, viewName, locale)) {<z>
view);<z>
.put(cacheKey, view);<z>
isTraceEnabled()) {<z>
trace(formatKey(cacheKey) + "served from cache");<z>
!= UNRESOLVED_VIEW ? view : null);<z>
{<z>
(HttpStatus.FORBIDDEN);<z>
UTF_8));<z>
);<z>
sameSite) {<z>
(), cookie.getValue())<z>
.domain(cookie.getDomain())<z>
))<z>
maxAge(cookie.getMaxAge())<z>
())<z>
(cookie.getSecure())<z>
sameSite)<z>
);<z>
String getShortPayloadLogMessage(Object payload) {<z>
payload instanceof String payloadText) {<z>
(payloadText.length() < 80) ?<z>
" payload=" + payloadText :<z>
"...(truncated)";<z>
payload instanceof byte[] bytes) {<z>
isReadableContentType()) {<z>
(bytes.length < 80) ?<z>
bytes, getCharset()) :<z>
getCharset()) + "...(truncated)";<z>
"]";<z>
);<z>
payloadText.length() < 80) ?<z>
:<z>
(payload);<z>
(<z>
Nullable Charset responseCharset,<z>
@Nullable HttpRequest request) {<z>
"]", statusCode, "",<z>
responseCharset, request);<z>
{<z>
.charsToDelete);<z>
.emptyArrayAsNull && array.length == 0) {<z>
(null);<z>
this.trimValues) {<z>
);<z>
(array);<z>
Exception> exceptionClass) {<z>
.class);<z>
ex) {<z>
(Throwable.class);<z>
(NoSuchMethodException ex2) {<z>
(String.class);<z>
) {<z>
IllegalArgumentException(<z>
+ exceptionClass.getName() +<z>
;<z>
(String runnableBeanName,<z>
String triggerBeanName, Element taskElement, ParserContext parserContext) {<z>
BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(<z>
"org.springframework.scheduling.config.TriggerTask");<z>
addConstructorArgReference(runnableBeanName);<z>
triggerBeanName);<z>
);<z>
{<z>
.size());<z>
) {<z>
;<z>
matchingCondition == null) {<z>
return null;<z>
.add(matchingCondition);<z>
result);<z>
<? super Integer> matcher) {<z>
exchangeResult.getRawStatusCode();<z>
));<z>
responseSpec;<z>
message)<z>
{<z>
null) {<z>
.getHeaders();<z>
sessionId = SimpMessageHeaderAccessor.getSessionId(headers);<z>
getDestinationHelper(headers, returnType);<z>
);<z>
{<z>
= sendToUser.broadcast();<z>
= getUserName(message, headers);<z>
(user == null) {<z>
null) {<z>
new MissingSessionUserException(message);<z>
= sessionId;<z>
false;<z>
;<z>
: destinations) {<z>
;<z>
if (broadcast) {<z>
this.messagingTemplate.convertAndSendToUser(<z>
);<z>
convertAndSendToUser(<z>
));<z>
= destinationHelper.getSendTo();<z>
{<z>
);<z>
destination : destinations) {<z>
expandTemplateVars(destination);<z>
(sessionId, returnType));<z>
Nullable String source) {<z>
name = source;<z>
null && source.startsWith("DB2")) {<z>
name = "DB2";<z>
equals(source)) {<z>
"MySQL";<z>
equals(source) ||<z>
) ||<z>
(source) ||<z>
.equalsIgnoreCase(source) ) {<z>
"Sybase";<z>
return name;<z>
{<z>
.scheduler != null) {<z>
.scheduler.standby();<z>
catch (SchedulerException ex) {<z>
);<z>
public Session currentSession() throws HibernateException {<z>
TransactionSynchronizationManager.getResource(this.sessionFactory);<z>
if (value instanceof Session session) {<z>
session;<z>
if (value instanceof SessionHolder sessionHolder) {<z>
();<z>
) &&<z>
()) {<z>
.registerSynchronization(<z>
sessionHolder, this.sessionFactory, false));<z>
setSynchronizedWithTransaction(true);<z>
);<z>
&&<z>
.isCurrentTransactionReadOnly()) {<z>
.AUTO);<z>
(flushMode);<z>
return session;<z>
else if (value instanceof EntityManagerHolder entityManagerHolder) {<z>
unwrap(Session.class);<z>
.jtaSessionContext != null) {<z>
STATUS_ACTIVE) {<z>
.currentSession();<z>
.isSynchronizationActive()) {<z>
(<z>
new SpringFlushSynchronization(session));<z>
;<z>
ex) {<z>
ex);<z>
(TransactionSynchronizationManager.isSynchronizationActive()) {<z>
session = this.sessionFactory.openSession();<z>
()) {<z>
MANUAL);<z>
new SessionHolder(session);<z>
(<z>
.sessionFactory, true));<z>
.sessionFactory, sessionHolder);<z>
);<z>
;<z>
"Could not obtain transaction-synchronized Session for current thread");<z>
(String name) throws NoSuchBeanDefinitionException {<z>
(name);<z>
FactoryBean) {<z>
isSingleton();<z>
return true;<z>
,<z>
> connectFuture) {<z>
(request, "'request' is required");<z>
"'handler' is required");<z>
"'connectFuture' is required");<z>
request;<z>
= handler;<z>
connectFuture;<z>
() {<z>
.poolSizeMonitor) {<z>
.keepAliveSeconds;<z>
setProperties(Properties transactionAttributes) {<z>
new TransactionAttributeEditor();<z>
.propertyNames();<z>
()) {<z>
.nextElement();<z>
value = transactionAttributes.getProperty(methodName);<z>
setAsText(value);<z>
= (TransactionAttribute) tae.getValue();<z>
;<z>
public void cancel() {<z>
Subscription s = this.subscription;<z>
{<z>
;<z>
s.cancel();<z>
;<z>
T mapping) {<z>
().lock();<z>
registry.remove(mapping);<z>
== null) {<z>
path : registration.getDirectPaths()) {<z>
this.pathLookup.get(path);<z>
) {<z>
);<z>
) {<z>
);<z>
.remove(registration.getHandlerMethod());<z>
().unlock();<z>
url, @Nullable Object request,<z>
throws RestClientException {<z>
requestCallback = httpEntityCallback(request, responseType);<z>
responseType);<z>
uriVariables));<z>
) {<z>
, next) -> {<z>
.attributes().get(BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE);<z>
(attr instanceof Credentials cred) {<z>
.exchange(ClientRequest.from(request)<z>
password))<z>
);<z>
exchange(request);<z>
{<z>
= getRequestContext().getRequestDataValueProcessor();<z>
this.pageContext.getRequest();<z>
HttpServletRequest) {<z>
) request, action, getHttpMethod());<z>
;<z>
> route(ServerRequest request) {<z>
this.first.route(request);<z>
) {<z>
>>) firstRoute;<z>
.route(request);<z>
ServerResponse>>) secondRoute;<z>
throws BeansException {<z>
!= null) {<z>
) {<z>
);<z>
customEditors != null) {<z>
(beanFactory::registerCustomEditor);<z>
closeResultSet(@Nullable ResultSet rs) {<z>
null) {<z>
.close();<z>
SQLException ex) {<z>
.trace("Could not close JDBC ResultSet", ex);<z>
(Throwable ex) {<z>
logger.trace("Unexpected exception on closing JDBC ResultSet", ex);<z>
evaluateAnnotation(Class<A> annotationType,<z>
, Function<A, String> reasonExtractor,<z>
context) {<z>
);<z>
context.getElement().get();<z>
, annotationType);<z>
annotation.isPresent()) {<z>
, element,<z>
getSimpleName());<z>
()) {<z>
(reason);<z>
enabled(reason);<z>
hasLength)<z>
String.format(<z>
getSimpleName(), element)));<z>
.get());<z>
context);<z>
result;<z>
(evaluatedToTrue) {<z>
);<z>
::hasText).orElseGet(<z>
format("%s is %s because @%s(\"%s\") evaluated to true", element, adjective,<z>
annotationType.getSimpleName(), expression));<z>
(logger.isInfoEnabled()) {<z>
reason);<z>
ConditionEvaluationResult.enabled(reason)<z>
.disabled(reason));<z>
adjective = (enabledOnTrue ? "disabled" : "enabled");<z>
"%s is %s because @%s(\"%s\") did not evaluate to true",<z>
, annotationType.getSimpleName(), expression);<z>
(logger.isDebugEnabled()) {<z>
);<z>
.disabled(reason) :<z>
enabled(reason));<z>
) && element instanceof Class) {<z>
<?>) element;<z>
;<z>
!= null) {<z>
HierarchyMode hierarchyMode = dirtiesContext.hierarchyMode();<z>
.getTestContext().markApplicationContextDirty(hierarchyMode);<z>
;<z>
> getResponseReference(Message<?> message) {<z>
;<z>
instanceof AtomicReference, "Expected AtomicReference");<z>
AtomicReference<Flux<Payload>>) headerValue;<z>
<T> targetClass) {<z>
Destination defaultDestination = getDefaultDestination();<z>
(defaultDestination != null) {<z>
(defaultDestination, targetClass);<z>
return receiveAndConvert(getRequiredDefaultDestinationName(), targetClass);<z>
boolean isAfterAdvice() {<z>
isAfterAdvice == null) {<z>
;<z>
.isAfterAdvice;<z>
name) {<z>
)) {<z>
return name;<z>
= name.replace('.', '_');<z>
) {<z>
;<z>
'_');<z>
.containsKey(noHyphenName)) {<z>
return noHyphenName;<z>
'_');<z>
containsKey(noDotNoHyphenName)) {<z>
return noDotNoHyphenName;<z>
null;<z>
(Throwable throwable) {<z>
.INSTANCE);<z>
);<z>
.error(throwable);<z>
long lastModified() throws IOException {<z>
null) {<z>
lastModified();<z>
this.filePath).toMillis();<z>
) {<z>
new FileNotFoundException(ex.getMessage());<z>
accessor) {<z>
Assert.notNull(accessor, "MessageHeaderAccessor must not be null");<z>
= accessor;<z>
return this;<z>
void invokeAwareMethods(Object parserStrategyBean, Environment environment,<z>
@Nullable ClassLoader classLoader) {<z>
parserStrategyBean instanceof Aware) {<z>
parserStrategyBean instanceof BeanClassLoaderAware && classLoader != null) {<z>
(classLoader);<z>
&& registry instanceof BeanFactory) {<z>
) registry);<z>
parserStrategyBean instanceof EnvironmentAware) {<z>
) parserStrategyBean).setEnvironment(environment);<z>
parserStrategyBean instanceof ResourceLoaderAware) {<z>
(resourceLoader);<z>
() {<z>
) {<z>
resourceKey);<z>
sessionCompleted() {<z>
getSessionMutex()) {<z>
{<z>
executeDestructionCallbacks();<z>
(SESSION_COMPLETED_NAME, Boolean.TRUE);<z>
void addBindValues(MutablePropertyValues mpvs, ServletRequest request) {<z>
.URI_TEMPLATE_VARIABLES_ATTRIBUTE;<z>
("unchecked")<z>
attr);<z>
uriVars != null) {<z>
, value) -> {<z>
{<z>
{<z>
);<z>
addPropertyValue(name, value);<z>
;<z>
> converters,<z>
<Object> requestResponseBodyAdvice) {<z>
, requestResponseBodyAdvice);<z>
, Object newArray, TypeConverter typeConverter,<z>
initializer) {<z>
]) newArray;<z>
i < newBooleanArray.length; i++) {<z>
state);<z>
(typeConverter, typedValue);<z>
) {<z>
(AGENT_CLASS_PRESENT) {<z>
InstrumentationAccessor.getInstrumentation();<z>
return null;<z>
{<z>
host;<z>
).getHostAddress();<z>
ex) {<z>
= "unknown";<z>
UUID.randomUUID();<z>
clearStatistics() {<z>
this.contextMap) {<z>
(0);<z>
0);<z>
TaskScheduler defaultSockJsTaskScheduler() {<z>
()) {<z>
ThreadPoolTaskScheduler threadPoolScheduler = new ThreadPoolTaskScheduler();<z>
"SockJS-");<z>
availableProcessors());<z>
;<z>
threadPoolScheduler;<z>
this.scheduler;<z>
, Set<Resource> result) {<z>
)) {<z>
;<z>
: "/" + filePath);<z>
ResourceUtils.JAR_URL_PREFIX + ResourceUtils.FILE_URL_PREFIX +<z>
;<z>
ex) {<z>
false;<z>
>> messageWriters,<z>
contentTypeResolver, ReactiveAdapterRegistry adapterRegistry) {<z>
adapterRegistry);<z>
Assert.notEmpty(messageWriters, "At least one message writer is required");<z>
= messageWriters;<z>
Object getValue(String paramName) {<z>
{<z>
("No value registered for key '" + paramName + "'");<z>
.values.get(paramName);<z>
reader) {<z>
;<z>
XMLStreamConstants.START_ELEMENT)) {<z>
IllegalStateException("XMLEventReader not at start of document or element");<z>
.reader = reader;<z>
public static MailSession getDefaultInstance(Properties props) {<z>
);<z>
);<z>
;<z>
(ServerWebExchange exchange) {<z>
;<z>
).getAcceptLanguageAsLocales();<z>
catch (IllegalArgumentException ex) {<z>
;<z>
, Object handler)<z>
{<z>
preHandle(request, response, handler);<z>
public Mono<WebSession> createWebSession() {<z>
();<z>
);<z>
() -> new InMemoryWebSession(now))<z>
)<z>
parallel());<z>
protected void copyFrom(AbstractBeanFactoryBasedTargetSource other) {<z>
targetBeanName;<z>
;<z>
;<z>
TransactionAttribute transactionAttribute) {<z>
) {<z>
(null);<z>
;<z>
) {<z>
) {<z>
;<z>
) {<z>
return false;<z>
(otherComposite);<z>
> otherConditions = otherComposite.getMessageConditions();<z>
++) {<z>
) {<z>
false;<z>
return true;<z>
locales) {<z>
()<z>
toLanguageTag()))<z>
toList()));<z>
] args) {<z>
operation, target, args);<z>
args);<z>
if (operation instanceof CachePutOperation) {<z>
);<z>
;<z>
msg, @Nullable Throwable cause) {<z>
"]: " + msg, cause);<z>
getDeclaringClass();<z>
.constructor = constructor;<z>
.constructingMethod = null;<z>
public int getTimeToLiveInSeconds() {<z>
) / 1000;<z>
diff);<z>
);<z>
return secs;<z>
ClassNotFoundException {<z>
name)) {<z>
);<z>
null) {<z>
return cls;<z>
);<z>
);<z>
ResourceUrlProvider mvcResourceUrlProvider() {<z>
();<z>
().getUrlPathHelperOrDefault());<z>
).getPathMatcherOrDefault());<z>
return urlProvider;<z>
receiveAndExecute(<z>
MessageConsumer consumer)<z>
JMSException {<z>
{<z>
(this.transactionDefinition);<z>
;<z>
session, consumer, status);<z>
| Error ex) {<z>
this.transactionManager, status, ex);<z>
ex;<z>
transactionManager.commit(status);<z>
messageReceived;<z>
);<z>
public UnsatisfiedDependencyException(<z>
beanName, String propertyName, String msg) {<z>
super(resourceDescription, beanName,<z>
+ "'" +<z>
;<z>
injectionPoint = null;<z>
<String> get(Object key) {<z>
> values = null;<z>
key)) {<z>
getHeaders((String) key);<z>
ArrayList<>(headers.length);<z>
(Header header : headers) {<z>
add(header.getValue());<z>
values;<z>
StompWebSocketEndpointRegistration setAllowedOrigins(String... allowedOrigins) {<z>
.clear();<z>
{<z>
(Arrays.asList(allowedOrigins));<z>
this;<z>
beforeBodyRead(HttpInputMessage request, MethodParameter parameter,<z>
{<z>
RequestBodyAdvice.class)) {<z>
) {<z>
parameter, targetType, converterType);<z>
;<z>
.hasAnnotation(method, RequestMapping.class) &&<z>
class));<z>
HandlerMethodArgumentResolver> customArgumentResolvers;<z>
private HandlerMethodArgumentResolverComposite argumentResolvers;<z>
HandlerMethodArgumentResolverComposite initBinderArgumentResolvers;<z>
customReturnValueHandlers;<z>
HandlerMethodReturnValueHandlerComposite returnValueHandlers;<z>
;<z>
ContentNegotiationManager contentNegotiationManager = new ContentNegotiationManager();<z>
List<HttpMessageConverter<?>> messageConverters;<z>
;<z>
WebBindingInitializer webBindingInitializer;<z>
;<z>
;<z>
];<z>
[] deferredResultInterceptors = new DeferredResultProcessingInterceptor[0];<z>
;<z>
private boolean ignoreDefaultModelOnRedirect = false;<z>
= 0;<z>
private boolean synchronizeOnSession = false;<z>
SessionAttributeStore sessionAttributeStore = new DefaultSessionAttributeStore();<z>
();<z>
beanFactory;<z>
new ConcurrentHashMap<>(64);<z>
(64);<z>
> initBinderAdviceCache = new LinkedHashMap<>();<z>
new ConcurrentHashMap<>(64);<z>
>();<z>
RequestMappingHandlerAdapter() {<z>
messageConverters = new ArrayList<>(4);<z>
.add(new ByteArrayHttpMessageConverter());<z>
add(new StringHttpMessageConverter());<z>
!shouldIgnoreXml) {<z>
(new SourceHttpMessageConverter<>());<z>
err) {<z>
;<z>
(String className) {<z>
();<z>
(), "findLoadedClass", String.class);<z>
findLoadedClassMethod);<z>
invokeMethod(findLoadedClassMethod, cl, className);<z>
;<z>
... values) {<z>
);<z>
(values)) {<z>
Object value : values) {<z>
value);<z>
queryParams.add(name, valueAsString);<z>
queryParams.add(name, null);<z>
);<z>
this;<z>
final int access, final String version) {<z>
symbolTable.addConstantModule(module).index)<z>
putShort(access)<z>
addConstantUtf8(version));<z>
requiresCount++;<z>
, String mappedName, TransactionAttribute attr) {<z>
.notNull(clazz, "Class must not be null");<z>
;<z>
clazz.getName() + '.' + mappedName;<z>
;<z>
);<z>
methods) {<z>
mappedName)) {<z>
);<z>
matchingMethods.isEmpty()) {<z>
new IllegalArgumentException(<z>
+ clazz.getName() + "]");<z>
method : matchingMethods) {<z>
);<z>
.length())) {<z>
() && regMethodName != null) {<z>
"]: current name '" +<z>
+ "'");<z>
put(method, name);<z>
method, attr);<z>
)) {<z>
debug("Keeping attribute for transactional method [" + method + "]: current name '" +<z>
regMethodName + "'");<z>
> targetClass) {<z>
BigInteger bigInt = null;<z>
) {<z>
;<z>
number instanceof BigDecimal) {<z>
) number).toBigInteger();<z>
> 0)) {<z>
number, targetClass);<z>
return number.longValue();<z>
) {<z>
;<z>
beanFactory != null, "No BeanFactory available");<z>
(this.targetBeanName != null, "No target bean name specified");<z>
targetBeanName);<z>
{<z>
.getAndSet(State.DISPOSED);<z>
);<z>
char theCloseBracketFor(char openBracket) {<z>
openBracket == '{') {<z>
;<z>
else if (openBracket == '[') {<z>
return ']';<z>
')';<z>
triggerAfterCommit(DefaultTransactionStatus status) {<z>
{<z>
);<z>
withProcedureName(String procedureName) {<z>
;<z>
false);<z>
;<z>
private void cookies(MockHttpServletRequest request) {<z>
ArrayList<>();<z>
("Cookie");<z>
null) {<z>
);<z>
(tokens.hasMoreTokens()) {<z>
tokens.nextToken().trim();<z>
isTrue(tokens.hasMoreTokens(),<z>
+ cookieName +<z>
+ "]");<z>
.trim();<z>
));<z>
));<z>
.Cookie cookie : managedCookies) {<z>
.getValue()));<z>
getCookies();<z>
if (parentCookies != null) {<z>
parentCookies);<z>
cookies)) {<z>
(new Cookie[0]));<z>
Collection<String> getAllowedOriginPatterns() {<z>
getAllowedOriginPatterns();<z>
.emptySet() :<z>
));<z>
(<z>
Exception {<z>
model, request);<z>
(model, request, response);<z>
request) {<z>
request.uri();<z>
; i++) {<z>
charAt(i);<z>
'#') {<z>
2 < uri.length())) {<z>
+ 2) == '/') {<z>
); j++) {<z>
);<z>
'#') {<z>
);<z>
"";<z>
;<z>
V> deepCopy() {<z>
);<z>
>(values)));<z>
;<z>
(Payload payload, DataBufferFactory bufferFactory) {<z>
if (bufferFactory instanceof NettyDataBufferFactory) {<z>
().retain();<z>
bufferFactory).wrap(byteBuf);<z>
.getData());<z>
> 0) {<z>
payload.release();<z>
HttpHeaders headers) {<z>
;<z>
MediaType.TEXT_PLAIN.equalsTypeAndSubtype(contentType))<z>
getFilename() == null;<z>
{<z>
= other.name;<z>
this.patternsCondition = other.patternsCondition;<z>
this.methodsCondition = other.methodsCondition;<z>
.paramsCondition = other.paramsCondition;<z>
headersCondition = other.headersCondition;<z>
= other.consumesCondition;<z>
.producesCondition = other.producesCondition;<z>
other.customConditionHolder;<z>
other.options;<z>
(Object other) {<z>
instanceof SerializablePerson)) {<z>
false;<z>
p = (SerializablePerson) other;<z>
.nullSafeEquals(name, p.name);<z>
) {<z>
) {<z>
return this;<z>
)) {<z>
return this;<z>
else if (isEmptyPathMapping()) {<z>
return other;<z>
();<z>
this.patterns) {<z>
PathPattern pattern2 : other.patterns) {<z>
.combine(pattern2));<z>
combined);<z>
Session session) throws JMSException {<z>
session.getTransacted()) {<z>
(isSessionLocallyTransacted(session)) {<z>
(session);<z>
{<z>
.recover();<z>
throwException(int valueIn) throws Exception {<z>
++;<z>
) {<z>
IllegalArgumentException("IllegalArgumentException for 1");<z>
) {<z>
);<z>
{<z>
;<z>
valueIn;<z>
(String source) {<z>
isEmpty()) {<z>
return null;<z>
.enumType, source.trim());<z>
Object getMappedAnnotationValue(int attributeIndex, boolean metaAnnotationsOnly) {<z>
[attributeIndex];<z>
mappedIndex == -1) {<z>
;<z>
attributeIndex];<z>
(source == this && metaAnnotationsOnly) {<z>
;<z>
);<z>
request, HttpServletResponse response, Object handler) {<z>
) {<z>
;<z>
asyncInterceptor.afterConcurrentHandlingStarted(webRequest);<z>
WebSocketHandler handler,<z>
, HttpHeaders handshakeHeaders, XhrClientSockJsSession session,<z>
connectFuture) {<z>
;<z>
httpHeaders, session, connectFuture);<z>
, listener);<z>
) {<z>
) {<z>
;<z>
);<z>
;<z>
catch (IllegalStateException ex) {<z>
public MissingRequestHeaderException(<z>
String headerName, MethodParameter parameter, boolean missingAfterConversion) {<z>
missingAfterConversion);<z>
;<z>
= parameter;<z>
IOException {<z>
this.statusMapping.containsKey(statusCode)) {<z>
, response);<z>
(statusCode.series())) {<z>
statusCode.series()), response);<z>
;<z>
, boolean allowFactoryBeanInit) throws NoSuchBeanDefinitionException {<z>
beanName = BeanFactoryUtils.transformedBeanName(name);<z>
= this.beans.get(beanName);<z>
{<z>
NoSuchBeanDefinitionException(beanName,<z>
()) + "]");<z>
&& !BeanFactoryUtils.isFactoryDereference(name)) {<z>
getObjectType();<z>
();<z>
CacheAnnotationParser annotationParser) {<z>
true;<z>
.notNull(annotationParser, "CacheAnnotationParser must not be null");<z>
(annotationParser);<z>
HttpServletRequest request) {<z>
getQueryString();<z>
(query)) {<z>
null;<z>
);<z>
anchorIndex > -1) {<z>
(anchorIndex);<z>
);<z>
) < 0) {<z>
('?').append(query);<z>
append('&').append(query);<z>
!= null) {<z>
;<z>
{<z>
inputMessage, context) -><z>
inputMessage, context, elementType,<z>
reader),<z>
from(unsupportedErrorHandler(inputMessage, ex)),<z>
skipBodyAsMono(inputMessage));<z>
) {<z>
{<z>
);<z>
("Expression [");<z>
this.expressionString);<z>
append(']');<z>
position >= 0) {<z>
" @");<z>
(this.position);<z>
);<z>
.append(getSimpleMessage());<z>
toString();<z>
();<z>
parameterName, CallParameterMetaData meta) {<z>
())) {<z>
getRefCursorSqlType(), new ColumnMapRowMapper());<z>
);<z>
pathMatcher) {<z>
!= defaultPathMatcher ? this.pathMatcher : pathMatcher);<z>
) {<z>
this.excludePatterns) {<z>
.getPatternString(), lookupPath)) {<z>
false;<z>
this.includePatterns)) {<z>
true;<z>
(PatternAdapter adapter : this.includePatterns) {<z>
(), lookupPath)) {<z>
return true;<z>
return false;<z>
throws JspException {<z>
tagWriter != null) {<z>
this.tagWriter.endTag();<z>
);<z>
return EVAL_PAGE;<z>
(HttpMessageWriter<?> writer) {<z>
, "HttpMessageWriter is required");<z>
.writer = writer;<z>
);<z>
) {<z>
Assert.notNull(key, "Key must not be null");<z>
startKey = key;<z>
HierarchyMode.EXHAUSTIVE) {<z>
.getParent();<z>
while (parent != null) {<z>
startKey = parent;<z>
);<z>
>();<z>
remove(removedContexts, startKey);<z>
removedContexts) {<z>
)) {<z>
(currentKey);<z>
entrySet()) {<z>
().isEmpty()) {<z>
.remove(entry.getKey());<z>
) {<z>
for (CronField field : this.fields) {<z>
(temporal);<z>
temporal == null) {<z>
;<z>
temporal;<z>
applicationContext) {<z>
ConfigurableApplicationContext,<z>
;<z>
) applicationContext;<z>
CacheEvictOperation parseEvictAnnotation(<z>
cacheEvict) {<z>
();<z>
(ae.toString());<z>
());<z>
));<z>
);<z>
cacheEvict.keyGenerator());<z>
());<z>
.setCacheResolver(cacheEvict.cacheResolver());<z>
.setCacheWide(cacheEvict.allEntries());<z>
.beforeInvocation());<z>
applyDefault(builder);<z>
);<z>
, op);<z>
return op;<z>
Nullable String messageSelector)<z>
JMSException {<z>
session.createBrowser(queue, messageSelector);<z>
) throws SchedulerConfigException {<z>
getConfigTimeTaskExecutor();<z>
if (this.taskExecutor == null) {<z>
new SchedulerConfigException("No local Executor found for configuration - " +<z>
);<z>
) {<z>
condition == null) {<z>
return this;<z>
.condition == null) {<z>
other;<z>
null) {<z>
this;<z>
.condition);<z>
condition.combine(other.condition);<z>
RequestConditionHolder(combined);<z>
) {<z>
request.getMethod();<z>
uri = request.getURI();<z>
.getHeaders();<z>
> cookies = request.getCookies();<z>
body);<z>
public BeanDefinitionStoreException(<z>
, String msg, @Nullable Throwable cause) {<z>
+ msg,<z>
;<z>
;<z>
.beanName = beanName;<z>
(WebExceptionHandler exceptionHandler) {<z>
"WebExceptionHandler must not be null");<z>
exceptionHandlers.add(exceptionHandler);<z>
return this;<z>
clientInboundChannel,<z>
{<z>
;<z>
> resolveResourceInternal(@Nullable ServerWebExchange exchange,<z>
locations, ResourceResolverChain chain) {<z>
return getResource(requestPath, locations);<z>
[] tokens, int startIndex) {<z>
;<z>
= tokens[startIndex];<z>
indexOf('(');<z>
- 1) == ')') {<z>
));<z>
StringBuilder();<z>
.length() - 1)) {<z>
bodyStart + 1));<z>
append(' ');<z>
numTokensConsumed++;<z>
startIndex + numTokensConsumed;<z>
(currentIndex < tokens.length) {<z>
) {<z>
++;<z>
].endsWith(")")) {<z>
);<z>
));<z>
;<z>
{<z>
1);<z>
append(toAppend);<z>
(' ');<z>
currentIndex++;<z>
;<z>
, null);<z>
(AsyncEvent event) {<z>
.getAsyncContext();<z>
context, this.completionFlag, () -> {<z>
;<z>
.complete();<z>
});<z>
() {<z>
= true;<z>
{<z>
);<z>
> valueType) {<z>
.notNull(valueType, "Value type must not be null");<z>
marker = nextMarker();<z>
));<z>
return marker;<z>
(<z>
typeRef,<z>
TypePath typePath,<z>
[] start,<z>
[] end,<z>
final int[] index,<z>
String descriptor,<z>
final boolean visible) {<z>
.ASM5) {<z>
REQUIRES_ASM5);<z>
) {<z>
(<z>
, end, index, descriptor, visible);<z>
return null;<z>
HttpServletResponse response) {<z>
;<z>
.encoding.getJavaName());<z>
(this.disableCaching) {<z>
, "no-store");<z>
public void onBegin(Response response) {<z>
) != 200) {<z>
));<z>
(new HttpServerErrorException(status, "Unexpected XHR receive status"));<z>
errorMessage) {<z>
errorMessage, StompHeaderAccessor.class);<z>
Assert.notNull(accessor, "No StompHeaderAccessor");<z>
isMutable()) {<z>
StompHeaderAccessor.wrap(errorMessage);<z>
null, null);<z>
ElementFactory<E> elementFactory) {<z>
notNull(backingList, "Backing List must not be null");<z>
elementFactory, "Element factory must not be null");<z>
;<z>
= elementFactory;<z>
resolveParameter(Class<?> parameterType,<z>
resourceLoader,<z>
ClassLoader classLoader) {<z>
parameterType == Environment.class) {<z>
return environment;<z>
(parameterType == ResourceLoader.class) {<z>
;<z>
== BeanFactory.class) {<z>
;<z>
== ClassLoader.class) {<z>
return classLoader;<z>
));<z>
<?> clazz, Object target) {<z>
propertyName, clazz, target instanceof Class);<z>
{<z>
false);<z>
return method;<z>
) {<z>
;<z>
{<z>
StringBuilder builder = new StringBuilder();<z>
.tags.forEach(tag -><z>
',')<z>
.setTags(builder.toString());<z>
this.event.commit();<z>
.recordingCallback.accept(this);<z>
, long period) {<z>
this.clock.millis();<z>
TimeUnit.MILLISECONDS);<z>
catch (RejectedExecutionException ex) {<z>
, ex);<z>
method) {<z>
= method.getParameterTypes();<z>
length];<z>
0; --i) {<z>
] = getType(classes[i]);<z>
return types;<z>
{<z>
= expression;<z>
onSetExpression(expression);<z>
(IllegalArgumentException ex) {<z>
this.location != null) {<z>
ex);<z>
;<z>
InvalidResultSetAccessException {<z>
if (this.columnNames == null) {<z>
columnNames = new String[getColumnCount()];<z>
++) {<z>
;<z>
columnNames;<z>
MethodParameter parameter) {<z>
) {<z>
);<z>
validationHints != null) {<z>
.validate(validationHints);<z>
mbd) {<z>
, mbd)) {<z>
) {<z>
(beanName, new DisposableBeanAdapter(<z>
, getBeanPostProcessorCache().destructionAware));<z>
(mbd.getScope());<z>
== null) {<z>
) + "'");<z>
, new DisposableBeanAdapter(<z>
, getBeanPostProcessorCache().destructionAware));<z>
DefaultListableBeanFactory getInternalBeanFactoryForBean(String beanName) {<z>
synchronized (this.internalBeanFactories) {<z>
(beanName,<z>
;<z>
request, HttpServletResponse response, FilterChain filterChain)<z>
IOException {<z>
responseToUse = response;<z>
) && !(response instanceof ConditionalContentCachingResponseWrapper)) {<z>
request);<z>
(request, responseToUse);<z>
request)) {<z>
);<z>
(RootBeanDefinition broker, RuntimeBeanReference inChannel,<z>
Object source) {<z>
);<z>
);<z>
).add("subProtocolWebSocketHandler", webSocketHandler);<z>
getBeanClass()) {<z>
add("stompBrokerRelay", broker);<z>
inChannel.getBeanName() + "Executor";<z>
{<z>
;<z>
= outChannel.getBeanName() + "Executor";<z>
(name)) {<z>
).getBeanDefinition(name));<z>
, source);<z>
("sockJsTaskScheduler", scheduler);<z>
, beanDef, context, source);<z>
, String password) throws JMSException {<z>
ConnectionFactory target = getTargetConnectionFactory();<z>
(!(target instanceof QueueConnectionFactory)) {<z>
IllegalStateException("'targetConnectionFactory' is no QueueConnectionFactory");<z>
username, password);<z>
QueueConnection) getTransactionAwareConnectionProxy(targetConnection);<z>
MessageConverter getMessageConverter() {<z>
;<z>
) {<z>
);<z>
;<z>
defaultVal) {<z>
) == null) {<z>
;<z>
name);<z>
catch (ServletRequestBindingException ex) {<z>
;<z>
throws Throwable {<z>
) {<z>
));<z>
ReflectionUtils.isHashCodeMethod(method)) {<z>
();<z>
.isToStringMethod(method)) {<z>
+ this.xt + "]";<z>
method.getName(), args);<z>
|| result == Primitive.VOID) {<z>
return null;<z>
(result instanceof Primitive) {<z>
Primitive) result).getValue();<z>
return result;<z>
) {<z>
throw new BshExecutionException(ex);<z>
A extends Annotation> TypeMappedAnnotation<A> createIfPossible(<z>
> annotation, IntrospectionFailureLogger logger) {<z>
TypeMappedAnnotation) {<z>
TypeMappedAnnotation<?>) annotation;<z>
,<z>
.rootAttributes,<z>
typeMappedAnnotation.valueExtractor,<z>
aggregateIndex, logger);<z>
(), annotation.synthesize(),<z>
getAggregateIndex(), logger);<z>
@Nullable Class<?> beanType) {<z>
null ?<z>
);<z>
createBeanTypePredicate(controllerAdvice);<z>
static Mono<Path> tempDirectory() {<z>
Mono.fromCallable(() -> {<z>
Files.createTempDirectory(IDENTIFIER);<z>
isDebugEnabled()) {<z>
("Created temporary storage directory: " + directory);<z>
;<z>
cache();<z>
) throws BeansException {<z>
getIfAvailable();<z>
null) {<z>
accept(dependency);<z>
(ScopeNotActiveException ex) {<z>
int maxByteLength) {<z>
charLength = stringValue.length();<z>
byteLength = offset;<z>
; ++i) {<z>
;<z>
charValue >= 0x0001 && charValue <= 0x007F) {<z>
++;<z>
charValue <= 0x07FF) {<z>
2;<z>
else {<z>
byteLength += 3;<z>
(byteLength > maxByteLength) {<z>
throw new IllegalArgumentException("UTF8 string too large");<z>
int byteLengthOffset = length - offset - 2;<z>
(byteLengthOffset >= 0) {<z>
>>> 8);<z>
byte) byteLength;<z>
offset > data.length) {<z>
- offset);<z>
length;<z>
i < charLength; ++i) {<z>
;<z>
0x007F) {<z>
byte) charValue;<z>
} else if (charValue <= 0x07FF) {<z>
);<z>
;<z>
} else {<z>
>> 12 & 0xF);<z>
& 0x3F);<z>
charValue & 0x3F);<z>
;<z>
return this;<z>
{<z>
, "Predicate must not be null");<z>
"RouterFunction must not be null");<z>
predicate = predicate;<z>
routerFunction;<z>
code, Locale locale) {<z>
);<z>
for (String basename : basenames) {<z>
ResourceBundle bundle = getResourceBundle(basename, locale);<z>
bundle != null) {<z>
= getMessageFormat(bundle, code, locale);<z>
!= null) {<z>
return messageFormat;<z>
null;<z>
{<z>
shouldReleaseBeforeCompletion()) {<z>
(this.resourceObject);<z>
;<z>
boolean isReplyPubSubDomain() {<z>
= getActivationSpecConfig();<z>
if (config != null) {<z>
();<z>
new IllegalStateException("Could not determine reply pubSubDomain - no activation spec config is set");<z>
void removeTransformers() {<z>
.transformers) {<z>
)) {<z>
) {<z>
);<z>
;<z>
String toChainString() {<z>
;<z>
.head;<z>
while (pe != null) {<z>
.add(pe.toString());<z>
pe.next;<z>
.toString();<z>
static void rejectIfEmptyOrWhitespace(<z>
{<z>
, errorCode, errorArgs, null);<z>
) {<z>
inputStream, "InputStream must not be null");<z>
this.inputStream = inputStream;<z>
description : "");<z>
, boolean startConnection) throws JmsException {<z>
);<z>
= null;<z>
sessionToClose = null;<z>
(<z>
(), this.transactionalResourceFactory, startConnection);<z>
== null) {<z>
conToClose = createConnection();<z>
;<z>
if (startConnection) {<z>
;<z>
sessionToClose;<z>
isDebugEnabled()) {<z>
);<z>
(sessionToUse);<z>
JMSException ex) {<z>
;<z>
sessionToClose);<z>
, startConnection);<z>
protected Method findMatchingMethod() {<z>
;<z>
) {<z>
);<z>
if (matchingMethod == null) {<z>
{getArguments()});<z>
matchingMethod;<z>
key, String value) {<z>
"'key' must not be null");<z>
value, "'value' must not be null");<z>
value);<z>
this;<z>
doSuspend(Object transaction) {<z>
DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;<z>
;<z>
TransactionSynchronizationManager.unbindResource(obtainDataSource());<z>
inputStreamSource, String contentType)<z>
MessagingException {<z>
, "InputStreamSource must not be null");<z>
()) {<z>
(<z>
;<z>
, "inline");<z>
;<z>
ConfigurableWebBindingInitializer getConfigurableWebBindingInitializer(<z>
Validator webFluxValidator) {<z>
;<z>
);<z>
;<z>
getMessageCodesResolver();<z>
if (messageCodesResolver != null) {<z>
setMessageCodesResolver(messageCodesResolver);<z>
;<z>
(Resource resource) {<z>
class,<z>
"Cannot convert an InputStreamResource to a ResourceRegion");<z>
;<z>
getRangeStart(contentLength);<z>
= getRangeEnd(contentLength);<z>
+ contentLength);<z>
end - start + 1);<z>
HttpHeaders headers, HttpServletResponse response, AsyncContext asyncContext,<z>
throws IOException {<z>
);<z>
.notNull(response, "HttpServletResponse must not be null");<z>
bufferFactory, "DataBufferFactory must not be null");<z>
bufferSize > 0, "Buffer size must be greater than 0");<z>
= response;<z>
.getOutputStream();<z>
bufferSize = bufferSize;<z>
this.request = request;<z>
new ResponseAsyncListener();<z>
).setWriteListener(new ResponseBodyWriteListener());<z>
(BeanDefinition interceptorDefinition) {<z>
interceptorDefinition.getBeanClassName();<z>
(beanClassName) ?<z>
)) : "");<z>
[] args) throws Throwable {<z>
) {<z>
:<z>
0]);<z>
"hashCode":<z>
System.identityHashCode(proxy);<z>
:<z>
;<z>
.target != null) {<z>
);<z>
(']');<z>
toString();<z>
case "close":<z>
.target, this.targetDataSource);<z>
closed = true;<z>
return null;<z>
case "isClosed":<z>
.closed;<z>
:<z>
.isInstance(proxy)) {<z>
proxy;<z>
case "isWrapperFor":<z>
.isInstance(proxy)) {<z>
return true;<z>
target == null) {<z>
) {<z>
return null;<z>
(this.closed) {<z>
"Connection handle already closed");<z>
shouldObtainFixedConnection(this.targetDataSource)) {<z>
doGetConnection(this.targetDataSource);<z>
actualTarget = this.target;<z>
) {<z>
targetDataSource);<z>
.equals("getTargetConnection")) {<z>
;<z>
(actualTarget, args);<z>
Statement) {<z>
) retVal, this.targetDataSource);<z>
return retVal;<z>
ex) {<z>
();<z>
!= this.target) {<z>
targetDataSource);<z>
private void flushIfPossible() {<z>
);<z>
) {<z>
+ result + "]");<z>
) {<z>
);<z>
{<z>
writePosition(); pos++) {<z>
);<z>
b)) {<z>
pos;<z>
;<z>
{<z>
dataBuffer);<z>
;<z>
set(State.DISPOSED);<z>
(exc);<z>
UnknownContentTypeException(Type targetType, MediaType contentType,<z>
{<z>
super("Could not extract response: no suitable HttpMessageConverter found " +<z>
+ contentType + "]");<z>
this.targetType = targetType;<z>
= contentType;<z>
statusCode;<z>
.statusText = statusText;<z>
= responseHeaders;<z>
responseBody;<z>
{<z>
).error(<z>
element);<z>
return null;<z>
Nullable T object) {<z>
null) {<z>
.length; i++) {<z>
object)) {<z>
i;<z>
instanceOrder.length;<z>
, boolean required, @Nullable String defaultValue) {<z>
this.name = name;<z>
this.required = required;<z>
defaultValue = defaultValue;<z>
() {<z>
string;<z>
null) {<z>
.append('(');<z>
{<z>
get(i);<z>
> 0) {<z>
append(", ");<z>
);<z>
append('=');<z>
(getAttributeValue(attribute)));<z>
append(')');<z>
= builder.toString();<z>
.string = string;<z>
string;<z>
AnnotationConfigApplicationContext(String... basePackages) {<z>
);<z>
);<z>
);<z>
method, URI uri, HttpClientRequest request,<z>
nettyOutbound) {<z>
method, uri, request, nettyOutbound);<z>
getResolvableType(ApplicationEvent event) {<z>
ResolvableType payloadType = null;<z>
event instanceof PayloadApplicationEvent) {<z>
= (PayloadApplicationEvent<?>) event;<z>
.getResolvableType();<z>
!= null) {<z>
getGeneric();<z>
.declaredEventTypes) {<z>
> eventClass = declaredEventType.toClass();<z>
!ApplicationEvent.class.isAssignableFrom(eventClass) &&<z>
&& declaredEventType.isAssignableFrom(payloadType)) {<z>
return declaredEventType;<z>
.isInstance(event)) {<z>
declaredEventType;<z>
;<z>
void flush() throws IOException {<z>
writeHeaders();<z>
{<z>
.servletResponse.flushBuffer();<z>
void initTypedWriters() {<z>
this.typedWriters.clear();<z>
(!this.registerDefaults) {<z>
.typedWriters.addAll(getBaseTypedWriters());<z>
(this.typedWriters);<z>
Nullable String[] headers,<z>
) {<z>
, headers);<z>
.expressions.size() > 1) {<z>
;<z>
? manager : DEFAULT_CONTENT_NEGOTIATION_MANAGER;<z>
void initContextHolders(HttpServletRequest request,<z>
, @Nullable RequestAttributes requestAttributes) {<z>
{<z>
;<z>
(requestAttributes != null) {<z>
requestAttributes, this.threadContextInheritable);<z>
public static void triggerBeforeCompletion() {<z>
: TransactionSynchronizationManager.getSynchronizations()) {<z>
);<z>
{<z>
("TransactionSynchronization.beforeCompletion threw exception", ex);<z>
name) throws BeansException {<z>
{<z>
bean).postProcessAfterInit();<z>
return bean;<z>
> handlerMap) {<z>
handlerMap != null) {<z>
);<z>
.putAll(handlerMap);<z>
this.autodetect = false;<z>
Nullable ClassLoader classLoader) {<z>
(classLoader, "ClassLoader must not be null");<z>
.classLoader = classLoader;<z>
"transformer");<z>
) {<z>
+<z>
));<z>
setAccessible(true);<z>
classLoader);<z>
(WRAPPER_TRANSFORMER_CLASS_NAME)) {<z>
suggestedTransformer.getClass(), "transformer");<z>
== null) {<z>
(<z>
.getName());<z>
(true);<z>
suggestedTransformer = wrappedTransformer.get(suggestedTransformer);<z>
equals(DELEGATING_TRANSFORMER_CLASS_NAME)) {<z>
throw new IllegalStateException(<z>
;<z>
= suggestedTransformer;<z>
,<z>
, ClassFileTransformer.class);<z>
) {<z>
new IllegalArgumentException(<z>
));<z>
);<z>
this.addTransformer = addTransformer;<z>
Throwable ex) {<z>
IllegalStateException("Could not initialize JBoss LoadTimeWeaver", ex);<z>
{<z>
ex instanceof JDBCConnectionException) {<z>
getMessage(), ex);<z>
) {<z>
.getSQL() + "]", ex);<z>
if (ex instanceof QueryTimeoutException jdbcEx) {<z>
;<z>
LockAcquisitionException jdbcEx) {<z>
ex);<z>
jdbcEx) {<z>
getSQL() + "]", ex);<z>
{<z>
"; SQL [" + jdbcEx.getSQL() +<z>
() + "]", ex);<z>
{<z>
.getSQL() + "]", ex);<z>
) {<z>
ex);<z>
{<z>
;<z>
if (ex instanceof NonUniqueResultException) {<z>
);<z>
ex instanceof NonUniqueObjectException) {<z>
;<z>
if (ex instanceof PropertyValueException) {<z>
ex.getMessage(), ex);<z>
if (ex instanceof PersistentObjectException) {<z>
, ex);<z>
ex instanceof TransientObjectException) {<z>
, ex);<z>
ObjectDeletedException) {<z>
), ex);<z>
ex instanceof UnresolvableObjectException) {<z>
) ex);<z>
) {<z>
((WrongClassException) ex);<z>
ex instanceof StaleObjectStateException) {<z>
ex);<z>
if (ex instanceof StaleStateException) {<z>
;<z>
ex instanceof OptimisticEntityLockException) {<z>
OptimisticEntityLockException) ex);<z>
PessimisticEntityLockException) {<z>
() instanceof LockAcquisitionException) {<z>
(), ex.getCause());<z>
ex);<z>
(ex);<z>
boolean defaultVal) {<z>
) == null) {<z>
;<z>
);<z>
ServletRequestBindingException ex) {<z>
;<z>
public TypeDescriptor(Field field) {<z>
;<z>
(field.getType());<z>
(field.getAnnotations());<z>
TypeDescriptor(Property property) {<z>
Assert.notNull(property, "Property must not be null");<z>
.forMethodParameter(property.getMethodParameter());<z>
());<z>
());<z>
) {<z>
applicationEvents =<z>
ApplicationEventsHolder.getApplicationEvents();<z>
applicationEvents != null) {<z>
.addEvent(event);<z>
Nullable Object result) {<z>
null) {<z>
targetType);<z>
;<z>
RequestHeadersSpec<?>> defaultRequest) {<z>
.defaultRequest != null ?<z>
;<z>
return this;<z>
) throws ResourceException {<z>
null) {<z>
throw new IllegalArgumentException("Property 'managedConnectionFactory' is required");<z>
null) {<z>
createConnectionFactory(this.connectionManager);<z>
this.managedConnectionFactory.createConnectionFactory();<z>
, String msg, @Nullable Throwable cause) {<z>
cause);<z>
beanClass;<z>
= null;<z>
.constructingMethod = null;<z>
,<z>
PropertyResolver propertyResolver, boolean ignoreUnresolvablePlaceholders) {<z>
(resourcePatternResolver, "ResourcePatternResolver must not be null");<z>
this.resourcePatternResolver = resourcePatternResolver;<z>
= propertyResolver;<z>
ignoreUnresolvablePlaceholders;<z>
(ResourceHandlerRegistration registration) {<z>
.getRequestHandler();<z>
)) {<z>
(transformer instanceof ResourceTransformerSupport) {<z>
).setResourceUrlProvider(this.resourceUrlProvider);<z>
);<z>
Throwable ex) {<z>
new BeanInitializationException("Failed to init ResourceHttpRequestHandler", ex);<z>
return handler;<z>
AspectJAnnotation(A annotation) {<z>
.annotation = annotation;<z>
this.annotationType = determineAnnotationType(annotation);<z>
resolveExpression(annotation);<z>
.getValue(annotation, "argNames");<z>
);<z>
{<z>
);<z>
(<z>
, BindingContext context, ServerWebExchange exchange) {<z>
methodParameter.getParameterType();<z>
(paramType)) {<z>
exchange;<z>
) {<z>
();<z>
isAssignableFrom(paramType)) {<z>
exchange.getResponse();<z>
if (HttpMethod.class == paramType) {<z>
);<z>
class == paramType) {<z>
();<z>
{<z>
);<z>
;<z>
));<z>
{<z>
();<z>
;<z>
());<z>
UriComponentsBuilder.class == paramType) {<z>
;<z>
();<z>
).replaceQuery(null);<z>
+<z>
;<z>
Destination resolveDestination(DestinationResolver destinationResolver, Session session)<z>
JMSException {<z>
if (this.destination instanceof Destination) {<z>
destination;<z>
if (this.destination instanceof DestinationNameHolder nameHolder) {<z>
(session,<z>
;<z>
;<z>
T> requiredType)<z>
DataAccessException {<z>
));<z>
unboxBooleanIfNecessary(MethodVisitor mv) {<z>
equals(lastDescriptor())) {<z>
"()Z", false);<z>
firstBytePos, @Nullable Long lastBytePos) {<z>
(firstBytePos < 0) {<z>
IllegalArgumentException("Invalid first byte position: " + firstBytePos);<z>
) {<z>
("firstBytePosition=" + firstBytePos +<z>
);<z>
importStack) {<z>
super(String.format("A circular @Import has been detected: " +<z>
element().getSimpleName(),<z>
), importStack),<z>
)));<z>
(Object bean, String beanName) {<z>
this.beanFactory != null) {<z>
));<z>
(bean, beanName);<z>
&& this.beanFactory != null &&<z>
)) {<z>
true);<z>
return proxyFactory;<z>
, ParserContext parserContext, BeanDefinitionBuilder builder) {<z>
attributes = element.getAttributes();<z>
) {<z>
);<z>
(attribute, parserContext)) {<z>
());<z>
),<z>
;<z>
, attribute.getValue());<z>
(builder, element);<z>
destroyHandler(WebSocketSession session) {<z>
.handlers.remove(session);<z>
handler != null) {<z>
provider.destroy(handler);<z>
{<z>
(logger.isWarnEnabled()) {<z>
;<z>
protected BeanDefinition createScriptFactoryBeanDefinition(BeanDefinition bd) {<z>
GenericBeanDefinition();<z>
.setBeanClassName(bd.getBeanClassName());<z>
());<z>
return scriptBd;<z>
, HttpOutputMessage outputMessage)<z>
{<z>
.getContentType();<z>
;<z>
MappingJacksonValue mappingJacksonValue ?<z>
getClass());<z>
objectMapper = selectObjectMapper(clazz, contentType);<z>
);<z>
);<z>
createGenerator(outputStream, encoding)) {<z>
generator, object);<z>
Object value = object;<z>
serializationView = null;<z>
FilterProvider filters = null;<z>
null;<z>
{<z>
= mappingJacksonValue.getValue();<z>
);<z>
= mappingJacksonValue.getFilters();<z>
{<z>
);<z>
?<z>
);<z>
{<z>
;<z>
{<z>
= objectWriter.forType(javaType);<z>
();<z>
isCompatibleWith(MediaType.TEXT_EVENT_STREAM) &&<z>
.INDENT_OUTPUT)) {<z>
.ssePrettyPrinter);<z>
;<z>
, object);<z>
();<z>
(InvalidDefinitionException ex) {<z>
), ex);<z>
) {<z>
, ex);<z>
message) throws MessagingException {<z>
sessionId = resolveSessionId(message);<z>
sessionId == null) {<z>
logger.isErrorEnabled()) {<z>
"Could not find session id in " + message);<z>
sessionId);<z>
holder == null) {<z>
isDebugEnabled()) {<z>
+ message);<z>
= holder.getSession();<z>
(session, message);<z>
(SessionLimitExceededException ex) {<z>
) {<z>
session + "'", ex);<z>
.isWarnEnabled()) {<z>
ex.getMessage());<z>
incrementLimitExceededCount();<z>
.getStatus());<z>
getStatus());<z>
catch (Exception secondException) {<z>
("Failure while closing session " + sessionId + ".", secondException);<z>
) {<z>
)) {<z>
, ex);<z>
accept(Method method) {<z>
getOverride(method);<z>
) {<z>
"MethodOverride for " + method + ": " + methodOverride);<z>
if (methodOverride == null) {<z>
return PASSTHROUGH;<z>
LookupOverride) {<z>
;<z>
methodOverride instanceof ReplaceOverride) {<z>
return METHOD_REPLACER;<z>
UnsupportedOperationException("Unexpected MethodOverride subclass: " +<z>
);<z>
) throws ServletRequestBindingException {<z>
values);<z>
parameters = new double[values.length];<z>
) {<z>
parseDouble(name, values[i]);<z>
parameters;<z>
HttpServletResponse response, Object handler)<z>
Exception {<z>
;<z>
return null;<z>
) {<z>
) {<z>
>) classLoader.loadClass(annotationType);<z>
catch (ClassNotFoundException ex) {<z>
;<z>
, MergedContextConfiguration mergedConfig) {<z>
{<z>
= wac.getServletContext();<z>
null) {<z>
);<z>
Object rootObject) throws EvaluationException {<z>
;<z>
();<z>
.getType() : null);<z>
{<z>
deferContextual(ctx -> {<z>
class)) {<z>
get(TransactionContext.class));<z>
class)) {<z>
class);<z>
)) {<z>
));<z>
(new NoTransactionInContextException());<z>
});<z>
Exception {<z>
== null) {<z>
;<z>
resource, Resource location) throws IOException {<z>
!= location.getClass()) {<z>
return false;<z>
;<z>
locationPath;<z>
{<z>
toExternalForm();<z>
.getURL().toString());<z>
{<z>
= classPathResource.getPath();<z>
);<z>
else if (resource instanceof ServletContextResource servletContextResource) {<z>
);<z>
());<z>
).getPath();<z>
.getURL().getPath());<z>
{<z>
true;<z>
: locationPath + "/");<z>
));<z>
{<z>
(outputStack == null) {<z>
= new int[10];<z>
outputStack.length;<z>
) {<z>
, 2 * outputStackLength)];<z>
outputStackLength);<z>
outputStack = newOutputStack;<z>
= abstractType;<z>
(short) (outputStackStart + outputStackTop);<z>
{<z>
= outputStackSize;<z>
databaseMetaData) throws SQLException {<z>
databaseMetaData.supportsCatalogsInProcedureCalls());<z>
SQLException ex) {<z>
("Error retrieving 'DatabaseMetaData.supportsCatalogsInProcedureCalls' - " + ex.getMessage());<z>
.supportsSchemasInProcedureCalls());<z>
{<z>
+ ex.getMessage());<z>
(databaseMetaData.storesUpperCaseIdentifiers());<z>
ex) {<z>
getMessage());<z>
.storesLowerCaseIdentifiers());<z>
) {<z>
"Error retrieving 'DatabaseMetaData.storesLowerCaseIdentifiers' - " + ex.getMessage());<z>
protected void registerAfterCompletionWithExistingTransaction(<z>
> synchronizations) {<z>
) transaction;<z>
"Registering after-completion synchronization with existing JTA transaction");<z>
doRegisterAfterCompletionWithJtaTransaction(txObject, synchronizations);<z>
(SystemException ex) {<z>
("JTA failure on registerSynchronization", ex);<z>
Exception ex) {<z>
|| ex.getCause() instanceof RollbackException) {<z>
logger.debug("Participating in existing JTA transaction that has been marked for rollback: " +<z>
);<z>
, TransactionSynchronization.STATUS_ROLLED_BACK);<z>
logger.debug("Participating in existing JTA transaction, but unexpected internal transaction " +<z>
+ ex);<z>
.STATUS_UNKNOWN);<z>
{<z>
) {<z>
;<z>
() {<z>
;<z>
.controllers.forEach(controller -> {<z>
.getClass().getName();<z>
;<z>
;<z>
-> {<z>
.getName();<z>
);<z>
});<z>
DelegatingWebFluxConfiguration.class);<z>
);<z>
.refresh();<z>
context;<z>
String> getParameterNames() {<z>
isFormPost()) {<z>
();<z>
super.getParameterNames();<z>
cachedArgument) {<z>
cachedArgument instanceof DependencyDescriptor descriptor) {<z>
.beanFactory != null, "No BeanFactory available");<z>
, null, null);<z>
cachedArgument;<z>
{<z>
{<z>
complete = true;<z>
{<z>
complete();<z>
TaskScheduler scheduler) {<z>
;<z>
.taskScheduler = scheduler;<z>
();<z>
throws Exception {<z>
super.afterPropertiesSet();<z>
getConfiguration() == null) {<z>
= autodetectConfiguration();<z>
));<z>
void handleTransportError(WebSocketSession session, Throwable exception) {<z>
handleTransportError(session, exception);<z>
catch (Exception ex) {<z>
);<z>
parse(String expression) {<z>
expression, "Expression string must not be empty");<z>
resolveMacros(expression);<z>
.tokenizeToStringArray(expression, " ");<z>
) {<z>
IllegalArgumentException(String.format(<z>
.length, expression));<z>
CronField.parseSeconds(fields[0]);<z>
1]);<z>
parseHours(fields[2]);<z>
fields[3]);<z>
.parseMonth(fields[4]);<z>
CronField.parseDaysOfWeek(fields[5]);<z>
daysOfWeek, expression);<z>
(IllegalArgumentException ex) {<z>
) + " in cron expression \"" + expression + "\"";<z>
new IllegalArgumentException(msg, ex);<z>
TypeDescriptor targetType) {<z>
== null) {<z>
sourceKey;<z>
.getMapKeyTypeDescriptor(sourceKey), targetType);<z>
throws IOException {<z>
return (getEncoding() != null ?<z>
:<z>
(name, locale));<z>
<?> implementationClass) {<z>
(baseType, "Base type must not be null");<z>
);<z>
) : asType);<z>
String str) {<z>
)) {<z>
;<z>
);<z>
> upgrade(ServerWebExchange exchange, WebSocketHandler handler,<z>
handshakeInfoFactory){<z>
();<z>
.getResponse();<z>
);<z>
servletResponse = ServerHttpResponseDecorator.getNativeResponse(response);<z>
get();<z>
= response.bufferFactory();<z>
return exchange.getResponse().setComplete()<z>
Mono.deferContextual(contextView -> {<z>
= new StandardWebSocketHandlerAdapter(<z>
ContextWebSocketHandler.decorate(handler, contextView),<z>
(session, handshakeInfo, bufferFactory));<z>
String requestURI = servletRequest.getRequestURI();<z>
DefaultServerEndpointConfig(requestURI, endpoint);<z>
null ?<z>
: Collections.emptyList());<z>
;<z>
);<z>
ex) {<z>
.error(ex);<z>
empty();<z>
);<z>
CompositeMessageCondition other) {<z>
(other);<z>
.messageConditions.size());<z>
.size(); i++) {<z>
));<z>
);<z>
source, SearchStrategy searchStrategy) {<z>
source == Object.class) {<z>
return true;<z>
if (source instanceof Class) {<z>
) source;<z>
class &&<z>
length == 0);<z>
== SearchStrategy.TYPE_HIERARCHY_AND_ENCLOSING_CLASSES ? noSuperTypes &&<z>
) == null : noSuperTypes);<z>
{<z>
isPrivate(sourceMethod.getModifiers()) ||<z>
searchStrategy));<z>
;<z>
runInThread(Runnable runnable) {<z>
"No TaskExecutor available");<z>
;<z>
;<z>
ex) {<z>
error("Task has been rejected by TaskExecutor", ex);<z>
false;<z>
Object value) {<z>
value != null) {<z>
value);<z>
.remove(name);<z>
private static Object doUnbindResource(Object actualKey) {<z>
();<z>
) {<z>
return null;<z>
;<z>
()) {<z>
();<z>
) {<z>
;<z>
;<z>
result) {<z>
(key, result);<z>
RuntimeException ex) {<z>
, result);<z>
> WebSocketMessage toMessage(T message) {<z>
delegateSession;<z>
!= null, "Cannot create message without a session");<z>
(message instanceof String text) {<z>
);<z>
.wrap(bytes));<z>
) {<z>
;<z>
WebSocketMessage(Type.BINARY, buffer);<z>
instanceof PongMessage pongMessage) {<z>
;<z>
);<z>
new IllegalArgumentException("Unexpected message type: " + message);<z>
.springframework.protobuf.Msg parseFrom(<z>
java.io.InputStream input,<z>
com.google.protobuf.ExtensionRegistryLite extensionRegistry)<z>
.IOException {<z>
);<z>
{<z>
this.objectMapperRegistrations == null) {<z>
new LinkedHashMap<>();<z>
, ObjectMapper> registrations =<z>
-> new LinkedHashMap<>());<z>
registrations);<z>
annotation, @Nullable String attributeName) {<z>
!StringUtils.hasText(attributeName)) {<z>
return null;<z>
().getDeclaredMethod(attributeName);<z>
);<z>
annotation);<z>
ex) {<z>
null;<z>
ex) {<z>
.getTargetException());<z>
new IllegalStateException("Could not obtain value for annotation attribute '" +<z>
attributeName + "' in " + annotation, ex);<z>
catch (Throwable ex) {<z>
ex);<z>
null;<z>
protected void checkOnDataAvailable() {<z>
);<z>
= this.pendingMessages.size();<z>
)) {<z>
+ " pending)");<z>
{<z>
);<z>
int status) {<z>
(status);<z>
!= STATUS_COMMITTED) {<z>
.getTransaction().rollback();<z>
ex) {<z>
throw convertException(ex);<z>
closeOnCompletion) {<z>
.closeEntityManager(this.entityManager);<z>
public HandlerMethodArgumentResolverComposite addResolvers(<z>
<? extends HandlerMethodArgumentResolver> resolvers) {<z>
(resolvers != null) {<z>
addAll(resolvers);<z>
return this;<z>
region,<z>
hints) {<z>
ZeroCopyHttpOutputMessage && resource.isFile()) {<z>
File file = resource.getFile();<z>
0;<z>
: file.length();<z>
.isDebugEnabled()) {<z>
(count) + " of " : "";<z>
resource + "]");<z>
));<z>
catch (IOException ex) {<z>
Optional.empty();<z>
(String attributeName, boolean required) {<z>
hasText(attributeName, "Attribute name must not be null");<z>
getAttributes().indexOf(attributeName));<z>
attributeIndex == -1 && required) {<z>
+<z>
().getName());<z>
return attributeIndex;<z>
BeanNameUrlHandlerMapping beanNameHandlerMapping(<z>
@Qualifier("mvcConversionService") FormattingConversionService conversionService,<z>
{<z>
new BeanNameUrlHandlerMapping();<z>
.setOrder(2);<z>
pathConfig = getPathMatchConfigurer();<z>
!= null) {<z>
.setPatternParser(pathConfig.getPatternParser());<z>
.setUrlPathHelper(pathConfig.getUrlPathHelperOrDefault());<z>
pathConfig.getPathMatcherOrDefault());<z>
(getInterceptors(conversionService, resourceUrlProvider));<z>
);<z>
;<z>
HeadersRequestCondition other, ServerWebExchange exchange) {<z>
expressions.size();<z>
if (result != 0) {<z>
return result;<z>
- getValueMatchCount(this.expressions));<z>
,<z>
request, HttpServletResponse response) {<z>
();<z>
== null) {<z>
());<z>
{<z>
processor = wac.getBean(<z>
.class);<z>
request, targetUrl);<z>
return targetUrl;<z>
, ReactiveAdapterRegistry adapterRegistry) {<z>
);<z>
(adapterRegistry, "ReactiveAdapterRegistry is required");<z>
methodResolver = methodResolver;<z>
.adapterRegistry = adapterRegistry;<z>
@Nullable Object[] array) {<z>
{<z>
0;<z>
INITIAL_HASH;<z>
{<z>
(element);<z>
hash;<z>
() {<z>
).getName());<z>
sb.append(": advice ");<z>
(this.adviceBeanName != null) {<z>
append('\'');<z>
;<z>
sb.toString();<z>
Object obj) {<z>
(this == obj) {<z>
;<z>
)) {<z>
return false;<z>
annotationType.equals(that.annotationType);<z>
public Object resolveReference(String key) {<z>
REFERENCE_REQUEST.equals(key)) {<z>
().getRequest();<z>
(key)) {<z>
);<z>
) {<z>
getExternalContext().getContext();<z>
("requestScope".equals(key)) {<z>
;<z>
)) {<z>
);<z>
)) {<z>
);<z>
("facesContext".equals(key)) {<z>
return getFacesContext();<z>
("cookie".equals(key)) {<z>
().getRequestCookieMap();<z>
(key)) {<z>
;<z>
(key)) {<z>
);<z>
) {<z>
;<z>
("paramValues".equals(key)) {<z>
.getRequestParameterValuesMap();<z>
)) {<z>
();<z>
equals(key)) {<z>
return getFacesContext().getViewRoot();<z>
("viewScope".equals(key)) {<z>
getViewRoot().getViewMap();<z>
equals(key)) {<z>
return getExternalContext().getFlash();<z>
.equals(key)) {<z>
);<z>
null;<z>
{<z>
);<z>
se) {<z>
;<z>
(WebRequest webRequest) throws IOException {<z>
;<z>
, this.webClient, webRequest);<z>
setContextPath(this.contextPath);<z>
(requestBuilder);<z>
();<z>
forwardedUrl != null) {<z>
forwardedUrl));<z>
requestBuilder);<z>
();<z>
;<z>
httpServletResponse).build();<z>
charBuffer) {<z>
)], charBuffer);<z>
{<z>
;<z>
attribute = this;<z>
while (attribute != null) {<z>
1;<z>
attribute.nextAttribute;<z>
count;<z>
key, @Nullable String value) {<z>
.Mutable mutableHttpFields)) {<z>
("Immutable headers");<z>
put(key, value);<z>
() {<z>
.nextPotentialReferencePosition != -1) {<z>
== '#');<z>
);<z>
(wasProcessable) {<z>
.nextSemicolonPosition + 1;<z>
this.currentPosition);<z>
);<z>
this.currentPosition++;<z>
obtainTargetConnectionFactory() {<z>
target = getTargetConnectionFactory();<z>
(target != null, "'targetConnectionFactory' is required");<z>
target;<z>
ApplicationEvent event) {<z>
[] args = resolveArguments(event);<z>
event, args)) {<z>
Object result = doInvoke(args);<z>
null) {<z>
);<z>
;<z>
() {<z>
variant) {<z>
: return "?[";<z>
;<z>
case LAST: return "$[";<z>
"";<z>
public synchronized Advice getAdvice() {<z>
) {<z>
.instantiatedAdvice = instantiateAdvice(this.declaredPointcut);<z>
return this.instantiatedAdvice;<z>
public void init() {<z>
));<z>
new JcaListenerContainerParser());<z>
;<z>
)<z>
throws IOException {<z>
scResource) {<z>
.getServletContext();<z>
getPath() + subPattern;<z>
LinkedHashSet<>(8);<z>
, scResource.getPath(), result);<z>
;<z>
, subPattern);<z>
throws Exception {<z>
, response.getStatus());<z>
"Error message", response.getErrorMessage());<z>
;<z>
("Content type", response.getContentType());<z>
.getContentAsString());<z>
, response.getForwardedUrl());<z>
("Redirected URL", response.getRedirectedUrl());<z>
());<z>
equals(@Nullable Object other) {<z>
if (this == other) {<z>
return true;<z>
other instanceof AnnotationMethodMatcher otherMm)) {<z>
false;<z>
checkInherited == otherMm.checkInherited);<z>
public Set<String> getExternallyManagedInitMethods() {<z>
.postProcessingLock) {<z>
?<z>
)) :<z>
.emptySet());<z>
String value,<z>
targetObjectTypeDescriptor) {<z>
= targetObject;<z>
= value;<z>
evaluationContext;<z>
.targetObjectTypeDescriptor = targetObjectTypeDescriptor;<z>
Runnable task) {<z>
(task, null);<z>
.concurrentExecutor, this.taskDecorator, future);<z>
return future;<z>
(RejectedExecutionException ex) {<z>
(<z>
);<z>
Object handleConverterNotFound(<z>
sourceType, TypeDescriptor targetType) {<z>
== null) {<z>
targetType);<z>
;<z>
) &&<z>
(source)) {<z>
;<z>
(sourceType, targetType);<z>
vfsResource) {<z>
vfsResource) > 0;<z>
) {<z>
false;<z>
String mimeType) {<z>
);<z>
) : mimeType).trim();<z>
if (fullType.isEmpty()) {<z>
throw new InvalidMimeTypeException(mimeType, "'mimeType' must not be empty");<z>
equals(fullType)) {<z>
"*/*";<z>
.indexOf('/');<z>
-1) {<z>
(mimeType, "does not contain '/'");<z>
- 1) {<z>
(mimeType, "does not contain subtype after '/'");<z>
.substring(0, subIndex);<z>
+ 1);<z>
MimeType.WILDCARD_TYPE.equals(subtype)) {<z>
new InvalidMimeTypeException(mimeType, "wildcard type is legal only in '*/*' (all mime types)");<z>
Map<String, String> parameters = null;<z>
nextIndex = index + 1;<z>
;<z>
length()) {<z>
;<z>
) {<z>
if (!quoted) {<z>
(ch == '"') {<z>
= !quoted;<z>
;<z>
.trim();<z>
0) {<z>
{<z>
new LinkedHashMap<>(4);<z>
.indexOf('=');<z>
eqIndex >= 0) {<z>
trim();<z>
1).trim();<z>
(attribute, value);<z>
nextIndex;<z>
);<z>
, parameters);<z>
catch (UnsupportedCharsetException ex) {<z>
;<z>
{<z>
.getMessage());<z>
(<z>
Class<T> targetClass) {<z>
null);<z>
{<z>
.executor instanceof LifeCycle) {<z>
executor).stop();<z>
catch (Throwable ex) {<z>
{<z>
String beanName = BeanFactoryUtils.transformedBeanName(name);<z>
beans.get(beanName);<z>
{<z>
new NoSuchBeanDefinitionException(beanName,<z>
;<z>
!(bean instanceof FactoryBean)) {<z>
);<z>
{<z>
>) bean).getObject();<z>
{<z>
throw new BeanCreationException(beanName, "FactoryBean exposed null object");<z>
;<z>
{<z>
ex);<z>
return bean;<z>
() throws IOException, TemplateException {<z>
Configuration config = newConfiguration();<z>
props = new Properties();<z>
(this.configLocation != null) {<z>
()) {<z>
;<z>
(props, this.configLocation);<z>
) {<z>
freemarkerSettings);<z>
{<z>
(props);<z>
(this.freemarkerVariables)) {<z>
getObjectWrapper()));<z>
if (this.defaultEncoding != null) {<z>
this.defaultEncoding);<z>
<>(this.templateLoaders);<z>
(this.preTemplateLoaders != null) {<z>
.addAll(this.preTemplateLoaders);<z>
null) {<z>
this.templateLoaderPaths) {<z>
;<z>
postProcessTemplateLoaders(templateLoaders);<z>
postTemplateLoaders != null) {<z>
addAll(this.postTemplateLoaders);<z>
);<z>
loader != null) {<z>
(loader);<z>
;<z>
return config;<z>
String lookupPath) {<z>
cacheControlMappings.entrySet()) {<z>
)) {<z>
getValue();<z>
return null;<z>
(TransactionManager transactionManager) {<z>
this();<z>
transactionManager, "TransactionManager must not be null");<z>
= transactionManager;<z>
);<z>
(<z>
classValuesAsString) {<z>
(classValuesAsString, true);<z>
(annotationName)<z>
))<z>
MergedAnnotation::withNonMergedAttributes)<z>
toMultiValueMap(map -><z>
: map, adaptations));<z>
{<z>
(definition instanceof AnnotatedBeanDefinition) {<z>
;<z>
if (StringUtils.hasText(beanName)) {<z>
return beanName;<z>
(definition, registry);<z>
xmlBeanDefinitionReader) {<z>
.getRegistry());<z>
;<z>
.groovyDslXmlBeanDefinitionReader = xmlBeanDefinitionReader;<z>
) {<z>
(this.loadTimeWeaver == null) {<z>
new IllegalStateException("Cannot apply class transformer without LoadTimeWeaver specified");<z>
classTransformer));<z>
getValueInternal(ExpressionState state) throws EvaluationException {<z>
getLeftOperand();<z>
(this.children.length < 2) {<z>
getValue();<z>
if (operand instanceof Number number) {<z>
number instanceof BigDecimal bigDecimal) {<z>
(bigDecimal.negate());<z>
) {<z>
TypedValue(bigInteger.negate());<z>
if (number instanceof Double) {<z>
;<z>
doubleValue());<z>
{<z>
;<z>
);<z>
number instanceof Long) {<z>
"J";<z>
longValue());<z>
) {<z>
exitTypeDescriptor = "I";<z>
intValue());<z>
{<z>
number.shortValue());<z>
Byte) {<z>
));<z>
0 - number.doubleValue());<z>
, operand, null);<z>
state).getValue();<z>
();<z>
instanceof Number rightNumber) {<z>
) {<z>
);<z>
BigDecimal.class);<z>
));<z>
instanceof Double || rightNumber instanceof Double) {<z>
;<z>
) - rightNumber.doubleValue());<z>
|| rightNumber instanceof Float) {<z>
;<z>
);<z>
) {<z>
class);<z>
class);<z>
;<z>
instanceof Long || rightNumber instanceof Long) {<z>
= "J";<z>
.longValue());<z>
rightNumber)) {<z>
.exitTypeDescriptor = "I";<z>
.intValue());<z>
) - rightNumber.doubleValue());<z>
) {<z>
;<z>
SUBTRACT, left, right);<z>
{<z>
public String toString() {<z>
class.getName() +".ADVISOR";<z>
type) {<z>
callbacks);<z>
(argumentTypes != null) {<z>
newInstance(type, argumentTypes, arguments);<z>
(type);<z>
(type, null);<z>
List<HandlerMethodArgumentResolver> exceptionHandlerResolvers(<z>
ReactiveAdapterRegistry adapterRegistry,<z>
ConfigurableApplicationContext context) {<z>
.emptyList());<z>
{<z>
)) {<z>
actual));<z>
, int initialCapacity) {<z>
()) {<z>
).newInstance();<z>
) {<z>
throw new IllegalArgumentException(<z>
ex);<z>
(SortedMap.class == mapType) {<z>
>();<z>
;<z>
throws IllegalArgumentException {<z>
) : null);<z>
{<z>
);<z>
) {<z>
TRUE);<z>
equalsIgnoreCase(input)) {<z>
Boolean.FALSE);<z>
&&<z>
) ||<z>
(input))) {<z>
setValue(Boolean.TRUE);<z>
(this.falseString == null &&<z>
) || VALUE_OFF.equalsIgnoreCase(input) ||<z>
.equals(input))) {<z>
FALSE);<z>
+ text + "]");<z>
, Object newArray, TypeConverter typeConverter,<z>
) {<z>
;<z>
newShortArray.length; i++) {<z>
).getTypedValue(state);<z>
, typedValue);<z>
{<z>
!= null) {<z>
interfaceMappings);<z>
String, ?> attributes) {<z>
null) {<z>
.forEach(this::addStaticAttribute);<z>
accept(Visitor visitor) {<z>
(this.name,<z>
(this.value != null) ?<z>
:<z>
));<z>
lookupPath, HttpServletRequest request)<z>
{<z>
;<z>
] keys, final Label[] labels) {<z>
;<z>
% 4) % 4);<z>
.put(code, lastBytecodeOffset, true);<z>
;<z>
length; ++i) {<z>
code.putInt(keys[i]);<z>
;<z>
(dflt, labels);<z>
(<z>
,<z>
AnnotationWriter lastRuntimeVisibleAnnotation,<z>
lastRuntimeInvisibleAnnotation,<z>
final AnnotationWriter lastRuntimeVisibleTypeAnnotation,<z>
,<z>
) {<z>
if (lastRuntimeVisibleAnnotation != null) {<z>
lastRuntimeVisibleAnnotation.putAnnotations(<z>
.RUNTIME_VISIBLE_ANNOTATIONS), output);<z>
!= null) {<z>
lastRuntimeInvisibleAnnotation.putAnnotations(<z>
(Constants.RUNTIME_INVISIBLE_ANNOTATIONS), output);<z>
lastRuntimeVisibleTypeAnnotation != null) {<z>
lastRuntimeVisibleTypeAnnotation.putAnnotations(<z>
.RUNTIME_VISIBLE_TYPE_ANNOTATIONS), output);<z>
lastRuntimeInvisibleTypeAnnotation != null) {<z>
lastRuntimeInvisibleTypeAnnotation.putAnnotations(<z>
Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS), output);<z>
WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,<z>
> supportedExtensions) {<z>
requestedExtensions.size());<z>
: requestedExtensions) {<z>
) {<z>
result.add(extension);<z>
result;<z>
{<z>
(original);<z>
original.annotationMetadata;<z>
original.factoryMethodMetadata;<z>
original.derivedBeanName;<z>
message, Class<T> targetClass) {<z>
;<z>
;<z>
(value == null) {<z>
() +<z>
;<z>
return value;<z>
void writeFrameInternal(SockJsFrame frame) throws IOException {<z>
"WebSocketSession not yet initialized");<z>
isTraceEnabled()) {<z>
logger.trace("Writing " + frame);<z>
());<z>
message);<z>
) {<z>
String> urls = Collections.emptySet();<z>
getMappingPathPatterns(mapping)) {<z>
{<z>
1) : urls);<z>
urls.add(path);<z>
;<z>
private void extractMatchDetails(<z>
PatternsRequestCondition condition, String lookupPath, HttpServletRequest request) {<z>
String bestPattern;<z>
, String> uriVariables;<z>
()) {<z>
bestPattern = lookupPath;<z>
= Collections.emptyMap();<z>
).next();<z>
lookupPath);<z>
shouldRemoveSemicolonContent()) {<z>
, extractMatrixVariables(request, uriVariables));<z>
request, uriVariables);<z>
, bestPattern);<z>
setAttribute(URI_TEMPLATE_VARIABLES_ATTRIBUTE, uriVariables);<z>
) {<z>
!= null) {<z>
attributes);<z>
;<z>
, CompilationCustomizer... compilationCustomizers) {<z>
this(scriptSourceLocator);<z>
compilationCustomizers)) {<z>
new CompilerConfiguration();<z>
this.compilerConfiguration.addCompilationCustomizers(compilationCustomizers);<z>
Nullable List<String> allowedMethods) {<z>
<>(allowedMethods) : null);<z>
CollectionUtils.isEmpty(allowedMethods)) {<z>
<>(allowedMethods.size());<z>
String method : allowedMethods) {<z>
) {<z>
this.resolvedMethods = null;<z>
);<z>
= DEFAULT_METHODS;<z>
> clazz) throws BeanInstantiationException {<z>
(clazz, "Class must not be null");<z>
(clazz.isInterface()) {<z>
throw new BeanInstantiationException(clazz, "Specified class is an interface");<z>
clazz.newInstance();<z>
ex) {<z>
ex);<z>
IllegalAccessException ex) {<z>
BeanInstantiationException(clazz, "Is the constructor accessible?", ex);<z>
, int targetStart, int length) {<z>
getTextCharacters();<z>
length);<z>
, length);<z>
length;<z>
getContent(MvcResult result) throws UnsupportedEncodingException {<z>
.UTF_8);<z>
) {<z>
,<z>
;<z>
(this.prefix));<z>
(this.prefix.length());<z>
StringIndexOutOfBoundsException ex) {<z>
"\" not found", ex);<z>
;<z>
Object remove(String name) {<z>
).getSessionMutex();<z>
synchronized (mutex) {<z>
return super.remove(name);<z>
{<z>
newProxyInstance(<z>
),<z>
?>[] {ConnectionProxy.class},<z>
());<z>
, @Nullable LockMode lockMode)<z>
throws DataAccessException {<z>
-> {<z>
;<z>
lockMode != null) {<z>
);<z>
);<z>
null;<z>
;<z>
, Resource inputResource,<z>
{<z>
inputResource)<z>
(outputResource -> {<z>
filename = outputResource.getFilename();<z>
equals(StringUtils.getFilenameExtension(filename)) ||<z>
EncodedResource) {<z>
just(outputResource);<z>
).bufferFactory();<z>
= DataBufferUtils<z>
.BUFFER_SIZE);<z>
flux)<z>
.flatMap(dataBuffer -> {<z>
));<z>
release(dataBuffer);<z>
= charBuffer.toString();<z>
;<z>
;<z>
;<z>
setBeanFactory(BeanFactory beanFactory) {<z>
if (!(beanFactory instanceof ConfigurableListableBeanFactory)) {<z>
(<z>
"AutowiredAnnotationBeanPostProcessor requires a ConfigurableListableBeanFactory: " + beanFactory);<z>
(ConfigurableListableBeanFactory) beanFactory;<z>
order) {<z>
;<z>
{<z>
registry.setOrder(order);<z>
;<z>
{<z>
(descriptor == null) {<z>
return false;<z>
= true;<z>
); i < max; i++) {<z>
charAt(i);<z>
{<z>
primitive = (ch != 'L');<z>
return primitive;<z>
visitBeanClassName(BeanDefinition beanDefinition) {<z>
beanClassName = beanDefinition.getBeanClassName();<z>
(beanClassName != null) {<z>
resolvedName = resolveStringValue(beanClassName);<z>
) {<z>
beanDefinition.setBeanClassName(resolvedName);<z>
prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {<z>
);<z>
!shouldIgnoreSpel) {<z>
);<z>
);<z>
addBeanPostProcessor(new ApplicationContextAwareProcessor(this));<z>
.class);<z>
);<z>
(ResourceLoaderAware.class);<z>
.ignoreDependencyInterface(ApplicationEventPublisherAware.class);<z>
class);<z>
class);<z>
.class);<z>
);<z>
registerResolvableDependency(ResourceLoader.class, this);<z>
.registerResolvableDependency(ApplicationEventPublisher.class, this);<z>
, this);<z>
(new ApplicationListenerDetector(this));<z>
{<z>
beanFactory));<z>
);<z>
)) {<z>
(ENVIRONMENT_BEAN_NAME, getEnvironment());<z>
(SYSTEM_PROPERTIES_BEAN_NAME)) {<z>
getEnvironment().getSystemProperties());<z>
!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {<z>
().getSystemEnvironment());<z>
.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) {<z>
.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup());<z>
void handleWarnings(Statement stmt) throws SQLException {<z>
if (isIgnoreWarnings()) {<z>
(logger.isDebugEnabled()) {<z>
getWarnings();<z>
!= null) {<z>
warningToLog.getSQLState() + "', error code '" +<z>
getMessage() + "]");<z>
warningToLog.getNextWarning();<z>
());<z>
{<z>
() != null) {<z>
getInputStream());<z>
!= null) {<z>
;<z>
new IllegalArgumentException("StreamSource contains neither InputStream nor Reader");<z>
) {<z>
(!supportsMimeType(headers)) {<z>
false;<z>
new AtomicReference<>();<z>
, causeRef)) {<z>
true;<z>
, causeRef.get());<z>
;<z>
,<z>
{<z>
null);<z>
boolean hasSessions() {<z>
this.sessionLookup != null) {<z>
isEmpty();<z>
.sessions.isEmpty();<z>
JspException {<z>
writeOptionalAttributeValue(CLASS_ATTRIBUTE, resolveCssClass());<z>
STYLE_ATTRIBUTE,<z>
);<z>
));<z>
));<z>
);<z>
;<z>
ONCLICK_ATTRIBUTE, getOnclick());<z>
getOndblclick());<z>
, ONMOUSEDOWN_ATTRIBUTE, getOnmousedown());<z>
));<z>
));<z>
getOnmousemove());<z>
ONMOUSEOUT_ATTRIBUTE, getOnmouseout());<z>
;<z>
;<z>
());<z>
.isEmpty(this.dynamicAttributes)) {<z>
this.dynamicAttributes.entrySet()) {<z>
));<z>
prepareRefresh() {<z>
.currentTimeMillis();<z>
;<z>
.active.set(true);<z>
()) {<z>
{<z>
+ this);<z>
("Refreshing " + getDisplayName());<z>
);<z>
);<z>
{<z>
LinkedHashSet<>(this.applicationListeners);<z>
();<z>
.applicationListeners.addAll(this.earlyApplicationListeners);<z>
LinkedHashSet<>();<z>
cookies) {<z>
isEmpty(cookies) ? null : cookies);<z>
(this.cookies == null) {<z>
.COOKIE);<z>
), true);<z>
, int parameterPosition, Object argValue) throws SQLException {<z>
{<z>
.getValue());<z>
;<z>
, final XmlResultProvider provider) {<z>
AbstractJdbc4SqlXmlValue() {<z>
SQLException, IOException {<z>
);<z>
) {<z>
Assert.notNull(clientInboundChannel, "Inbound MessageChannel must not be null");<z>
clientOutboundChannel, "Outbound MessageChannel must not be null");<z>
this.clientInboundChannel = clientInboundChannel;<z>
clientOutboundChannel = clientOutboundChannel;<z>
() {<z>
= getExpression();<z>
!= null, "No expression set");<z>
expression;<z>
checkCompile(ExpressionState expressionState) {<z>
();<z>
getCompilerMode();<z>
OFF) {<z>
.IMMEDIATE) {<z>
1) {<z>
();<z>
{<z>
compileExpression();<z>
) {<z>
null) {<z>
PAGE_SCOPE;<z>
(name, REQUEST_SCOPE) != null) {<z>
return REQUEST_SCOPE;<z>
(name, SESSION_SCOPE) != null) {<z>
return SESSION_SCOPE;<z>
APPLICATION_SCOPE) != null) {<z>
APPLICATION_SCOPE;<z>
return 0;<z>
{<z>
;<z>
) {<z>
);<z>
.add(new ReflectiveConstructorResolver());<z>
= resolvers;<z>
return resolvers;<z>
beanDefinition) {<z>
;<z>
getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE);<z>
instanceof Boolean) {<z>
= (Boolean) attributeValue;<z>
attributeValue instanceof String) {<z>
Boolean.parseBoolean((String) attributeValue);<z>
null) {<z>
BeanDefinitionStoreException("Invalid proxy target class attribute [" +<z>
"] with value '" + attributeValue +<z>
);<z>
return proxyTargetClass;<z>
> parsePathParams(String input, Charset charset) {<z>
result = new LinkedMultiValueMap<>();<z>
;<z>
< input.length()) {<z>
= input.indexOf(';', begin);<z>
;<z>
parsePathParamValues(param, charset, result);<z>
-1) {<z>
end + 1;<z>
return result;<z>
public static Class<?> findAnnotationDeclaringClassForTypes(<z>
Nullable Class<?> clazz) {<z>
if (clazz == null) {<z>
;<z>
, SearchStrategy.SUPERCLASS)<z>
()<z>
and(MergedAnnotation::isDirectlyPresent))<z>
.map(MergedAnnotation::getSource)<z>
null);<z>
{<z>
this);<z>
();<z>
());<z>
.addPropertyValues(context.getMergedJobDataMap());<z>
(pvs, true);<z>
SchedulerException ex) {<z>
ex);<z>
(context);<z>
ResourceLoader deduceResourceLoader(@Nullable BeanDefinitionRegistry source) {<z>
) {<z>
ResourceLoader) source;<z>
;<z>
(Locale locale) throws Exception {<z>
url = getUrl();<z>
!= null, "'url' not set");<z>
getResource(url) != null);<z>
@Nullable ResolvableType actualType,<z>
MediaType mediaType, ServerHttpRequest request,<z>
hints) {<z>
headers = response.getHeaders();<z>
, "bytes");<z>
> ranges;<z>
.getRange();<z>
catch (IllegalArgumentException ex) {<z>
.REQUESTED_RANGE_NOT_SATISFIABLE);<z>
setComplete();<z>
resource -> {<z>
{<z>
elementType, mediaType, response, hints);<z>
;<z>
.toResourceRegions(ranges, resource);<z>
resource, hints);<z>
) == 1){<z>
ResourceRegion region = regions.get(0);<z>
resourceMediaType);<z>
);<z>
(contentLength != -1) {<z>
();<z>
() - 1;<z>
contentLength - 1);<z>
;<z>
1);<z>
hints);<z>
.generateMultipartBoundaryString();<z>
+ boundary);<z>
(multipartType);<z>
, ResourceRegionEncoder.BOUNDARY_STRING_HINT, boundary);<z>
;<z>
);<z>
String encoding) {<z>
;<z>
Assert.notNull(encoding, "Encoding is required");<z>
;<z>
{<z>
.charAt(i);<z>
characterEntityReferences.isMappedToReference(character, encoding)) {<z>
escaped.append(HtmlCharacterEntityReferences.HEX_REFERENCE_START);<z>
);<z>
append(HtmlCharacterEntityReferences.REFERENCE_END);<z>
;<z>
toString();<z>
String beanName, RootBeanDefinition mbd,<z>
) {<z>
.beanFactory.getInstantiationStrategy().instantiate(<z>
;<z>
ex) {<z>
.getResourceDescription(), beanName,<z>
);<z>
synchronizations) {<z>
)<z>
).onErrorContinue((t, o) -><z>
"TransactionSynchronization.beforeCompletion threw exception", t)).then();<z>
{<z>
super(beanFactory, name);<z>
.isPrototype(name)) {<z>
throw new IllegalArgumentException(<z>
name + "': not a prototype");<z>
Class<?>... args) {<z>
;<z>
"Method name must not be null");<z>
args);<z>
null;<z>
(NoSuchMethodException ex) {<z>
;<z>
String beanName) throws BeansException {<z>
this.mergedBeanDefinitions.get(beanName);<z>
!= null && !mbd.stale) {<z>
mbd;<z>
beanName));<z>
) {<z>
, "Encoding must not be empty");<z>
;<z>
= forceRequestEncoding;<z>
.forceResponseEncoding = forceResponseEncoding;<z>
paramValues) {<z>
null) {<z>
{<z>
SqlParameterValue) {<z>
);<z>
) {<z>
inValue).cleanup();<z>
if (inValue instanceof DisposableSqlTypeValue) {<z>
).cleanup();<z>
getContentCodingKey(HttpServletRequest request) {<z>
= request.getHeader(HttpHeaders.ACCEPT_ENCODING);<z>
(header)) {<z>
;<z>
(StringUtils.tokenizeToStringArray(header, ","))<z>
.map(token -> {<z>
.indexOf(';');<z>
;<z>
.contentCodings::contains)<z>
()<z>
));<z>
getAttachmentAsDataHandler(String contentId) {<z>
(CID)) {<z>
(CID.length());<z>
UTF_8);<z>
contentId + '>';<z>
;<z>
(dataHandler == null) {<z>
;<z>
return dataHandler;<z>
int index) {<z>
propertyName != null ?<z>
PROPERTY_KEY_PREFIX + index + PropertyAccessor.PROPERTY_KEY_SUFFIX :<z>
null);<z>
{<z>
getEventType();<z>
eventType != expectedType) {<z>
+ eventType + "]");<z>
> getDeclaredMethods() {<z>
);<z>
.doWithLocalMethods(getIntrospectedClass(), method -><z>
);<z>
result;<z>
,<z>
String[] interfaces) {<z>
this.className = toClassName(name);<z>
= access;<z>
access)) {<z>
= toClassName(supername);<z>
++) {<z>
]));<z>
, HttpHeaders headers,<z>
cookies, T entity,<z>
<String, Object> hints) {<z>
cookies, hints);<z>
.entity = entity;<z>
this.inserter = inserter;<z>
[] charBuffer) {<z>
(offset);<z>
|| constantPoolEntryIndex == 0) {<z>
;<z>
return readUtf(constantPoolEntryIndex, charBuffer);<z>
(<z>
String unitName) throws NoSuchBeanDefinitionException {<z>
notNull(beanFactory, "ListableBeanFactory must not be null");<z>
)) {<z>
] candidateNames =<z>
EntityManagerFactory.class);<z>
: candidateNames) {<z>
;<z>
&&<z>
)) {<z>
emf;<z>
);<z>
beanFactory.getBean(EntityManagerFactory.class);<z>
Message<?> message) {<z>
getHeaders();<z>
messageType = SimpMessageHeaderAccessor.getMessageType(headers);<z>
)) {<z>
+ message);<z>
SimpMessageHeaderAccessor.getSessionId(headers);<z>
if (sessionId == null) {<z>
) {<z>
logger.error("No sessionId in " + message);<z>
subscriptionId = SimpMessageHeaderAccessor.getSubscriptionId(headers);<z>
if (subscriptionId == null) {<z>
logger.isErrorEnabled()) {<z>
;<z>
message);<z>
(<z>
{<z>
"Function must not be null");<z>
.flatMap(next::handle);<z>
void postHandle(<z>
modelAndView)<z>
{<z>
.getParameter("noView") != null) {<z>
;<z>
{<z>
("Wrong interceptor order");<z>
(request.getAttribute("test2x"))) {<z>
;<z>
);<z>
HttpServletRequest request) {<z>
= getDefaultLocale();<z>
{<z>
defaultLocale;<z>
;<z>
= getSupportedLocales();<z>
{<z>
;<z>
;<z>
null) {<z>
return supportedLocale;<z>
defaultLocale : requestLocale);<z>
String path) {<z>
(path == null) {<z>
.length(); i++) {<z>
charAt(i);<z>
';') {<z>
path + ": Invalid cookie path char '" + c + "'");<z>
Class<?> requiredType) throws SQLException {<z>
null) {<z>
(rs, index);<z>
Object value;<z>
.class == requiredType) {<z>
getString(index);<z>
== requiredType) {<z>
);<z>
requiredType || Byte.class == requiredType) {<z>
index);<z>
) {<z>
.getShort(index);<z>
.class == requiredType) {<z>
(index);<z>
{<z>
);<z>
== requiredType) {<z>
= rs.getFloat(index);<z>
||<z>
requiredType) {<z>
getDouble(index);<z>
BigDecimal.class == requiredType) {<z>
return rs.getBigDecimal(index);<z>
.class == requiredType) {<z>
rs.getDate(index);<z>
.class == requiredType) {<z>
getTime(index);<z>
requiredType) {<z>
.getTimestamp(index);<z>
requiredType) {<z>
.getBytes(index);<z>
(Blob.class == requiredType) {<z>
.getBlob(index);<z>
if (Clob.class == requiredType) {<z>
);<z>
requiredType.isEnum()) {<z>
.getObject(index);<z>
String) {<z>
;<z>
if (obj instanceof Number) {<z>
);<z>
return rs.getString(index);<z>
requiredType);<z>
err) {<z>
);<z>
ex) {<z>
debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex);<z>
SQLException ex) {<z>
logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex);<z>
);<z>
)) {<z>
rs.getDate(index);<z>
)) {<z>
index);<z>
(typeName)) {<z>
(index);<z>
, index);<z>
);<z>
DefaultClientResponseBuilder rawStatusCode(int statusCode) {<z>
, "StatusCode must be between 1xx and 5xx");<z>
statusCode;<z>
this;<z>
{<z>
ResolvableType cachedReturnType = mbd.factoryMethodReturnType;<z>
if (cachedReturnType != null) {<z>
;<z>
commonType = null;<z>
factoryMethodToIntrospect;<z>
{<z>
factoryClass;<z>
boolean isStatic = true;<z>
factoryBeanName = mbd.getFactoryBeanName();<z>
) {<z>
) {<z>
(), beanName,<z>
;<z>
;<z>
;<z>
);<z>
null) {<z>
return null;<z>
factoryClass = ClassUtils.getUserClass(factoryClass);<z>
=<z>
);<z>
candidates = this.factoryMethodCandidateCache.computeIfAbsent(factoryClass,<z>
));<z>
Method candidate : candidates) {<z>
(candidate) &&<z>
minNrOfArgs) {<z>
getTypeParameters().length > 0) {<z>
getParameterTypes();<z>
= null;<z>
= getParameterNameDiscoverer();<z>
if (pnd != null) {<z>
candidate);<z>
ConstructorArgumentValues cav = mbd.getConstructorArgumentValues();<z>
(paramTypes.length);<z>
.length];<z>
length; i++) {<z>
= cav.getArgumentValue(<z>
);<z>
== null) {<z>
, null, usedValueHolders);<z>
null) {<z>
= valueHolder.getValue();<z>
valueHolder);<z>
(<z>
;<z>
== candidate.getReturnType() ?<z>
);<z>
;<z>
{<z>
null;<z>
ex) {<z>
.isDebugEnabled()) {<z>
;<z>
null ? candidate : null);<z>
getReturnType(), commonType);<z>
) {<z>
;<z>
.factoryMethodToIntrospect = uniqueCandidate;<z>
commonType == null) {<z>
null;<z>
!= null ?<z>
;<z>
.factoryMethodReturnType = cachedReturnType;<z>
return cachedReturnType.resolve();<z>
, NoSuchMethodException {<z>
);<z>
.beanName);<z>
.class : StatefulMethodInvokingJob.class);<z>
);<z>
!= null ? name : toString());<z>
this.group);<z>
;<z>
jdi.setDurability(true);<z>
).put("methodInvoker", this);<z>
jobDetail = jdi;<z>
this.jobDetail);<z>
public ClassLoader getThrowawayClassLoader() {<z>
.classLoader));<z>
InvocationTargetException ex) {<z>
, ex.getCause());<z>
) {<z>
new IllegalStateException("Could not invoke GlassFish copy method", ex);<z>
ApplicationContext applicationContext) {<z>
webApplicationContext == null && applicationContext instanceof WebApplicationContext wac) {<z>
= wac;<z>
this.webApplicationContextInjected = true;<z>
{<z>
);<z>
getStereotypes())));<z>
store(out, null);<z>
message, Throwable exception) {<z>
logger.isErrorEnabled()) {<z>
valueOf(message), exception);<z>
t) {<z>
servletResponse, this.context);<z>
catch (ServletException | IOException handlingThrowable) {<z>
;<z>
afterCompletion(int status) {<z>
if (!this.beforeCompletionCalled) {<z>
beforeCompletion();<z>
{<z>
case Status.STATUS_COMMITTED:<z>
TransactionSynchronization.STATUS_COMMITTED);<z>
:<z>
STATUS_ROLLED_BACK);<z>
;<z>
[] tasks, ScheduledExecutorService executor) {<z>
: tasks) {<z>
getRunnableToSchedule(task);<z>
) {<z>
));<z>
.isFixedRate()) {<z>
(), task.getTimeUnit());<z>
());<z>
protected ModelAndView doResolveException(<z>
) {<z>
ResponseStatusException) {<z>
request, response, handler);<z>
.getClass(), ResponseStatus.class);<z>
!= null) {<z>
handler, ex);<z>
) instanceof Exception) {<z>
Exception) ex.getCause());<z>
) {<z>
(logger.isWarnEnabled()) {<z>
;<z>
;<z>
(<z>
) {<z>
);<z>
()) {<z>
)) {<z>
"Found 'Content-Type:" + contentType + "' in response");<z>
;<z>
exchange);<z>
getProducibleTypes(exchange, producibleTypesSupplier);<z>
compatibleMediaTypes = new LinkedHashSet<>();<z>
MediaType acceptable : acceptableTypes) {<z>
: producibleTypes) {<z>
)) {<z>
));<z>
compatibleMediaTypes);<z>
.sortBySpecificity(result);<z>
MediaType selected = null;<z>
{<z>
) {<z>
mediaType;<z>
.isPresentIn(ALL_APPLICATION_MEDIA_TYPES)) {<z>
= MediaType.APPLICATION_OCTET_STREAM;<z>
!= null) {<z>
selected = selected.removeQualityValue();<z>
(logger.isDebugEnabled()) {<z>
) + "Using '" + selected + "' given " + acceptableTypes +<z>
producibleTypes);<z>
isDebugEnabled()) {<z>
getLogPrefix() +<z>
+ ", supported: " + producibleTypes);<z>
;<z>
processProperties(ConfigurableListableBeanFactory beanFactory, Properties props)<z>
{<z>
;) {<z>
nextElement();<z>
key));<z>
ex) {<z>
= "Could not process key '" + key + "' in PropertyOverrideConfigurer";<z>
if (!this.ignoreInvalidKeys) {<z>
msg, ex);<z>
logger.isDebugEnabled()) {<z>
debug(msg, ex);<z>
,<z>
> destroyMethods) {<z>
;<z>
;<z>
this.destroyMethods = destroyMethods;<z>
static void sortIfNecessary(Object value) {<z>
(value instanceof Object[]) {<z>
value);<z>
List) {<z>
;<z>
visitCode() {<z>
{<z>
mv.visitCode();<z>
Annotation[] getAnnotations(Method method) {<z>
getAnnotations(), method);<z>
(Throwable ex) {<z>
method, ex);<z>
return null;<z>
> extract(Payload payload, MimeType metadataMimeType) {<z>
;<z>
)) {<z>
, false)) {<z>
getMimeType(), result);<z>
;<z>
.isDebugEnabled()) {<z>
("Values extracted from metadata: " + result +<z>
;<z>
return result;<z>
) {<z>
"{");<z>
.methodsCondition.isEmpty()) {<z>
methodsCondition.getMethods();<z>
: httpMethods);<z>
this.patternsCondition.isEmpty()) {<z>
patternsCondition.getPatterns();<z>
patterns);<z>
{<z>
;<z>
headersCondition.isEmpty()) {<z>
append(this.headersCondition);<z>
consumesCondition.isEmpty()) {<z>
", consumes ").append(this.consumesCondition);<z>
producesCondition.isEmpty()) {<z>
this.producesCondition);<z>
!this.customConditionHolder.isEmpty()) {<z>
).append(this.customConditionHolder);<z>
builder.append('}');<z>
;<z>
(@Nullable Supplier<Executor> defaultExecutor,<z>
Supplier<AsyncUncaughtExceptionHandler> exceptionHandler) {<z>
beanFactory));<z>
new);<z>
Element getSuperClass(Element element) {<z>
.asType());<z>
)) {<z>
null;<z>
superTypes.get(0));<z>
> rowMapper) throws DataAccessException {<z>
>>, SqlProvider {<z>
(Statement stmt) throws SQLException {<z>
ResultSet rs = stmt.executeQuery(sql);<z>
Connection con = stmt.getConnection();<z>
).onClose(() -> {<z>
(rs);<z>
JdbcUtils.closeStatement(stmt);<z>
, getDataSource());<z>
});<z>
public String getSql() {<z>
;<z>
));<z>
{<z>
()) {<z>
;<z>
"[", "]");<z>
)) {<z>
style(entry));<z>
result;<z>
public static SecondMsg parseFrom(<z>
io.InputStream input,<z>
.protobuf.ExtensionRegistryLite extensionRegistry)<z>
java.io.IOException {<z>
);<z>
parameter, int index) {<z>
.getDeclaringExecutable();<z>
.isInnerClass(executable.getDeclaringClass()) &&<z>
getParameterCount() - 1) {<z>
;<z>
;<z>
JMSException {<z>
(this.sharedConnectionMonitor) {<z>
= false;<z>
!= null) {<z>
);<z>
.jms.IllegalStateException ex) {<z>
.debug("Ignoring Connection stop exception - assuming already stopped: " + ex);<z>
bd) {<z>
propertyName = ele.getAttribute(NAME_ATTRIBUTE);<z>
(propertyName)) {<z>
ele);<z>
PropertyEntry(propertyName));<z>
(propertyName)) {<z>
ele);<z>
;<z>
PropertyValue(propertyName, val);<z>
parseMetaElements(ele, pv);<z>
extractSource(ele));<z>
pv);<z>
this.parseState.pop();<z>
message, String name)<z>
Exception {<z>
get(name);<z>
);<z>
headerValue != null && nativeHeaderValue != null) {<z>
if (logger.isDebugEnabled()) {<z>
"A value was found for '" + name + "', in both the top level header map " +<z>
"Use 'nativeHeader.myHeader' to resolve the native header.");<z>
nativeHeaderValue);<z>
(Class<?> clazz) {<z>
!= clazz) {<z>
this.cachedIntrospectionResults = null;<z>
private void sendNextMessage() {<z>
) {<z>
messages.peek();<z>
) {<z>
{<z>
)) {<z>
;<z>
);<z>
) {<z>
(Throwable ex) {<z>
{<z>
;<z>
(message);<z>
;<z>
trySend();<z>
, List<String> value) {<z>
;<z>
put(key, value);<z>
oldValues;<z>
SQLException, DataAccessException {<z>
) {<z>
;<z>
executeUpdate();<z>
(int expectedCount, int actualCount) {<z>
"Incorrect column count: expected " + expectedCount + ", actual " + actualCount);<z>
= expectedCount;<z>
;<z>
bh) {<z>
{<z>
ArrayList<>();<z>
: data.patterns) {<z>
matches(path)) {<z>
pattern);<z>
;<z>
consume(matches);<z>
) {<z>
MethodParameter nestedParameter = parameter.nestedIfOptional();<z>
();<z>
Principal.class.isAssignableFrom(paramType);<z>
void applyCookies() {<z>
.flatMap(Collection::stream)<z>
))<z>
addCookie);<z>
{<z>
()) {<z>
;<z>
declaredParameters.add(param);<z>
String message, String statusText,<z>
Nullable Charset charset) {<z>
);<z>
private MethodParameter resolveMethodParameter() {<z>
resolveReadMethodParameter();<z>
();<z>
) {<z>
read == null) {<z>
throw new IllegalStateException("Property is neither readable nor writeable");<z>
return read;<z>
if (read != null) {<z>
getParameterType();<z>
writeType = write.getParameterType();<z>
) && writeType.isAssignableFrom(readType)) {<z>
return read;<z>
write;<z>
rollbackRules, String noRollbackForValue) {<z>
exceptionTypeNames = StringUtils.commaDelimitedListToStringArray(noRollbackForValue);<z>
{<z>
;<z>
) {<z>
, toLookFor);<z>
result != null) {<z>
new AspectJAnnotation<>(result);<z>
null;<z>
[] getParameterAnnotations() {<z>
.parameterAnnotations;<z>
(paramAnns == null) {<z>
executable.getParameterAnnotations();<z>
;<z>
.executable instanceof Constructor &&<z>
this.executable.getDeclaringClass()) &&<z>
executable.getParameterCount() - 1) {<z>
parameterIndex - 1;<z>
index >= 0 && index < annotationArray.length ?<z>
[index]) : EMPTY_ANNOTATION_ARRAY);<z>
paramAnns;<z>
;<z>
JspException {<z>
).isError();<z>
catch (IllegalStateException ex) {<z>
false;<z>
CannotLoadBeanClassException(@Nullable String resourceDescription, String beanName,<z>
Nullable String beanClassName, ClassNotFoundException cause) {<z>
"'" +<z>
" defined in " + resourceDescription : ""), cause);<z>
this.resourceDescription = resourceDescription;<z>
this.beanName = beanName;<z>
= beanClassName;<z>
(String pathSeparator) {<z>
"'pathSeparator' is required");<z>
this.pathSeparator = pathSeparator;<z>
;<z>
Object returnValue, MethodParameter returnType,<z>
) throws Exception {<z>
== null) {<z>
else if (returnValue instanceof Model) {<z>
());<z>
throw new UnsupportedOperationException("Unexpected return type [" +<z>
));<z>
void handleMissingValueInternal(<z>
, NativeWebRequest request, boolean missingAfterConversion)<z>
throws Exception {<z>
.getNativeRequest(HttpServletRequest.class);<z>
MultipartResolutionDelegate.isMultipartArgument(parameter)) {<z>
) {<z>
"Current request is not a multipart request");<z>
throw new MissingServletRequestPartException(name);<z>
new MissingServletRequestParameterException(name,<z>
).getSimpleName(), missingAfterConversion);<z>
Attributes attributes) {<z>
int attrLength = attributes.getLength();<z>
attrLength);<z>
i++) {<z>
(i));<z>
{<z>
attributes.getValue(i)));<z>
;<z>
getServletPath(ServletConfig config) {<z>
String name = config.getServletName();<z>
().getServletRegistration(name);<z>
== null) {<z>
new IllegalStateException("ServletRegistration not found for Servlet '" + name + "'");<z>
= registration.getMappings();<z>
mappings.size() == 1) {<z>
.next();<z>
) {<z>
;<z>
) {<z>
.length() - 2);<z>
logger.isDebugEnabled()) {<z>
path + "' for '" + name + "'");<z>
return path;<z>
new IllegalArgumentException("Expected a single Servlet mapping: " +<z>
"'");<z>
(<z>
, Map<String, Object> attributes) {<z>
.getPrincipal();<z>
locale) throws NoSuchMessageException {<z>
resolvable.getCodes();<z>
!= null) {<z>
) {<z>
, locale);<z>
!= null) {<z>
message;<z>
getDefaultMessage(resolvable, locale);<z>
{<z>
return defaultMessage;<z>
;<z>
private static Map<String, DefaultValueHolder> computeDefaultValues(<z>
> annotationType) {<z>
= AttributeMethods.forAnnotationType(annotationType);<z>
) {<z>
();<z>
(methods.size());<z>
)) {<z>
); i++) {<z>
.get(i);<z>
getDefaultValue();<z>
(defaultValue != null) {<z>
(), new DefaultValueHolder(defaultValue));<z>
of(annotationType)<z>
asMap(annotation -><z>
;<z>
.entrySet()) {<z>
);<z>
result;<z>
public void destroy() {<z>
(this.newlyRegistered) {<z>
(this.server);<z>
(int port) {<z>
));<z>
close();<z>
;<z>
Exception ex) {<z>
return false;<z>
public ConfigurationClass asConfigClass(ConfigurationClass importedBy) {<z>
source instanceof Class) {<z>
?>) this.source, importedBy);<z>
source, importedBy);<z>
sourceType, TypeDescriptor targetType) {<z>
(this.printerObjectType)) {<z>
source, sourceType, this.printerObjectType);<z>
null) {<z>
;<z>
);<z>
static XmlContent of(Object source) {<z>
(source instanceof StringWriter) {<z>
);<z>
);<z>
assertNotException(String attributeName, Object attributeValue) {<z>
if (attributeValue instanceof Throwable) {<z>
(String.format(<z>
Throwable) attributeValue);<z>
afterPropertiesSet() {<z>
null && this.beanFactory == null) {<z>
new IllegalStateException(<z>
"containing a TransactionManager bean!");<z>
if (getTransactionAttributeSource() == null) {<z>
new IllegalStateException(<z>
"If there are no transactional methods, then don't use a transaction aspect.");<z>
{<z>
RequestDispatcher.INCLUDE_MAPPING);<z>
== null) {<z>
;<z>
mapping.getMappingMatch();<z>
nullSafeEquals(match, MappingMatch.PATH)) {<z>
null;<z>
request.getAttribute(WebUtils.INCLUDE_SERVLET_PATH_ATTRIBUTE);<z>
: request.getServletPath());<z>
encodePath(servletPath, StandardCharsets.UTF_8);<z>
(PathPatternParser parser, String... patterns) {<z>
)) {<z>
EMPTY_PATH_PATTERN;<z>
result = new TreeSet<>();<z>
: patterns) {<z>
("/")) {<z>
;<z>
path));<z>
result;<z>
contains(Object entity) throws DataAccessException {<z>
-> session.contains(entity));<z>
, "No contains result");<z>
return result;<z>
messageSource,<z>
@Nullable RequestDataValueProcessor dataValueProcessor) {<z>
"ServerWebExchange is required");<z>
, "Model is required");<z>
.notNull(messageSource, "MessageSource is required");<z>
= exchange;<z>
model = model;<z>
messageSource = messageSource;<z>
getLocaleContext();<z>
();<z>
;<z>
TimeZone timeZone = (localeContext instanceof TimeZoneAwareLocaleContext tzaLocaleContext ?<z>
tzaLocaleContext.getTimeZone() : null);<z>
TimeZone.getDefault());<z>
.defaultHtmlEscape = null;<z>
dataValueProcessor = dataValueProcessor;<z>
public static Msg parseFrom(<z>
.protobuf.CodedInputStream input)<z>
.IOException {<z>
.parseFrom(input);<z>
{<z>
i) {<z>
attribute.type)) {<z>
return true;<z>
return false;<z>
protected HandlerMethod(HandlerMethod handlerMethod) {<z>
notNull(handlerMethod, "HandlerMethod is required");<z>
bean;<z>
= handlerMethod.beanFactory;<z>
messageSource = handlerMethod.messageSource;<z>
beanType;<z>
method = handlerMethod.method;<z>
.bridgedMethod = handlerMethod.bridgedMethod;<z>
handlerMethod.parameters;<z>
responseStatus;<z>
.responseStatusReason = handlerMethod.responseStatusReason;<z>
.description;<z>
;<z>
private Object[] getArguments(ExpressionState state) {<z>
= new Object[getChildCount()];<z>
< arguments.length; i++) {<z>
));<z>
).getValue();<z>
;<z>
arguments;<z>
public void onStartup(ServletContext servletContext) throws ServletException {<z>
;<z>
, "getServletName() must not return null or empty");<z>
= createApplicationContext();<z>
notNull(applicationContext, "createApplicationContext() must not return null");<z>
applicationContext);<z>
applicationContext);<z>
.applicationContext(applicationContext).build();<z>
new ServletHttpHandlerAdapter(httpHandler);<z>
servletContext.addServlet(servletName, servlet);<z>
if (registration == null) {<z>
("Failed to register servlet with name '" + servletName + "'. " +<z>
;<z>
;<z>
));<z>
;<z>
) {<z>
pos - this.pathElementStart];<z>
pathElementStart, pathElementText, 0,<z>
.pos - this.pathElementStart);<z>
;<z>
{<z>
) {<z>
;<z>
otherParam)) {<z>
return false;<z>
getContainingClass() &&<z>
typeIndexesPerLevel, otherParam.typeIndexesPerLevel) &&<z>
nestingLevel == otherParam.nestingLevel &&<z>
&&<z>
);<z>
protected final String resolvableToString() {<z>
(64);<z>
);<z>
));<z>
;<z>
result.toString();<z>
fieldType) {<z>
= getFormatter(annotation, fieldType);<z>
formatter == DateTimeFormatter.ISO_DATE) {<z>
)) {<z>
;<z>
if (formatter == DateTimeFormatter.ISO_TIME) {<z>
(fieldType)) {<z>
.ISO_LOCAL_TIME;<z>
) {<z>
if (isLocal(fieldType)) {<z>
DateTimeFormatter.ISO_LOCAL_DATE_TIME;<z>
(formatter);<z>
protected void checkDaoConfig() {<z>
jdbcTemplate == null) {<z>
("'dataSource' or 'jdbcTemplate' is required");<z>
subscribe(StompHeaders headers, StompFrameHandler handler) {<z>
);<z>
(handler, "StompFrameHandler must not be null");<z>
= headers.getId();<z>
(!StringUtils.hasText(subscriptionId)) {<z>
);<z>
.setId(subscriptionId);<z>
checkOrAddReceipt(headers);<z>
subscription = new DefaultSubscription(headers, handler);<z>
);<z>
accessor.addNativeHeaders(headers);<z>
;<z>
);<z>
;<z>
MockHttpServletRequestBuilder contentType(String contentType) {<z>
.notNull(contentType, "'contentType' must not be null");<z>
contentType = contentType;<z>
return this;<z>
extends Number> T parseNumber(<z>
, @Nullable NumberFormat numberFormat) {<z>
null) {<z>
);<z>
);<z>
DecimalFormat decimalFormat = null;<z>
resetBigDecimal = false;<z>
{<z>
DecimalFormat) numberFormat;<z>
isParseBigDecimal()) {<z>
decimalFormat.setParseBigDecimal(true);<z>
resetBigDecimal = true;<z>
(text));<z>
return convertNumberToTargetClass(number, targetClass);<z>
(ParseException ex) {<z>
;<z>
resetBigDecimal) {<z>
(false);<z>
(text, targetClass);<z>
() {<z>
;<z>
{<z>
return exceptionTranslator;<z>
(this) {<z>
exceptionTranslator = this.exceptionTranslator;<z>
== null) {<z>
getDataSource();<z>
shouldIgnoreXml) {<z>
= new SQLExceptionSubclassTranslator();<z>
null) {<z>
);<z>
exceptionTranslator = new SQLStateSQLExceptionTranslator();<z>
= exceptionTranslator;<z>
;<z>
getSourceMethodName() {<z>
) {<z>
resolve();<z>
getSourceMethodName();<z>
private void handleProcessingInstruction() throws SAXException {<z>
) != null) {<z>
));<z>
unitInfo) {<z>
);<z>
: files) {<z>
.trim();<z>
(StringUtils.hasText(value)) {<z>
(value);<z>
{<z>
new StringBuilder();<z>
stringBuilder.append('(');<z>
Type argumentType : argumentTypes) {<z>
stringBuilder);<z>
')');<z>
;<z>
;<z>
<WebSocketSession> doHandshakeInternal(WebSocketHandler wsHandler,<z>
,<z>
) {<z>
final ClientUpgradeRequest request = new ClientUpgradeRequest();<z>
request.setSubProtocols(protocols);<z>
extension : extensions) {<z>
;<z>
request.setHeaders(headers);<z>
);<z>
user);<z>
connectTask = () -> {<z>
wsSession);<z>
connect(adapter, uri, request);<z>
+ 2000, TimeUnit.MILLISECONDS);<z>
wsSession;<z>
taskExecutor != null) {<z>
return this.taskExecutor.submitListenable(connectTask);<z>
);<z>
);<z>
return task;<z>
> consumer){<z>
() -> {<z>
.class);<z>
(value);<z>
;<z>
private ConfigurableListableBeanFactory getBeanFactory() {<z>
;<z>
.state(beanFactory != null, "No BeanFactory available");<z>
return beanFactory;<z>
() {<z>
<>();<z>
ObjectError objectError : this.errors) {<z>
if (!(objectError instanceof FieldError)) {<z>
objectError);<z>
return Collections.unmodifiableList(result);<z>
{<z>
);<z>
put(scheduledFuture, listenableFuture);<z>
(scheduledFuture),<z>
scheduledFuture));<z>
<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,<z>
extends Resource> locations, ResourceResolverChain chain) {<z>
resolveResource(exchange, requestPath, locations)<z>
defer(() -><z>
, requestPath, locations, chain)));<z>
throws IOException {<z>
state(!isClosed(), "Cannot send a message when session is closed");<z>
(TextMessage.class, message, "SockJS supports text messages only");<z>
getPayload());<z>
void loadBeanDefinitions(<z>
{<z>
annotatedClasses = webMergedConfig.getClasses();<z>
()) {<z>
));<z>
).register(annotatedClasses);<z>
(OutputStream out) throws IOException {<z>
);<z>
()) {<z>
);<z>
if (it.hasNext()) {<z>
length);<z>
(bytes, 0, this.index);<z>
ConfigurableEnvironment getEnvironment() {<z>
{<z>
();<z>
.environment;<z>
(String beanName) throws NoSuchBeanDefinitionException {<z>
);<z>
{<z>
new NoSuchBeanDefinitionException(beanName);<z>
bd;<z>
setFoo(<z>
) {<z>
== null) {<z>
);<z>
;<z>
= value;<z>
onChanged();<z>
this;<z>
() {<z>
= new LinkedHashSet<>();<z>
this.partialMatches) {<z>
getMethods();<z>
RequestMethod.PATCH)) {<z>
;<z>
result;<z>
public void reset() {<z>
(NestedMatcher matcher : this.matchers) {<z>
);<z>
protected boolean write(DataBuffer dataBuffer) throws IOException {<z>
.flushOnNext) {<z>
.isTraceEnabled()) {<z>
trace(getLogPrefix() + "flushing");<z>
();<z>
ready = ServletServerHttpResponse.this.isWritePossible();<z>
readableByteCount();<z>
{<z>
= writeToOutputStream(dataBuffer);<z>
()) {<z>
);<z>
remaining) {<z>
.release(dataBuffer);<z>
return true;<z>
)) {<z>
", remaining: " + remaining);<z>
;<z>
<String, ?> values) {<z>
values != null) {<z>
(key, value) -> {<z>
value);<z>
) {<z>
());<z>
);<z>
;<z>
evaluationContext, Object value,<z>
List<TypeDescriptor> argumentTypes) {<z>
evaluationContext.getMethodResolvers();<z>
get(0) instanceof ReflectiveMethodResolver)) {<z>
;<z>
CachedMethodExecutor executorToCheck = this.cachedExecutor;<z>
)) {<z>
return executorToCheck.get();<z>
.cachedExecutor = null;<z>
;<z>
request,<z>
) {<z>
instanceof ServletRequestAttributes) {<z>
response);<z>
null;<z>
{<z>
;<z>
(methodName, "Method name must not be null");<z>
0;<z>
.getDeclaredMethods();<z>
declaredMethods) {<z>
.getName())) {<z>
count++;<z>
);<z>
Class<?> ifc : ifcs) {<z>
+= getMethodCountForName(ifc, methodName);<z>
!= null) {<z>
, methodName);<z>
count;<z>
{<z>
);<z>
) {<z>
"Template resource [" + path + "] not found");<z>
reader = (this.charset != null ?<z>
), this.charset) :<z>
));<z>
;<z>
private MessageBuilder(T payload, MessageHeaderAccessor accessor) {<z>
"Payload must not be null");<z>
.notNull(accessor, "MessageHeaderAccessor must not be null");<z>
.payload = payload;<z>
.providedMessage = null;<z>
headerAccessor = accessor;<z>
requestBuffer() {<z>
null &&<z>
isCancelled() &&<z>
&&<z>
, true)) {<z>
);<z>
expectedUri, Object... uriVars) {<z>
(expectedUri, "'uri' must not be null");<z>
.toUri();<z>
requestTo(uri);<z>
size) {<z>
array = new int[size];<z>
;<z>
array;<z>
,<z>
throws XPathExpressionException {<z>
);<z>
Collections.emptyMap());<z>
.newXPath();<z>
;<z>
.compile(expression);<z>
) {<z>
<?> resolved = resolve();<z>
== null) {<z>
return NONE;<z>
();<z>
null) {<z>
NONE;<z>
this.superType;<z>
(superType == null) {<z>
superType = forType(superclass, this);<z>
superType = superType;<z>
return superType;<z>
{<z>
NONE;<z>
{<z>
{<z>
;<z>
importMetadata) {<z>
.class.getName());<z>
.fromMap(map);<z>
if (this.enableMBeanExport == null) {<z>
new IllegalArgumentException(<z>
"@EnableMBeanExport is not present on importing class " + importMetadata.getClassName());<z>
public boolean hasProducesMismatch() {<z>
partialMatches) {<z>
()) {<z>
false;<z>
;<z>
CompositeRequestCondition getMatchingCondition(HttpServletRequest request) {<z>
)) {<z>
;<z>
[getLength()];<z>
i < getLength(); i++) {<z>
(request);<z>
== null) {<z>
null;<z>
CompositeRequestCondition(matchingConditions);<z>
void closeBeanFactory() {<z>
= this.beanFactory;<z>
) {<z>
null);<z>
this.beanFactory = null;<z>
handlerType) {<z>
.findMergedAnnotation(method, MessageMapping.class);<z>
!= null) {<z>
handlerType, MessageMapping.class);<z>
)) {<z>
value());<z>
null) {<z>
result);<z>
return result;<z>
findMergedAnnotation(method, SubscribeMapping.class);<z>
null) {<z>
.findMergedAnnotation(handlerType, MessageMapping.class);<z>
().length > 0)) {<z>
;<z>
if (typeAnn != null) {<z>
;<z>
;<z>
null;<z>
synchronizationManager,<z>
{<z>
{<z>
synchronizationManager.getSynchronizations());<z>
;<z>
public String toString() {<z>
;<z>
.proxyTargetClass).append("; ");<z>
optimize).append("; ");<z>
append("; ");<z>
).append("; ");<z>
frozen);<z>
toString();<z>
() {<z>
exceptOnInit) {<z>
RuntimeException("I am being init'd!");<z>
cf) {<z>
mv, cf);<z>
cf.unboxBooleanIfNecessary(mv);<z>
elseTarget = new Label();<z>
Label endOfIf = new Label();<z>
mv.visitJumpInsn(IFNE,elseTarget);<z>
.visitInsn(ICONST_1);<z>
;<z>
mv.visitLabel(elseTarget);<z>
mv.visitInsn(ICONST_0);<z>
.visitLabel(endOfIf);<z>
exitTypeDescriptor);<z>
) {<z>
expectations.isEmpty()) {<z>
return 0;<z>
!this.requestFailures.isEmpty()) {<z>
throw new AssertionError("Some requests did not execute successfully.\n" +<z>
.stream()<z>
.getValue())<z>
"")));<z>
= 0;<z>
(RequestExpectation expectation : this.expectations) {<z>
(!expectation.isSatisfied()) {<z>
;<z>
count;<z>
(<z>
ConstructorArgumentValues resolvedValues,<z>
String[] paramNames, Executable executable,<z>
autowiring, boolean fallback) throws UnsatisfiedDependencyException {<z>
= this.beanFactory.getCustomTypeConverter();<z>
);<z>
args = new ArgumentsHolder(paramTypes.length);<z>
HashSet<>(paramTypes.length);<z>
<>(4);<z>
< paramTypes.length; paramIndex++) {<z>
];<z>
: "");<z>
valueHolder = null;<z>
(resolvedValues != null) {<z>
(paramIndex, paramType, paramName, usedValueHolders);<z>
length == resolvedValues.getArgumentCount())) {<z>
getGenericArgumentValue(null, null, usedValueHolders);<z>
valueHolder != null) {<z>
);<z>
getValue();<z>
Object convertedValue;<z>
valueHolder.isConverted()) {<z>
);<z>
[paramIndex] = convertedValue;<z>
;<z>
, paramType, methodParam);<z>
{<z>
UnsatisfiedDependencyException(<z>
new InjectionPoint(methodParam),<z>
valueHolder.getValue()) +<z>
+ "]: " + ex.getMessage());<z>
sourceHolder = valueHolder.getSource();<z>
(sourceHolder instanceof ConstructorArgumentValues.ValueHolder) {<z>
getValue();<z>
.resolveNecessary = true;<z>
;<z>
;<z>
args.rawArguments[paramIndex] = originalValue;<z>
forExecutable(executable, paramIndex);<z>
!autowiring) {<z>
new UnsatisfiedDependencyException(<z>
methodParam),<z>
paramType.getName() +<z>
;<z>
Object autowiredArgument = resolveAutowiredArgument(<z>
, fallback);<z>
;<z>
args.arguments[paramIndex] = autowiredArgument;<z>
[paramIndex] = autowiredArgumentMarker;<z>
args.resolveNecessary = true;<z>
{<z>
new UnsatisfiedDependencyException(<z>
, new InjectionPoint(methodParam), ex);<z>
autowiredBeanNames) {<z>
.beanFactory.registerDependentBean(autowiredBeanName, beanName);<z>
if (logger.isDebugEnabled()) {<z>
.debug("Autowiring by type from bean name '" + beanName +<z>
Constructor ? "constructor" : "factory method") +<z>
autowiredBeanName + "'");<z>
return args;<z>
{<z>
bootstrapMethods != null) {<z>
Constants.BOOTSTRAP_METHODS))<z>
2)<z>
.putShort(bootstrapMethodCount)<z>
.length);<z>
conversionHint) {<z>
converter : getConverters()) {<z>
?<z>
.fromMessage(message, targetClass, conversionHint) :<z>
converter.fromMessage(message, targetClass));<z>
(result != null) {<z>
return result;<z>
;<z>
throws Throwable {<z>
;<z>
;<z>
null;<z>
advised.getTargetSource();<z>
.exposeProxy) {<z>
AopContext.setCurrentProxy(proxy);<z>
= true;<z>
getTarget();<z>
target.getClass() : null);<z>
method, targetClass);<z>
retVal;<z>
(method)) {<z>
adaptArgumentsIfNecessary(method, args);<z>
;<z>
(CodeGenerationException ex) {<z>
CglibMethodInvocation.logFastClassGenerationFailure(method);<z>
.invokeJoinpointUsingReflection(target, method, argsToUse);<z>
;<z>
(proxy, target, method, retVal);<z>
retVal;<z>
.isStatic()) {<z>
.releaseTarget(target);<z>
if (setProxyContext) {<z>
;<z>
String convertJndiName(String jndiName) {<z>
-1) {<z>
CONTAINER_PREFIX + jndiName;<z>
;<z>
(<z>
<A> annotationType) {<z>
if (annotationType == null) {<z>
;<z>
.matches(annotationType) ||<z>
annotatedElement)) {<z>
;<z>
.INHERITED_ANNOTATIONS, RepeatableContainers.none())<z>
).withNonMergedAttributes()<z>
).orElse(null);<z>
{<z>
ctor.getAnnotation(ConstructorProperties.class);<z>
(ctor));<z>
, () -> "Cannot resolve parameter names for constructor " + ctor);<z>
,<z>
);<z>
return paramNames;<z>
@Nullable ClassLoader classLoader,<z>
throws ClassNotFoundException {<z>
filterType = element.getAttribute(FILTER_TYPE_ATTRIBUTE);<z>
;<z>
(expression);<z>
filterType)) {<z>
));<z>
(filterType)) {<z>
.forName(expression, classLoader));<z>
equals(filterType)) {<z>
expression, classLoader);<z>
)) {<z>
.compile(expression));<z>
(filterType)) {<z>
, classLoader);<z>
)) {<z>
(<z>
.getName() + "]: " + expression);<z>
TypeFilter) BeanUtils.instantiateClass(filterClass);<z>
IllegalArgumentException("Unsupported filter type: " + filterType);<z>
() throws IllegalStateException {<z>
;<z>
) {<z>
{<z>
.getFacesRequestAttributes();<z>
attributes == null) {<z>
new IllegalStateException("No thread-bound request found: " +<z>
);<z>
;<z>
(String prefix, String suffix) {<z>
();<z>
prefix);<z>
suffix);<z>
(<z>
request, @Nullable InetSocketAddress remoteAddress) {<z>
remoteAddress != null ?<z>
getScheme()) ? 443 : 80);<z>
().getFirst("Forwarded");<z>
(forwardedHeader)) {<z>
)[0];<z>
matcher(forwardedToUse);<z>
matcher.find()) {<z>
;<z>
= value;<z>
lastIndexOf(':');<z>
']');<z>
portSeparatorIdx > squareBracketIdx) {<z>
(':') != portSeparatorIdx) {<z>
throw new IllegalArgumentException("Invalid IPv4 address: " + value);<z>
);<z>
10);<z>
ex) {<z>
throw new IllegalArgumentException(<z>
value);<z>
InetSocketAddress.createUnresolved(host, port);<z>
getHeaders().getFirst("X-Forwarded-For");<z>
hasText(forHeader)) {<z>
)[0];<z>
.createUnresolved(host, port);<z>
;<z>
MultiValueMap<String, HttpCookie> getCookies() {<z>
get())) {<z>
unmodifiableMultiValueMap(this.cookies);<z>
cookies;<z>
(MethodParameter parameter) {<z>
> paramType = parameter.getParameterType();<z>
WebRequest.class.isAssignableFrom(paramType) ||<z>
paramType) ||<z>
class.isAssignableFrom(paramType) ||<z>
HttpSession.class.isAssignableFrom(paramType) ||<z>
.isAssignableFrom(paramType)) ||<z>
()) ||<z>
isAssignableFrom(paramType) ||<z>
.class.isAssignableFrom(paramType) ||<z>
.class == paramType ||<z>
== paramType ||<z>
||<z>
class == paramType);<z>
putByte(final int byteValue) {<z>
int currentLength = length;<z>
data.length) {<z>
1);<z>
byte) byteValue;<z>
length = currentLength;<z>
return this;<z>
(Message<byte[]> message) {<z>
StompHeaderAccessor.class);<z>
!= null, "No StompHeaderAccessor");<z>
.sessionId);<z>
= this.connectHeaders.getUser();<z>
) {<z>
;<z>
);<z>
)) {<z>
.isDebugEnabled()) {<z>
));<z>
(accessor);<z>
command)) {<z>
.getPayload()));<z>
logger.isTraceEnabled()) {<z>
;<z>
message);<z>
username, String password) {<z>
setDriver(driver);<z>
);<z>
;<z>
;<z>
Object extractData(ResultSet rs) throws SQLException {<z>
(rs.next()) {<z>
);<z>
return null;<z>
Publisher<? extends DataBuffer> body) {<z>
return doCommit(() -> {<z>
(body instanceof Mono) {<z>
::toByteBuf);<z>
then();<z>
;<z>
();<z>
});<z>
IllegalArgumentException {<z>
(managedBean)) {<z>
throw new IllegalArgumentException(<z>
;<z>
[] convertValidationHints(@Nullable Object hints) {<z>
null) {<z>
;<z>
);<z>
TemplateInfo parse(String uriTemplate) {<z>
level = 0;<z>
ArrayList<>();<z>
StringBuilder();<z>
StringBuilder();<z>
) {<z>
.charAt(i);<z>
'{') {<z>
++;<z>
level == 1) {<z>
builder));<z>
);<z>
{<z>
--;<z>
0) {<z>
= builder.toString();<z>
= variable.indexOf(':');<z>
(idx == -1) {<z>
.append("([^/]*)");<z>
variableNames.add(variable);<z>
.length()) {<z>
(<z>
variable + "\"");<z>
(idx + 1);<z>
;<z>
);<z>
')');<z>
(0, idx));<z>
= new StringBuilder();<z>
(c);<z>
length() > 0) {<z>
(quote(builder));<z>
));<z>
<? extends Annotation> annotationType) {<z>
ArrayList<>();<z>
: this.beanDefinitionNames) {<z>
this.beanDefinitionMap.get(beanName);<z>
annotationType) != null) {<z>
);<z>
String beanName : this.manualSingletonNames) {<z>
null) {<z>
(beanName);<z>
;<z>
> registerHandlerMapping(<z>
source) {<z>
.class);<z>
"order");<z>
(orderAttribute);<z>
"order", order);<z>
("path-helper");<z>
(StringUtils.hasText(pathHelper)) {<z>
("urlPathHelper", new RuntimeBeanReference(pathHelper));<z>
new ManagedMap<>();<z>
.setSource(source);<z>
.add("urlMap", urlMap);<z>
;<z>
;<z>
, int rowNum) throws SQLException {<z>
();<z>
();<z>
> mapOfColumnValues = createColumnMap(columnCount);<z>
i++) {<z>
, i);<z>
, i));<z>
mapOfColumnValues;<z>
) {<z>
<>();<z>
.propertySources) {<z>
instanceof EnumerablePropertySource)) {<z>
(<z>
;<z>
getPropertyNames()));<z>
names);<z>
message) {<z>
.getGenericParameterType();<z>
).as(Message.class);<z>
toClass();<z>
public MonoFutureCallbackAdapter(MonoSink<ClientHttpResponse> sink,<z>
context) {<z>
.sink = sink;<z>
= dataBufferFactory;<z>
this.context = context;<z>
Field field, @Nullable Object target) {<z>
get(target);<z>
(IllegalAccessException ex) {<z>
handleReflectionException(ex);<z>
);<z>
String importingClass) {<z>
()) {<z>
;) {<z>
)) {<z>
.remove();<z>
public String[] getPathPatterns() {<z>
isEmpty(this.includePatterns) ?<z>
String[]::new) :<z>
null);<z>
, Object payload, @Nullable MessagePostProcessor postProcessor)<z>
throws MessagingException {<z>
(destinationName, payload, null, postProcessor);<z>
, Object[] arguments) throws JMSException {<z>
();<z>
(getDelegate());<z>
setTargetMethod(methodName);<z>
setArguments(arguments);<z>
methodInvoker.prepare();<z>
;<z>
ex) {<z>
= ex.getTargetException();<z>
{<z>
(JMSException) targetEx;<z>
new ListenerExecutionFailedException(<z>
"Listener method '" + methodName + "' threw exception", targetEx);<z>
Throwable ex) {<z>
+<z>
.nullSafeToString(arguments), ex);<z>
(Session session) {<z>
sessionToUse = session;<z>
SessionProxy) {<z>
);<z>
return sessionToUse;<z>
Element ele, String beanName,<z>
) {<z>
if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {<z>
("Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration", ele);<z>
)) {<z>
ele.getAttribute(SCOPE_ATTRIBUTE));<z>
containingBean != null) {<z>
;<z>
ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {<z>
getAttribute(ABSTRACT_ATTRIBUTE)));<z>
;<z>
isDefaultValue(lazyInit)) {<z>
= this.defaults.getLazyInit();<z>
.equals(lazyInit));<z>
getAttribute(AUTOWIRE_ATTRIBUTE);<z>
getAutowireMode(autowire));<z>
(DEPENDS_ON_ATTRIBUTE)) {<z>
);<z>
MULTI_VALUE_ATTRIBUTE_DELIMITERS));<z>
(AUTOWIRE_CANDIDATE_ATTRIBUTE);<z>
)) {<z>
candidatePattern = this.defaults.getAutowireCandidates();<z>
!= null) {<z>
= StringUtils.commaDelimitedListToStringArray(candidatePattern);<z>
.simpleMatch(patterns, beanName));<z>
autowireCandidate));<z>
) {<z>
PRIMARY_ATTRIBUTE)));<z>
(ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {<z>
);<z>
.setInitMethodName(initMethodName);<z>
.getInitMethod() != null) {<z>
));<z>
false);<z>
) {<z>
.getAttribute(DESTROY_METHOD_ATTRIBUTE);<z>
(destroyMethodName);<z>
) {<z>
;<z>
(false);<z>
)) {<z>
FACTORY_METHOD_ATTRIBUTE));<z>
(FACTORY_BEAN_ATTRIBUTE)) {<z>
FACTORY_BEAN_ATTRIBUTE));<z>
return bd;<z>
public String procedureNameToUse(@Nullable String procedureName) {<z>
{<z>
null;<z>
else if (isStoresUpperCaseIdentifiers()) {<z>
);<z>
()) {<z>
.toLowerCase();<z>
procedureName;<z>
(Class<?> clazz) {<z>
{<z>
;<z>
CacheOperationSource cas = getCacheOperationSource();<z>
null || cas.isCandidateClass(clazz));<z>
() {<z>
) {<z>
("'targetConnectionFactory' is required");<z>
{<z>
) {<z>
IllegalStateException("Cannot activate transaction synchronization - already active");<z>
new LinkedHashSet<>());<z>
(AdvisedSupport advised, boolean decoratingProxy) {<z>
] specifiedInterfaces = advised.getProxiedInterfaces();<z>
(specifiedInterfaces.length == 0) {<z>
advised.getTargetClass();<z>
null) {<z>
isInterface()) {<z>
);<z>
)) {<z>
setInterfaces(targetClass.getInterfaces());<z>
specifiedInterfaces = advised.getProxiedInterfaces();<z>
specifiedInterfaces.length + 3);<z>
(Class<?> ifc : specifiedInterfaces) {<z>
{<z>
ifc);<z>
)) {<z>
;<z>
) {<z>
.add(Advised.class);<z>
.class)) {<z>
DecoratingProxy.class);<z>
;<z>
namedParameterCount, String parameter) {<z>
(!namedParameters.contains(parameter)) {<z>
add(parameter);<z>
namedParameterCount++;<z>
;<z>
(Message<?> message) {<z>
running) {<z>
(logger.isTraceEnabled()) {<z>
;<z>
message);<z>
{<z>
violation.getPropertyPath();<z>
= new StringBuilder();<z>
first = true;<z>
: path) {<z>
)) {<z>
);<z>
.getIndex();<z>
if (index == null) {<z>
.getKey();<z>
) {<z>
(index);<z>
;<z>
.getName();<z>
.startsWith("<")) {<z>
) {<z>
);<z>
first = false;<z>
name);<z>
;<z>
{<z>
= initWebAppContext();<z>
ServletContext servletContext = wac.getServletContext();<z>
;<z>
: this.configurers) {<z>
.beforeMockMvcCreated(this, wac);<z>
null) {<z>
null) {<z>
= MockMvcRequestBuilders.get("/");<z>
(this.defaultRequestBuilder instanceof ConfigurableSmartRequestBuilder) {<z>
defaultRequestBuilder).with(processor);<z>
toArray(new Filter[0]);<z>
wac, this.defaultRequestBuilder,<z>
, this.globalResultHandlers,<z>
.dispatcherServletCustomizers);<z>
void registerNamedDispatcher(String name, RequestDispatcher requestDispatcher) {<z>
(name, "RequestDispatcher name must not be null");<z>
"RequestDispatcher must not be null");<z>
(name, requestDispatcher);<z>
] getInterfaces() {<z>
= header + 6;<z>
= readUnsignedShort(currentOffset);<z>
interfacesCount];<z>
0) {<z>
[] charBuffer = new char[maxStringLength];<z>
< interfacesCount; ++i) {<z>
currentOffset += 2;<z>
readClass(currentOffset, charBuffer);<z>
;<z>
(<z>
final String name,<z>
final String descriptor,<z>
,<z>
final Object... bootstrapMethodArguments) {<z>
.length;<z>
invokeDynamicSymbol =<z>
addConstantInvokeDynamic(<z>
);<z>
.INVOKEDYNAMIC, invokeDynamicSymbol.index);<z>
);<z>
null) {<z>
== COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {<z>
0, invokeDynamicSymbol, symbolTable);<z>
} else {<z>
= invokeDynamicSymbol.getArgumentsAndReturnSizes();<z>
;<z>
+ stackSizeDelta;<z>
(size > maxRelativeStackSize) {<z>
;<z>
= size;<z>
(ConversionService conversionService, TypeDescriptor targetDescriptor) {<z>
notNull(conversionService, "ConversionService must not be null");<z>
"TypeDescriptor must not be null");<z>
conversionService = conversionService;<z>
targetDescriptor = targetDescriptor;<z>
String.class));<z>
IOException {<z>
);<z>
) {<z>
FileNotFoundException(<z>
+ " cannot be resolved to URL because it does not exist");<z>
return url;<z>
charBuffer) {<z>
constantPoolEntryIndex];<z>
- 1]) {<z>
Symbol.CONSTANT_INTEGER_TAG:<z>
);<z>
CONSTANT_FLOAT_TAG:<z>
cpInfoOffset));<z>
CONSTANT_LONG_TAG:<z>
return readLong(cpInfoOffset);<z>
.CONSTANT_DOUBLE_TAG:<z>
Double.longBitsToDouble(readLong(cpInfoOffset));<z>
Symbol.CONSTANT_CLASS_TAG:<z>
(cpInfoOffset, charBuffer));<z>
Symbol.CONSTANT_STRING_TAG:<z>
;<z>
Symbol.CONSTANT_METHOD_TYPE_TAG:<z>
));<z>
CONSTANT_METHOD_HANDLE_TAG:<z>
cpInfoOffset);<z>
readUnsignedShort(cpInfoOffset + 1)];<z>
];<z>
charBuffer);<z>
String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);<z>
charBuffer);<z>
boolean isInterface =<z>
[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;<z>
);<z>
CONSTANT_DYNAMIC_TAG:<z>
return readConstantDynamic(constantPoolEntryIndex, charBuffer);<z>
);<z>
{<z>
(WebMvcConfigurer delegate : this.delegates) {<z>
.configurePathMatch(configurer);<z>
String value) {<z>
(value.isEmpty()) {<z>
return value;<z>
this.ignoreUnresolvableNestedPlaceholders ?<z>
));<z>
>> readMono(ResolvableType elementType,<z>
, Object> hints) {<z>
.getContentType();<z>
charset = getMediaTypeCharset(contentType);<z>
, this.maxInMemorySize)<z>
map(buffer -> {<z>
));<z>
body = charBuffer.toString();<z>
.release(buffer);<z>
body);<z>
formData, hints);<z>
formData;<z>
);<z>
MapBenchmarkState state, Blackhole bh) {<z>
.size());<z>
Integer.valueOf(v)));<z>
.consume(target);<z>
Boolean value) {<z>
(value == null) {<z>
.TYPE_CONVERSION_ERROR, "null", "boolean");<z>
() {<z>
();<z>
null) {<z>
customConverter;<z>
typeConverter = new SimpleTypeConverter();<z>
));<z>
;<z>
return typeConverter;<z>
Collection> collectionType, boolean nullAsEmptyCollection) {<z>
notNull(collectionType, "Collection type is required");<z>
collectionType)) {<z>
throw new IllegalArgumentException(<z>
);<z>
collectionType;<z>
nullAsEmptyCollection = nullAsEmptyCollection;<z>
annotation) {<z>
= resolveEmbeddedValue(annotation.pattern());<z>
{<z>
pattern);<z>
annotation.style();<z>
if (style == Style.NUMBER) {<z>
;<z>
.PERCENT) {<z>
new NumberDecoratingFormatter(new PercentStyleFormatter());<z>
;<z>
public void initialize(Object proxy) throws DataAccessException {<z>
(proxy);<z>
{<z>
);<z>
charset) {<z>
input, "`input` is required");<z>
charset, "`charset` is required");<z>
);<z>
);<z>
= input.getBytes(charset);<z>
int len = source.length;<z>
);<z>
charset.name());<z>
sb.append("''");<z>
{<z>
(b)) {<z>
.append((char) b);<z>
;<z>
0xF, 16));<z>
forDigit(b & 0xF, 16));<z>
append(hex1);<z>
(hex2);<z>
sb.toString();<z>
{<z>
<>(2);<z>
));<z>
, this);<z>
;<z>
private Type getGenericType(MethodParameter returnType) {<z>
isAssignableFrom(returnType.getParameterType())) {<z>
.getGeneric().getType();<z>
return returnType.getGenericParameterType();<z>
ParamsRequestCondition combine(ParamsRequestCondition other) {<z>
isEmpty()) {<z>
this;<z>
{<z>
this;<z>
()) {<z>
other;<z>
;<z>
(other.expressions);<z>
;<z>
) {<z>
RequestContext context =<z>
create()<z>
(endpointPath))<z>
.userPrincipal(request.getUserPrincipal())<z>
isSecure())<z>
.getRemoteAddr())<z>
build();<z>
, value));<z>
return context;<z>
b, ClassLoader loader,<z>
throws Exception {<z>
);<z>
statusCode, String statusText,<z>
body, @Nullable Charset charset) {<z>
statusText, headers, body, charset);<z>
validate() throws BeanDefinitionValidationException {<z>
) != null) {<z>
BeanDefinitionValidationException(<z>
"the factory method must create the concrete bean instance.");<z>
()) {<z>
prepareMethodOverrides();<z>
getFirstAttributeOffset() {<z>
* 2;<z>
);<z>
currentOffset += 2;<z>
-- > 0) {<z>
+ 6);<z>
8;<z>
> 0) {<z>
+ readInt(currentOffset + 2);<z>
= readUnsignedShort(currentOffset);<z>
+= 2;<z>
methodsCount-- > 0) {<z>
int attributesCount = readUnsignedShort(currentOffset + 6);<z>
8;<z>
0) {<z>
2);<z>
currentOffset + 2;<z>
) {<z>
this.compiledAst = null;<z>
0);<z>
this.failedAttempts.set(0);<z>
<T> requiredType) throws BeansException {<z>
) {<z>
return doGetSingleton(name, requiredType);<z>
;<z>
(NameNotFoundException ex) {<z>
new NoSuchBeanDefinitionException(name, "not found in JNDI environment");<z>
ex) {<z>
(), ex.getActualType());<z>
catch (NamingException ex) {<z>
, ex);<z>
<T> type) {<z>
attributeIndex = getAttributeIndex(attributeName, false);<z>
{<z>
();<z>
attributeIndex);<z>
;<z>
@Nullable MediaType contentType) {<z>
(contentType != null) {<z>
();<z>
{<z>
;<z>
contentType.isCompatibleWith(MediaType.APPLICATION_JSON) ||<z>
contentType.isCompatibleWith(APPLICATION_PLUS_JSON)) {<z>
UTF_8;<z>
Charset charset = getDefaultCharset();<z>
(charset != null, "No default charset");<z>
return charset;<z>
) {<z>
mi = ExposeInvocationInterceptor.currentInvocation();<z>
) {<z>
new IllegalStateException("MethodInvocation is not a Spring ProxyMethodInvocation: " + mi);<z>
pmi.getUserAttribute(JOIN_POINT_KEY);<z>
jp == null) {<z>
(pmi);<z>
.setUserAttribute(JOIN_POINT_KEY, jp);<z>
;<z>
request) {<z>
filterModel(model);<z>
JsonView.class.getName());<z>
());<z>
null) {<z>
MappingJacksonValue container = new MappingJacksonValue(value);<z>
!= null) {<z>
);<z>
{<z>
setFilters(filters);<z>
container;<z>
;<z>
MethodWriter methodWriter) {<z>
= inputLocals;<z>
numLocal = 0;<z>
= 0;<z>
= 0;<z>
< localTypes.length) {<z>
;<z>
|| localType == DOUBLE) ? 2 : 1;<z>
TOP) {<z>
numTrailingTop++;<z>
} else {<z>
numLocal += numTrailingTop + 1;<z>
numTrailingTop = 0;<z>
stackTypes = inputStack;<z>
;<z>
;<z>
< stackTypes.length) {<z>
int stackType = stackTypes[i];<z>
== DOUBLE) ? 2 : 1;<z>
++;<z>
, numStack);<z>
0;<z>
> 0) {<z>
i];<z>
;<z>
methodWriter.visitAbstractType(frameIndex++, localType);<z>
;<z>
(numStack-- > 0) {<z>
= stackTypes[i];<z>
2 : 1;<z>
visitAbstractType(frameIndex++, stackType);<z>
.visitFrameEnd();<z>
remove(K key) {<z>
lock.writeLock().lock();<z>
(key) != null);<z>
remove(key);<z>
= this.cache.size();<z>
wasPresent;<z>
writeLock().unlock();<z>
void extendBeanDefinition(Element element, ParserContext parserContext) {<z>
=<z>
().getBeanDefinition(AopConfigUtils.AUTO_PROXY_CREATOR_BEAN_NAME);<z>
) {<z>
beanDef);<z>
) {<z>
)) {<z>
.removeAttribute(UrlPathHelper.PATH_ATTRIBUTE);<z>
(request);<z>
);<z>
;<z>
).resolveAndCacheLookupPath(request);<z>
method) throws NoSuchMethodException {<z>
(serviceLocatorInterface != null, "No service locator interface specified");<z>
] paramTypes = method.getParameterTypes();<z>
, paramTypes);<z>
?> serviceLocatorReturnType = interfaceMethod.getReturnType();<z>
) {<z>
UnsupportedOperationException(<z>
;<z>
return serviceLocatorReturnType;<z>
>> T rollForward(T temporal) {<z>
;<z>
range(this.field);<z>
.getMaximum() - current + 1;<z>
);<z>
@Nullable HttpHeaders headers) {<z>
(headers != null) {<z>
headers);<z>
this;<z>
> resolveViewName(String viewName, Locale locale) {<z>
)) {<z>
.empty();<z>
urlBasedView;<z>
)) {<z>
;<z>
.apply(redirectUrl);<z>
= createView(viewName);<z>
, urlBasedView);<z>
) : Mono.empty());<z>
(Exception ex) {<z>
;<z>
) {<z>
?<z>
;<z>
;<z>
public boolean equals(Object other) {<z>
{<z>
;<z>
instanceof ItemPet)) {<z>
false;<z>
other;<z>
);<z>
public SimpMessagingTemplate brokerMessagingTemplate(<z>
, AbstractSubscribableChannel clientInboundChannel,<z>
brokerMessageConverter) {<z>
SimpMessagingTemplate template = new SimpMessagingTemplate(brokerChannel);<z>
registry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);<z>
.getUserDestinationPrefix();<z>
prefix != null) {<z>
template.setUserDestinationPrefix(prefix);<z>
brokerMessageConverter);<z>
template;<z>
) throws JmsException {<z>
Destination defaultDestination = getDefaultDestination();<z>
!= null) {<z>
receive(defaultDestination);<z>
));<z>
) {<z>
.asyncDispatchLatch != null,<z>
"The asyncDispatch CountDownLatch was not set by the TestDispatcherServlet.");<z>
);<z>
) {<z>
return false;<z>
(T handler) {<z>
(this.beanFactory != null) {<z>
;<z>
int statusCode, String statusText,<z>
byte[] responseBody, @Nullable Charset charset,<z>
@Nullable HttpRequest request) {<z>
message);<z>
statusCode;<z>
statusText;<z>
: HttpHeaders.EMPTY);<z>
? responseBody : new byte[0]);<z>
= charset;<z>
;<z>
> insert(ClientHttpRequest outputMessage, Context context) {<z>
> messageWriter =<z>
.APPLICATION_FORM_URLENCODED);<z>
), FORM_DATA_TYPE,<z>
.APPLICATION_FORM_URLENCODED,<z>
hints());<z>
static UriComponentsBuilder fromController(@Nullable UriComponentsBuilder builder,<z>
{<z>
);<z>
controllerType);<z>
;<z>
= getClassMapping(controllerType);<z>
);<z>
;<z>
String name) throws BeansException {<z>
instanceof ProtectedLifecycleBean) {<z>
) bean).postProcessBeforeInit();<z>
bean;<z>
handlerMethod) {<z>
.handlerMethod = handlerMethod;<z>
MethodParameter parameter : handlerMethod.getMethodParameters()) {<z>
hasParameterAnnotation(ModelAttribute.class)) {<z>
);<z>
public static Msg parseFrom(<z>
com.google.protobuf.CodedInputStream input,<z>
protobuf.ExtensionRegistryLite extensionRegistry)<z>
java.io.IOException {<z>
;<z>
<String, Object> model,<z>
throws Exception {<z>
viewResolvers != null) {<z>
viewResolver : this.viewResolvers) {<z>
, locale);<z>
!= null) {<z>
;<z>
;<z>
(final int api, final ModuleVisitor moduleVisitor) {<z>
api != Opcodes.ASM9<z>
api != Opcodes.ASM8<z>
&& api != Opcodes.ASM7<z>
.ASM6<z>
!= Opcodes.ASM5<z>
ASM4<z>
&& api != Opcodes.ASM10_EXPERIMENTAL) {<z>
("Unsupported api " + api);<z>
.api = api;<z>
= moduleVisitor;<z>
Nullable MediaType mediaType) {<z>
== null) {<z>
true;<z>
(MediaType supportedMediaType : getSupportedMediaTypes()) {<z>
(supportedMediaType.includes(mediaType)) {<z>
;<z>
return false;<z>
{<z>
);<z>
(20);<z>
visited);<z>
type.isArray();<z>
i = 0;<z>
hierarchy.size()) {<z>
.get(i);<z>
);<z>
;<z>
{<z>
hierarchy, visited);<z>
(candidate, array, hierarchy, visited);<z>
++;<z>
)) {<z>
visited);<z>
.class, false, hierarchy, visited);<z>
array, hierarchy, visited);<z>
visited);<z>
, false, hierarchy, visited);<z>
hierarchy;<z>
parameterContext) {<z>
).getType())) {<z>
() instanceof Method,<z>
);<z>
;<z>
return false;<z>
void clearCache() {<z>
logger.debug("Clearing entire resource bundle cache");<z>
this.cachedProperties.clear();<z>
this.cachedMergedProperties.clear();<z>
public Set<MediaType> getProducibleMediaTypes() {<z>
new LinkedHashSet<>();<z>
for (ProduceMediaTypeExpression expression : this.expressions) {<z>
if (!expression.isNegated()) {<z>
add(expression.getMediaType());<z>
;<z>
private static Object adaptValue(<z>
Object value, boolean classValuesAsString) {<z>
if (classValuesAsString) {<z>
instanceof Class) {<z>
);<z>
{<z>
;<z>
names = new String[classes.length];<z>
.length; i++) {<z>
.getName();<z>
return names;<z>
Annotation annotation) {<z>
.synthesize();<z>
{<z>
newInstance(<z>
, annotations.length);<z>
length; i++) {<z>
);<z>
return synthesized;<z>
return value;<z>
synchronizationManager,<z>
status, int completionStatus) {<z>
()) {<z>
synchronizations = synchronizationManager.getSynchronizations();<z>
);<z>
() || status.isNewTransaction()) {<z>
(synchronizationManager, synchronizations, completionStatus);<z>
) {<z>
registerAfterCompletionWithExistingTransaction(<z>
(), synchronizations);<z>
();<z>
private static void invokeBeanDefinitionRegistryPostProcessors(<z>
postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup) {<z>
postProcessors) {<z>
)<z>
tag("postProcessor", postProcessor::toString);<z>
(registry);<z>
.end();<z>
ResolvableType elementType,<z>
, Object> hints) {<z>
elementType, mimeType, hints));<z>
, Principal user) {<z>
(userName, "User name must not be null");<z>
= userName;<z>
this.user = user;<z>
(IntroductionAdvisor advisor) {<z>
advisor.validateInterfaces();<z>
.getInterfaces();<z>
ifc : ifcs) {<z>
addInterface(ifc);<z>
> matcher) {<z>
return result -> {<z>
name);<z>
, matcher);<z>
protected void configureClientInboundChannel(ChannelRegistration registration) {<z>
.configurers) {<z>
.configureClientInboundChannel(registration);<z>
{<z>
()) {<z>
(new TransactionSynchronization() {<z>
() {<z>
clear();<z>
);<z>
clear();<z>
) {<z>
"->", "[", "]");<z>
for (ConfigurationClass configurationClass : this) {<z>
configurationClass.getSimpleName());<z>
;<z>
Void> setComplete() {<z>
(() -> {<z>
HttpRequest.BodyPublishers.noBody());<z>
Mono.empty();<z>
);<z>
>> validateValue(<z>
<?>... groups) {<z>
!= null, "No target Validator set");<z>
, propertyName, value, groups);<z>
MutablePropertyValues mpvs) {<z>
getRequiredFields();<z>
.isEmpty(requiredFields)) {<z>
new HashMap<>();<z>
;<z>
pvs) {<z>
);<z>
pv);<z>
String field : requiredFields) {<z>
;<z>
pv.getValue() == null);<z>
!empty) {<z>
() instanceof String) {<z>
getValue());<z>
getValue() instanceof String[]) {<z>
String[]) pv.getValue();<z>
(values[0]));<z>
(empty) {<z>
getInternalBindingResult());<z>
pv != null) {<z>
pv);<z>
;<z>
) {<z>
!= null, "No CallMetaDataProvider available");<z>
;<z>
parameterCount = 0;<z>
String catalogNameToUse;<z>
;<z>
(this.metaDataProvider.isSupportsSchemasInProcedureCalls() &&<z>
)) {<z>
metaDataProvider.catalogNameToUse(getCatalogName());<z>
getSchemaName());<z>
;<z>
metaDataProvider.schemaNameToUse(getSchemaName());<z>
() || isReturnValueRequired()) {<z>
("{? = call ");<z>
1;<z>
("{call ");<z>
) {<z>
catalogNameToUse).append('.');<z>
hasLength(schemaNameToUse)) {<z>
append('.');<z>
)));<z>
.append('(');<z>
(SqlParameter parameter : this.callParameters) {<z>
if (!parameter.isResultsParameter()) {<z>
if (parameterCount > 0) {<z>
callString.append(", ");<z>
>= 0) {<z>
append(createParameterBinding(parameter));<z>
;<z>
callString.append(")}");<z>
toString();<z>
> propertyType,<z>
throws IntrospectionException {<z>
null;<z>
(indexedReadMethod != null) {<z>
;<z>
.length != 1) {<z>
("Bad indexed read method arg count: " + indexedReadMethod);<z>
!= Integer.TYPE) {<z>
;<z>
;<z>
if (indexedPropertyType == Void.TYPE) {<z>
indexedReadMethod);<z>
if (indexedWriteMethod != null) {<z>
();<z>
2) {<z>
new IntrospectionException("Bad indexed write method arg count: " + indexedWriteMethod);<z>
.TYPE) {<z>
indexedWriteMethod);<z>
if (indexedPropertyType != null) {<z>
1])) {<z>
;<z>
isAssignableFrom(indexedPropertyType)) {<z>
throw new IntrospectionException("Type mismatch between indexed read and write methods: " +<z>
);<z>
params[1];<z>
null && (!propertyType.isArray() ||<z>
.getComponentType() != indexedPropertyType)) {<z>
new IntrospectionException("Type mismatch between indexed and non-indexed methods: " +<z>
+ " - " + indexedWriteMethod);<z>
indexedPropertyType;<z>
boolean isReplyPubSubDomain() {<z>
replyPubSubDomain != null) {<z>
this.replyPubSubDomain;<z>
();<z>
(@Nullable Object returnValue, MethodParameter returnType,<z>
) throws Exception {<z>
if (returnValue == null) {<z>
;<z>
?> result;<z>
returnValue instanceof DeferredResult) {<z>
(DeferredResult<?>) returnValue;<z>
{<z>
((ListenableFuture<?>) returnValue);<z>
(returnValue instanceof CompletionStage) {<z>
;<z>
new IllegalStateException("Unexpected return value type: " + returnValue);<z>
webRequest).startDeferredResultProcessing(result, mavContainer);<z>
access, String declaringClassName,<z>
, MergedAnnotations annotations) {<z>
methodName;<z>
;<z>
this.declaringClassName = declaringClassName;<z>
this.returnTypeName = returnTypeName;<z>
;<z>
= annotations;<z>
) {<z>
{<z>
throw new ConversionFailedException(sourceType, targetType, null,<z>
"A null value cannot be assigned to a primitive type"));<z>
message, Throwable exception) {<z>
) {<z>
, null, exception);<z>
private void emitSetCallbacks(ClassEmitter ce) {<z>
, null);<z>
();<z>
0);<z>
++) {<z>
.dup2();<z>
.aaload(i);<z>
.checkcast(callbackTypes[i]);<z>
getCallbackField(i));<z>
;<z>
.end_method();<z>
) throws UncategorizedMappingException {<z>
ArrayList<>();<z>
packageToScan : this.packagesToScan) {<z>
pattern = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +<z>
;<z>
;<z>
CachingMetadataReaderFactory(this.resourcePatternResolver);<z>
Resource resource : resources) {<z>
;<z>
metadataReaderFactory)) {<z>
getClassMetadata().getClassName();<z>
> jaxb2AnnotatedClass =<z>
.getClassLoader());<z>
);<z>
jaxb2Classes);<z>
IOException ex) {<z>
new UncategorizedMappingException("Failed to scan classpath for unlisted classes", ex);<z>
{<z>
new UncategorizedMappingException("Failed to load annotated classes from classpath", ex);<z>
{<z>
(<z>
);<z>
);<z>
.addConstructorArgValue(method);<z>
, builder);<z>
String value) {<z>
, "'name' is required and must not be empty.");<z>
name;<z>
);<z>
modifiers) {<z>
getSignature(member);<z>
) {<z>
private ClassInfo ci;<z>
() {<z>
)<z>
getDeclaringClass());<z>
;<z>
) {<z>
return modifiers;<z>
() {<z>
;<z>
[] getExceptionTypes() {<z>
getExceptionTypes(member);<z>
() {<z>
;<z>
> messageSupplier) {<z>
(collection)) {<z>
nullSafeGet(messageSupplier));<z>
){<z>
(() -> {<z>
);<z>
.accept(value);<z>
;<z>
(ApplicationEvent event) {<z>
(TransactionSynchronizationManager.isSynchronizationActive() &&<z>
.isActualTransactionActive()) {<z>
(<z>
this.callbacks));<z>
.fallbackExecution()) {<z>
&& logger.isWarnEnabled()) {<z>
("Processing " + event + " as a fallback execution on AFTER_ROLLBACK phase");<z>
);<z>
logger.isDebugEnabled()) {<z>
("No transaction is active - skipping " + event);<z>
getInfoUrl() {<z>
(this.sockJsUrl)<z>
)<z>
"info")<z>
();<z>
? extends Annotation> annotationType) {<z>
);<z>
length);<z>
beanName : beanNames) {<z>
getBean(beanName);<z>
NullBean)) {<z>
, beanInstance);<z>
return result;<z>
(Object key) {<z>
Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);<z>
= doGetResource(actualKey);<z>
return (value != null);<z>
, StompHeaderAccessor accessor,<z>
session) {<z>
Principal principal = getUser(session);<z>
null) {<z>
accessor, message);<z>
));<z>
accessor.getHeartbeat();<z>
{<z>
;<z>
) {<z>
) session).disableHeartbeat();<z>
return accessor;<z>
BeanDefinition definition) {<z>
definition.getBeanClassName();<z>
(beanClassName != null, "No bean class name set");<z>
;<z>
String name)<z>
throws ServletRequestBindingException {<z>
name) == null) {<z>
return null;<z>
getRequiredIntParameter(request, name);<z>
ClassLoader classLoader, Class<?> interfaceClass) {<z>
(classLoader == interfaceClass.getClassLoader()) {<z>
;<z>
classLoader) == interfaceClass;<z>
) {<z>
;<z>
DefaultTransactionStatus(<z>
newSynchronization,<z>
boolean debug, @Nullable Object suspendedResources) {<z>
transaction = transaction;<z>
= newTransaction;<z>
.newSynchronization = newSynchronization;<z>
this.readOnly = readOnly;<z>
= debug;<z>
= suspendedResources;<z>
boolean flush) throws ServletException, IOException {<z>
, this.response);<z>
if (flush) {<z>
);<z>
equals(final Object object) {<z>
== object) {<z>
true;<z>
object instanceof Type)) {<z>
return false;<z>
= (Type) object;<z>
sort)) {<z>
return false;<z>
int begin = valueBegin;<z>
valueEnd;<z>
valueBegin;<z>
otherEnd = other.valueEnd;<z>
!= otherEnd - otherBegin) {<z>
false;<z>
end; i++, j++) {<z>
.valueBuffer.charAt(j)) {<z>
false;<z>
return true;<z>
String toString() {<z>
).getName());<z>
;<z>
);<z>
.append(" advisors ");<z>
("; ");<z>
).append("]; ");<z>
append(super.toString());<z>
.toString();<z>
) {<z>
) {<z>
handlerCompletionSink.tryEmitError(ex);<z>
handlerCompletionMono != null) {<z>
.handlerCompletionMono.onError(ex);<z>
ex.getMessage()));<z>
exchange) {<z>
getSessionIdResolver().resolveSessionIds(exchange))<z>
retrieveSession)<z>
next();<z>
boolean mutate) {<z>
other, "ClientResponse must not be null");<z>
();<z>
();<z>
mutate) {<z>
other.bodyToFlux(DataBuffer.class);<z>
HttpHeaders();<z>
.asHttpHeaders());<z>
other;<z>
this.request = (other instanceof DefaultClientResponse defaultClientResponse ?<z>
request() : EMPTY_REQUEST);<z>
sourceType, TypeDescriptor targetType) {<z>
null) {<z>
return null;<z>
.getElementTypeDescriptor();<z>
targetType.getType(),<z>
);<z>
) {<z>
target.add(source);<z>
source, sourceType, elementDesc);<z>
;<z>
;<z>
(Project project) {<z>
.getConfigurations().create("optional");<z>
optional.setCanBeConsumed(false);<z>
;<z>
.class, (javaPlugin) -> {<z>
JavaPluginExtension.class)<z>
.getSourceSets();<z>
(sourceSet) -> {<z>
);<z>
)).extendsFrom(optional);<z>
);<z>
;<z>
<SyncInvocableHandlerMethod> getInitBinderMethods(HandlerMethod handlerMethod) {<z>
> result = new ArrayList<>();<z>
getBeanType();<z>
((adviceBean, methods) -> {<z>
.isApplicableToBeanType(handlerType)) {<z>
;<z>
));<z>
;<z>
initBinderMethodCache<z>
,<z>
(handlerType, INIT_BINDER_METHODS))<z>
-> {<z>
= handlerMethod.getBean();<z>
, method));<z>
;<z>
;<z>
String getMessage() {<z>
.getSimpleName();<z>
+ " is " +<z>
? "present but converted to null" : "not present");<z>
overrides) {<z>
new LinkedHashSet<>(8);<z>
XhrPollingTransportHandler());<z>
(new XhrReceivingTransportHandler());<z>
());<z>
));<z>
);<z>
));<z>
catch (Exception ex) {<z>
class);<z>
{<z>
);<z>
null) {<z>
result.addAll(overrides);<z>
;<z>
getShortDescription() {<z>
sb = new StringBuilder();<z>
sessionId).append("]; ");<z>
("]; ");<z>
);<z>
(@Nullable Object obj) {<z>
{<z>
return NULL_STRING;<z>
instanceof String) {<z>
;<z>
{<z>
);<z>
instanceof boolean[]) {<z>
]) obj);<z>
{<z>
) obj);<z>
(obj instanceof char[]) {<z>
]) obj);<z>
(obj instanceof double[]) {<z>
double[]) obj);<z>
(obj instanceof float[]) {<z>
float[]) obj);<z>
if (obj instanceof int[]) {<z>
int[]) obj);<z>
[]) {<z>
]) obj);<z>
if (obj instanceof short[]) {<z>
[]) obj);<z>
();<z>
? str : EMPTY_STRING);<z>
void start() {<z>
(!isRunning()) {<z>
;<z>
.handlers.values()) {<z>
Lifecycle) {<z>
();<z>
{<z>
getFetchSize();<z>
if (fetchSize != -1) {<z>
setFetchSize(fetchSize);<z>
= getMaxRows();<z>
!= -1) {<z>
;<z>
, getQueryTimeout());<z>
void validate(Annotation annotation) {<z>
(annotation);<z>
(); i++) {<z>
{<z>
invoke(annotation);<z>
(Throwable ex) {<z>
IllegalStateException("Could not obtain annotation attribute value for " +<z>
.annotationType(), ex);<z>
Cache cache) {<z>
);<z>
{<z>
;<z>
) {<z>
));<z>
;<z>
});<z>
)) {<z>
);<z>
return result;<z>
private void writeMultipart(<z>
)<z>
IOException {<z>
contentType == null) {<z>
MediaType.MULTIPART_FORM_DATA;<z>
+ 2);<z>
putAll(contentType.getParameters());<z>
= generateMultipartBoundary();<z>
(!isFilenameCharsetSet()) {<z>
.UTF_8) &&<z>
US_ASCII)) {<z>
.name());<z>
US_ASCII));<z>
= new MediaType(contentType, parameters);<z>
getHeaders().setContentType(contentType);<z>
(outputMessage instanceof StreamingHttpOutputMessage streamingOutputMessage) {<z>
streamingOutputMessage.setBody(outputStream -> {<z>
, boundary);<z>
, boundary);<z>
;<z>
(), parts, boundary);<z>
boundary);<z>
TypeDescriptor targetType) {<z>
if (targetType == null) {<z>
;<z>
), targetType);<z>
?> beanClass, String propertyName) {<z>
super(beanClass, propertyName,<z>
propertyName + "' is not writable or has an invalid setter method: " +<z>
);<z>
null;<z>
(@Nullable Object other) {<z>
) {<z>
return true;<z>
{<z>
false;<z>
(), otherPc.getTransactionAttributeSource());<z>
, Filter filter) {<z>
String filterName = Conventions.getVariableName(filter);<z>
= servletContext.addFilter(filterName, filter);<z>
== null) {<z>
int counter = 0;<z>
null) {<z>
== 100) {<z>
"'. " +<z>
);<z>
+ counter, filter);<z>
++;<z>
isAsyncSupported());<z>
());<z>
registration;<z>
,<z>
sessionAttributesHandler) {<z>
ArrayList<>();<z>
parameter : handlerMethod.getMethodParameters()) {<z>
class)) {<z>
);<z>
;<z>
, paramType)) {<z>
;<z>
;<z>
() throws SchedulerException {<z>
!= null) {<z>
"Shutting down Quartz Scheduler");<z>
scheduler.shutdown(this.waitForJobsToCompleteOnShutdown);<z>
) {<z>
;<z>
values.put(paramName, value);<z>
(paramName, sqlType);<z>
paramName, typeName);<z>
return this;<z>
(Connection connection) throws ScriptException {<z>
notNull(connection, "'connection' must not be null");<z>
for (Resource script : this.scripts) {<z>
EncodedResource(script, this.sqlScriptEncoding);<z>
.ignoreFailedDrops,<z>
blockCommentStartDelimiter, this.blockCommentEndDelimiter);<z>
String tagName,<z>
ancestorTagName) {<z>
tagName, "'tagName' must not be empty");<z>
Assert.hasText(ancestorTagName, "'ancestorTagName' must not be empty");<z>
, ancestorTagClass)) {<z>
IllegalStateException("The '" + tagName +<z>
ancestorTagName + "' tag.");<z>
String logPrefix) {<z>
traceDebug(logger, traceOn -> {<z>
();<z>
HttpStatus.resolve(code);<z>
null ? status : code) +<z>
()) : "");<z>
;<z>
<String, ?> attributes) {<z>
forEach((name, value) -> {<z>
)) {<z>
name, value);<z>
});<z>
) {<z>
();<z>
)) {<z>
.setMessageId(messageId);<z>
messageId);<z>
acknowledge(headers, consumed);<z>
locale)<z>
MissingResourceException {<z>
cachedBundleMessageFormats.get(bundle);<z>
, MessageFormat> localeMap = null;<z>
) {<z>
= codeMap.get(code);<z>
null) {<z>
);<z>
result != null) {<z>
result;<z>
code);<z>
if (msg != null) {<z>
== null) {<z>
<>());<z>
{<z>
);<z>
msg, locale);<z>
);<z>
;<z>
;<z>
String, ?> model) {<z>
view = viewName;<z>
!= null) {<z>
().addAllAttributes(model);<z>
getArgumentResolvers(Element element, ParserContext context) {<z>
= DomUtils.getChildElementByTagName(element, "argument-resolvers");<z>
) {<z>
resolvers = extractBeanSubElements(resolversElement, context);<z>
wrapLegacyResolvers(resolvers, context);<z>
null;<z>
TransactionAttribute parseTransactionAnnotation(AnnotatedElement element) {<z>
AnnotationAttributes attributes = AnnotatedElementUtils.getMergedAnnotationAttributes(<z>
.transaction.Transactional.class);<z>
{<z>
;<z>
null;<z>
(NativeWebRequest request, DeferredResult<?> deferredResult)<z>
Exception {<z>
) {<z>
;<z>
start, int end) {<z>
end) {<z>
"";<z>
));<z>
public void visitUse(final String service) {<z>
!= null) {<z>
service);<z>
) {<z>
response.containsHeader(HttpHeaders.VARY)) {<z>
);<z>
varyByRequestHeaders.length);<z>
result, varyByRequestHeaders);<z>
HttpHeaders.VARY)) {<z>
(header, ",")) {<z>
(existing)) {<z>
);<z>
{<z>
equalsIgnoreCase(existing)) {<z>
(value);<z>
return result;<z>
{<z>
);<z>
{<z>
throw new IllegalArgumentException("Unsupported parameter type [" +<z>
).getName() + "]. supportsParameter should be called first.");<z>
, message);<z>
boolean isPlainAccessor(Method method) {<z>
.getReturnType() == void.class ||<z>
getModifiers())) {<z>
;<z>
.getDeclaredField(method.getName());<z>
true;<z>
) {<z>
;<z>
type) {<z>
= getAttributeValue(attributeName, type);<z>
value == null) {<z>
+ attributeName +<z>
getType().getName());<z>
return value;<z>
@Nullable Object newValue)<z>
throws AccessException {<z>
"Beans in a BeanFactory are read-only");<z>
{<z>
|= 0x00000002;<z>
);<z>
return getBlahFieldBuilder().getBuilder();<z>
) {<z>
CustomEditorHolder holder =<z>
) : null);<z>
getPropertyEditor(requiredType) : null);<z>
{<z>
parsePartialFrom(<z>
.protobuf.CodedInputStream input,<z>
.protobuf.ExtensionRegistryLite extensionRegistry)<z>
{<z>
);<z>
session) {<z>
Session) Proxy.newProxyInstance(<z>
class},<z>
));<z>
>> T nextOrSame(T temporal) {<z>
;<z>
(CronField field : this.fields) {<z>
candidate = field.nextOrSame(temporal);<z>
if (result == null ||<z>
) {<z>
result = candidate;<z>
result;<z>
final void startDocument() throws SAXException {<z>
removeAllNamespaceMappings();<z>
();<z>
;<z>
ex) {<z>
+ ex.getMessage(), ex);<z>
(AnnotatedElement element) {<z>
.annotationParsers) {<z>
;<z>
null) {<z>
;<z>
return null;<z>
) {<z>
JtaTransactionObject) transaction;<z>
(txObject);<z>
{<z>
new TransactionSystemException("JTA failure on suspend", ex);<z>
void prepareTransactionalConnection(Connection con, TransactionDefinition definition)<z>
{<z>
() && definition.isReadOnly()) {<z>
.createStatement()) {<z>
);<z>
(int statusCode) {<z>
(statusCode);<z>
status == null) {<z>
statusCode + "]");<z>
return status;<z>
)<z>
{<z>
(beanName, annotationType);<z>
value) {<z>
{<z>
::invokeMethod;<z>
value instanceof Map) {<z>
return TypeMappedAnnotation::extractFromMap;<z>
;<z>
rollbackToHeldSavepoint() throws TransactionException {<z>
();<z>
(savepoint == null) {<z>
throw new TransactionUsageException(<z>
);<z>
getSavepointManager().rollbackToSavepoint(savepoint);<z>
.releaseSavepoint(savepoint);<z>
(null);<z>
> configurer) {<z>
this.strategiesConfigurers == null) {<z>
);<z>
this.strategiesConfigurers.add(configurer);<z>
this;<z>
session, String destinationName, boolean pubSubDomain)<z>
JMSException {<z>
Assert.notNull(session, "Session must not be null");<z>
"Destination name must not be null");<z>
if (pubSubDomain) {<z>
);<z>
destinationName);<z>
public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {<z>
getEvaluationContext().getBeanResolver();<z>
(beanResolver == null) {<z>
SpelEvaluationException(<z>
;<z>
getEvaluationContext(), this.beanName));<z>
catch (AccessException ex) {<z>
), ex, SpelMessage.EXCEPTION_DURING_BEAN_RESOLUTION,<z>
));<z>
String getOriginatingServletPath(HttpServletRequest request) {<z>
FORWARD_SERVLET_PATH_ATTRIBUTE);<z>
{<z>
= request.getServletPath();<z>
return servletPath;<z>
(<z>
cargs, MutablePropertyValues pvs) {<z>
cargs, pvs);<z>
;<z>
(beanClass);<z>
(String content) {<z>
content);<z>
ex) {<z>
this.expression + "\"", ex);<z>
HttpHeaders getHeaders() {<z>
.SET_COOKIE) == null) {<z>
stream)<z>
);<z>
this.headers;<z>
<?> message) throws Exception {<z>
);<z>
paramType)) {<z>
message.getHeaders();<z>
else if (MessageHeaderAccessor.class == paramType) {<z>
, MessageHeaderAccessor.class);<z>
message);<z>
class.isAssignableFrom(paramType)) {<z>
getAccessor(message, MessageHeaderAccessor.class);<z>
())) {<z>
;<z>
"wrap", Message.class);<z>
null) {<z>
(<z>
paramType + " for message " + message);<z>
message);<z>
paramType +<z>
;<z>
(<z>
ServerResponse, ServerResponse> responseProcessor) {<z>
notNull(responseProcessor, "ResponseProcessor must not be null");<z>
responseProcessor));<z>
getParamConditions() {<z>
PartialMatch::hasProducesMatch).<z>
).getExpressions()).<z>
(Collectors.toList());<z>
{<z>
= SimpMessageHeaderAccessor.getUser(headers);<z>
if (principal != null) {<z>
(principal instanceof DestinationUserNameProvider ?<z>
.getName());<z>
;<z>
firstCharIsZero) {<z>
= false;<z>
= this.pos;<z>
.pos + 1];<z>
== 'x' || ch == 'X';<z>
(firstCharIsZero && isHex) {<z>
1;<z>
++;<z>
;<z>
(isChar('L', 'l')) {<z>
;<z>
++;<z>
false, start, this.pos);<z>
++;<z>
this.pos]));<z>
this.pos];<z>
{<z>
;<z>
pos;<z>
pos++;<z>
[this.pos]));<z>
{<z>
.pos = dotpos;<z>
start, this.pos);<z>
endOfNumber = this.pos;<z>
(isChar('L', 'l')) {<z>
isReal) {<z>
raiseParseException(start, SpelMessage.REAL_CANNOT_BE_LONG);<z>
;<z>
++;<z>
pos])) {<z>
true;<z>
this.pos++;<z>
;<z>
)) {<z>
this.pos++;<z>
.pos++;<z>
));<z>
= false;<z>
.pos])) {<z>
= true;<z>
.pos;<z>
pos])) {<z>
this.pos;<z>
;<z>
pos];<z>
= false;<z>
{<z>
true;<z>
= true;<z>
endOfNumber = ++this.pos;<z>
(ch)) {<z>
;<z>
endOfNumber = ++this.pos;<z>
if (isReal) {<z>
);<z>
, false, start, endOfNumber);<z>
Object parameter)<z>
ServletRequestBindingException {<z>
if (parameter == null) {<z>
);<z>
{<z>
;<z>
name, PageContext.PAGE_SCOPE);<z>
.REQUEST_SCOPE);<z>
.removeAttribute(name, PageContext.SESSION_SCOPE);<z>
, PageContext.APPLICATION_SCOPE);<z>
, HttpHeaders headers, TextMessage message) {<z>
)) {<z>
url);<z>
, headers, message);<z>
HttpStatus.NO_CONTENT) {<z>
{<z>
") failed: " + response);<z>
response.getStatusCode());<z>
if (logger.isTraceEnabled()) {<z>
url + ") response: " + response);<z>
void addAllowedOrigin(@Nullable String origin) {<z>
) {<z>
) {<z>
allowedOrigins = new ArrayList<>(4);<z>
)) {<z>
setAllowedOrigins(DEFAULT_PERMIT_ALL);<z>
origin);<z>
);<z>
) {<z>
{<z>
return true;<z>
other instanceof CloseStatus otherStatus)) {<z>
false;<z>
otherStatus.reason));<z>
) {<z>
= BeanFactoryUtils.beansOfTypeIncludingAncestors(<z>
false);<z>
values());<z>
);<z>
.handlerMappings = Collections.unmodifiableList(mappings);<z>
beansOfTypeIncludingAncestors(<z>
.class, true, false);<z>
(adapterBeans.values());<z>
handlerAdapters);<z>
beans = BeanFactoryUtils.beansOfTypeIncludingAncestors(<z>
HandlerResultHandler.class, true, false);<z>
<>(beans.values());<z>
AnnotationAwareOrderComparator.sort(this.resultHandlers);<z>
(HandshakeResponse response) {<z>
logger.isTraceEnabled()) {<z>
.getHeaders());<z>
request, String viewName) {<z>
this.statusCodes.containsKey(viewName)) {<z>
(viewName);<z>
;<z>
{<z>
!= null) {<z>
: converters) {<z>
if (converter instanceof GenericConverter) {<z>
);<z>
) {<z>
<?, ?>) converter);<z>
?, ?>) {<z>
ConverterFactory<?, ?>) converter);<z>
("Each converter object must implement one of the " +<z>
"Converter, ConverterFactory, or GenericConverter interfaces");<z>
ancestorTagClass) {<z>
notNull(tag, "Tag cannot be null");<z>
.notNull(ancestorTagClass, "Ancestor tag class cannot be null");<z>
isAssignableFrom(ancestorTagClass)) {<z>
throw new IllegalArgumentException(<z>
getName() + "' is not a valid Tag type");<z>
= tag.getParent();<z>
!= null) {<z>
isAssignableFrom(ancestor.getClass())) {<z>
true;<z>
();<z>
;<z>
preventCaching(HttpServletResponse response) {<z>
setHeader(HEADER_PRAGMA, "no-cache");<z>
.useExpiresHeader) {<z>
setDateHeader(HEADER_EXPIRES, 1L);<z>
this.useCacheControlHeader) {<z>
(HEADER_CACHE_CONTROL, "no-cache");<z>
{<z>
HEADER_CACHE_CONTROL, "no-store");<z>
String path) {<z>
) {<z>
(logger.isWarnEnabled()) {<z>
logger.warn(LogFormatUtils.formatValue(<z>
-1, true));<z>
true;<z>
) {<z>
path.substring(1) : path);<z>
) {<z>
logger.isWarnEnabled()) {<z>
.formatValue(<z>
, -1, true));<z>
return true;<z>
{<z>
{<z>
(LogFormatUtils.formatValue(<z>
));<z>
true;<z>
false;<z>
doBegin(TransactionSynchronizationManager synchronizationManager, Object transaction,<z>
{<z>
ConnectionFactoryTransactionObject) transaction;<z>
) -> {<z>
Connection> connectionMono;<z>
().isSynchronizedWithTransaction()) {<z>
());<z>
= newCon.doOnNext(connection -> {<z>
{<z>
+ "] for R2DBC transaction");<z>
(new ConnectionHolder(connection), true);<z>
;<z>
.getConnectionHolder().setSynchronizedWithTransaction(true);<z>
));<z>
connectionMono.flatMap(con -> {<z>
beginTransaction()))<z>
v -> {<z>
setTransactionActive(true);<z>
;<z>
()) {<z>
toMillis());<z>
) {<z>
, txObject.getConnectionHolder());<z>
).onErrorResume(e -> {<z>
isNewConnectionHolder()) {<z>
())<z>
-> txObject.setConnectionHolder(null, false))<z>
);<z>
error(e);<z>
;<z>
(e -> {<z>
new CannotCreateTransactionException(<z>
e);<z>
(ex);<z>
});<z>
();<z>
run() {<z>
;<z>
concurrencyThrottle.afterAccess();<z>
) {<z>
if (maybeEatLiteral()) {<z>
();<z>
(maybeEatParenExpression()) {<z>
);<z>
maybeEatNullReference() || maybeEatConstructorReference() ||<z>
|| maybeEatFunctionOrVar()) {<z>
pop();<z>
)) {<z>
;<z>
) || maybeEatIndexer()) {<z>
;<z>
maybeEatInlineListOrMap()) {<z>
);<z>
return null;<z>
<T> set) {<z>
if (isEmpty(set)) {<z>
return null;<z>
) {<z>
) set).first();<z>
;<z>
null;<z>
)) {<z>
= it.next();<z>
;<z>
throws JMSException {<z>
.get();<z>
null) {<z>
password);<z>
;<z>
{<z>
(name, "Name must not be null");<z>
, "MessageSource must not be null");<z>
name;<z>
;<z>
Transport connectTransport() throws MessagingException {<z>
String username = getUsername();<z>
getPassword();<z>
(username)) {<z>
;<z>
password)) {<z>
password = null;<z>
transport = getTransport(getSession());<z>
getPort(), username, password);<z>
;<z>
AcceptPredicate(Set<MediaType> mediaTypes) {<z>
(headers -> {<z>
> acceptedMediaTypes = acceptedMediaTypes(headers);<z>
()<z>
.anyMatch(acceptedMediaType -> mediaTypes.stream()<z>
anyMatch(acceptedMediaType::isCompatibleWith));<z>
, acceptedMediaTypes, match);<z>
return match;<z>
});<z>
mediaTypes;<z>
,<z>
propertyResolver) throws BeansException {<z>
placeholderPrefix);<z>
setPlaceholderSuffix(this.placeholderSuffix);<z>
(this.valueSeparator);<z>
= strVal -> {<z>
this.ignoreUnresolvablePlaceholders ?<z>
strVal) :<z>
(strVal));<z>
trimValues) {<z>
();<z>
nullValue) ? null : resolved);<z>
valueResolver);<z>
HttpMessageNotReadableException ex,<z>
Nullable Object handler) throws IOException {<z>
.SC_BAD_REQUEST);<z>
return new ModelAndView();<z>
{<z>
this.multipartParameters == null) {<z>
);<z>
;<z>
ExpressionState state, Object newArray, TypeConverter typeConverter,<z>
) {<z>
]) newArray;<z>
< newFloatArray.length; i++) {<z>
getTypedValue(state);<z>
(typeConverter, typedValue);<z>
(ResourceResolverChain resolverChain,<z>
transformer, @Nullable ResourceTransformerChain chain) {<z>
transformer != null && chain != null),<z>
);<z>
;<z>
transformer;<z>
nextChain = chain;<z>
WebSocketExtension extension) {<z>
getName();<z>
{<z>
add(new Parameter() {<z>
{<z>
return paramName;<z>
public String getValue() {<z>
.getParameters().get(paramName);<z>
});<z>
<String, Object> globalBindings) {<z>
.getBindings(globalBindings);<z>
this.globalBindings = bindings;<z>
scriptEngineManager = this.scriptEngineManager;<z>
!= null) {<z>
bindings);<z>
public AntPathStringMatcher(String pattern, boolean caseSensitive) {<z>
= pattern;<z>
;<z>
;<z>
pattern);<z>
;<z>
while (matcher.find()) {<z>
));<z>
.group();<z>
equals(match)) {<z>
('.');<z>
match)) {<z>
.append(".*");<z>
) {<z>
.indexOf(':');<z>
colonIdx == -1) {<z>
.append(DEFAULT_VARIABLE_PATTERN);<z>
group(1));<z>
);<z>
'(');<z>
append(variablePattern);<z>
;<z>
(1, colonIdx);<z>
.variableNames.add(variableName);<z>
);<z>
if (end == 0) {<z>
this.exactMatch = true;<z>
this.pattern = null;<z>
= false;<z>
;<z>
toString()) :<z>
), Pattern.CASE_INSENSITIVE));<z>
parameter, @Nullable ModelAndViewContainer mavContainer,<z>
throws Exception {<z>
;<z>
request != null, "No HttpServletRequest");<z>
request);<z>
capacity(int newCapacity) {<z>
if (newCapacity <= 0) {<z>
));<z>
();<z>
= writePosition();<z>
int oldCapacity = capacity();<z>
) {<z>
= this.byteBuffer;<z>
);<z>
.capacity());<z>
);<z>
oldBuffer);<z>
clear();<z>
(newBuffer);<z>
newCapacity < oldCapacity) {<z>
.byteBuffer;<z>
));<z>
newCapacity) {<z>
writePosition > newCapacity) {<z>
;<z>
writePosition);<z>
;<z>
;<z>
.put(oldBuffer);<z>
;<z>
newCapacity);<z>
;<z>
;<z>
this;<z>
(@Nullable Object other) {<z>
== other) {<z>
;<z>
(!(other instanceof SimpSubscription otherSubscription)) {<z>
false;<z>
otherSubscription.getId()) &&<z>
otherSubscription.getSession()));<z>
ClassUtils.isPresent("com.fasterxml.jackson.databind.ObjectMapper", classLoader) &&<z>
classLoader);<z>
= ClassUtils.isPresent("com.fasterxml.jackson.dataformat.smile.SmileFactory", classLoader);<z>
("jakarta.xml.bind.Binder", classLoader);<z>
, classLoader);<z>
classLoader);<z>
"io.netty.buffer.ByteBuf", classLoader);<z>
, classLoader);<z>
jackson2JsonDecoder;<z>
> jackson2JsonEncoder;<z>
Encoder<?> jackson2SmileEncoder;<z>
Decoder<?> jackson2SmileDecoder;<z>
> protobufDecoder;<z>
;<z>
jaxb2Decoder;<z>
> jaxb2Encoder;<z>
private Decoder<?> kotlinSerializationJsonDecoder;<z>
> kotlinSerializationJsonEncoder;<z>
<Object> codecConsumer;<z>
Integer maxInMemorySize;<z>
;<z>
true;<z>
> typedReaders = new ArrayList<>();<z>
> objectReaders = new ArrayList<>();<z>
new ArrayList<>();<z>
ArrayList<>();<z>
() {<z>
;<z>
initWriters();<z>
String name)<z>
{<z>
;<z>
Class<?> introspectedClass, boolean nestedAnnotationsAsMap) {<z>
(introspectedClass);<z>
= MergedAnnotations.from(introspectedClass,<z>
.none());<z>
nestedAnnotationsAsMap;<z>
connection,<z>
Connection, Publisher<Void>> closeFunction) {<z>
connection;<z>
= closeFunction;<z>
getDoubleParameters(ServletRequest request, String name) {<z>
, name);<z>
{<z>
double[0];<z>
mimeType) {<z>
selectObjectMapper(elementType, mimeType);<z>
) {<z>
;<z>
.getType());<z>
supportsMimeType(mimeType)) {<z>
;<z>
{<z>
);<z>
);<z>
, causeRef)) {<z>
;<z>
javaType, causeRef.get());<z>
false;<z>
context) {<z>
new ManagedList<>();<z>
extractSource(parentElement));<z>
"bean", "ref")) {<z>
);<z>
list.add(object);<z>
return list;<z>
(<z>
RuntimeBeanReference brokerTemplate,<z>
source) {<z>
);<z>
.class);<z>
().addIndexedArgumentValue(0, userRegistry);<z>
brokerTemplate);<z>
2, destination);<z>
;<z>
, context, source);<z>
);<z>
Method> findCandidateWriteMethods(MethodDescriptor[] methodDescriptors) {<z>
ArrayList<>();<z>
{<z>
getMethod();<z>
)) {<z>
.add(method);<z>
toString).reversed());<z>
;<z>
{<z>
args.length - 1] instanceof Closure);<z>
Class<?> beanClass) {<z>
) {<z>
) {<z>
GroovyBeanDefinitionWrapper(<z>
);<z>
= new GroovyBeanDefinitionWrapper(beanName, beanClass);<z>
currentBeanDefinition = new GroovyBeanDefinitionWrapper(<z>
args.length));<z>
) {<z>
);<z>
());<z>
instanceof Map) {<z>
1] instanceof Class) {<z>
=<z>
);<z>
args[1], constructorArgs);<z>
;<z>
> entity : namedArgs.entrySet()) {<z>
);<z>
(propName, entity.getValue());<z>
beanName);<z>
iterator().next();<z>
);<z>
){<z>
.length);<z>
= new GroovyBeanDefinitionWrapper(beanName, null,<z>
;<z>
currentBeanDefinition = new GroovyBeanDefinitionWrapper(beanName);<z>
());<z>
.getValue().toString());<z>
{<z>
);<z>
.getBeanDefinition().setAbstract(true);<z>
List<Object> constructorArgs =<z>
.length - 1 : args.length);<z>
, constructorArgs);<z>
{<z>
.length - 1];<z>
callable.setDelegate(this);<z>
DELEGATE_FIRST);<z>
.currentBeanDefinition);<z>
this.currentBeanDefinition;<z>
;<z>
beanDefinition);<z>
;<z>
return beanDefinition;<z>
{<z>
();<z>
) {<z>
addAll(Arrays.asList(allowedOrigins));<z>
this;<z>
resourceLoader, String templateLoaderPath) {<z>
;<z>
) {<z>
"/";<z>
= templateLoaderPath;<z>
)) {<z>
("SpringTemplateLoader for FreeMarker: using resource loader [" + this.resourceLoader +<z>
);<z>
callback) {<z>
);<z>
.resources) {<z>
yaml, resource);<z>
FIRST_FOUND && found) {<z>
(int bytesToAdd) {<z>
) {<z>
.MAX_VALUE - this.byteCount) {<z>
();<z>
;<z>
{<z>
;<z>
, DataBufferFactory bufferFactory,<z>
String, Object> hints) {<z>
map(message -><z>
));<z>
) throws EvaluationException {<z>
.lookupVariable(this.name);<z>
.NULL) {<z>
;<z>
value.getValue() instanceof Method)) {<z>
new SpelEvaluationException(<z>
);<z>
value.getValue());<z>
catch (SpelEvaluationException ex) {<z>
(getStartPosition());<z>
;<z>
, Subscription subscription) {<z>
"Subscription must not be null");<z>
) {<z>
.subscription = subscription;<z>
subscription.request(1);<z>
(processor, subscription);<z>
DestructionAwareBeanPostProcessor> filterPostProcessors(<z>
List<DestructionAwareBeanPostProcessor> processors, Object bean) {<z>
;<z>
(processors)) {<z>
(processors.size());<z>
: processors) {<z>
if (processor.requiresDestruction(bean)) {<z>
(processor);<z>
return filteredPostProcessors;<z>
getRelated(String className) throws IOException {<z>
(this.source instanceof Class) {<z>
));<z>
, DEFAULT_EXCLUSION_FILTER);<z>
(ClassNotFoundException ex) {<z>
{<z>
ex);<z>
getMetadataReader(className));<z>
, DEFAULT_EXCLUSION_FILTER);<z>
) {<z>
.isTraceEnabled()) {<z>
class);<z>
(accessor != null) {<z>
;<z>
> conn = this.connection;<z>
(conn != null, "Connection closed");<z>
;<z>
ExecutionException ex) {<z>
ex.getCause());<z>
catch (Throwable ex) {<z>
throw new MessageDeliveryException(message, ex);<z>
> headersToCopy) {<z>
== null) {<z>
)<z>
get(NATIVE_HEADERS);<z>
)) {<z>
.forEach(this::setNativeHeaderValues);<z>
);<z>
[] args) throws Throwable {<z>
.getName()) {<z>
"equals":<z>
);<z>
:<z>
();<z>
case "toString":<z>
.targetFactory + "]";<z>
case "getEntityManagerFactory":<z>
targetFactory;<z>
:<z>
:<z>
);<z>
{<z>
);<z>
:<z>
?>) args[0];<z>
isInstance(proxy)) {<z>
;<z>
:<z>
return true;<z>
case "close":<z>
null;<z>
case "getTransaction":<z>
IllegalStateException(<z>
);<z>
EntityManager target = EntityManagerFactoryUtils.doGetTransactionalEntityManager(<z>
synchronizedWithTransaction);<z>
method.getName()) {<z>
case "getTargetEntityManager":<z>
{<z>
"No transactional EntityManager available");<z>
return target;<z>
"unwrap":<z>
];<z>
{<z>
!= null ? target : proxy);<z>
== null) {<z>
"No transactional EntityManager available");<z>
)) {<z>
.isActualTransactionActive() &&<z>
)) {<z>
+<z>
+ method.getName() + "' call");<z>
= false;<z>
== null) {<z>
.debug("Creating new EntityManager for shared EntityManager invocation");<z>
) ?<z>
.targetFactory.createEntityManager(this.properties) :<z>
this.targetFactory.createEntityManager());<z>
= true;<z>
.invoke(target, args);<z>
(result instanceof Query query) {<z>
isNewEm) {<z>
(query.getClass(), key -><z>
proxyClassLoader));<z>
,<z>
target));<z>
= false;<z>
query, this.targetFactory);<z>
result;<z>
ex) {<z>
throw ex.getTargetException();<z>
) {<z>
;<z>
void setRemoveOnCancelPolicy(boolean flag) {<z>
) {<z>
).setRemoveOnCancelPolicy(flag);<z>
flag;<z>
, Locale locale) {<z>
source, "MessageSource must not be null");<z>
messageSource = source;<z>
;<z>
Class<T> annotationType) {<z>
annotationType) ||<z>
class &&<z>
this.returnValue instanceof ReactiveTypeHandler.CollectedValuesList));<z>
(String user, String destination, Object payload,<z>
) throws MessagingException {<z>
);<z>
cal) throws InvalidResultSetAccessException {<z>
;<z>
{<z>
(se);<z>
protected void initServer() throws Exception {<z>
);<z>
.setBaseDir(baseDir);<z>
getHost());<z>
getPort());<z>
ServletHttpHandlerAdapter servlet = initServletAdapter();<z>
System.getProperty("java.io.tmpdir"));<z>
, base.getAbsolutePath());<z>
(true);<z>
, "httpHandlerServlet");<z>
if (wsListener != null) {<z>
());<z>
ScheduledTask scheduleFixedRateTask(FixedRateTask task) {<z>
(task);<z>
false;<z>
) {<z>
);<z>
true;<z>
null) {<z>
(task.getInitialDelay() > 0) {<z>
;<z>
.future =<z>
.getInterval());<z>
=<z>
());<z>
(task);<z>
.unresolvedTasks.put(task, scheduledTask);<z>
: null);<z>
@Nullable Supplier<T> instanceSupplier) {<z>
();<z>
(beanClass);<z>
instanceSupplier);<z>
{<z>
(this == NONE) {<z>
;<z>
new DefaultVariableResolver(this);<z>
releaseAndClear() {<z>
{<z>
DataBufferUtils.release(buf);<z>
Throwable ex) {<z>
;<z>
();<z>
hasTasks() {<z>
!CollectionUtils.isEmpty(this.triggerTasks) ||<z>
(this.cronTasks) ||<z>
isEmpty(this.fixedRateTasks) ||<z>
(this.fixedDelayTasks));<z>
getFile() throws IOException {<z>
getResource(this.path);<z>
url)) {<z>
();<z>
, this.path);<z>
File(realPath);<z>
setValue(@Nullable Object newValue) {<z>
0, SpelMessage.NOT_ASSIGNABLE, "null");<z>
Nullable Object rejectedValue, String[] codes,<z>
adapter) {<z>
, violation.getMessage());<z>
= adapter;<z>
violation;<z>
(violation);<z>
> properties,<z>
{<z>
;<z>
{<z>
();<z>
entityManagerInterfaces.length + 1];<z>
ifcs, 0, entityManagerInterfaces.length);<z>
= EntityManagerProxy.class;<z>
(EntityManager) Proxy.newProxyInstance(<z>
getClassLoader()),<z>
, synchronizedWithTransaction));<z>
public final void onComplete() {<z>
.get();<z>
rsWriteFlushLogger.isTraceEnabled()) {<z>
state + "]");<z>
onComplete(this);<z>
MockHttpServletRequestBuilder session(MockHttpSession session) {<z>
);<z>
session;<z>
return this;<z>
<MediaType> getAcceptedMediaTypes(HttpServletRequest request)<z>
HttpMediaTypeNotAcceptableException {<z>
;<z>
== null) {<z>
(new ServletWebRequest(request));<z>
request.setAttribute(MEDIA_TYPES_ATTRIBUTE, result);<z>
return result;<z>
) throws JMSException {<z>
;<z>
) {<z>
;<z>
System.currentTimeMillis();<z>
;<z>
this.activeInvokerCount > 0) {<z>
!isAcceptMessagesWhileStopping() &&<z>
.currentTimeMillis() - waitStartTime >= receiveTimeout) {<z>
) {<z>
.interruptIfNecessary();<z>
(logger.isDebugEnabled()) {<z>
+ this.activeInvokerCount +<z>
")");<z>
) {<z>
.wait(receiveTimeout);<z>
);<z>
;<z>
(AsyncMessageListenerInvoker scheduledInvoker : this.scheduledInvokers) {<z>
.clearResources();<z>
clear();<z>
catch (InterruptedException ex) {<z>
interrupt();<z>
handleBinaryMessage(WebSocketSession session, BinaryMessage message) {<z>
"Binary messages not supported"));<z>
{<z>
public int size() {<z>
0;<z>
{<z>
size += segment.getCount();<z>
size;<z>
MultiValueMap<String, ?> map,<z>
String, Object> hints) {<z>
boundary = generateMultipartBoundary();<z>
, boundary);<z>
().setContentType(mediaType);<z>
hints) + "Encoding " +<z>
() ?<z>
formatValue(map, !traceOn) :<z>
));<z>
= outputMessage.bufferFactory();<z>
entrySet())<z>
), bufferFactory))<z>
(generateLastLine(boundary, bufferFactory))<z>
DataBufferUtils::release);<z>
if (logger.isDebugEnabled()) {<z>
, hints, logger));<z>
outputMessage.writeWith(body);<z>
targetClass) {<z>
||<z>
) &&<z>
)))));<z>
clazz, FieldCallback fc) {<z>
field : getDeclaredFields(clazz)) {<z>
(field);<z>
(IllegalAccessException ex) {<z>
+ ex);<z>
, Consumer<String> consumer) {<z>
).getValue();<z>
));<z>
return this.responseSpec;<z>
protected void resetCommonCaches() {<z>
();<z>
clearCache();<z>
.clearCache();<z>
);<z>
publicId, @Nullable String systemId)<z>
SAXException, IOException {<z>
null) {<z>
{<z>
;<z>
(systemId.endsWith(XSD_SUFFIX)) {<z>
.resolveEntity(publicId, systemId);<z>
null;<z>
void setBcc(String bcc) throws MailParseException {<z>
setBcc(bcc);<z>
{<z>
throw new MailParseException(ex);<z>
) {<z>
{<z>
ReactorServerHttpRequest.reactorNettyRequestChannelOperationsIdPresent) {<z>
) {<z>
response.withConnection(connection -> {<z>
);<z>
;<z>
);<z>
PropertySource<?> propertySource) {<z>
{<z>
propertySource);<z>
(propertySource);<z>
) {<z>
instanceof DefaultSubscriptionRegistry) {<z>
selectorHeaderName);<z>
(<z>
,<z>
,<z>
] local,<z>
final int numStack,<z>
{<z>
= 0;<z>
) {<z>
i]);<z>
[i] == Opcodes.DOUBLE) {<z>
TOP;<z>
length) {<z>
= TOP;<z>
;<z>
numStack; ++i) {<z>
stack[i] == Opcodes.DOUBLE) {<z>
++numStackTop;<z>
= new int[numStack + numStackTop];<z>
;<z>
< numStack; ++i) {<z>
(symbolTable, stack[i]);<z>
) {<z>
TOP;<z>
outputStackTop = 0;<z>
initializationCount = 0;<z>
protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {<z>
this.handlerAdapters != null) {<z>
(HandlerAdapter adapter : this.handlerAdapters) {<z>
)) {<z>
adapter;<z>
handler +<z>
"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler");<z>
,<z>
, BeanDefinitionRegistry registry,<z>
{<z>
= clazz.getDeclaredConstructors();<z>
.getParameterCount() > 0) {<z>
= constructors[0];<z>
),<z>
;<z>
, args);<z>
ex) {<z>
clazz, "No suitable constructor found", ex);<z>
(clazz);<z>
transaction) {<z>
HibernateTransactionObject) transaction;<z>
||<z>
);<z>
parameter, Message<?> message,<z>
, MimeType mimeType) {<z>
parameter);<z>
?> resolvedType = targetType.resolve();<z>
).getAdapter(resolvedType) : null);<z>
? targetType.getGeneric() : targetType);<z>
);<z>
validator = getValidator(message, parameter);<z>
= Collections.emptyMap();<z>
) {<z>
) {<z>
&& adapter.isMultiValue()) {<z>
<?> flux = content<z>
filter(this::nonEmptyDataBuffer)<z>
, mimeType, hints))<z>
)));<z>
(isContentRequired) {<z>
(parameter, message)));<z>
) {<z>
(validator);<z>
));<z>
> mono = content.next()<z>
)<z>
(buffer, elementType, mimeType, hints))<z>
(parameter, message, ex)));<z>
isContentRequired) {<z>
;<z>
) {<z>
= mono.doOnNext(validator);<z>
(mono));<z>
(new MethodArgumentResolutionException(<z>
"Cannot decode to [" + targetType + "]" + message));<z>
(<z>
NativeWebRequest request) throws Exception {<z>
true);<z>
{<z>
;<z>
.resolve(methodParameter.getNestedParameterType());<z>
getParameterIndex() == -1 ?<z>
.getParameterAnnotations());<z>
byte[] bytes) {<z>
, 0, bytes.length);<z>
incrementAndGet();<z>
clazz;<z>
, HttpStatus statusCode,<z>
, @Nullable Charset charset) {<z>
(statusCode) {<z>
:<z>
message != null ?<z>
, statusText, headers, body, charset) :<z>
);<z>
case NOT_IMPLEMENTED:<z>
return message != null ?<z>
, statusText, headers, body, charset) :<z>
headers, body, charset);<z>
:<z>
?<z>
headers, body, charset) :<z>
);<z>
SERVICE_UNAVAILABLE:<z>
!= null ?<z>
headers, body, charset) :<z>
, headers, body, charset);<z>
case GATEWAY_TIMEOUT:<z>
message != null ?<z>
, body, charset) :<z>
(statusText, headers, body, charset);<z>
!= null ?<z>
) :<z>
body, charset);<z>
public AbstractSubscribableChannel clientInboundChannel(TaskExecutor clientInboundChannelExecutor) {<z>
;<z>
));<z>
ChannelRegistration reg = getClientInboundChannelRegistration();<z>
if (reg.hasInterceptors()) {<z>
(reg.getInterceptors());<z>
channel;<z>
beanName)<z>
throws BeansException {<z>
pvs;<z>
public UrlBasedViewResolverRegistration freeMarker() {<z>
(FreeMarkerConfigurer.class)) {<z>
BeanInitializationException("In addition to a FreeMarker view resolver " +<z>
;<z>
();<z>
(registration.getViewResolver());<z>
return registration;<z>
arguments,<z>
parameterNameDiscoverer) {<z>
(rootObject);<z>
method = method;<z>
this.arguments = arguments;<z>
parameterNameDiscoverer;<z>
, String name) {<z>
;<z>
HttpSession session = request.getSession(false);<z>
(name) : null);<z>
MapIndexingValueRef(<z>
{<z>
.typeConverter = typeConverter;<z>
.map = map;<z>
key;<z>
mapEntryDescriptor = mapEntryDescriptor;<z>
) {<z>
) {<z>
new IllegalStateException("Immutable headers");<z>
(key, value);<z>
boolean inCommentIfPresent) {<z>
index = line.indexOf(token);<z>
- 1) {<z>
inCommentIfPresent;<z>
;<z>
protected String resolveStringValue(String strVal) {<z>
== null) {<z>
throw new IllegalStateException("No StringValueResolver specified - pass a resolver " +<z>
);<z>
);<z>
resolvedValue) ? strVal : resolvedValue);<z>
String sessionId, SessionInfo info) {<z>
getSubscriptions()) {<z>
;<z>
matcher)<z>
throws Exception {<z>
(content, encoding, Node.class);<z>
.expression, node, matcher);<z>
resolverElement, ParserContext context) {<z>
(ContentNegotiatingViewResolver.class);<z>
setSource(context.extractSource(resolverElement));<z>
(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
.getPropertyValues();<z>
.getChildElementsByTagName(resolverElement, "default-views");<z>
) {<z>
);<z>
, "ref")) {<z>
).parsePropertySubElement(element, null));<z>
list);<z>
"use-not-acceptable")) {<z>
"useNotAcceptableStatusCode", resolverElement.getAttribute("use-not-acceptable"));<z>
(context);<z>
!= null) {<z>
"contentNegotiationManager", manager);<z>
beanDef;<z>
destroy() {<z>
!= null) {<z>
();<z>
setClientHttpRequestInitializers(<z>
<ClientHttpRequestInitializer> clientHttpRequestInitializers) {<z>
) {<z>
clientHttpRequestInitializers.clear();<z>
.addAll(clientHttpRequestInitializers);<z>
AnnotationAwareOrderComparator.sort(this.clientHttpRequestInitializers);<z>
initializeNativeSession(Session session) {<z>
session);<z>
();<z>
;<z>
;<z>
.isEmpty(nativeHeaders)) {<z>
headers.putAll(nativeHeaders);<z>
= HttpHeaders.readOnlyHttpHeaders(headers);<z>
();<z>
.extensions = getExtensions(session);<z>
(this.user == null) {<z>
getUpgradeRequest().getUserPrincipal();<z>
boolean isAspectJAdvice(Advisor advisor) {<z>
(advisor instanceof InstantiationModelAwarePointcutAdvisor ||<z>
||<z>
&&<z>
.getPointcut() instanceof AspectJExpressionPointcut));<z>
, HttpHeaders headers,<z>
<?, ? super ClientHttpRequest> body,<z>
> httpRequestConsumer) {<z>
.method = method;<z>
.url = url;<z>
.readOnlyHttpHeaders(headers);<z>
cookies);<z>
this.body = body;<z>
.unmodifiableMap(attributes);<z>
this.httpRequestConsumer = httpRequestConsumer;<z>
(this));<z>
.logPrefix = "[" + id + "] ";<z>
) {<z>
defaultLocale != null) {<z>
.defaultLocale;<z>
.fallbackToSystemLocale) {<z>
();<z>
;<z>
) {<z>
) {<z>
;<z>
= Array.getLength(array);<z>
>= length && index < this.autoGrowCollectionLimit) {<z>
).getComponentType();<z>
+ 1);<z>
length);<z>
newArray); i++) {<z>
);<z>
);<z>
defaultValue = getPropertyValue(name);<z>
state(defaultValue != null, "Default value must not be null");<z>
return defaultValue;<z>
array;<z>
private String initRequestUri() {<z>
null) {<z>
return this.forwardedPrefix +<z>
get());<z>
;<z>
(boolean alwaysUseFullPath) {<z>
alwaysUseFullPath);<z>
{<z>
(alwaysUseFullPath);<z>
) {<z>
--;<z>
!= null && activeInvokerCount == 0) {<z>
;<z>
= null;<z>
Class<?> clazz) {<z>
if (this.dimensions != 0) {<z>
.dimensions; i++) {<z>
;<z>
.getClass();<z>
;<z>
Flux<DataBuffer> readAsynchronousFileChannel(<z>
{<z>
bufferSize);<z>
) {<z>
matcher = null;<z>
cachePatterns = this.cachePatterns;<z>
|| cachePatterns.booleanValue()) {<z>
get(pattern);<z>
{<z>
;<z>
CACHE_TURNOFF_THRESHOLD) {<z>
;<z>
matcher;<z>
{<z>
(pattern, matcher);<z>
return matcher;<z>
Object> hints) {<z>
;<z>
);<z>
, contentType, allHints);<z>
Nullable MessagePostProcessor postProcessor)<z>
throws MessagingException {<z>
);<z>
, ServerWebExchange exchange) throws Exception {<z>
= null;<z>
keySet()) {<z>
.matches(lookupPath)) {<z>
<>());<z>
;<z>
== null) {<z>
return null;<z>
> 1) {<z>
;<z>
()) {<z>
"Matching patterns " + matches);<z>
);<z>
pathWithinMapping = pattern.extractPathWithinPattern(lookupPath);<z>
= pattern.matchAndExtract(lookupPath);<z>
Assert.notNull(matchInfo, "Expected a match");<z>
= this.handlerMap.get(pattern);<z>
) {<z>
().getBean(handlerName);<z>
{<z>
null;<z>
exchange);<z>
handler);<z>
(BEST_MATCHING_PATTERN_ATTRIBUTE, pattern);<z>
pathWithinMapping);<z>
(URI_TEMPLATE_VARIABLES_ATTRIBUTE, matchInfo.getUriVariables());<z>
return handler;<z>
createRequestConfig(Object client) {<z>
Configurable) {<z>
(Configurable) client).getConfig();<z>
mergeRequestConfig(clientRequestConfig);<z>
this.requestConfig;<z>
(Class<? extends Annotation> annotationType)<z>
{<z>
assertBeanFactoryActive();<z>
return getBeanFactory().getBeansWithAnnotation(annotationType);<z>
(String alias) {<z>
.aliasMap) {<z>
this.aliasMap.remove(alias);<z>
null) {<z>
);<z>
attribute) {<z>
) {<z>
.visitAttribute(attribute);<z>
, DependencyDescriptor descriptor) {<z>
(String beanName : this.beanDefinitionNames) {<z>
(beanName);<z>
?> targetType = mbd.getTargetType();<z>
.isAssignableFrom(targetType) &&<z>
())) {<z>
false);<z>
class ?<z>
));<z>
!type.isAssignableFrom(beanType)) {<z>
;<z>
(NoSuchBeanDefinitionException ex) {<z>
parent = getParentBeanFactory();<z>
DefaultListableBeanFactory) {<z>
type, descriptor);<z>
) {<z>
.aspectBeanName != null &&<z>
.beanFactory.isSingleton(this.aspectBeanName) &&<z>
Ordered.class)) {<z>
);<z>
;<z>
ClassInfo getClassInfo(final Class clazz) {<z>
= Type.getType(clazz);<z>
(clazz.getSuperclass());<z>
return new ClassInfo() {<z>
Type getType() {<z>
return type;<z>
) {<z>
sc;<z>
{<z>
clazz.getInterfaces());<z>
public int getModifiers() {<z>
();<z>
?> clazz, MutablePropertyValues pvs) throws BeansException {<z>
);<z>
);<z>
clazz);<z>
);<z>
.registerBeanDefinition(name, bd);<z>
?> sourceClass) {<z>
.get(targetClass);<z>
member, sourceClass)) {<z>
return member;<z>
;<z>
== null) {<z>
(targetClass, sourceClass);<z>
null) {<z>
= determineFactoryConstructor(targetClass, sourceClass);<z>
(member == null) {<z>
return null;<z>
);<z>
;<z>
, @Nullable Object value) {<z>
);<z>
.put(name, value);<z>
;<z>
void initializeWithMetaData(DatabaseMetaData databaseMetaData) throws SQLException {<z>
);<z>
supportsGetGeneratedKeys()) {<z>
{<z>
("Overriding supportsGetGeneratedKeys from DatabaseMetaData to 'true'; it was reported as " +<z>
);<z>
this.supportsGeneratedKeysOverride = true;<z>
resourceHandlerMapping(<z>
"mvcContentNegotiationManager") ContentNegotiationManager contentNegotiationManager,<z>
,<z>
Qualifier("mvcResourceUrlProvider") ResourceUrlProvider resourceUrlProvider) {<z>
);<z>
"No ServletContext set");<z>
();<z>
registry = new ResourceHandlerRegistry(this.applicationContext,<z>
));<z>
(registry);<z>
AbstractHandlerMapping handlerMapping = registry.getHandlerMapping();<z>
{<z>
null;<z>
(pathConfig.getPatternParser() != null) {<z>
setPatternParser(pathConfig.getPatternParser());<z>
setUrlPathHelper(pathConfig.getUrlPathHelperOrDefault());<z>
setPathMatcher(pathConfig.getPathMatcherOrDefault());<z>
conversionService, resourceUrlProvider));<z>
);<z>
handlerMapping;<z>
() {<z>
) {<z>
;<z>
this.initedViaDeclaredInitMethod) {<z>
new RuntimeException("Factory called declared init method twice");<z>
.initedViaDeclaredInitMethod = true;<z>
) {<z>
) {<z>
return str;<z>
str.strip();<z>
ServerHttpResponse response,<z>
selectedExtensions,<z>
attributes)<z>
throws HandshakeFailureException {<z>
class, request, "ServletServerHttpRequest required");<z>
getServletRequest();<z>
getServletContext();<z>
.class, response, "ServletServerHttpResponse required");<z>
getServletResponse();<z>
, user);<z>
;<z>
= (upgradeRequest, upgradeResponse) -> {<z>
{<z>
.setAcceptedSubProtocol(selectedProtocol);<z>
handlerAdapter;<z>
servletContext);<z>
(webSocketCreator, servletRequest, servletResponse);<z>
catch (UndeclaredThrowableException ex) {<z>
("Failed to upgrade", ex.getUndeclaredThrowable());<z>
) {<z>
"Failed to upgrade", ex);<z>
String pattern) {<z>
getRequiredValue(name);<z>
pattern + "]";<z>
pattern)));<z>
;<z>
Mono<Integer> sumRowsUpdated(<z>
, Connection it) {<z>
it)<z>
.flatMap(Result::getRowsUpdated)<z>
Collectors.summingInt(Integer::intValue));<z>
{<z>
.clear();<z>
) {<z>
prefixes) {<z>
;<z>
prefix);<z>
, Throwable exception) {<z>
exception);<z>
{<z>
logger);<z>
(String content) {<z>
content);<z>
+ this.expression + "\"";<z>
.assertTrue(reason, value != null);<z>
&& value instanceof List<?> list) {<z>
, !list.isEmpty());<z>
value;<z>
connectionFactory,<z>
) {<z>
= bindMarkersFactory;<z>
;<z>
;<z>
: null);<z>
void registerDefaultFilters() {<z>
));<z>
();<z>
add(new AnnotationTypeFilter(<z>
, cl)), false));<z>
("JSR-250 'jakarta.annotation.ManagedBean' found and supported for component scanning");<z>
{<z>
(<z>
cl)), false));<z>
;<z>
ex) {<z>
public String filename() {<z>
getFilename();<z>
"No filename found");<z>
;<z>
Element element, ParserContext parserContext, BeanDefinition beanDef) {<z>
> includePatterns = new ManagedList<>();<z>
= element.getChildNodes();<z>
; i++) {<z>
childNodes.item(i);<z>
(node instanceof Element includeElement) {<z>
.getAttribute("name"));<z>
);<z>
.add(valueHolder);<z>
if (!includePatterns.isEmpty()) {<z>
);<z>
.add("includePatterns", includePatterns);<z>
TokenBuffer> parseTokenBufferFlux() throws IOException {<z>
result = new ArrayList<>();<z>
false;<z>
.isClosed()) {<z>
= this.parser.nextToken();<z>
token == JsonToken.NOT_AVAILABLE ||<z>
&& previousNull) {<z>
) {<z>
= true;<z>
false;<z>
;<z>
) {<z>
processTokenNormal(token, result);<z>
);<z>
;<z>
> handleConversionNotSupported(<z>
HttpHeaders headers, HttpStatus status, WebRequest request) {<z>
, request);<z>
(@Nullable String... names) {<z>
(isCompiled()) {<z>
new InvalidDataAccessApiUsageException(<z>
;<z>
.generatedKeysColumnNames = names;<z>
(String... messages) throws SockJsMessageDeliveryException {<z>
.length; i++) {<z>
if (isClosed()) {<z>
logUndeliveredMessages(i, messages);<z>
);<z>
catch (Exception ex) {<z>
()) {<z>
) {<z>
);<z>
messages);<z>
);<z>
messageHeaders) {<z>
, "Payload must not be null");<z>
notNull(messageHeaders, "MessageHeaders must not be null");<z>
) {<z>
ErrorMessage((Throwable) payload, messageHeaders);<z>
GenericMessage<>(payload, messageHeaders);<z>
endDocument() throws SAXException {<z>
;<z>
);<z>
ex) {<z>
);<z>
Type type, @Nullable MediaType contentType,<z>
{<z>
.getHeaders();<z>
(headers, t, contentType);<z>
outputMessage instanceof StreamingHttpOutputMessage streamingOutputMessage) {<z>
HttpOutputMessage() {<z>
() {<z>
return outputStream;<z>
getHeaders() {<z>
;<z>
);<z>
writeInternal(t, type, outputMessage);<z>
();<z>
beanName) {<z>
targetSource =<z>
beanClass, beanName);<z>
(targetSource == null) {<z>
;<z>
if (logger.isDebugEnabled()) {<z>
.debug("Configuring AbstractBeanFactoryBasedTargetSource: " + targetSource);<z>
getInternalBeanFactoryForBean(beanName);<z>
(beanName);<z>
new GenericBeanDefinition(bd);<z>
()) {<z>
.setScope(BeanDefinition.SCOPE_PROTOTYPE);<z>
);<z>
setTargetBeanName(beanName);<z>
setBeanFactory(internalBeanFactory);<z>
return targetSource;<z>
;<z>
)<z>
String[] value() default {};<z>
(MvcResult result) throws Exception {<z>
);<z>
(result.getRequest());<z>
;<z>
result.getInterceptors());<z>
printHeading("Async");<z>
;<z>
this.printer.printHeading("Resolved Exception");<z>
getResolvedException());<z>
;<z>
(result.getModelAndView());<z>
printHeading("FlashMap");<z>
getRequest()));<z>
printHeading("MockHttpServletResponse");<z>
));<z>
) {<z>
);<z>
boolean newTask = false;<z>
{<z>
ScheduledTask(task);<z>
;<z>
{<z>
> 0) {<z>
;<z>
scheduledTask.future =<z>
startTime, task.getInterval());<z>
future =<z>
task.getInterval());<z>
(task);<z>
scheduledTask);<z>
);<z>
[] getResources(String locationPattern) throws IOException {<z>
;<z>
CLASSPATH_ALL_URL_PREFIX)) {<z>
.length()))) {<z>
(locationPattern);<z>
(CLASSPATH_ALL_URL_PREFIX.length()));<z>
locationPattern.indexOf("*/") + 1 :<z>
);<z>
))) {<z>
return findPathMatchingResources(locationPattern);<z>
;<z>
@Nullable ResourceLoader resourceLoader) {<z>
{<z>
) resourceLoader;<z>
(resourceLoader != null) {<z>
return new PathMatchingResourcePatternResolver(resourceLoader);<z>
;<z>
(<z>
String> namespaces, Object[] args) {<z>
);<z>
catch (XPathExpressionException ex) {<z>
, ex);<z>
public StreamingSockJsSession createSession(<z>
, Object> attributes) {<z>
, getServiceConfig(), handler, attributes);<z>
triggerContext) {<z>
Date date = triggerContext.lastCompletionTime();<z>
if (date != null) {<z>
();<z>
before(scheduled)) {<z>
scheduled;<z>
);<z>
toInstant(), this.zoneId);<z>
(dateTime);<z>
)) : null);<z>
, WebSocketHandler webSocketHandler,<z>
sockJsSession) {<z>
);<z>
webSocketHandler, "webSocketHandler must not be null");<z>
.notNull(sockJsSession, "session must not be null");<z>
serviceConfig;<z>
.sockJsSession = sockJsSession;<z>
);<z>
subProtocols = ((webSocketHandler instanceof SubProtocolCapable) ?<z>
.emptyList());<z>
InputStream body, HttpStatus statusCode) {<z>
;<z>
(statusCode, "HttpStatus is required");<z>
status = statusCode;<z>
headers) {<z>
.view = view;<z>
emptyMap());<z>
status;<z>
? headers : EMPTY_HEADERS);<z>
>> prefixes) {<z>
;<z>
prefixes.entrySet().stream()<z>
))<z>
;<z>
propertyName) {<z>
.propertyValueList) {<z>
{<z>
;<z>
null;<z>
> toMultiValueMap(<z>
, MultiValueMap<String, Object>> finisher,<z>
{<z>
?<z>
: NO_CHARACTERISTICS);<z>
::new,<z>
adaptations).forEach(map::add),<z>
);<z>
equals(@Nullable Object other) {<z>
) {<z>
true;<z>
(other == null) {<z>
return false;<z>
JdkDynamicAopProxy otherProxy;<z>
{<z>
(JdkDynamicAopProxy) other;<z>
{<z>
.getInvocationHandler(other);<z>
JdkDynamicAopProxy)) {<z>
false;<z>
) ih;<z>
;<z>
;<z>
<? extends String, ?> map) {<z>
)) {<z>
entry.getValue());<z>
String attributeName, ResolvableType attributeType,<z>
context, ServerWebExchange exchange) {<z>
get(attributeName);<z>
{<z>
.getModel(), attributeName);<z>
null) {<z>
exchange);<z>
.getAdapter(null, attribute);<z>
adapter != null) {<z>
), "Data binding only supports single-value async types");<z>
));<z>
.justOrEmpty(attribute);<z>
locale) {<z>
;<z>
instanceof DecimalFormat) {<z>
) format).setParseBigDecimal(true);<z>
;<z>
REQUIRED;<z>
.DEFAULT;<z>
.TIMEOUT_DEFAULT;<z>
() default "";<z>
;<z>
};<z>
) {<z>
addAdvisor(namedBeanToAdvisor(next));<z>
, boolean condition) {<z>
!condition) {<z>
(message);<z>
{<z>
= dataBuffer.readableByteCount();<z>
bytes = new byte[bufferSize];<z>
bytes);<z>
dataBuffer);<z>
.length);<z>
result = parseTokenBufferFlux();<z>
);<z>
result;<z>
{<z>
getOriginalMessage(), ex);<z>
catch (IOException ex) {<z>
propagate(ex);<z>
setInterceptors(HandshakeInterceptor... interceptors) {<z>
();<z>
!ObjectUtils.isEmpty(interceptors)) {<z>
));<z>
;<z>
... pathSegments) {<z>
isEmpty(pathSegments)) {<z>
.class);<z>
(FullPathComponentBuilder.class);<z>
if (psBuilder == null) {<z>
= new PathSegmentComponentBuilder();<z>
.add(psBuilder);<z>
!= null) {<z>
;<z>
pathSegments);<z>
int[] doExecuteBatch(SqlParameterSource... batch) {<z>
;<z>
;<z>
for (SqlParameterSource parameterSource : batch) {<z>
matchInParameterValuesWithInsertColumns(parameterSource));<z>
;<z>
reason) {<z>
;<z>
null;<z>
.emptyList();<z>
= null;<z>
{<z>
connectionInitialized) {<z>
;<z>
catch (JMSException ex) {<z>
throw new CannotCreateTransactionException(<z>
;<z>
;<z>
{<z>
if (this.initParamName == null) {<z>
("initParamName is required");<z>
(this.initParamName);<z>
== null) {<z>
);<z>
(String text) throws IllegalArgumentException {<z>
setAsText(text);<z>
this.resourceEditor.getValue();<z>
getReader() : null);<z>
catch (IOException ex) {<z>
ex);<z>
) {<z>
adapter.getClass().getName();<z>
if (adapterClassName.endsWith(RESOURCE_ADAPTER_SUFFIX)) {<z>
providerName =<z>
());<z>
= providerName + ACTIVATION_SPEC_SUFFIX;<z>
;<z>
) {<z>
isDebugEnabled()) {<z>
("No default <Provider>ActivationSpec class found: " + specClassName);<z>
endsWith(RESOURCE_ADAPTER_IMPL_SUFFIX)){<z>
=<z>
) - RESOURCE_ADAPTER_IMPL_SUFFIX.length());<z>
= providerName + ACTIVATION_SPEC_IMPL_SUFFIX;<z>
specClassName);<z>
ClassNotFoundException ex) {<z>
isDebugEnabled()) {<z>
;<z>
+ 1);<z>
+ ACTIVATION_SPEC_IMPL_SUFFIX;<z>
specClassName);<z>
ex) {<z>
logger.isDebugEnabled()) {<z>
);<z>
+ ACTIVATION_SPEC_IMPL_SUFFIX;<z>
.loadClass(specClassName);<z>
) {<z>
)) {<z>
logger.debug("No default ActivationSpecImpl class found in inbound subpackage: " + specClassName);<z>
"No ActivationSpec class defined - " +<z>
);<z>
> advisors) {<z>
other);<z>
targetSource;<z>
= other.advisorChainFactory;<z>
<>(other.interfaces);<z>
{<z>
if (advisor instanceof IntroductionAdvisor) {<z>
IntroductionAdvisor) advisor);<z>
;<z>
advisors.add(advisor);<z>
adviceChanged();<z>
{<z>
, args, locale);<z>
{<z>
;<z>
(defaultMessage == null) {<z>
);<z>
;<z>
doWithAnnotations(Object type, int aggregateIndex,<z>
{<z>
: annotations) {<z>
(annotation)) {<z>
source, annotation);<z>
(result != null) {<z>
return result;<z>
null;<z>
() {<z>
.doFinally();<z>
;<z>
= null;<z>
previousRequestStatus = null;<z>
Set<A> getAllMergedAnnotations(<z>
element, Class<A> annotationType) {<z>
).stream(annotationType)<z>
toAnnotationSet());<z>
.emptyList()) {<z>
void checkConfigMembers(RootBeanDefinition beanDefinition) {<z>
void invokeInitMethods(Object target, String beanName) {<z>
String beanName) {<z>
hasDestroyMethods() {<z>
return false;<z>
response, Object handler)<z>
{<z>
HandlerMethod) handler);<z>
updateResponse(ServerHttpResponse response, Throwable ex) {<z>
result = false;<z>
ex);<z>
;<z>
if (code != -1) {<z>
code)) {<z>
instanceof ResponseStatusException) {<z>
((ResponseStatusException) ex).getResponseHeaders()<z>
forEach((name, values) -><z>
;<z>
true;<z>
cause = ex.getCause();<z>
if (cause != null) {<z>
= updateResponse(response, cause);<z>
;<z>
> getResourcePaths(String path) {<z>
path + "/");<z>
String resourceLocation = getResourceLocation(actualPath);<z>
resource = null;<z>
);<z>
= resource.getFile();<z>
file.list();<z>
.isEmpty(fileList)) {<z>
return null;<z>
new LinkedHashSet<>(fileList.length);<z>
{<z>
actualPath + fileEntry;<z>
()) {<z>
resultPath += "/";<z>
resourcePaths.add(resultPath);<z>
return resourcePaths;<z>
{<z>
isDebugEnabled()) {<z>
"Could not get resource paths for " +<z>
resourceLocation), ex);<z>
null;<z>
{<z>
jstlPresent) {<z>
());<z>
if (locale != null) {<z>
return locale;<z>
return getRequest().getLocale();<z>
> parseMatrixVariables(String matrixVariables) {<z>
> result = new LinkedMultiValueMap<>();<z>
!StringUtils.hasText(matrixVariables)) {<z>
result;<z>
);<z>
(pairs.hasMoreTokens()) {<z>
pair = pairs.nextToken();<z>
);<z>
{<z>
, index);<z>
)) {<z>
index + 1);<z>
{<z>
);<z>
add(pair, "");<z>
result;<z>
synchronizationManager) throws TransactionException {<z>
new ConnectionFactoryTransactionObject();<z>
);<z>
txObject.setConnectionHolder(conHolder, false);<z>
return txObject;<z>
exchange) {<z>
Mono<?>> asyncAttributes = null;<z>
: model.entrySet()) {<z>
);<z>
(value == null) {<z>
(null, value);<z>
null) {<z>
(asyncAttributes == null) {<z>
= new ArrayList<>();<z>
String name = entry.getKey();<z>
{<z>
asyncAttributes.add(<z>
toPublisher(value))<z>
)<z>
put(name, result)));<z>
.add(<z>
toPublisher(value))<z>
{<z>
) {<z>
(name, result);<z>
name, result, model, exchange);<z>
name);<z>
));<z>
: Mono.empty();<z>
, ResolvableType elementType,<z>
Map<String, Object> hints) {<z>
()];<z>
read(result);<z>
dataBuffer);<z>
if (logger.isDebugEnabled()) {<z>
+ "Read " + result.length + " bytes");<z>
result;<z>
public void setBeanFactory(BeanFactory beanFactory) throws BeansException {<z>
.endpointProvider != null) {<z>
beanFactory);<z>
configure(<z>
keyGenerator,<z>
Supplier<CacheManager> cacheManager) {<z>
);<z>
>(keyGenerator, SimpleKeyGenerator::new);<z>
SingletonSupplier<>(cacheResolver,<z>
(cacheManager)));<z>
setConversionService(@Nullable ConversionService conversionService) {<z>
.conversionService == null, "DataBinder is already initialized with ConversionService");<z>
;<z>
conversionService != null) {<z>
initConversion(conversionService);<z>
uriComponents) {<z>
(this.contextPath == null) {<z>
();<z>
()) {<z>
.setContextPath("");<z>
+ pathSegments.get(0));<z>
();<z>
&& path.startsWith(this.contextPath),<z>
.getPath() +<z>
"\" should start with context path \"" + this.contextPath + "\"");<z>
contextPath);<z>
contentType) {<z>
-> {<z>
getContentType();<z>
!= null);<z>
) {<z>
,<z>
));<z>
HttpServletRequest request) {<z>
= UrlPathHelper.getResolvedLookupPath(request);<z>
;<z>
: null;<z>
(String beanName, RootBeanDefinition mbd) {<z>
{<z>
;<z>
instance;<z>
(beanName);<z>
mbd);<z>
instance == null) {<z>
, null);<z>
instance = bw.getWrappedInstance();<z>
{<z>
ex;<z>
BeanCreationException ex) {<z>
{<z>
ex);<z>
onSuppressedException(ex);<z>
return null;<z>
(beanName);<z>
, instance);<z>
void setPatterns(String... patterns) {<z>
;<z>
patterns.length];<z>
) {<z>
.strip();<z>
);<z>
username, String password) throws JMSException {<z>
ConnectionFactory target = obtainTargetConnectionFactory();<z>
QueueConnectionFactory) {<z>
target).createQueueConnection(username, password);<z>
);<z>
con instanceof QueueConnection)) {<z>
new jakarta.jms.IllegalStateException("'targetConnectionFactory' is not a QueueConnectionFactory");<z>
;<z>
() {<z>
t = classLoader;<z>
null) {<z>
getDefaultClassLoader();<z>
== null) {<z>
).getClassLoader();<z>
== null) {<z>
);<z>
t == null) {<z>
"Cannot determine classloader");<z>
return t;<z>
String name() default "";<z>
)<z>
default {};<z>
toMultiValueMap(<z>
... adaptations) {<z>
(Function.identity(), adaptations);<z>
> toEntityList(Class<T> elementClass) {<z>
-><z>
response,<z>
));<z>
String destination) {<z>
if (destination == null) {<z>
null;<z>
(getDestinationPrefixes())) {<z>
;<z>
: getDestinationPrefixes()) {<z>
) {<z>
.slashPathSeparator) {<z>
() - 1);<z>
length());<z>
;<z>
, BrowserCallback<T> action) throws JmsException {<z>
();<z>
(defaultQueue != null) {<z>
, action);<z>
getRequiredDefaultDestinationName(), messageSelector, action);<z>
() throws JspException {<z>
;<z>
) {<z>
argument = this.value;<z>
(getBodyContent() != null) {<z>
();<z>
ArgumentAware.class);<z>
== null) {<z>
JspException("The argument tag must be a descendant of a tag that supports arguments");<z>
addArgument(argument);<z>
return EVAL_PAGE;<z>
throws NamingException {<z>
overrideThreadContextClassLoader(this.beanClassLoader);<z>
();<z>
) {<z>
;<z>
catch (NamingException ex) {<z>
defaultObject != null) {<z>
{<z>
"JNDI lookup failed - returning specified default object instead", ex);<z>
logger.isDebugEnabled()) {<z>
("JNDI lookup failed - returning specified default object instead: " + ex);<z>
return this.defaultObject;<z>
throw ex;<z>
if (originalClassLoader != null) {<z>
().setContextClassLoader(originalClassLoader);<z>
> checkWriteOptions(OpenOption[] options) {<z>
length;<z>
<>(length + 3);<z>
== 0) {<z>
.CREATE);<z>
.TRUNCATE_EXISTING);<z>
{<z>
if (opt == StandardOpenOption.READ) {<z>
;<z>
;<z>
WRITE);<z>
result;<z>
{<z>
)) {<z>
null;<z>
messageSourceAccessor = null;<z>
null) {<z>
)) {<z>
(<z>
.getName() + "]");<z>
context;<z>
(context);<z>
);<z>
applicationContext != context) {<z>
new ApplicationContextException(<z>
"]");<z>
{<z>
result = null;<z>
getMimeType(resource.getFilename());<z>
if (StringUtils.hasText(mimeType)) {<z>
result = MediaType.parseMediaType(mimeType);<z>
{<z>
;<z>
filename = resource.getFilename();<z>
);<z>
ext != null) {<z>
ENGLISH));<z>
mediaType == null) {<z>
.getMediaTypes(filename);<z>
isEmpty(mediaTypes)) {<z>
mediaTypes.get(0);<z>
{<z>
;<z>
;<z>
isRemoteHost(String targetUrl) {<z>
isEmpty(getHosts())) {<z>
false;<z>
);<z>
(!StringUtils.hasLength(targetHost)) {<z>
false;<z>
(String host : getHosts()) {<z>
)) {<z>
false;<z>
return true;<z>
getDefaultDriver() {<z>
.defaultDriver == null) {<z>
, this.nameCoder);<z>
;<z>
public void handleFailure(Throwable ex) {<z>
if (this.tcpConnection != null) {<z>
getMessage(), ex);<z>
.isErrorEnabled()) {<z>
"Transport failure: " + ex);<z>
(<z>
boolean includeNonSingletons, boolean allowEagerInit) throws BeansException {<z>
, allowEagerInit);<z>
= CollectionUtils.newLinkedHashMap(beanNames.length);<z>
(String beanName : beanNames) {<z>
beanInstance = getBean(beanName);<z>
)) {<z>
T) beanInstance);<z>
{<z>
ex.getMostSpecificCause();<z>
if (rootCause instanceof BeanCurrentlyInCreationException) {<z>
BeanCreationException) rootCause;<z>
();<z>
exBeanName)) {<z>
logger.isTraceEnabled()) {<z>
+ exBeanName + "': " +<z>
));<z>
);<z>
;<z>
return result;<z>
Type, Type> matchedBefore) {<z>
Assert.notNull(other, "ResolvableType must not be null");<z>
== NONE) {<z>
false;<z>
)) {<z>
other.getComponentType()));<z>
== other.type) {<z>
true;<z>
= WildcardBounds.get(this);<z>
WildcardBounds typeBounds = WildcardBounds.get(other);<z>
if (typeBounds != null) {<z>
.isSameKind(typeBounds) &&<z>
(typeBounds.getBounds()));<z>
) {<z>
;<z>
);<z>
;<z>
<?> ourResolved = null;<z>
.type instanceof TypeVariable) {<z>
TypeVariable<?>) this.type;<z>
if (this.variableResolver != null) {<z>
this.variableResolver.resolveVariable(variable);<z>
(resolved != null) {<z>
= resolved.resolve();<z>
) {<z>
{<z>
);<z>
(resolved != null) {<z>
();<z>
checkGenerics = false;<z>
) {<z>
;<z>
) {<z>
= resolve(Object.class);<z>
?> otherResolved = other.toClass();<z>
isAssignable(ourResolved, otherResolved)) {<z>
return false;<z>
) {<z>
ourGenerics = getGenerics();<z>
;<z>
typeGenerics.length) {<z>
return false;<z>
(matchedBefore == null) {<z>
= new IdentityHashMap<>(1);<z>
;<z>
; i++) {<z>
typeGenerics[i], matchedBefore)) {<z>
;<z>
return true;<z>
void registerComponents(<z>
Element element) {<z>
(element);<z>
(element.getTagName(), source);<z>
) {<z>
;<z>
;<z>
if (element.hasAttribute(ANNOTATION_CONFIG_ATTRIBUTE)) {<z>
.getAttribute(ANNOTATION_CONFIG_ATTRIBUTE));<z>
annotationConfig) {<z>
<BeanDefinitionHolder> processorDefinitions =<z>
), source);<z>
processorDefinitions) {<z>
(processorDefinition));<z>
readerContext.fireComponentRegistered(compositeDef);<z>
params) {<z>
sb = new StringBuilder(methodName);<z>
{<z>
;<z>
toString();<z>
parserContext) {<z>
new MutablePropertyValues();<z>
.hasAttribute(RESOURCE_ADAPTER_ATTRIBUTE)) {<z>
);<z>
) {<z>
(<z>
"Listener container 'resource-adapter' attribute contains empty value.", containerEle);<z>
));<z>
activationSpecFactoryBeanName = containerEle.getAttribute(ACTIVATION_SPEC_FACTORY_ATTRIBUTE);<z>
getAttribute(DESTINATION_RESOLVER_ATTRIBUTE);<z>
(StringUtils.hasText(activationSpecFactoryBeanName)) {<z>
hasText(destinationResolverBeanName)) {<z>
error("Specify either 'activation-spec-factory' or " +<z>
;<z>
(activationSpecFactoryBeanName));<z>
(destinationResolverBeanName)) {<z>
);<z>
= containerEle.getAttribute(TRANSACTION_MANAGER_ATTRIBUTE);<z>
transactionManagerBeanName)) {<z>
, new RuntimeBeanReference(transactionManagerBeanName));<z>
String phase = containerEle.getAttribute(PHASE_ATTRIBUTE);<z>
)) {<z>
;<z>
;<z>
{<z>
request.getNativeRequest(ServletRequest.class);<z>
);<z>
ServletRequestDataBinder) binder;<z>
.bind(servletRequest);<z>
roleNames) {<z>
);<z>
(String roleName : roleNames) {<z>
.hasLength(roleName, "Role name must not be empty");<z>
add(roleName);<z>
{<z>
mockMvc, webClient, this.contextPath);<z>
this.alwaysUseMockMvc) {<z>
;<z>
this.requestMatchers.size());<z>
) {<z>
DelegateWebConnection(matcher, connection));<z>
(defaultConnection, delegates);<z>
, Adapt[] adaptations) {<z>
?> attributeType = attribute.getReturnType();<z>
attributeType.getComponentType() : attributeType);<z>
.class) {<z>
.class : String.class);<z>
.class;<z>
, String description) throws FileNotFoundException {<z>
resourceUri, "Resource URI must not be null");<z>
)) {<z>
throw new FileNotFoundException(<z>
" cannot be resolved to absolute file path " +<z>
resourceUri);<z>
getSchemeSpecificPart());<z>
matcher) {<z>
return result -> {<z>
, name);<z>
);<z>
() {<z>
;<z>
builder.defaultConfiguration();<z>
;<z>
String cleanDuplicateSlashes(String path) {<z>
sb = null;<z>
char prev = 0;<z>
) {<z>
charAt(i);<z>
prev == '/')) {<z>
== null) {<z>
path.substring(0, i));<z>
!= null) {<z>
);<z>
= curr;<z>
() : path;<z>
setAsText(@Nullable String text) throws IllegalArgumentException {<z>
) {<z>
("JndiTemplate cannot be created from null string");<z>
)) {<z>
;<z>
this.propertiesEditor.setAsText(text);<z>
propertiesEditor.getValue();<z>
);<z>
void updateExitTypeDescriptor() {<z>
cachedExecutor;<z>
executorToCheck.get() instanceof ReflectiveMethodExecutor) {<z>
;<z>
(method.getReturnType());<z>
CodeFlow.isPrimitive(descriptor)) {<z>
.originalPrimitiveExitTypeDescriptor = descriptor;<z>
toBoxedDescriptor(descriptor);<z>
this.exitTypeDescriptor = descriptor;<z>
) {<z>
) {<z>
;<z>
if (match != null) {<z>
.get(mapping)));<z>
) {<z>
;<z>
setSavepointAllowed(isNestedTransactionAllowed());<z>
emHolder = (EntityManagerHolder)<z>
.getResource(obtainEntityManagerFactory());<z>
!= null) {<z>
logger.isDebugEnabled()) {<z>
emHolder.getEntityManager() +<z>
;<z>
(emHolder, false);<z>
{<z>
ConnectionHolder)<z>
));<z>
.setConnectionHolder(conHolder);<z>
txObject;<z>
Object getValueForMirrorResolution(Method attribute, Object annotation) {<z>
indexOf(attribute);<z>
attribute.getName());<z>
, true);<z>
resolvers) {<z>
.emptyList());<z>
;<z>
.resolver;<z>
;<z>
extends Annotation>... annotationTypes) {<z>
annotationTypes);<z>
-><z>
allMatch(annotType -><z>
!= null));<z>
;<z>
context) {<z>
ManagedList<>();<z>
object : list) {<z>
(object instanceof BeanDefinitionHolder beanDef) {<z>
().getBeanClassName();<z>
Assert.notNull(className, "No resolver class");<z>
getReaderContext().getBeanClassLoader());<z>
WebArgumentResolver.class.isAssignableFrom(clazz)) {<z>
;<z>
(0, beanDef);<z>
+ "Adapter"));<z>
.add(object);<z>
return result;<z>
render(String name, Object... modelAttributes) {<z>
return new DefaultRenderingResponseBuilder(name)<z>
)<z>
.headers))<z>
.addAll(this.cookies))<z>
modelAttributes(modelAttributes)<z>
);<z>
protected MockHttpServletResponse getMockHttpServletResponse(ServletResponse response) {<z>
) {<z>
) response;<z>
HttpServletResponseWrapper) {<z>
response).getResponse());<z>
);<z>
(ClientHttpRequest request) {<z>
((MockClientHttpRequest) request);<z>
catch (Exception ex) {<z>
("Failed to parse XML request content", ex);<z>
HttpServletRequest request, HttpServletResponse response)<z>
, IOException {<z>
request, response);<z>
Class<?> intf) {<z>
proxyIntf : this.interfaces) {<z>
(intf.isAssignableFrom(proxyIntf)) {<z>
;<z>
;<z>
() {<z>
{<z>
);<z>
(DataBuffer dataBuffer) {<z>
= NO_DELIMITER;<z>
dataBuffer.writePosition(); pos++) {<z>
b = dataBuffer.getByte(pos);<z>
(NestedMatcher matcher : this.matchers) {<z>
.longestDelimiter.length) {<z>
= matcher.delimiter();<z>
) {<z>
reset();<z>
pos;<z>
1;<z>
,<z>
BeanDefinitionRegistry registry) {<z>
, "Class must not be null");<z>
);<z>
isInterface()) {<z>
throw new BeanInstantiationException(clazz, "Specified class is an interface");<z>
?<z>
));<z>
resourceLoader, registry, classLoader);<z>
);<z>
return instance;<z>
protected void establishSharedConnection() {<z>
;<z>
catch (Exception ex) {<z>
JMSException) {<z>
ex);<z>
debug("Could not establish shared JMS Connection - " +<z>
, ex);<z>
(@Nullable Object other) {<z>
{<z>
return true;<z>
) {<z>
;<z>
.beanFactory == otherAdvice.beanFactory);<z>
) {<z>
== other) {<z>
true;<z>
BeanExpressionContext otherContext)) {<z>
;<z>
this.scope == otherContext.scope);<z>
List<HandshakeInterceptor> interceptors) {<z>
.interceptors.clear();<z>
null) {<z>
addAll(interceptors);<z>
) throws IllegalStateException {<z>
this.lastTaskInfo == null) {<z>
"No tasks run: can't get last task info");<z>
return this.lastTaskInfo;<z>
) {<z>
)) {<z>
;<z>
getElementTypeDescriptor() {<z>
)) {<z>
getAnnotations());<z>
())) {<z>
class).getGeneric(0));<z>
().getGeneric(0));<z>
destroy() {<z>
if (this.useGlobalResources) {<z>
.shutdownTimeout).block();<z>
ConnectionProvider provider = this.connectionProvider;<z>
&& this.manageConnectionProvider) {<z>
;<z>
catch (Throwable ex) {<z>
LoopResources resources = this.loopResources;<z>
manageLoopResources) {<z>
.shutdownTimeout).block();<z>
{<z>
onNext(DataBuffer buf) {<z>
)) {<z>
()) {<z>
("Last boundary found in " + buf);<z>
{<z>
);<z>
buf);<z>
!= -1) {<z>
logger.isTraceEnabled()) {<z>
("End of headers found @" + endIdx + " in " + buf);<z>
addAndGet(endIdx);<z>
)) {<z>
buf, endIdx);<z>
.add(headerBuf);<z>
, endIdx);<z>
);<z>
());<z>
, bodyBuf);<z>
.readableByteCount());<z>
)) {<z>
.add(buf);<z>
();<z>
value) {<z>
return result -> {<z>
result.getResponse();<z>
(name);<z>
, headerValue);<z>
headers = new HttpHeaders();<z>
);<z>
("actual", headerValue);<z>
"' " +<z>
headers.getFirst("expected") + "'",<z>
);<z>
() throws Exception {<z>
notNull(this.host, "Host must not be null");<z>
);<z>
"No HttpHandler configured");<z>
"Cannot reconfigure while running");<z>
(this.lifecycleMonitor) {<z>
initServer();<z>
(Resource resource) {<z>
null;<z>
getFilename());<z>
(mimeType)) {<z>
parseMediaType(mimeType);<z>
APPLICATION_OCTET_STREAM.equals(mediaType)) {<z>
resource);<z>
if (superMediaType != null) {<z>
= superMediaType;<z>
return mediaType;<z>
{<z>
.webAppContext.getServletContext();<z>
;<z>
= WebApplicationContextUtils.getWebApplicationContext(servletContext);<z>
if (rootWac == null) {<z>
this.webAppContext;<z>
this.webAppContext.getParent();<z>
!= null) {<z>
) instanceof WebApplicationContext)) {<z>
;<z>
;<z>
ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, rootWac);<z>
;<z>
(final int opcode, final int operand) {<z>
mv != null) {<z>
opcode, operand);<z>
next(String hint) {<z>
(hint, "Name hint must not be null");<z>
(hint);<z>
this.nameLimit) {<z>
substring(0, this.nameLimit);<z>
(this.prefix + name, name);<z>
String original) {<z>
characterEntityReferences;<z>
;<z>
.length());<z>
ReactiveHttpInputMessage message) {<z>
.takeWhile(buffer -> {<z>
DataBufferUtils.release(buffer);<z>
false;<z>
;<z>
String> getDirectLookupDestinations(SimpMessageMappingInfo mapping) {<z>
);<z>
.getDestinationConditions().getPatterns()) {<z>
pattern)) {<z>
result.add(pattern);<z>
return result;<z>
Class<? extends Endpoint> endpointClass) {<z>
path, "Path must not be empty");<z>
;<z>
= path;<z>
= null;<z>
endpointProvider = new BeanCreatingHandlerProvider<>(endpointClass);<z>
() {<z>
.getStatus();<z>
== Status.STATUS_ROLLEDBACK);<z>
{<z>
throw new TransactionSystemException("JTA failure on getStatus", ex);<z>
path(String pattern) {<z>
;<z>
) {<z>
pattern = "/" + pattern;<z>
);<z>
ClassPathXmlApplicationContext(<z>
, @Nullable ApplicationContext parent)<z>
throws BeansException {<z>
);<z>
(configLocations);<z>
(refresh) {<z>
();<z>
getOrCreate(String namedParameter) {<z>
.computeIfAbsent(<z>
());<z>
if (reference.isEmpty()) {<z>
NamedParameter param = new NamedParameter(namedParameter);<z>
;<z>
;<z>
identifiable) {<z>
0);<z>
new NamedParameter(namedParameter);<z>
param);<z>
;<z>
Method method, Class<?> handlerType) {<z>
method);<z>
!= null) {<z>
typeCondition = getCondition(handlerType);<z>
typeCondition != null) {<z>
combine(methodCondition);<z>
methodCondition;<z>
, ObjectFactory<?> singletonFactory) {<z>
(singletonFactory, "Singleton factory must not be null");<z>
) {<z>
)) {<z>
.singletonFactories.put(beanName, singletonFactory);<z>
.remove(beanName);<z>
(beanName);<z>
duration) throws InterruptedException {<z>
);<z>
{<z>
created.forEach(info -> {<z>
{<z>
throw info.getError();<z>
);<z>
catch (AssertionError ex) {<z>
(start.plus(duration))) {<z>
;<z>
50);<z>
MethodResolver> initMethodResolvers() {<z>
resolvers = this.methodResolvers;<z>
null) {<z>
= new ArrayList<>(1);<z>
);<z>
add(this.reflectiveMethodResolver);<z>
methodResolvers = resolvers;<z>
resolvers;<z>
) {<z>
;<z>
= nioBuffer.position();<z>
> messages = decodeInternal(nioBuffer);<z>
;<z>
return messages;<z>
String toString() {<z>
;<z>
(value == null) {<z>
builder = new StringBuilder();<z>
(builder);<z>
= builder.toString();<z>
toStringValue = value;<z>
;<z>
String toString() {<z>
StringBuilder();<z>
httpMethod);<z>
);<z>
.isEmpty()) {<z>
());<z>
.length() == 0) {<z>
("Not yet initialized");<z>
;<z>
SQLException {<z>
.content != null) {<z>
new ByteArrayInputStream(this.content);<z>
binaryStream : StreamUtils.emptyInput());<z>
public MethodArgumentResolutionException(<z>
@Nullable Throwable cause) {<z>
": " + description, cause);<z>
= parameter;<z>
ScheduledExecutorService scheduledExecutor) {<z>
if (scheduledExecutor != null) {<z>
;<z>
!= null &&<z>
isInstance(scheduledExecutor));<z>
= Executors.newSingleThreadScheduledExecutor();<z>
= false;<z>
scheduledExecutor;<z>
DatabaseMetaData databaseMetaData,<z>
, @Nullable String tableName) {<z>
tableMeta = new HashMap<>();<z>
null;<z>
(<z>
tableName), null);<z>
.next()) {<z>
);<z>
));<z>
);<z>
setTableName(tables.getString("TABLE_NAME"));<z>
) == null) {<z>
() : "", tmd);<z>
tmd);<z>
ex) {<z>
logger.isWarnEnabled()) {<z>
.getMessage());<z>
tables);<z>
)) {<z>
.isInfoEnabled()) {<z>
tableName + "': column names must be provided");<z>
findTableMetaData(schemaName, tableName, tableMeta));<z>
) throws XMLStreamException {<z>
.START_ELEMENT) {<z>
new XMLStreamException("Parser must be on START_ELEMENT to read next text", getLocation());<z>
);<z>
);<z>
{<z>
|| eventType == XMLStreamConstants.CDATA ||<z>
|| eventType == XMLStreamConstants.ENTITY_REFERENCE) {<z>
);<z>
if (eventType == XMLStreamConstants.PROCESSING_INSTRUCTION ||<z>
) {<z>
.END_DOCUMENT) {<z>
XMLStreamException("Unexpected end of document when reading element text content",<z>
());<z>
eventType == XMLStreamConstants.START_ELEMENT) {<z>
("Element text content may not contain START_ELEMENT", getLocation());<z>
));<z>
();<z>
();<z>
public void doSetup() {<z>
getMessageHeaders());<z>
uniqueIdGenerator = new AtomicInteger();<z>
registry = new DefaultSubscriptionRegistry();<z>
setCacheLimit(this.cacheSizeLimit);<z>
specialization) ? "someSelector" : null);<z>
)<z>
-> "/some/destination/" + i)<z>
]::new);<z>
)<z>
+ i)<z>
]::new);<z>
) {<z>
) {<z>
registerSubscriptions(sessionId, destinationId);<z>
offset, int length) {<z>
(source, "Byte array must not be null");<z>
ensureCapacity(length);<z>
;<z>
= this.writePosition + length;<z>
limit(limit);<z>
put(source, offset, length);<z>
.writePosition += length;<z>
this;<z>
@Nullable List<HandlerMethodArgumentResolver> argumentResolvers) {<z>
(argumentResolvers == null) {<z>
this.initBinderArgumentResolvers = null;<z>
= new HandlerMethodArgumentResolverComposite();<z>
);<z>
<?> message) {<z>
.getParameterAnnotation(Payload.class);<z>
expression())) {<z>
new IllegalStateException("@Payload SpEL expressions not supported by this resolver");<z>
(message);<z>
mimeType != null ? mimeType : MimeTypeUtils.APPLICATION_OCTET_STREAM;<z>
content = extractContent(parameter, message);<z>
;<z>
void validateLocalePart(String localePart) {<z>
.length(); i++) {<z>
localePart.charAt(i);<z>
) {<z>
new IllegalArgumentException(<z>
);<z>
Task<T> task) {<z>
TaskOption.RESIZE);<z>
RESTRUCTURE_BEFORE)) {<z>
;<z>
() == 0) {<z>
null);<z>
;<z>
;<z>
index];<z>
, key, hash);<z>
;<z>
entries = value -> {<z>
("unchecked")<z>
);<z>
(newEntry, hash, head);<z>
[index] = newReference;<z>
this.count.incrementAndGet();<z>
(ref, entry, entries);<z>
unlock();<z>
TaskOption.RESTRUCTURE_AFTER)) {<z>
);<z>
adapter, ResolvableType type) {<z>
)) {<z>
return VOID_RESOLVABLE_TYPE;<z>
(type != ResolvableType.NONE) {<z>
type;<z>
return OBJECT_RESOLVABLE_TYPE;<z>
) {<z>
{<z>
DestructionAwareBeanPostProcessor processor : this.beanPostProcessors) {<z>
.bean, this.beanName);<z>
if (this.invokeDisposableBean) {<z>
if (logger.isTraceEnabled()) {<z>
("Invoking destroy() on bean with name '" + this.beanName + "'");<z>
.bean).destroy();<z>
Throwable ex) {<z>
.beanName + "'";<z>
) {<z>
msg, ex);<z>
(msg + ": " + ex);<z>
invokeAutoCloseable) {<z>
()) {<z>
+ this.beanName + "'");<z>
.bean).close();<z>
(Throwable ex) {<z>
+ this.beanName + "'";<z>
(logger.isDebugEnabled()) {<z>
logger.warn(msg, ex);<z>
warn(msg + ": " + ex);<z>
(this.destroyMethod != null) {<z>
(this.destroyMethod);<z>
!= null) {<z>
methodToInvoke = determineDestroyMethod(this.destroyMethodName);<z>
null) {<z>
));<z>
Void> resetConnection() {<z>
.target.get();<z>
connection == null) {<z>
empty();<z>
Mono.defer(() -> {<z>
(connection, null)) {<z>
this.connection = null;<z>
connection.close());<z>
Mono.empty();<z>
});<z>
> getTargetClass() {<z>
(this.cachedObject != null) {<z>
this.cachedObject.getClass();<z>
this.targetClass != null) {<z>
targetClass;<z>
return getExpectedType();<z>
@Nullable String parentName) {<z>
if (parentName != null) {<z>
IllegalArgumentException("Root bean cannot be changed into a child bean with parent reference");<z>
Context context)<z>
{<z>
);<z>
return null;<z>
public void clear() {<z>
clear();<z>
false;<z>
null;<z>
ObjectRetrievalFailureException(String persistentClassName, Object identifier) {<z>
(persistentClassName, identifier,<z>
+ "] with identifier [" + identifier + "]: not found",<z>
);<z>
element) {<z>
useDefaultFilters = true;<z>
if (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) {<z>
));<z>
parserContext.getReaderContext(), useDefaultFilters);<z>
());<z>
().getAutowireCandidatePatterns());<z>
RESOURCE_PATTERN_ATTRIBUTE)) {<z>
));<z>
(element, scanner);<z>
) {<z>
);<z>
parseScope(element, scanner);<z>
(Exception ex) {<z>
));<z>
);<z>
;<z>
) {<z>
) {<z>
).getSimpleName())) {<z>
return true;<z>
;<z>
boolean isAllowed(int c) {<z>
{<z>
false;<z>
) || '/' == c || '?' == c;<z>
= ClassUtils.isPresent("com.fasterxml.jackson.databind.ObjectMapper", classLoader) &&<z>
;<z>
ClassUtils.isPresent("com.fasterxml.jackson.dataformat.xml.XmlMapper", classLoader);<z>
;<z>
);<z>
ClassUtils.isPresent("com.google.gson.Gson", classLoader);<z>
"jakarta.json.bind.Jsonb", classLoader);<z>
= ClassUtils.isPresent("kotlinx.serialization.json.Json", classLoader);<z>
private ApplicationContext applicationContext;<z>
ServletContext servletContext;<z>
List<Object> interceptors;<z>
private PathMatchConfigurer pathMatchConfigurer;<z>
ContentNegotiationManager contentNegotiationManager;<z>
argumentResolvers;<z>
;<z>
<?>> messageConverters;<z>
private Map<String, CorsConfiguration> corsConfigurations;<z>
;<z>
) {<z>
applicationContext;<z>
exporter, AnnotationAttributes enableMBeanExport) {<z>
server = enableMBeanExport.getString("server");<z>
&& this.environment != null) {<z>
;<z>
StringUtils.hasText(server)) {<z>
!= null, "No BeanFactory set");<z>
MBeanServer.class));<z>
create(<z>
final SymbolTable symbolTable,<z>
final int typeRef,<z>
typePath,<z>
String descriptor,<z>
) {<z>
new ByteVector();<z>
.putTarget(typeRef, typeAnnotation);<z>
TypePath.put(typePath, typeAnnotation);<z>
putShort(0);<z>
AnnotationWriter(<z>
symbolTable, true, typeAnnotation, previousAnnotation);<z>
getJaxbContext() {<z>
= this.jaxbContext;<z>
{<z>
return context;<z>
.jaxbContextMonitor) {<z>
jaxbContext;<z>
context == null) {<z>
) {<z>
createJaxbContextFromContextPath(this.contextPath);<z>
.isEmpty(this.classesToBeBound)) {<z>
;<z>
packagesToScan)) {<z>
packagesToScan);<z>
.newInstance();<z>
.jaxbContext = context;<z>
(JAXBException ex) {<z>
);<z>
context;<z>
MediaType> resolveMediaTypes(NativeWebRequest webRequest)<z>
throws HttpMediaTypeNotAcceptableException {<z>
getMediaTypeKey(webRequest));<z>
isBoolean() {<z>
) {<z>
ParseException {<z>
;<z>
int startIndex, int endIndex) {<z>
;<z>
startIndex = startIndex;<z>
endIndex;<z>
Part> getParts() throws IOException, ServletException {<z>
> result = new LinkedList<>();<z>
.parts.values()) {<z>
(list);<z>
result;<z>
(String mediaType) {<z>
;<z>
.parseMimeType(mediaType);<z>
) {<z>
InvalidMediaTypeException(ex);<z>
type);<z>
) {<z>
;<z>
(RequestBuilder requestBuilder) throws Exception {<z>
{<z>
this.defaultRequestBuilder);<z>
= requestBuilder.buildRequest(this.servletContext);<z>
);<z>
mockResponse;<z>
HttpServletResponse servletResponse;<z>
{<z>
getResponse();<z>
);<z>
new MockHttpServletResponse();<z>
servletResponse = mockResponse;<z>
defaultResponseCharacterEncoding != null) {<z>
.defaultResponseCharacterEncoding.name());<z>
(requestBuilder instanceof SmartRequestBuilder) {<z>
) requestBuilder).postProcessRequest(request);<z>
mockResponse);<z>
setAttribute(MVC_RESULT_ATTRIBUTE, mvcResult);<z>
RequestContextHolder.getRequestAttributes();<z>
request, servletResponse));<z>
filters);<z>
, servletResponse);<z>
equals(request.getDispatcherType()) &&<z>
) {<z>
();<z>
mvcResult);<z>
(previousAttributes);<z>
{<z>
matcher) throws Exception {<z>
;<z>
this;<z>
throws Exception {<z>
mvcResult);<z>
;<z>
public MvcResult andReturn() {<z>
mvcResult;<z>
byte[] src) {<z>
== 0) {<z>
return "";<z>
DEFAULT_CHARSET);<z>
public String toString() {<z>
toString();<z>
result.endsWith("\n")) {<z>
);<z>
result;<z>
(MethodParameter methodParameter, Type targetType,<z>
converterType) {<z>
) &&<z>
getParameterAnnotation(JsonView.class) != null);<z>
private void parseResourceChain(<z>
Object source) {<z>
getAttribute("auto-registration");<z>
);<z>
ManagedList<>();<z>
);<z>
();<z>
source);<z>
, resourceTransformers, element, source);<z>
, element, source);<z>
resourceResolvers.isEmpty()) {<z>
"resourceResolvers", resourceResolvers);<z>
) {<z>
);<z>
Node node) throws XmlMappingException {<z>
streamWriter;<z>
document) {<z>
DomWriter(document, this.nameCoder);<z>
element) {<z>
this.nameCoder);<z>
IllegalArgumentException("DOMResult contains neither Document nor Element");<z>
);<z>
{<z>
nonTransactionalDataSource != null) {<z>
= this.nonTransactionalDataSource;<z>
{<z>
.applicationContext;<z>
prepareSchedulerFactory());<z>
;<z>
);<z>
{<z>
(true);<z>
Exception ex2) {<z>
debug("Scheduler shutdown exception after registration failure", ex2);<z>
;<z>
obj, @Nullable String msg) {<z>
getName() : "null");<z>
String result = "";<z>
= true;<z>
msg)) {<z>
msg)) {<z>
= msg + " ";<z>
;<z>
false;<z>
defaultMessage) {<z>
+ "] must be an instance of " + type);<z>
throw new IllegalArgumentException(result);<z>
) {<z>
.size());<z>
, getFirst(key)));<z>
singleValueMap;<z>
, MessageChannel channel) {<z>
, MessageHeaderAccessor.class);<z>
.isMutable()) {<z>
setImmutable();<z>
message;<z>
String publicId, @Nullable String systemId)<z>
throws SAXException, IOException {<z>
;<z>
&& systemId != null) {<z>
= null;<z>
;<z>
).toString();<z>
.toURL().toString();<z>
givenUrl.startsWith(systemRootUrl)) {<z>
.length());<z>
ex) {<z>
if (logger.isDebugEnabled()) {<z>
"] against system root URL", ex);<z>
= systemId;<z>
null) {<z>
(logger.isTraceEnabled()) {<z>
systemId + "] as resource [" + resourcePath + "]");<z>
resourcePath);<z>
.getInputStream());<z>
source.setPublicId(publicId);<z>
source.setSystemId(systemId);<z>
logger.isDebugEnabled()) {<z>
;<z>
) {<z>
systemId;<z>
.startsWith("http:")) {<z>
substring(5);<z>
).openStream());<z>
source.setPublicId(publicId);<z>
;<z>
(IOException ex) {<z>
.isDebugEnabled()) {<z>
);<z>
null;<z>
return source;<z>
) throws NotAcceptableStatusException {<z>
;<z>
acceptedMediaType : acceptedMediaTypes) {<z>
) && matchParameters(acceptedMediaType)) {<z>
;<z>
return false;<z>
(<z>
) {<z>
(beanName);<z>
candidateAdvisors, beanClass);<z>
.setCurrentProxiedBeanName(null);<z>
<T> annotationClass) {<z>
for (Annotation annotation : this.annotations) {<z>
) == annotationClass) {<z>
;<z>
;<z>
Nullable Object payload) {<z>
if (payload == null) {<z>
return true;<z>
]) {<z>
0;<z>
(payload instanceof String) {<z>
;<z>
false;<z>
private static Pattern initPattern(String patternValue) {<z>
null;<z>
;<z>
(matcher.matches()) {<z>
patternValue = matcher.group(1);<z>
= matcher.group(2);<z>
"\\E";<z>
"*", "\\E.*\\Q");<z>
null) {<z>
")");<z>
Pattern.compile(patternValue);<z>
builder) {<z>
String poolSize = element.getAttribute("pool-size");<z>
(poolSize)) {<z>
("poolSize", poolSize);<z>
> c) {<z>
, c);<z>
{<z>
;<z>
return success;<z>
, DataHandler dataHandler) {<z>
.bytes = bytes;<z>
= dataHandler;<z>
;<z>
triggerAfterReceiveCompletion(<z>
Exception ex) {<z>
--) {<z>
interceptor = interceptors.get(i);<z>
, ex);<z>
{<z>
(logger.isErrorEnabled()) {<z>
error("Exception from afterReceiveCompletion in " + interceptor, ex2);<z>
CacheResolver getDefaultCacheResolver() {<z>
) {<z>
()));<z>
);<z>
] values) throws ServletRequestBindingException {<z>
validateRequiredParameter(name, values);<z>
new long[values.length];<z>
.length; i++) {<z>
(name, values[i]);<z>
return parameters;<z>
NotAcceptableStatusException {<z>
).getFirst(getParameterName());<z>
StringUtils.hasText(key)) {<z>
MEDIA_TYPE_ALL_LIST;<z>
);<z>
= this.mediaTypes.get(key);<z>
null) {<z>
+ key)<z>
orElseThrow(() -> {<z>
);<z>
new NotAcceptableStatusException(supported);<z>
;<z>
;<z>
return Collections.singletonList(match);<z>
NamedValueInfo createNamedValueInfo(MethodParameter parameter) {<z>
.class);<z>
annot != null, "No Header annotation");<z>
annot);<z>
{<z>
ArrayList<>(simpleMessages.length);<z>
for (SimpleMailMessage simpleMessage : simpleMessages) {<z>
MimeMailMessage(createMimeMessage());<z>
message);<z>
message.getMimeMessage());<z>
[0]), simpleMessages);<z>
DefaultTransactionStatus status) {<z>
JpaTransactionObject) status.getTransaction();<z>
(status.isDebug()) {<z>
logger.debug("Setting JPA transaction on EntityManager [" +<z>
).getEntityManager() + "] rollback-only");<z>
);<z>
ConfigurableListableBeanFactory beanFactory) {<z>
);<z>
aspectJAdvisorFactory == null) {<z>
.aspectJAdvisorFactory = new ReflectiveAspectJAdvisorFactory(beanFactory);<z>
aspectJAdvisorsBuilder =<z>
new BeanFactoryAspectJAdvisorsBuilderAdapter(beanFactory, this.aspectJAdvisorFactory);<z>
int getAbstractTypeFromDescriptor(<z>
int offset) {<z>
String internalName;<z>
switch (buffer.charAt(offset)) {<z>
'V':<z>
;<z>
'Z':<z>
case 'C':<z>
case 'B':<z>
case 'S':<z>
case 'I':<z>
return INTEGER;<z>
:<z>
FLOAT;<z>
case 'J':<z>
;<z>
case 'D':<z>
;<z>
case 'L':<z>
- 1);<z>
(internalName);<z>
:<z>
1;<z>
charAt(elementDescriptorOffset) == '[') {<z>
++elementDescriptorOffset;<z>
typeValue;<z>
(buffer.charAt(elementDescriptorOffset)) {<z>
'Z':<z>
BOOLEAN;<z>
:<z>
CHAR;<z>
:<z>
typeValue = BYTE;<z>
:<z>
= SHORT;<z>
'I':<z>
typeValue = INTEGER;<z>
'F':<z>
FLOAT;<z>
'J':<z>
;<z>
:<z>
= DOUBLE;<z>
:<z>
- 1);<z>
;<z>
);<z>
) | typeValue;<z>
throw new IllegalArgumentException();<z>
expected, @Nullable Object actual) {<z>
-> {<z>
message = getMessage(name);<z>
expected, actual);<z>
});<z>
responseSpec;<z>
) {<z>
();<z>
);<z>
this.cacheWide);<z>
sb.append(',');<z>
;<z>
return sb;<z>
) throws DataAccessException {<z>
if (!readOnly) {<z>
();<z>
{<z>
), true);<z>
... inserts) {<z>
));<z>
= message;<z>
inserts;<z>
() {<z>
result = 27;<z>
patterns) {<z>
+ pattern.hashCode();<z>
) {<z>
result + excludedPattern.hashCode();<z>
return result;<z>
classes,<z>
<?>>> contextInitializerClasses,<z>
activeProfiles, @Nullable ContextLoader contextLoader,<z>
CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,<z>
@Nullable MergedContextConfiguration parent) {<z>
contextInitializerClasses, activeProfiles, null, null,<z>
);<z>
setCacheOperationSources(CacheOperationSource... cacheOperationSources) {<z>
;<z>
= (cacheOperationSources.length > 1 ?<z>
]);<z>
void afterPropertiesSet() {<z>
messageConverter == null) {<z>
messageConverter = new GenericMessageConverter(this.conversionService);<z>
.getResolvers().isEmpty()) {<z>
));<z>
String generateBeanName(BeanDefinition beanDefinition, BeanDefinitionRegistry registry)<z>
BeanDefinitionStoreException {<z>
generateBeanName(beanDefinition, registry, false);<z>
PropertyValues pvs) {<z>
{<z>
(pvs) {<z>
pd != null && pvs instanceof MutablePropertyValues) {<z>
this.pd.getName());<z>
public int getCacheLimit() {<z>
{<z>
metadataReaderCache).getCacheLimit();<z>
);<z>
int ackMode) {<z>
if (ackMode == Session.SESSION_TRANSACTED) {<z>
new IllegalArgumentException("No support for SESSION_TRANSACTED: Only \"Auto-acknowledge\" " +<z>
"and \"Dups-ok-acknowledge\" supported in standard JCA 1.5");<z>
CLIENT_ACKNOWLEDGE) {<z>
IllegalArgumentException("No support for CLIENT_ACKNOWLEDGE: Only \"Auto-acknowledge\" " +<z>
;<z>
(bw.isWritableProperty("acknowledgeMode")) {<z>
("acknowledgeMode",<z>
DUPS_OK_ACKNOWLEDGE ? "Dups-ok-acknowledge" : "Auto-acknowledge");<z>
.DUPS_OK_ACKNOWLEDGE) {<z>
"Dups-ok-acknowledge not supported by underlying provider");<z>
public void stopInternal() {<z>
();<z>
this.heartbeatFuture != null) {<z>
this.heartbeatFuture.cancel(true);<z>
(String id, SockJsServiceConfig config,<z>
Nullable Map<String, Object> attributes) {<z>
, handler, attributes);<z>
(Random random) {<z>
"/" : "\\";<z>
;<z>
sb.append("jar:file:///c:");<z>
segmentCount; i++) {<z>
sb.append(separator);<z>
SEGMENTS.size())));<z>
(separator);<z>
("the%20file.txt");<z>
sb.toString();<z>
response, FilterChain filterChain)<z>
IOException, ServletException {<z>
request;<z>
.getPathWithinApplication(httpRequest);<z>
matches(requestPath)) {<z>
request, response, filterChain);<z>
(request, response);<z>
() throws JspException {<z>
);<z>
msg);<z>
msg) : msg;<z>
) {<z>
this.scope));<z>
(msg);<z>
return EVAL_PAGE;<z>
ex) {<z>
, ex);<z>
NoSuchMessageException ex) {<z>
(ex));<z>
?> clazz) {<z>
getModifiers())) {<z>
getParameterTypes());<z>
return clazz;<z>
(NoSuchMethodException ex) {<z>
) != null) {<z>
);<z>
;<z>
void complete() {<z>
!isCompleted()) {<z>
.complete();<z>
public void onComplete() {<z>
{<z>
DecodingException("Could not find first boundary"));<z>
(int expectedCount) {<z>
result -> {<z>
getModelMap());<z>
;<z>
) {<z>
{<z>
);<z>
+ type, ex);<z>
JsonProcessingException) {<z>
JsonProcessingException) ex).getOriginalMessage();<z>
+ originalMessage, ex);<z>
ex);<z>
String, String> validationProperties) {<z>
if (validationProperties != null) {<z>
validationProperties);<z>
hashCode() {<z>
= 1;<z>
);<z>
this.methodName.hashCode();<z>
.hashCode();<z>
;<z>
, QName evaluationType, Class<T> expectedClass)<z>
throws XPathExpressionException {<z>
document, evaluationType);<z>
throws InvalidDataAccessApiUsageException {<z>
FlushMode.COMMIT)) {<z>
(<z>
);<z>
int getIdleTaskExecutionLimit() {<z>
.lifecycleMonitor) {<z>
;<z>
Nullable ClientHttpRequest request) throws IOException {<z>
;<z>
.contentResource != null) {<z>
getInputStream();<z>
.statusCode);<z>
content, this.statusCode);<z>
).putAll(this.headers);<z>
response;<z>
) {<z>
).trim();<z>
.getResources(pattern));<z>
ex) {<z>
IllegalArgumentException(<z>
+ "]: " + ex.getMessage());<z>
) {<z>
.spouse1 = spouse1;<z>
this.spouse2 = spouse2;<z>
;<z>
) {<z>
)];<z>
getTableParameterMetaData();<z>
.size());<z>
(TableParameterMetaData tpmd : parameters) {<z>
);<z>
typeIndx = 0;<z>
getTableColumns()) {<z>
) {<z>
;<z>
(column.toUpperCase());<z>
!= null) {<z>
tpmd.getSqlType();<z>
types[typeIndx] = SqlTypeValue.TYPE_UNKNOWN;<z>
++;<z>
types;<z>
() {<z>
{<z>
throw new IllegalArgumentException("Property 'connectionFactory' is required");<z>
(ServletRequest request, ServletResponse response, FilterChain chain)<z>
ServletException {<z>
).doFilter(request, response);<z>
{<z>
.lifecycleMonitor) {<z>
false;<z>
.unsubscribe(this);<z>
(this);<z>
MethodVisitor mv, CodeFlow cf) {<z>
Label elseTarget = new Label();<z>
);<z>
.enterCompilationScope();<z>
().generateCode(mv, cf);<z>
unboxBooleanIfNecessary(mv);<z>
);<z>
visitJumpInsn(IFNE, elseTarget);<z>
;<z>
;<z>
visitLabel(elseTarget);<z>
cf.enterCompilationScope();<z>
;<z>
;<z>
.exitCompilationScope();<z>
visitLabel(endOfIf);<z>
(this.exitTypeDescriptor);<z>
() {<z>
if (this.resourceLoader == null) {<z>
this.resourceLoader = SchedulerFactoryBean.getConfigTimeResourceLoader();<z>
) {<z>
resourceLoader = new DefaultResourceLoader();<z>
] getParameterNames(Constructor<?> ctor) {<z>
raiseExceptions) {<z>
"An advice method can never be a constructor");<z>
null;<z>
onDataAvailable(AbstractListenerReadPublisher<T> publisher) {<z>
changeState(this, READING)) {<z>
demandAvailable = publisher.readAndPublish();<z>
(demandAvailable) {<z>
changeToDemandState(READING);<z>
.handlePendingCompletionOrError();<z>
);<z>
NO_DEMAND)) {<z>
.handlePendingCompletionOrError()) {<z>
publisher.demand;<z>
) {<z>
.changeToDemandState(NO_DEMAND);<z>
) {<z>
onError(ex);<z>
Date sentDate) throws MailParseException {<z>
helper.setSentDate(sentDate);<z>
ex) {<z>
);<z>
{<z>
);<z>
;<z>
;<z>
cf) {<z>
Integer) this.value.getValue();<z>
;<z>
1) {<z>
.visitInsn(ICONST_M1);<z>
) {<z>
intValue);<z>
.visitLdcInsn(intValue);<z>
);<z>
) {<z>
("{");<z>
int count = getChildCount();<z>
c++) {<z>
(c > 0) {<z>
;<z>
);<z>
sb.append(':');<z>
.toStringAST());<z>
;<z>
toString();<z>
(EvaluationContext context, String beanName) throws AccessException {<z>
);<z>
(BeansException ex) {<z>
AccessException("Could not resolve bean reference against BeanFactory", ex);<z>
) {<z>
= new LinkedHashMap<>();<z>
handlerTypes = new LinkedHashSet<>();<z>
Class<?> specificHandlerType = null;<z>
{<z>
getUserClass(targetType);<z>
handlerTypes.add(specificHandlerType);<z>
);<z>
) {<z>
currentHandlerType);<z>
ReflectionUtils.doWithMethods(currentHandlerType, method -> {<z>
(method, targetClass);<z>
.inspect(specificMethod);<z>
null) {<z>
bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);<z>
{<z>
, result);<z>
ReflectionUtils.USER_DECLARED_METHODS);<z>
return methodMap;<z>
(String entityName, Object entity, LockMode lockMode)<z>
DataAccessException {<z>
-> {<z>
, entity);<z>
;<z>
});<z>
(TypeMismatchException ex,<z>
Nullable Object handler) throws IOException {<z>
);<z>
);<z>
{<z>
parserContext);<z>
mode = element.getAttribute("mode");<z>
) {<z>
;<z>
getClassLoader())) {<z>
;<z>
AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);<z>
;<z>
BenchmarkData data, Blackhole bh) {<z>
for (String type : data.requestedMediaTypes) {<z>
(type));<z>
String namespaceURI) throws XMLStreamException {<z>
;<z>
;<z>
true;<z>
(int scope) {<z>
switch (scope) {<z>
PAGE_SCOPE:<z>
;<z>
REQUEST_SCOPE:<z>
;<z>
SESSION_SCOPE:<z>
.request.getSession(false);<z>
emptyEnumeration());<z>
APPLICATION_SCOPE:<z>
return this.servletContext.getAttributeNames();<z>
+ scope);<z>
filterChain)<z>
{<z>
this.delegate;<z>
{<z>
delegateMonitor) {<z>
;<z>
null) {<z>
;<z>
null) {<z>
throw new IllegalStateException("No WebApplicationContext found: " +<z>
;<z>
;<z>
delegate = delegateToUse;<z>
request, response, filterChain);<z>
IOException, ClassNotFoundException {<z>
;<z>
new JndiTemplate();<z>
();<z>
();<z>
List<HandlerMethodReturnValueHandler> returnValueHandlers) {<z>
for (WebSocketMessageBrokerConfigurer configurer : this.configurers) {<z>
returnValueHandlers);<z>
public String getColumnClassName(int column) throws InvalidResultSetAccessException {<z>
(column);<z>
(SQLException se) {<z>
(se);<z>
> autowiredBeanNames) {<z>
{<z>
autowiredBeanName : autowiredBeanNames) {<z>
.beanFactory.containsBean(autowiredBeanName)) {<z>
autowiredBeanName, beanName);<z>
) {<z>
logger.trace("Autowiring by type from bean name '" + beanName +<z>
);<z>
entity) throws DataAccessException {<z>
executeWithNativeSession(session -> {<z>
session);<z>
entityName, entity);<z>
));<z>
EntityManagerFactory emf) {<z>
= new LinkedHashSet<>();<z>
> entityManagerFactoryInterface = this.entityManagerFactoryInterface;<z>
!= null) {<z>
add(entityManagerFactoryInterface);<z>
emf != null) {<z>
), this.beanClassLoader));<z>
(EntityManagerFactory.class);<z>
class);<z>
) Proxy.newProxyInstance(this.beanClassLoader,<z>
);<z>
{<z>
!= null) {<z>
("EntityManagerFactory interface [" + entityManagerFactoryInterface +<z>
, ex);<z>
"Conflicting EntityManagerFactory interfaces - " +<z>
;<z>
(Method method) {<z>
method.getParameterCount();<z>
<>(parameterCount);<z>
++) {<z>
i);<z>
);<z>
return result;<z>
{<z>
) {<z>
NULL;<z>
) {<z>
+ value + "\'";<z>
Class) {<z>
) value);<z>
if (value instanceof Method method) {<z>
.getDeclaringClass());<z>
instanceof Map) {<z>
) value);<z>
) {<z>
<? ,?>) value);<z>
else if (value instanceof Collection) {<z>
value);<z>
) {<z>
(value));<z>
(value);<z>
<?> deferredResult, Throwable ex)<z>
{<z>
this.interceptors) {<z>
if (deferredResult.isSetOrExpired()) {<z>
return false;<z>
{<z>
return false;<z>
true;<z>
{<z>
rejectionPolicy = element.getAttribute("rejection-policy");<z>
)) {<z>
prefix = "java.util.concurrent.ThreadPoolExecutor.";<z>
String policyClassName;<z>
)) {<z>
prefix + "AbortPolicy";<z>
"CALLER_RUNS")) {<z>
policyClassName = prefix + "CallerRunsPolicy";<z>
{<z>
"DiscardPolicy";<z>
.equals("DISCARD_OLDEST")) {<z>
;<z>
;<z>
RootBeanDefinition(policyClassName));<z>
, boolean readOnly)<z>
PersistenceException, SQLException {<z>
);<z>
session);<z>
{<z>
)) {<z>
= beanFactory.getBeanDefinitionNames();<z>
for (String beanName : beanNames) {<z>
beanName;<z>
{<z>
= BeanFactory.FACTORY_BEAN_PREFIX + beanName;<z>
(nameToLookup);<z>
null) {<z>
(beanType);<z>
)) {<z>
beanDefinition = beanFactory.getBeanDefinition(beanName);<z>
logDeprecatedBean(beanName, beanType, beanDefinition);<z>
(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor) {<z>
) {<z>
return false;<z>
checkGenericTypeMatch(bdHolder, descriptor);<z>
] getNotificationInfo(Object managedBean, String beanKey) {<z>
;<z>
)) {<z>
;<z>
{<z>
= this.notificationInfos;<z>
: new ModelMBeanNotificationInfo[0]);<z>
throws DataAccessException {<z>
Hibernate.close(it);<z>
{<z>
;<z>
) throws IllegalStateException {<z>
= getWebApplicationContext(fc);<z>
null) {<z>
throw new IllegalStateException("No WebApplicationContext found: no ContextLoaderListener registered?");<z>
return wac;<z>
MediaType contentType, HttpOutputMessage outputMessage)<z>
IOException, HttpMessageNotWritableException {<z>
) {<z>
>) map, contentType, outputMessage);<z>
;<z>
(final Object value) {<z>
lastBytecodeOffset = code.length;<z>
addConstant(value);<z>
int constantIndex = constantSymbol.index;<z>
firstDescriptorChar;<z>
isLongOrDouble =<z>
== Symbol.CONSTANT_LONG_TAG<z>
|| constantSymbol.tag == Symbol.CONSTANT_DOUBLE_TAG<z>
.CONSTANT_DYNAMIC_TAG<z>
'J'<z>
firstDescriptorChar == 'D'));<z>
isLongOrDouble) {<z>
LDC2_W, constantIndex);<z>
>= 256) {<z>
LDC_W, constantIndex);<z>
else {<z>
constantIndex);<z>
if (currentBasicBlock != null) {<z>
COMPUTE_INSERTED_FRAMES) {<z>
);<z>
{<z>
;<z>
(size > maxRelativeStackSize) {<z>
maxRelativeStackSize = size;<z>
= size;<z>
throws Exception {<z>
Object job = (this.applicationContext != null ?<z>
().createBean(<z>
:<z>
createJobInstance(bundle));<z>
{<z>
(job);<z>
MutablePropertyValues pvs = new MutablePropertyValues();<z>
!= null) {<z>
);<z>
.getJobDataMap());<z>
.getJobDataMap());<z>
ignoredUnknownProperties != null) {<z>
this.ignoredUnknownProperties) {<z>
(propName)) {<z>
pvs.removePropertyValue(propName);<z>
);<z>
.setPropertyValues(pvs, true);<z>
return job;<z>
List<String> varNames) {<z>
{<z>
countNumberOfUnboundAnnotationArguments();<z>
1) {<z>
) +<z>
numAnnotationSlots + " potential argument slots");<z>
1) {<z>
{<z>
get(0));<z>
"Found " + varNames.size() +<z>
" but only one potential argument binding slot");<z>
int getColumnDisplaySize(int column) throws InvalidResultSetAccessException {<z>
);<z>
) {<z>
se);<z>
scheduler) throws SchedulerException {<z>
(this.schedulerContextMap != null) {<z>
().putAll(this.schedulerContextMap);<z>
null) {<z>
{<z>
IllegalStateException(<z>
;<z>
, this.applicationContext);<z>
uriVariables) throws RestClientException {<z>
responseType);<z>
<T> responseExtractor =<z>
getMessageConverters(), logger);<z>
GET, requestCallback, responseExtractor, uriVariables);<z>
List<Charset> getAcceptCharset() {<z>
value = getFirst(ACCEPT_CHARSET);<z>
value != null) {<z>
= StringUtils.tokenizeToStringArray(value, ",");<z>
>(tokens.length);<z>
String token : tokens) {<z>
indexOf(';');<z>
charsetName;<z>
{<z>
= token;<z>
= token.substring(0, paramIdx);<z>
(!charsetName.equals("*")) {<z>
;<z>
return result;<z>
Collections.emptyList();<z>
private Method getExceptionHandler(Throwable exception) {<z>
();<z>
if (logger.isTraceEnabled()) {<z>
;<z>
this.exceptionHandlerMap.get(exceptionClass);<z>
Throwable.class) {<z>
getSuperclass();<z>
= this.exceptionHandlerMap.get(exceptionClass);<z>
null && logger.isTraceEnabled()) {<z>
handler);<z>
return handler;<z>
{<z>
.containsKey(PARAM_QUALITY_FACTOR)) {<z>
;<z>
LinkedHashMap<>(getParameters());<z>
(PARAM_QUALITY_FACTOR));<z>
params);<z>
Object existingBean, String beanName) throws BeansException {<z>
ApplicationContextAware) {<z>
;<z>
return existingBean;<z>
{<z>
;<z>
clazz = clazz;<z>
this.executableMap = map;<z>
name = name;<z>
.args = Type.getArgumentTypes(desc);<z>
];<z>
isStatic;<z>
args);<z>
public String toString() {<z>
return new ToStringCreator(this)<z>
.append("collaborator", this.collaborator)<z>
;<z>
initMultipartData(ServerHttpRequest request,<z>
HttpMessageReader<?>> readers) {<z>
);<z>
(contentType)) {<z>
stream()<z>
.canRead(MULTIPART_DATA_TYPE, MediaType.MULTIPART_FORM_DATA))<z>
)<z>
)<z>
Hints.none())<z>
.switchIfEmpty(EMPTY_MULTIPART_DATA)<z>
();<z>
catch (InvalidMediaTypeException ex) {<z>
return EMPTY_MULTIPART_DATA;<z>
, boolean html) throws MessagingException {<z>
(text, "Text must not be null");<z>
MimePart partToUse;<z>
(isMultipart()) {<z>
partToUse = getMainPart();<z>
this.mimeMessage;<z>
{<z>
);<z>
setPlainTextToMimePart(partToUse, text);<z>
stop() {<z>
MessageListenerContainer listenerContainer : getListenerContainers()) {<z>
stop();<z>
() {<z>
if (this.queryParams == null) {<z>
unmodifiableMultiValueMap(initQueryParams());<z>
this.queryParams;<z>
String comments) throws IOException {<z>
= new ByteArrayOutputStream();<z>
null : comments));<z>
(StandardCharsets.ISO_8859_1);<z>
) {<z>
.startsWith("#"))) {<z>
getBytes(StandardCharsets.ISO_8859_1));<z>
NoSuchMethodException {<z>
"Bean is required");<z>
.notNull(methodName, "Method name is required");<z>
bean = bean;<z>
this.beanFactory = null;<z>
= ClassUtils.getUserClass(bean);<z>
methodName, parameterTypes);<z>
;<z>
.bridgedMethod);<z>
;<z>
super T> callback) {<z>
);<z>
) {<z>
.state) {<z>
:<z>
;<z>
SUCCESS:<z>
);<z>
{<z>
.resolver);<z>
{<z>
resolved = resolved.trim();<z>
);<z>
(<z>
variableResolver) {<z>
= type;<z>
typeProvider = typeProvider;<z>
.variableResolver = variableResolver;<z>
this.componentType = null;<z>
);<z>
null;<z>
ServerHttpRequest request, ServerHttpResponse response) throws IOException {<z>
!= HttpMethod.GET) {<z>
GET);<z>
.format(IFRAME_CONTENT, getSockJsClientLibraryUrl());<z>
StandardCharsets.UTF_8);<z>
new StringBuilder("\"0");<z>
contentBytes, builder);<z>
;<z>
toString();<z>
.getHeaders().getIfNoneMatch();<z>
)) {<z>
setStatusCode(HttpStatus.NOT_MODIFIED);<z>
UTF_8));<z>
length);<z>
response);<z>
);<z>
);<z>
throws NamingException {<z>
{<z>
ThreadFactory.class);<z>
(NamingException ex) {<z>
()) {<z>
+ "] from JNDI", ex);<z>
("Could not find default managed thread factory in JNDI - " +<z>
);<z>
beanFactory) {<z>
{<z>
.beanFactory = (ListableBeanFactory) beanFactory;<z>
logger.debug("MBeanExporter not running in a ListableBeanFactory: autodetection of MBeans not available.");<z>
exchange) {<z>
;<z>
+ name + "' is not present";<z>
parameter);<z>
) throws XMLStreamException {<z>
();<z>
true) {<z>
event = nextEvent();<z>
)) {<z>
XMLStreamConstants.START_ELEMENT:<z>
case XMLStreamConstants.END_ELEMENT:<z>
event;<z>
:<z>
return null;<z>
XMLStreamConstants.SPACE:<z>
:<z>
:<z>
XMLStreamConstants.CDATA:<z>
CHARACTERS:<z>
isWhiteSpace()) {<z>
throw new XMLStreamException(<z>
+ event);<z>
;<z>
configClass, SourceClass sourceClass,<z>
> filter) throws IOException {<z>
= sourceClass.getMemberClasses();<z>
)) {<z>
size());<z>
(SourceClass memberClass : memberClasses) {<z>
.getMetadata()) &&<z>
.getClassName())) {<z>
(memberClass);<z>
;<z>
candidate : candidates) {<z>
(configClass)) {<z>
, this.importStack));<z>
configClass);<z>
), filter);<z>
.pop();<z>
{<z>
(this.parentPostProcessor != null) {<z>
parentPostProcessor.postProcessRequest(request);<z>
!= null) {<z>
);<z>
return request;<z>
(ObjectName objectName) {<z>
) {<z>
: this.listeners) {<z>
;<z>
RequestMappingInfo(@Nullable String name,<z>
,<z>
,<z>
,<z>
HeadersRequestCondition headersCondition, ConsumesRequestCondition consumesCondition,<z>
producesCondition, RequestConditionHolder customCondition,<z>
) {<z>
!= null,<z>
"Neither PathPatterns nor String patterns condition");<z>
name : null);<z>
= pathPatternsCondition;<z>
= patternsCondition;<z>
methodsCondition = methodsCondition;<z>
paramsCondition;<z>
= headersCondition;<z>
= consumesCondition;<z>
= producesCondition;<z>
;<z>
;<z>
= calculateHashCode(<z>
this.pathPatternsCondition, this.patternsCondition,<z>
paramsCondition, this.headersCondition,<z>
;<z>
URL getCleanedUrl() {<z>
this.cleanedUrl;<z>
) {<z>
;<z>
url).toString());<z>
.cleanedUrl = cleanedUrl;<z>
cleanedUrl;<z>
setAutodetectModeName(String constantName) {<z>
(CONSTANT_PREFIX_AUTODETECT)) {<z>
);<z>
);<z>
httpMethod,<z>
MultiValueMap<String, HttpCookie> cookies,<z>
InetSocketAddress remoteAddress,<z>
? extends DataBuffer> body) {<z>
headers);<z>
httpMethod;<z>
;<z>
.localAddress = localAddress;<z>
;<z>
this.sslInfo = sslInfo;<z>
);<z>
servletContext) {<z>
.get(request, Config.FMT_LOCALE);<z>
localeObject == null) {<z>
request.getSession(false);<z>
session != null) {<z>
);<z>
null) {<z>
;<z>
Locale ? (Locale) localeObject : null);<z>
getResourceType() {<z>
.isField) {<z>
).getType();<z>
null) {<z>
;<z>
;<z>
{<z>
;<z>
(dataSource);<z>
afterPropertiesSet();<z>
List<Cookie> cookies, Cookie cookie) {<z>
cookie);<z>
equals(cookie.getName())) {<z>
(cookie.getValue());<z>
.getValue()));<z>
maybeBindProceedingJoinPoint(Class<?> candidateParameterType) {<z>
{<z>
{<z>
"ProceedingJoinPoint is only supported for around advice");<z>
;<z>
;<z>
;<z>
protected Mono<Void> writeAndFlushWithInternal(<z>
extends DataBuffer>> body) {<z>
).concatMap(Flux::from));<z>
unreliable() {<z>
++;<z>
% 2 != 0) {<z>
throw new RetryableException("foo");<z>
return this.calls;<z>
servletRequest) {<z>
ServerRequest serverRequest =<z>
) servletRequest.getAttribute(RouterFunctions.REQUEST_ATTRIBUTE);<z>
() -> "Required attribute '" +<z>
.REQUEST_ATTRIBUTE + "' is missing");<z>
;<z>
matcher) {<z>
);<z>
values()) {<z>
;<z>
.localRegistry.findSubscriptions(matcher));<z>
return result;<z>
) {<z>
storeValue == NullValue.INSTANCE) {<z>
;<z>
storeValue;<z>
) {<z>
{<z>
;<z>
?> other) {<z>
()) &&<z>
;<z>
return false;<z>
MethodVisitor mv, CodeFlow codeflow) {<z>
;<z>
codeflow.getClassName();<z>
-><z>
);<z>
registerNewClinit((mVisitor, cflow) -><z>
false));<z>
;<z>
"Ljava/util/List");<z>
) {<z>
originalMessage == null) {<z>
;<z>
toString() + " for original " + this.originalMessage;<z>
[] consumes, String[] headers) {<z>
ConsumeMediaTypeExpression> result = null;<z>
(!ObjectUtils.isEmpty(headers)) {<z>
String header : headers) {<z>
);<z>
(expr.name)) {<z>
LinkedHashSet<>());<z>
expr.value)) {<z>
ConsumeMediaTypeExpression(mediaType, expr.isNegated));<z>
(!ObjectUtils.isEmpty(consumes)) {<z>
>());<z>
consume : consumes) {<z>
(new ConsumeMediaTypeExpression(consume));<z>
);<z>
public BeanDefinitionHolder decorateBeanDefinitionIfRequired(<z>
, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) {<z>
originalDef;<z>
.getAttributes();<z>
.getLength(); i++) {<z>
.item(i);<z>
decorateIfRequired(node, finalDefinition, containingBd);<z>
children = ele.getChildNodes();<z>
getLength(); i++) {<z>
;<z>
) {<z>
finalDefinition, containingBd);<z>
finalDefinition;<z>
parserContext) {<z>
(EmbeddedDatabaseFactoryBean.class);<z>
;<z>
builder);<z>
, builder);<z>
(element, builder);<z>
);<z>
.getBeanDefinition();<z>
() throws InvalidResultSetAccessException {<z>
.previous();<z>
SQLException se) {<z>
);<z>
) {<z>
return result -> {<z>
.getResponse().getHeaderValues(name);<z>
), actual);<z>
parameter, @Nullable ModelAndViewContainer mavContainer,<z>
, @Nullable WebDataBinderFactory binderFactory) throws Exception {<z>
.nestedIfOptional();<z>
);<z>
getVariableNameForParameter(parameter);<z>
if (binderFactory != null) {<z>
.createBinder(webRequest, arg, name);<z>
!= null) {<z>
parameter);<z>
&& isBindExceptionRequired(binder, parameter)) {<z>
);<z>
mavContainer != null) {<z>
binder.getBindingResult());<z>
adaptArgumentIfNecessary(arg, parameter);<z>
String name, String fieldName, String error) {<z>
mvcResult -> {<z>
mav = getModelAndView(mvcResult);<z>
BindingResult result = getBindingResult(mav, name);<z>
());<z>
fieldName);<z>
+ "'", fieldError);<z>
;<z>
code);<z>
convertSendAndReceive(String destinationName, Object request,<z>
> headers, Class<T> targetClass,<z>
Nullable MessagePostProcessor postProcessor) {<z>
;<z>
, headers, targetClass, postProcessor);<z>
, HttpServletResponse response, DeferredResult<?> deferredResult)<z>
IOException {<z>
request);<z>
= WebAsyncUtils.createAsyncWebRequest(request, response);<z>
(asyncWebRequest);<z>
);<z>
ex) {<z>
;<z>
(Exception ex) {<z>
new ServletException("Async processing failed", ex);<z>
bean) {<z>
.validator != null, "No Validator set");<z>
bean);<z>
null) {<z>
objectToValidate = bean;<z>
(objectToValidate);<z>
if (!result.isEmpty()) {<z>
new StringBuilder("Bean state is invalid: ");<z>
); it.hasNext();) {<z>
.next();<z>
getMessage());<z>
(it.hasNext()) {<z>
append("; ");<z>
;<z>
adviceChanged() {<z>
super.adviceChanged();<z>
(this) {<z>
) {<z>
.listeners) {<z>
);<z>
final boolean match(ServerWebExchange exchange) {<z>
;<z>
this.value != null) {<z>
exchange);<z>
matchName(exchange);<z>
;<z>
key, @Nullable final Object value) {<z>
= new PutIfAbsentFunction(value);<z>
key, callable);<z>
null : toValueWrapper(result));<z>
super BeanPostProcessor> filter) {<z>
);<z>
(success) {<z>
= null;<z>
return success;<z>
protected Object doInvoke(MethodInvocation invocation) throws Throwable {<z>
invocation.getMethod();<z>
;<z>
!= null) {<z>
);<z>
pd = BeanUtils.findPropertyForMethod(method);<z>
null) {<z>
;<z>
method, invocation.getArguments());<z>
(method, -1));<z>
MBeanException ex) {<z>
getTargetException();<z>
RuntimeMBeanException ex) {<z>
;<z>
(RuntimeErrorException ex) {<z>
throw ex.getTargetError();<z>
(RuntimeOperationsException ex) {<z>
();<z>
instanceof RuntimeMBeanException) {<z>
);<z>
) {<z>
RuntimeErrorException) rex).getTargetError();<z>
throw rex;<z>
) {<z>
method, ex.getClass())) {<z>
;<z>
InvalidInvocationException(ex.getMessage());<z>
catch (JMException ex) {<z>
) {<z>
throw ex;<z>
);<z>
(IOException ex) {<z>
)) {<z>
;<z>
"I/O failure during JMX access", ex);<z>
columnIndex) throws SQLException {<z>
(columnIndex);<z>
name)) {<z>
name = resultSetMetaData.getColumnName(columnIndex);<z>
;<z>
suspendReceiving() {<z>
(this, 0, 1)) {<z>
).suspend();<z>
consumeArguments(List<SpelNodeImpl> accumulatedArguments) {<z>
();<z>
;<z>
;<z>
Token next;<z>
();<z>
;<z>
if (t == null) {<z>
, SpelMessage.RUN_OUT_OF_ARGUMENTS);<z>
RPAREN) {<z>
());<z>
next = peekToken();<z>
.kind == TokenKind.COMMA);<z>
== null) {<z>
.RUN_OUT_OF_ARGUMENTS);<z>
metadata, @Nullable ConfigurationPhase phase) {<z>
Conditional.class.getName())) {<z>
return false;<z>
) {<z>
if (metadata instanceof AnnotationMetadata &&<z>
AnnotationMetadata) metadata)) {<z>
ConfigurationPhase.PARSE_CONFIGURATION);<z>
return shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);<z>
new ArrayList<>();<z>
)) {<z>
: conditionClasses) {<z>
());<z>
add(condition);<z>
sort(conditions);<z>
condition : conditions) {<z>
= null;<z>
) {<z>
);<z>
.context, metadata)) {<z>
return true;<z>
return false;<z>
apply(DataBuffer dataBuffer) {<z>
;<z>
asByteBuffer());<z>
);<z>
true) {<z>
) == AsyncXMLStreamReader.EVENT_INCOMPLETE) {<z>
;<z>
add(event);<z>
if (event.isEndDocument()) {<z>
(event);<z>
&& this.byteCount > this.maxInMemorySize) {<z>
raiseLimitException();<z>
events;<z>
{<z>
;<z>
release(dataBuffer);<z>
String arraytype) {<z>
.length();<z>
++) {<z>
arraytype.charAt(i);<z>
'[') {<z>
return (ch == 'L');<z>
return false;<z>
Integer> lowerOrders) {<z>
);<z>
{<z>
add(nextField, 1);<z>
(field));<z>
(0);<z>
nextValue != value) {<z>
(field, nextValue);<z>
(calendar, lowerOrders);<z>
;<z>
(String route, Object... routeVars) {<z>
{<z>
return route;<z>
= new StringBuffer();<z>
= 0;<z>
);<z>
()) {<z>
) + "'");<z>
.toString();<z>
;<z>
;<z>
++;<z>
matcher.appendTail(sb);<z>
();<z>
equals(@Nullable Object other) {<z>
== other) {<z>
;<z>
) {<z>
return false;<z>
equals(otherPointcut.classFilter) &&<z>
methodMatcher.equals(otherPointcut.methodMatcher));<z>
initAllowHeader() {<z>
<String> allowedMethods;<z>
if (this.supportedMethods == null) {<z>
;<z>
()) {<z>
!= HttpMethod.TRACE) {<z>
;<z>
.OPTIONS.name())) {<z>
= this.supportedMethods;<z>
new ArrayList<>(this.supportedMethods);<z>
(HttpMethod.OPTIONS.name());<z>
;<z>
getBodyAdviceCount(Class<?> adviceType) {<z>
advice = this.requestResponseBodyAdvice;<z>
adviceType) ?<z>
, RequestBodyAdvice.class).size() :<z>
size();<z>
Nullable DatabasePopulator populator) {<z>
, "ConnectionFactory must be set");<z>
&& populator != null) {<z>
.connectionFactory).block();<z>
ObjectInputStream ois) throws IOException, ClassNotFoundException {<z>
defaultReadObject();<z>
());<z>
) ois.readObject());<z>
;<z>
);<z>
ResourceException {<z>
true;<z>
;<z>
();<z>
) {<z>
new ApplicationServerInternalException("Failed to begin transaction", ex);<z>
();<z>
;<z>
(getEndpointClassLoader());<z>
(Map<ExpressionKey, Expression> cache,<z>
AnnotatedElementKey elementKey, String expression) {<z>
= createKey(elementKey, expression);<z>
get(expressionKey);<z>
null) {<z>
expr = parseExpression(expression);<z>
);<z>
return expr;<z>
Nullable ServletContext servletContext, @Nullable HttpServletRequest request,<z>
HttpServletResponse response) {<z>
response, null);<z>
() {<z>
new HashMap<>();<z>
{<z>
(i);<z>
AliasFor.class);<z>
{<z>
= resolveAliasTarget(attribute, aliasFor);<z>
.add(attribute);<z>
;<z>
, boolean isDefaultBeanName) {<z>
beanName, "'beanName' must not be empty");<z>
;<z>
isDefaultBeanName = isDefaultBeanName;<z>
()<z>
HeuristicMixedException, HeuristicRollbackException,<z>
{<z>
commit();<z>
) {<z>
()) {<z>
.format("Test class [%s] has been configured with @ContextConfiguration's 'locations' " +<z>
webMergedConfig.getTestClass().getName(),<z>
, getClass().getSimpleName());<z>
msg);<z>
msg);<z>
) {<z>
;<z>
clazz);<z>
{<z>
Constructor<?>[] {primaryCtor};<z>
= clazz.getConstructors();<z>
) {<z>
;<z>
;<z>
T nextOrSame(T temporal) {<z>
temporal);<z>
if (result != null) {<z>
result.compareTo(temporal) < 0) {<z>
this.rollForwardType.rollForward(temporal);<z>
);<z>
null) {<z>
= type().reset(result);<z>
return result;<z>
hasForwardedHeaders(ServerHttpRequest request) {<z>
.getHeaders();<z>
String headerName : FORWARDED_HEADER_NAMES) {<z>
headerName)) {<z>
return true;<z>
false;<z>
) {<z>
{<z>
.heartbeatFuture != null) {<z>
{<z>
+ getId());<z>
);<z>
;<z>
!= null) {<z>
.cancel();<z>
null;<z>
, @Nullable String delimiter) {<z>
{<z>
null;<z>
= toSplit.indexOf(delimiter);<z>
) {<z>
;<z>
.substring(0, offset);<z>
offset + delimiter.length());<z>
};<z>
class.getDeclaredMethods()) {<z>
())<z>
) > 0) {<z>
(method);<z>
String initMethod) {<z>
.postProcessingLock) {<z>
(this.externallyManagedInitMethods != null &&<z>
));<z>
) {<z>
if (this.delegateSession != null) {<z>
, message);<z>
(webSocketMessage.getType(), webSocketMessage);<z>
contextPath) {<z>
.notNull(mockMvc, "MockMvc must not be null");<z>
"WebClient must not be null");<z>
(contextPath);<z>
webClient;<z>
mockMvc = mockMvc;<z>
contextPath;<z>
) {<z>
.transactionStack.peek();<z>
!= null) {<z>
;<z>
new TransactionContext();<z>
.push(context);<z>
context;<z>
(String message, String statusText,<z>
charset) {<z>
, headers, body, charset);<z>
public ModelAndView resolveException(<z>
{<z>
{<z>
) {<z>
handler, ex);<z>
{<z>
return mav;<z>
null;<z>
) {<z>
;<z>
) {<z>
new StandardToWebSocketExtensionAdapter(extension));<z>
return result;<z>
... mediaTypes) {<z>
"'mediaTypes' must not be empty");<z>
));<z>
;<z>
public void stop() {<z>
lifecycleMonitor) {<z>
;<z>
();<z>
;<z>
this);<z>
clientInboundChannel instanceof InterceptableChannel) {<z>
unsentDisconnectInterceptor);<z>
;<z>
.info("Stopped.");<z>
] body,<z>
HttpRequest request) {<z>
,<z>
;<z>
() {<z>
();<z>
-> !set.isEmpty());<z>
();<z>
,<z>
throws Exception {<z>
{<z>
.triggerAfterCompletion(request, response, ex);<z>
;<z>
properties, String databaseName) {<z>
this.driverClass);<z>
.setUrl("jdbc:hsqldb:mem:" + databaseName);<z>
);<z>
setPassword("");<z>
E> candidates) {<z>
) {<z>
null;<z>
for (E candidate : candidates) {<z>
source.contains(candidate)) {<z>
;<z>
;<z>
getObjectType() {<z>
!= null) {<z>
proxyInterfaces.length == 1) {<z>
proxyInterfaces[0];<z>
> 1) {<z>
(this.proxyInterfaces);<z>
(this.jndiObject != null) {<z>
.getClass();<z>
return getExpectedType();<z>
) {<z>
(TokenKind.IDENTIFIER)) {<z>
peekToken();<z>
);<z>
))) {<z>
;<z>
Token t = takeToken();<z>
if (peekToken(TokenKind.RSQUARE)) {<z>
.startPos, t.endPos));<z>
return true;<z>
eatToken(TokenKind.LPAREN);<z>
eatPossiblyQualifiedId();<z>
dims = 0;<z>
.LSQUARE, true)) {<z>
TokenKind.RSQUARE);<z>
;<z>
;<z>
node, dims));<z>
;<z>
false;<z>
visitTryCatchAnnotation(<z>
boolean visible) {<z>
visible) {<z>
lastCodeRuntimeVisibleTypeAnnotation =<z>
AnnotationWriter.create(<z>
descriptor, lastCodeRuntimeVisibleTypeAnnotation);<z>
else {<z>
return lastCodeRuntimeInvisibleTypeAnnotation =<z>
.create(<z>
typeRef, typePath, descriptor, lastCodeRuntimeInvisibleTypeAnnotation);<z>
(<z>
bufferFactory, int bufferSize) {<z>
isFile()) {<z>
file = resource.getFile();<z>
(<z>
), StandardOpenOption.READ),<z>
bufferFactory, bufferSize);<z>
{<z>
bufferSize);<z>
? result : skipUntilByteCount(result, position);<z>
entry) {<z>
null) {<z>
false;<z>
) {<z>
return false;<z>
);<z>
canWrite(type, null);<z>
ConfigurableJtaPlatform(TransactionManager tm, @Nullable UserTransaction ut,<z>
Nullable TransactionSynchronizationRegistry tsr) {<z>
.notNull(tm, "TransactionManager reference must not be null");<z>
= tm;<z>
(tm));<z>
transactionSynchronizationRegistry = tsr;<z>
to) throws MessagingException {<z>
);<z>
;<z>
.TO, to);<z>
servlet.http.Cookie[] cookies) {<z>
Date();<z>
getCookieManager();<z>
cookies) {<z>
() == null) {<z>
.getUrl().getHost());<z>
);<z>
expires = toManage.getExpires();<z>
|| expires.after(now)) {<z>
.addCookie(toManage);<z>
toManage);<z>
) {<z>
(this.annotationType);<z>
if (ann == null) {<z>
IllegalStateException(<z>
);<z>
, sourceType.getObjectType());<z>
cachedPrinters.get(converterKey);<z>
{<z>
.getPrinter(<z>
));<z>
fieldType, printer, FormattingConversionService.this);<z>
cachedPrinters.put(converterKey, converter);<z>
.convert(source, sourceType, targetType);<z>
{<z>
this.handlerExceptionResolvers = null;<z>
detectAllHandlerExceptionResolvers) {<z>
, HandlerExceptionResolver> matchingBeans = BeanFactoryUtils<z>
, false);<z>
if (!matchingBeans.isEmpty()) {<z>
values());<z>
handlerExceptionResolvers);<z>
her =<z>
getBean(HANDLER_EXCEPTION_RESOLVER_BEAN_NAME, HandlerExceptionResolver.class);<z>
.singletonList(her);<z>
{<z>
) {<z>
HandlerExceptionResolver.class);<z>
isTraceEnabled()) {<z>
trace("No HandlerExceptionResolvers declared in servlet '" + getServletName() +<z>
);<z>
validatePath(ServerHttpRequest request) {<z>
request.getURI().getPath();<z>
;<z>
';', index) == -1);<z>
, Method method, Object... args) {<z>
contributor = getUriComponentsContributor();<z>
);<z>
argCount = args.length;<z>
{<z>
paramCount +<z>
);<z>
<>();<z>
i < paramCount; i++) {<z>
method, i);<z>
);<z>
;<z>
);<z>
(Parameter param) {<z>
anns = param.getAnnotations();<z>
return (anns.length > 0 ?<z>
+ param :<z>
toString());<z>
{<z>
.isComposite) {<z>
allocator.compositeBuffer();<z>
.route != null) {<z>
,<z>
());<z>
entries.forEach(entry -> {<z>
();<z>
io.rsocket.metadata.CompositeMetadataCodec.encodeAndAddMetadata(<z>
),<z>
(encodeEntry(entry)));<z>
});<z>
return asDataBuffer(composite);<z>
catch (Throwable ex) {<z>
composite.release();<z>
ex;<z>
{<z>
isEmpty(), "Composite metadata required for route and other entries");<z>
WellKnownMimeType.MESSAGE_RSOCKET_ROUTING.getString();<z>
) ?<z>
) :<z>
this.route, this.metadataMimeType);<z>
);<z>
);<z>
())) {<z>
(<z>
;<z>
);<z>
{<z>
{<z>
);<z>
;<z>
+ "'", result.hasErrors());<z>
(String fieldName : fieldNames) {<z>
);<z>
+ "'", hasFieldErrors);<z>
String beanName) {<z>
) &&<z>
) < this.beanPostProcessorTargetCount) {<z>
isInfoEnabled()) {<z>
.getClass().getName() +<z>
;<z>
;<z>
(ObjectName objectName, Object managedResource)<z>
{<z>
();<z>
ObjectUtils.getIdentityHexString(managedResource));<z>
;<z>
Nullable String name) {<z>
name)) {<z>
false;<z>
0))) {<z>
return false;<z>
) {<z>
(name.charAt(i))) {<z>
false;<z>
true;<z>
public QueueConnection createQueueConnection() throws JMSException {<z>
Connection con;<z>
) {<z>
FALSE;<z>
;<z>
!(con instanceof QueueConnection)) {<z>
.IllegalStateException(<z>
);<z>
);<z>
(PropertyValue newPv, PropertyValue currentPv) {<z>
;<z>
value instanceof Mergeable mergeable) {<z>
()) {<z>
currentPv.getValue());<z>
.getName(), merged);<z>
return newPv;<z>
populateActivationSpecProperties(BeanWrapper bw, JmsActivationSpecConfig config) {<z>
.getDestinationName();<z>
{<z>
config.isPubSubDomain();<z>
destination = destinationName;<z>
null) {<z>
, destinationName, pubSubDomain);<z>
) {<z>
throw new DestinationResolutionException(<z>
destinationName + "]", ex);<z>
, destination);<z>
));<z>
) {<z>
"Durable" : "NonDurable");<z>
.isSubscriptionDurable()) {<z>
IllegalArgumentException("Durable subscriptions not supported by underlying provider");<z>
(config.isSubscriptionShared()) {<z>
);<z>
) {<z>
, config.getSubscriptionName());<z>
!= null) {<z>
);<z>
config.getMessageSelector() != null) {<z>
config.getMessageSelector());<z>
, config.getAcknowledgeMode());<z>
handleNoMatch(<z>
ServletException {<z>
PartialMatchHelper(infos, request);<z>
(helper.isEmpty()) {<z>
;<z>
{<z>
.getAllowedMethods();<z>
.getMethod())) {<z>
;<z>
new HttpOptionsHandler(methods, mediaTypes);<z>
(handler, HTTP_OPTIONS_HANDLE_METHOD);<z>
;<z>
hasConsumesMismatch()) {<z>
MediaType> mediaTypes = helper.getConsumableMediaTypes();<z>
;<z>
{<z>
));<z>
(InvalidMediaTypeException ex) {<z>
;<z>
ArrayList<>(mediaTypes));<z>
) {<z>
;<z>
<>(mediaTypes));<z>
{<z>
);<z>
));<z>
;<z>
) {<z>
) {<z>
();<z>
super T> callback) {<z>
;<z>
this.mutex) {<z>
) {<z>
case NEW:<z>
(callback);<z>
failureCallbacks.add(callback);<z>
SUCCESS:<z>
notifySuccess(callback);<z>
FAILURE:<z>
(callback);<z>
() {<z>
.equals(this.sharedEngine)) {<z>
) {<z>
);<z>
createEngineFromSupplier();<z>
, "No shared engine available");<z>
return this.engine;<z>
String value)<z>
JspException {<z>
value != null) {<z>
(evaluate(attributeName, value)));<z>
{<z>
()) {<z>
event).standaloneSet();<z>
IllegalStateException();<z>
ExplicitRepeatableContainer(@Nullable RepeatableContainers parent,<z>
> container) {<z>
(parent);<z>
.notNull(repeatable, "Repeatable must not be null");<z>
if (container == null) {<z>
;<z>
get(MergedAnnotation.VALUE);<z>
valueMethod == null) {<z>
);<z>
valueMethod.getReturnType();<z>
.getComponentType() != repeatable) {<z>
("Container type [" +<z>
) +<z>
) + "]");<z>
catch (AnnotationConfigurationException ex) {<z>
;<z>
(Throwable ex) {<z>
new AnnotationConfigurationException(<z>
getName() +<z>
repeatable.getName() + "]",<z>
);<z>
.repeatable = repeatable;<z>
container = container;<z>
valueMethod;<z>
SimpSubscriptionMatcher matcher) {<z>
HashSet<>();<z>
.values()) {<z>
{<z>
.match(subscription)) {<z>
result.add(subscription);<z>
result;<z>
public String decode() {<z>
originalMessage.length()) {<z>
);<z>
();<z>
;<z>
toString();<z>
ResolvableType elementType,<z>
Object> hints) {<z>
, hints));<z>
Object message) {<z>
|| this.logger.isTraceEnabled()) {<z>
trace(String.valueOf(message));<z>
>[] classes,<z>
@Nullable ContextLoader contextLoader) {<z>
;<z>
depth) {<z>
(exceptionMapping)) {<z>
return depth;<z>
== Throwable.class) {<z>
return -1;<z>
);<z>
?> paramMap)<z>
{<z>
, new MapSqlParameterSource(paramMap));<z>
CompositeRequestCondition other) {<z>
.isEmpty()) {<z>
;<z>
isEmpty()) {<z>
return this;<z>
else if (isEmpty()) {<z>
other;<z>
(other);<z>
[getLength()];<z>
< getLength(); i++) {<z>
;<z>
new CompositeRequestCondition(combinedConditions);<z>
, String beanKey) throws JMException {<z>
, "No BeanFactory set");<z>
ProxyFactory proxyFactory = new ProxyFactory();<z>
(true);<z>
;<z>
{<z>
targetSource = new LazyInitTargetSource();<z>
;<z>
beanFactory);<z>
setTargetSource(targetSource);<z>
;<z>
(proxy, beanKey);<z>
logger.isDebugEnabled()) {<z>
beanKey + "': registering with JMX server as lazy-init MBean [" +<z>
;<z>
doRegister(proxy, objectName);<z>
;<z>
NotificationPublisherAwareLazyTargetSource targetSource = new NotificationPublisherAwareLazyTargetSource();<z>
);<z>
this.beanFactory);<z>
);<z>
);<z>
= getObjectName(proxy, beanKey);<z>
) {<z>
debug("Located simple bean '" + beanKey + "': registering with JMX server as lazy-init MBean [" +<z>
objectName + "]");<z>
(proxy, beanKey);<z>
setModelMBean(mbean);<z>
.setObjectName(objectName);<z>
(mbean, objectName);<z>
return objectName;<z>
List<Locale> requestLocales) {<z>
) {<z>
getDefaultLocale();<z>
getSupportedLocales();<z>
)) {<z>
get(0);<z>
;<z>
(Locale locale : requestLocales) {<z>
supportedLocales.contains(locale)) {<z>
.getLanguage())) {<z>
return locale;<z>
languageMatch == null) {<z>
(Locale candidate : supportedLocales) {<z>
(candidate.getCountry()) &&<z>
locale.getLanguage())) {<z>
languageMatch = candidate;<z>
if (languageMatch != null) {<z>
return languageMatch;<z>
getDefaultLocale();<z>
));<z>
(@Nullable UriComponentsBuilder baseUrl) {<z>
== null ?<z>
ServletUriComponentsBuilder.fromCurrentServletMapping() :<z>
cloneBuilder();<z>
method) {<z>
(method, "HttpMethod must not be null");<z>
.method = method;<z>
;<z>
) {<z>
(newBuffer);<z>
();<z>
contentLength = this.expectedContentLength;<z>
getBufferSize() < contentLength) {<z>
();<z>
();<z>
();<z>
.stompDecoder.decode(bufferToDecode, headers);<z>
.hasRemaining()) {<z>
);<z>
(headers);<z>
messages;<z>
response)<z>
ServletException, IOException {<z>
, response);<z>
String toString() {<z>
(super.toString());<z>
this.relatedCauses != null) {<z>
for (Throwable relatedCause : this.relatedCauses) {<z>
"\nRelated cause: ");<z>
);<z>
sb.toString();<z>
, HttpServletRequest request) {<z>
) && other.isEmpty()) {<z>
0;<z>
{<z>
;<z>
(other.isEmpty()) {<z>
1;<z>
assertNumberOfConditions(other);<z>
(); i++) {<z>
i], request);<z>
if (result != 0) {<z>
return result;<z>
;<z>
Throwable ex) {<z>
ex instanceof RuntimeException) {<z>
) ex;<z>
if (ex instanceof Error) {<z>
;<z>
UndeclaredThrowableException(ex);<z>
RecordComponentVisitor(<z>
recordComponentVisitor) {<z>
api != Opcodes.ASM9<z>
api != Opcodes.ASM8<z>
ASM7<z>
api != Opcodes.ASM6<z>
.ASM5<z>
.ASM4<z>
api != Opcodes.ASM10_EXPERIMENTAL) {<z>
;<z>
api = api;<z>
recordComponentVisitor;<z>
) {<z>
String, String> caseInsensitiveParameterNames =<z>
SqlParameterSourceUtils.extractCaseInsensitiveParameterNames(parameterSource);<z>
callParameters.size());<z>
);<z>
) {<z>
)) {<z>
= parameter.getName();<z>
.parameterNameToUse(parameterName);<z>
(parameterNameToMatch != null) {<z>
parameterNameToMatch.toLowerCase(), parameterName);<z>
if (parameterName != null) {<z>
parameterSource.hasValue(parameterName)) {<z>
matchedParameters.put(parameterName,<z>
parameterName));<z>
parameterName.toLowerCase();<z>
(parameterSource.hasValue(lowerCaseName)) {<z>
.put(parameterName,<z>
(parameterSource, lowerCaseName));<z>
.ENGLISH);<z>
) {<z>
.put(parameterName,<z>
));<z>
;<z>
) {<z>
,<z>
propertyName));<z>
if (caseInsensitiveParameterNames.containsKey(lowerCaseName)) {<z>
get(lowerCaseName);<z>
parameterName,<z>
SqlParameterSourceUtils.getTypedValue(parameterSource, sourceName));<z>
else if (logger.isInfoEnabled()) {<z>
("Unable to locate the corresponding parameter value for '" +<z>
+<z>
;<z>
()) {<z>
.values());<z>
("Found match for " + matchedParameters.keySet());<z>
return matchedParameters;<z>
String trimTrailingWhitespace(String str) {<z>
{<z>
;<z>
);<z>
buildSafePointcut() {<z>
= getPointcut();<z>
MethodMatchers.intersection(<z>
.getMethodMatcher());<z>
, safeMethodMatcher);<z>
) {<z>
secureRandom = new SecureRandom();<z>
;<z>
secureRandom.nextBytes(seed);<z>
seed).longValue());<z>
DefaultNegotiation negotiation) {<z>
);<z>
protocol = responseHeaders.getFirst("Sec-WebSocket-Protocol");<z>
Mono.empty(), protocol);<z>
String beanName) {<z>
prototypesCurrentlyInCreation.get();<z>
instanceof String) {<z>
.prototypesCurrentlyInCreation.remove();<z>
) {<z>
String>) curVal;<z>
);<z>
if (beanNameSet.isEmpty()) {<z>
prototypesCurrentlyInCreation.remove();<z>
changeFirstCharacterCase(String str, boolean capitalize) {<z>
str)) {<z>
;<z>
char baseChar = str.charAt(0);<z>
char updatedChar;<z>
{<z>
;<z>
toLowerCase(baseChar);<z>
{<z>
return str;<z>
();<z>
= updatedChar;<z>
);<z>
{<z>
driverClassName, "Property 'driverClassName' must not be empty");<z>
= driverClassName.trim();<z>
, ClassUtils.getDefaultClassLoader());<z>
{<z>
+ driverClassNameToUse + "]", ex);<z>
if (logger.isDebugEnabled()) {<z>
driverClassNameToUse);<z>
(ServerWebExchange exchange) {<z>
ParamExpression expression : this.expressions) {<z>
!expression.match(exchange)) {<z>
return null;<z>
return this;<z>
ClassEmitter ce, int[] keys) {<z>
null);<z>
;<z>
;<z>
.load_this();<z>
;<z>
keys, new ProcessSwitchCallback() {<z>
, Label end) {<z>
));<z>
end);<z>
() {<z>
();<z>
);<z>
});<z>
;<z>
end_method();<z>
{<z>
.getHeaders() instanceof MutableMessageHeaders) {<z>
);<z>
MessageHeaderAccessor accessor = mutableHeaders.getAccessor();<z>
(message));<z>
(message);<z>
ListenableFuture<Void> shutdown() {<z>
if (this.stopping) {<z>
new SettableListenableFuture<>();<z>
;<z>
return future;<z>
.stopping = true;<z>
;<z>
channelGroup != null) {<z>
.channelGroup.close());<z>
null) {<z>
.loopResources.disposeLater());<z>
) {<z>
;<z>
(stopScheduler());<z>
result = stopScheduler();<z>
MonoToListenableFutureAdapter<>(result);<z>
) {<z>
(blahBuilder_ == null) {<z>
blah_ = SecondMsg.getDefaultInstance();<z>
;<z>
else {<z>
;<z>
~0x00000002);<z>
this;<z>
methodInvocation, Matcher matcher, StringBuffer output) {<z>
methodInvocation.getMethod().getParameterTypes();<z>
[argumentTypes.length];<z>
; i++) {<z>
ClassUtils.getShortName(argumentTypes[i]);<z>
appendReplacement(output,<z>
(argumentTypeShortNames)));<z>
BeanDefinition beanDefinition) throws IllegalStateException {<z>
registry.containsBeanDefinition(beanName)) {<z>
true;<z>
= this.registry.getBeanDefinition(beanName);<z>
BeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition();<z>
originatingDef != null) {<z>
;<z>
isCompatible(beanDefinition, existingDef)) {<z>
false;<z>
beanName +<z>
getBeanClassName() + "] conflicts with existing, " +<z>
+ existingDef.getBeanClassName() + "]");<z>
, @Nullable LockMode lockMode) throws DataAccessException {<z>
session -> {<z>
{<z>
LockOptions(lockMode));<z>
;<z>
}));<z>
static CacheParameterDetail initializeValueParameterDetail(<z>
) {<z>
;<z>
: allParameters) {<z>
{<z>
== null) {<z>
;<z>
IllegalArgumentException("More than one @CacheValue found on " + method + "");<z>
result;<z>
, @Nullable String content)<z>
SQLException {<z>
{<z>
!= null) {<z>
), content.length());<z>
) null);<z>
if (wrapAsLob) {<z>
{<z>
PassThroughClob(content));<z>
) null);<z>
;<z>
()) {<z>
null ? "Set string for CLOB with length " + content.length() :<z>
;<z>
public void afterPropertiesSet() {<z>
GsonBuilder builder = (this.base64EncodeByteArrays ?<z>
GsonBuilder());<z>
this.serializeNulls) {<z>
);<z>
this.prettyPrinting) {<z>
();<z>
.disableHtmlEscaping) {<z>
();<z>
null) {<z>
this.dateFormatPattern);<z>
.create();<z>
mergedConfig) throws Exception {<z>
mergedConfig instanceof WebMergedContextConfiguration,<z>
"Cannot load WebApplicationContext from non-web merged context configuration %s. " +<z>
);<z>
mergedConfig;<z>
if (logger.isDebugEnabled()) {<z>
String.format("Loading WebApplicationContext for merged context configuration %s.",<z>
webMergedConfig));<z>
webMergedConfig);<z>
GenericWebApplicationContext();<z>
= mergedConfig.getParentApplicationContext();<z>
!= null) {<z>
);<z>
(context, webMergedConfig);<z>
(context, webMergedConfig);<z>
getDefaultListableBeanFactory(), webMergedConfig);<z>
context, webMergedConfig);<z>
;<z>
customizeContext(context, webMergedConfig);<z>
;<z>
();<z>
context;<z>
visitFieldInsn(<z>
{<z>
= code.length;<z>
.addConstantFieldref(owner, name, descriptor);<z>
.index);<z>
) {<z>
COMPUTE_INSERTED_FRAMES) {<z>
0, fieldrefSymbol, symbolTable);<z>
{<z>
;<z>
0);<z>
(opcode) {<z>
.GETSTATIC:<z>
;<z>
:<z>
-1);<z>
:<z>
|| firstDescChar == 'J' ? 1 : 0);<z>
case Opcodes.PUTFIELD:<z>
;<z>
{<z>
size;<z>
= size;<z>
public String getLastTaskName() throws IllegalStateException {<z>
== null) {<z>
);<z>
);<z>
> valueType) {<z>
Class<?> valueTypeForLookup = valueType;<z>
(valueTypeForLookup == null) {<z>
);<z>
findEditor(field, valueTypeForLookup);<z>
!= null) {<z>
= null;<z>
!= null && getTarget() != null) {<z>
getPropertyTypeDescriptor(fixedField(field));<z>
)))) {<z>
;<z>
) {<z>
);<z>
)) {<z>
new ConvertingPropertyEditorAdapter(this.conversionService, td);<z>
editor;<z>
<?> testClass) {<z>
;<z>
.class;<z>
);<z>
) {<z>
debug("Retrieved @ProfileValueSourceConfiguration [" + config + "] for test class [" +<z>
() + "]");<z>
ProfileValueSource> profileValueSourceType;<z>
null) {<z>
);<z>
) AnnotationUtils.getDefaultValue(annotationType);<z>
;<z>
(logger.isDebugEnabled()) {<z>
"Retrieved ProfileValueSource type [" + profileValueSourceType + "] for class [" +<z>
.getName() + "]");<z>
;<z>
) {<z>
= SystemProfileValueSource.getInstance();<z>
;<z>
ex) {<z>
.isWarnEnabled()) {<z>
+ profileValueSourceType +<z>
getName() + "]: using default.", ex);<z>
();<z>
;<z>
handleResult(Object result) {<z>
subscribeToPublisher(result)) {<z>
(logger.isTraceEnabled()) {<z>
+ result);<z>
result instanceof CompletionStage) {<z>
) -> {<z>
!= null) {<z>
;<z>
if (event != null) {<z>
event);<z>
;<z>
if (result instanceof ListenableFuture) {<z>
this::publishEvents, this::handleAsyncError);<z>
(result);<z>
{<z>
{<z>
.applicationListenerBeans.remove(listenerBeanName);<z>
clear();<z>
> keySet() {<z>
<String> keySet = this.keySet;<z>
keySet == null) {<z>
.targetMap.keySet());<z>
.keySet = keySet;<z>
keySet;<z>
{<z>
{<z>
) {<z>
addAttribute(attributeValue);<z>
;<z>
{<z>
);<z>
.containsKey(inputToUse)) {<z>
);<z>
headerKeyUpdateCache) {<z>
;<z>
) {<z>
getBytes(StandardCharsets.UTF_8);<z>
put(inputToUse, bytes);<z>
inputToUse, bytes);<z>
return bytes;<z>
setSerializationId(@Nullable String serializationId) {<z>
if (serializationId != null) {<z>
(this));<z>
serializationId != null) {<z>
serializationId);<z>
serializationId;<z>
ctx, int idx) throws SpelEvaluationException {<z>
().getComponentType();<z>
Boolean.TYPE) {<z>
]) ctx;<z>
checkAccess(array.length, idx);<z>
= "Z";<z>
idx];<z>
(arrayComponentType == Byte.TYPE) {<z>
) ctx;<z>
array.length, idx);<z>
exitTypeDescriptor = "B";<z>
return array[idx];<z>
) {<z>
[]) ctx;<z>
.length, idx);<z>
this.exitTypeDescriptor = "C";<z>
array[idx];<z>
TYPE) {<z>
ctx;<z>
array.length, idx);<z>
;<z>
return array[idx];<z>
== Float.TYPE) {<z>
float[]) ctx;<z>
length, idx);<z>
this.exitTypeDescriptor = "F";<z>
[idx];<z>
.TYPE) {<z>
]) ctx;<z>
, idx);<z>
this.exitTypeDescriptor = "I";<z>
return array[idx];<z>
if (arrayComponentType == Long.TYPE) {<z>
] array = (long[]) ctx;<z>
(array.length, idx);<z>
"J";<z>
;<z>
== Short.TYPE) {<z>
ctx;<z>
.length, idx);<z>
"S";<z>
array[idx];<z>
(Object[]) ctx;<z>
);<z>
retValue = array[idx];<z>
= CodeFlow.toDescriptor(arrayComponentType);<z>
retValue;<z>
registerCustomEditors(PropertyEditorRegistry registry) {<z>
(this.resourceLoader, this.propertyResolver);<z>
);<z>
, ContextResource.class, baseEditor);<z>
(baseEditor));<z>
, new InputSourceEditor(baseEditor));<z>
baseEditor));<z>
PathEditor(baseEditor));<z>
(baseEditor));<z>
;<z>
getClassLoader();<z>
;<z>
));<z>
classLoader));<z>
{<z>
[].class,<z>
));<z>
callback) {<z>
this.result instanceof Throwable, "No Throwable result for failure state");<z>
.result);<z>
{<z>
DefaultSubscription(StompHeaders headers, StompFrameHandler handler) {<z>
());<z>
headers.getDestination(), "Destination must not be null");<z>
handler, "StompFrameHandler must not be null");<z>
this.headers = headers;<z>
;<z>
(headers.getId(), this);<z>
public String getSessionId() {<z>
) {<z>
, "-");<z>
.sessionId;<z>
statusCode) throws IOException {<z>
= response.getStatusText();<z>
;<z>
body = getResponseBody(response);<z>
response);<z>
, charset);<z>
statusCode.series()) {<z>
CLIENT_ERROR:<z>
headers, body, charset);<z>
case SERVER_ERROR:<z>
charset);<z>
charset);<z>
boolean areBoxingCompatible(String desc1, String desc2) {<z>
)) {<z>
;<z>
desc1.length() == 1) {<z>
("Z")) {<z>
return desc2.equals("Ljava/lang/Boolean");<z>
(desc1.equals("D")) {<z>
equals("Ljava/lang/Double");<z>
desc1.equals("F")) {<z>
);<z>
equals("I")) {<z>
;<z>
) {<z>
("Ljava/lang/Long");<z>
desc2.length() == 1) {<z>
{<z>
return desc1.equals("Ljava/lang/Boolean");<z>
equals("D")) {<z>
"Ljava/lang/Double");<z>
(desc2.equals("F")) {<z>
return desc1.equals("Ljava/lang/Float");<z>
.equals("I")) {<z>
equals("Ljava/lang/Integer");<z>
equals("J")) {<z>
;<z>
return false;<z>
HttpServletResponse response, @Nullable Exception ex) {<z>
{<z>
(i);<z>
);<z>
{<z>
ex2);<z>
, Object[] args) {<z>
= 0;<z>
i++) {<z>
, args[i])) {<z>
MAX_VALUE;<z>
if (args[i] != null) {<z>
> paramType = paramTypes[i];<z>
.getClass().getSuperclass();<z>
(superClass != null) {<z>
superClass)) {<z>
;<z>
null;<z>
(paramType, superClass)) {<z>
+ 2;<z>
getSuperclass();<z>
null;<z>
()) {<z>
result = result + 1;<z>
;<z>
String subProtocol) {<z>
.get();<z>
if (subProtocol != null) {<z>
.protocols(subProtocol);<z>
(this.maxFramePayloadLength != null) {<z>
maxFramePayloadLength(this.maxFramePayloadLength);<z>
handlePing != null) {<z>
.handlePing(this.handlePing);<z>
;<z>
@Nullable Object expectedValue) {<z>
content);<z>
List)) {<z>
.isEmpty()) {<z>
+ this.expression + "\"");<z>
) {<z>
+ actualValue +<z>
+ expectedValue);<z>
actualValue = actualValueList.get(0);<z>
!= null && expectedValue != null &&<z>
{<z>
(content, expectedValue.getClass());<z>
) {<z>
(<z>
getDescriptiveType(actualValue),<z>
.getDescriptiveType(expectedValue));<z>
));<z>
.expression + "\"", expectedValue, actualValue);<z>
caches) {<z>
CollectionUtils.isEmpty(caches)) {<z>
return null;<z>
.size() == 1) {<z>
next();<z>
"Unsupported cache resolution result " + caches +<z>
;<z>
public MatchableHandlerMapping getMatchableHandlerMapping(HttpServletRequest request) throws Exception {<z>
HttpServletRequest wrappedRequest = new AttributesPreservingRequest(request);<z>
-> {<z>
instanceof MatchableHandlerMapping) {<z>
pathPatternHandlerMappings.get(matchedMapping);<z>
!= null) {<z>
RequestPath requestPath = ServletRequestPathUtils.getParsedRequestPath(wrappedRequest);<z>
(mapping, requestPath);<z>
);<z>
PathSettingHandlerMapping((MatchableHandlerMapping) matchedMapping, lookupPath);<z>
("HandlerMapping is not a MatchableHandlerMapping");<z>
;<z>
(HttpServletRequest request, HttpServletResponse response, Object handler)<z>
{<z>
.handleRequest(request, response);<z>
?>>> prefixes) {<z>
!prefixes.isEmpty() ?<z>
prefixes)) :<z>
());<z>
Exception {<z>
(this.webSocketSession != null) {<z>
;<z>
mappedClass) {<z>
.mappedClass == null) {<z>
;<z>
{<z>
"The mapped class can not be reassigned to map to " +<z>
);<z>
[] argumentTypes, Object[] arguments) {<z>
false;<z>
!= arguments.length) {<z>
new IllegalArgumentException("Arguments must be non-null and of equal length");<z>
argumentTypes = argumentTypes;<z>
this.arguments = arguments;<z>
();<z>
request) {<z>
Locale.ENGLISH));<z>
= request.getHeaderNames();<z>
)) {<z>
;<z>
(!FORWARDED_HEADER_NAMES.contains(name)) {<z>
headerNames.add(name);<z>
unmodifiableSet(headerNames);<z>
final void skippedEntity(String name) throws SAXException {<z>
;<z>
catch (XMLStreamException ex) {<z>
(), ex);<z>
List<RouterFunction<?>> routerFunctions) {<z>
(mappingsLogger.isDebugEnabled()) {<z>
function));<z>
()) {<z>
);<z>
= total + " RouterFunction(s) in " + formatMappingName();<z>
{<z>
) {<z>
.trace("Mapped " + function));<z>
;<z>
{<z>
message);<z>
(<z>
) {<z>
<?> adaptedIfc;<z>
(actualInterfaces.length == 1) {<z>
];<z>
, this.beanClassLoader);<z>
null) {<z>
;<z>
) {<z>
scriptSource,<z>
scriptEngine);<z>
if (script != null) {<z>
, adaptedIfc);<z>
null) {<z>
.getInterface(adaptedIfc);<z>
) {<z>
,<z>
);<z>
;<z>
{<z>
convertKey(key), key);<z>
null;<z>
(key)) {<z>
.targetMap.remove(oldKey);<z>
put(key, value);<z>
;<z>
{<z>
()) {<z>
false;<z>
heldCon = conHolder.getConnection();<z>
passedInCon));<z>
) throws IOException {<z>
, headers);<z>
this.httpRequest instanceof HttpEntityEnclosingRequest entityEnclosingRequest) {<z>
= new ByteArrayEntity(bufferedOutput);<z>
(requestEntity);<z>
, this.httpContext);<z>
httpResponse);<z>
Charset charset)<z>
IOException, HttpMessageConversionException {<z>
) {<z>
charset);<z>
message, writer);<z>
flush();<z>
(<z>
"protobuf-java-util does not support printing " + contentType);<z>
() throws IOException {<z>
.mergedMappings = new Properties();<z>
mergedMappings);<z>
(this.mappingLocations != null) {<z>
) {<z>
()) {<z>
+ location);<z>
location);<z>
throws NotSupportedException, SystemException {<z>
();<z>
);<z>
) {<z>
setTransactionTimeout(timeout);<z>
();<z>
(tm);<z>
] toObjectArray(@Nullable Object source) {<z>
Object[]) {<z>
return (Object[]) source;<z>
) {<z>
;<z>
isArray()) {<z>
new IllegalArgumentException("Source is not an array: " + source);<z>
);<z>
0) {<z>
;<z>
();<z>
length);<z>
i < length; i++) {<z>
, i);<z>
newArray;<z>
filename) throws IOException {<z>
();<z>
InputStream is = resource.getInputStream()) {<z>
resource.getFilename();<z>
(XML_SUFFIX)) {<z>
)) {<z>
) + "]");<z>
propertiesPersister.loadFromXml(props, is);<z>
encoding = null;<z>
.fileEncodings != null) {<z>
(filename);<z>
) {<z>
();<z>
!= null) {<z>
) {<z>
"] with encoding '" + encoding + "'");<z>
(is, encoding));<z>
logger.isDebugEnabled()) {<z>
+ resource.getFilename() + "]");<z>
load(props, is);<z>
props;<z>
protected Mono<Void> handleMatch(<z>
Message<?> message) {<z>
).getPatterns();<z>
{<z>
.iterator().next();<z>
);<z>
"Missing destination header");<z>
destination);<z>
.isEmpty(vars)) {<z>
class);<z>
, "Mutable MessageHeaderAccessor required");<z>
setHeader(DestinationVariableMethodArgumentResolver.DESTINATION_TEMPLATE_VARIABLES_HEADER, vars);<z>
(mapping, handlerMethod, message);<z>
Void> writeAndFlushWithInternal(<z>
<? extends DataBuffer>> body) {<z>
(false, true)) {<z>
error(new IllegalStateException(<z>
));<z>
createBodyFlushProcessor();<z>
return Mono.from(subscriber -> {<z>
body.subscribe(processor);<z>
subscriber);<z>
);<z>
Object retrieveAttribute(WebRequest request, String attributeName) {<z>
(request, "WebRequest must not be null");<z>
;<z>
String storeAttributeName = getAttributeNameInSession(request, attributeName);<z>
WebRequest.SCOPE_SESSION);<z>
protected String formatRequest(ServerHttpRequest request) {<z>
.getRawQuery();<z>
rawQuery : "";<z>
request.getPath() + query + "\"";<z>
Element element, BeanDefinitionBuilder builder) {<z>
;<z>
{<z>
("generateUniqueDatabaseName", generateName);<z>
ServerWebExchange exchange) throws UnsupportedMediaTypeStatusException {<z>
().getContentType();<z>
? contentType : MediaType.APPLICATION_OCTET_STREAM);<z>
(contentType);<z>
catch (InvalidMediaTypeException ex) {<z>
"Can't parse Content-Type [" +<z>
.getHeaders().getFirst("Content-Type") +<z>
));<z>
Binding> bindings) {<z>
"Collection must not be null");<z>
.size());<z>
getBindMarker(), binding));<z>
.bindings = mapping;<z>
model, String encodingScheme)<z>
{<z>
null;<z>
int anchorIndex = targetUrl.indexOf("#");<z>
> -1) {<z>
targetUrl.substring(anchorIndex);<z>
);<z>
0);<z>
.entrySet()) {<z>
rawValue = entry.getValue();<z>
?> values;<z>
().isArray()) {<z>
arrayToList(rawValue);<z>
rawValue instanceof Collection) {<z>
rawValue);<z>
(rawValue);<z>
(Object value : values) {<z>
) {<z>
'?');<z>
= false;<z>
append('&');<z>
;<z>
) : "");<z>
(encodedValue);<z>
(fragment != null) {<z>
(fragment);<z>
, ClassLoader loader) throws ClassNotFoundException {<z>
indexOf('(');<z>
(')', lparen);<z>
ArrayList();<z>
lparen + 1;<z>
{<z>
.indexOf(',', start);<z>
(comma < 0) {<z>
, comma).trim());<z>
+ 1;<z>
rparen) {<z>
;<z>
()];<z>
) {<z>
loader);<z>
;<z>
void afterConnectionEstablished(WebSocketSession session) {<z>
().afterConnectionEstablished(session);<z>
ex) {<z>
logger);<z>
) {<z>
ResultValuePrinter() {<z>
printHeading(String heading) {<z>
();<z>
"%s:", heading));<z>
label, @Nullable Object value) {<z>
.isArray()) {<z>
value = CollectionUtils.arrayToList(value);<z>
"%17s = %s", label, value));<z>
);<z>
, ParserContext parserContext) {<z>
instanceof Attr attr) {<z>
).getLocalName(attr);<z>
= attr.getValue();<z>
();<z>
if (pvs.contains(propertyName)) {<z>
+ propertyName + "' is already defined using " +<z>
"both <property> and inline syntax. Only one approach may be used per property.", attr);<z>
) {<z>
) - REF_SUFFIX.length());<z>
);<z>
propertyValue);<z>
return definition;<z>
> body) {<z>
) -> {<z>
).map(DataBuffer::asByteBuffer);<z>
);<z>
});<z>
protected XStream buildXStream() {<z>
();<z>
configureXStream(xstream);<z>
(xstream);<z>
;<z>
() {<z>
state = new HashMap<>();<z>
{<z>
next();<z>
;<z>
.getValue();<z>
remove();<z>
{<z>
);<z>
{<z>
value));<z>
state;<z>
CallbackFilter filter, Callback[] callbacks) {<z>
Enhancer e = new Enhancer();<z>
e.setSuperclass(superclass);<z>
;<z>
(filter);<z>
(callbacks);<z>
);<z>
Session session, CloseReason reason) {<z>
if (this.delegateSession != null) {<z>
().getCode();<z>
.getReasonPhrase()));<z>
pvs) {<z>
;<z>
);<z>
needsRefresh(metadata, clazz)) {<z>
(this.injectionMetadataCache) {<z>
get(cacheKey);<z>
{<z>
) {<z>
(pvs);<z>
clazz);<z>
);<z>
metadata;<z>
) {<z>
value == null) {<z>
return null;<z>
);<z>
) {<z>
match : this.partialMatches) {<z>
if (match.hasParamsMatch()) {<z>
return false;<z>
return true;<z>
void writeProperty(<z>
evalContext, String name, @Nullable Object newValue)<z>
{<z>
) == null && this.nullSafe) {<z>
() == null) {<z>
), SpelMessage.PROPERTY_OR_FIELD_NOT_WRITABLE_ON_NULL, name);<z>
.cachedWriteAccessor;<z>
null) {<z>
().contains(accessorToUse)) {<z>
(), name, newValue);<z>
Exception ex) {<z>
null;<z>
List<PropertyAccessor> accessorsToTry =<z>
evalContext.getPropertyAccessors());<z>
{<z>
)) {<z>
accessor;<z>
, name, newValue);<z>
) {<z>
SpelMessage.EXCEPTION_DURING_PROPERTY_WRITE,<z>
);<z>
, SpelMessage.PROPERTY_OR_FIELD_NOT_WRITABLE, name,<z>
())));<z>
Nullable Object value,<z>
, Throwable cause) {<z>
, cause);<z>
.name = name;<z>
= param;<z>
PropertyAccessException[] propertyAccessExceptions) {<z>
, null);<z>
(propertyAccessExceptions, "At least 1 PropertyAccessException required");<z>
propertyAccessExceptions;<z>
) {<z>
this.connectorTargetSource = new JMXConnectorLazyInitTargetSource();<z>
= new MBeanServerConnectionLazyInitTargetSource();<z>
connector = (JMXConnector)<z>
;<z>
connection = (MBeanServerConnection)<z>
connectionTargetSource).getProxy(this.beanClassLoader);<z>
{<z>
"";<z>
= new TransferSimpSession();<z>
.destination = "";<z>
binderFactory) {<z>
SessionAttributesHandler sessionAttrHandler = getSessionAttributesHandler(handlerMethod);<z>
handlerMethod.getBeanType();<z>
modelAttributeCache.get(handlerType);<z>
== null) {<z>
.selectMethods(handlerType, MODEL_ATTRIBUTE_METHODS);<z>
handlerType, methods);<z>
>();<z>
-> {<z>
isApplicableToBeanType(handlerType)) {<z>
= controllerAdviceBean.resolveBean();<z>
for (Method method : methodSet) {<z>
createModelAttributeMethod(binderFactory, bean, method));<z>
);<z>
) {<z>
Object bean = handlerMethod.getBean();<z>
(binderFactory, bean, method));<z>
binderFactory, sessionAttrHandler);<z>
String cookieValue) {<z>
.notNull(response, "HttpServletResponse must not be null");<z>
(cookieValue);<z>
getCookieMaxAge();<z>
if (maxAge != null) {<z>
.setMaxAge(maxAge);<z>
)) {<z>
cookie.setSecure(true);<z>
)) {<z>
);<z>
addCookie(cookie);<z>
()) {<z>
"=" + cookieValue + "]");<z>
bean) {<z>
);<z>
if (bean instanceof SmartLifecycle) {<z>
.smartMemberCount++;<z>
<String, Object> processResultSet(<z>
ResultSet rs, ResultSetSupportingSqlParameter param) throws SQLException {<z>
) {<z>
) {<z>
param.getRowMapper();<z>
).extractData(rs);<z>
data);<z>
param.getRowCallbackHandler() != null) {<z>
param.getRowCallbackHandler();<z>
;<z>
getName(),<z>
);<z>
null) {<z>
.getResultSetExtractor().extractData(rs);<z>
.getName(), data);<z>
rs);<z>
;<z>
<T> publisher, Throwable t) {<z>
(this, COMPLETED)) {<z>
publisher.discardData();<z>
s = publisher.subscriber;<z>
) {<z>
);<z>
).onError(publisher, t);<z>
void applyCookiesIfNecessary() {<z>
) == null) {<z>
stream().flatMap(Collection::stream)<z>
COOKIE, cookie.toString()));<z>
> uriVariables)<z>
throws RestClientException {<z>
requestCallback = httpEntityCallback(request);<z>
.PUT, requestCallback, null, uriVariables);<z>
{<z>
"Value must not be empty");<z>
.notNull(type, "Type must not be null");<z>
BitsCronField result = new BitsCronField(type);<z>
(value, ",");<z>
(String field : fields) {<z>
'/');<z>
(slashPos == -1) {<z>
field, type);<z>
(range);<z>
;<z>
= field.substring(slashPos + 1);<z>
parseRange(rangeStr, type);<z>
1) {<z>
;<z>
Integer.parseInt(deltaStr);<z>
(delta <= 0) {<z>
new IllegalArgumentException("Incrementer delta must be 1 or higher");<z>
, delta);<z>
result;<z>
ex) {<z>
;<z>
new IllegalArgumentException(msg, ex);<z>
public Class<?> getObjectType() {<z>
) {<z>
null;<z>
().getReturnType();<z>
(final MethodInvocation invocation) throws Throwable {<z>
()) : null);<z>
), targetClass);<z>
.findBridgedMethod(specificMethod);<z>
= determineAsyncExecutor(userDeclaredMethod);<z>
executor == null) {<z>
new IllegalStateException(<z>
"No executor specified and no default executor set on AsyncExecutionInterceptor either");<z>
Object> task = () -> {<z>
();<z>
(result instanceof Future) {<z>
>) result).get();<z>
{<z>
());<z>
catch (Throwable ex) {<z>
, userDeclaredMethod, invocation.getArguments());<z>
;<z>
.getReturnType());<z>
{<z>
getMethod();<z>
getName() + "'" : "constructor") +<z>
this.parameterIndex;<z>
setImmutable() {<z>
)) {<z>
> map = getNativeHeaders();<z>
!= null) {<z>
);<z>
NATIVE_HEADERS, Collections.unmodifiableMap(map));<z>
();<z>
Object handler)<z>
ServletException {<z>
;<z>
!= null) {<z>
(request);<z>
themeResolver == null) {<z>
throw new IllegalStateException("No ThemeResolver found: not in a DispatcherServlet request?");<z>
, newTheme);<z>
true;<z>
, KeyHolder generatedKeyHolder)<z>
DataAccessException {<z>
);<z>
,<z>
context)<z>
, IOException {<z>
, context);<z>
return null;<z>
) throws AccessException {<z>
) {<z>
false;<z>
;<z>
()) {<z>
return false;<z>
member instanceof Method method) {<z>
;<z>
.getName())) {<z>
;<z>
StringUtils.capitalize(name);<z>
())) {<z>
true;<z>
);<z>
PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {<z>
head == null) {<z>
, pathContainer);<z>
) {<z>
null;<z>
true);<z>
);<z>
(0, matchingContext);<z>
matches) {<z>
return null;<z>
;<z>
;<z>
) {<z>
pathContainer;<z>
= EMPTY_PATH;<z>
, matchingContext.remainingPathIndex);<z>
matchingContext.remainingPathIndex);<z>
);<z>
MediaType contentType) {<z>
;<z>
);<z>
return this;<z>
getConnection() throws CannotGetJdbcConnectionException {<z>
getDataSource();<z>
"No DataSource set");<z>
.getConnection(dataSource);<z>
protected void customizeContext(<z>
) {<z>
customizeContext(context, webMergedConfig);<z>
> methodDetails, CacheResolver cacheResolver,<z>
, @Nullable CacheResolver exceptionCacheResolver) {<z>
);<z>
ann = methodDetails.getCacheAnnotation();<z>
(), ann.nonCachedExceptions());<z>
exceptionCacheResolver;<z>
.exceptionCacheName() : null);<z>
{<z>
) transaction;<z>
txObject.setResourceHolder(null);<z>
.unbindResource(obtainConnectionFactory());<z>
source) {<z>
= new Properties();<z>
ISO_8859_1)));<z>
return props;<z>
{<z>
"] into Properties", ex);<z>
> registerAfterCompletionWithExistingTransaction(TransactionSynchronizationManager synchronizationManager,<z>
) throws TransactionException {<z>
"Cannot register Spring after-completion synchronization with existing transaction - " +<z>
;<z>
(synchronizationManager, synchronizations, TransactionSynchronization.STATUS_UNKNOWN);<z>
) {<z>
servletContext = request.getServletContext();<z>
.securityContextMethod.invoke(servletContext);<z>
invoke(null, securityContext, request);<z>
null) {<z>
);<z>
(securityProvider);<z>
;<z>
Exception ex) {<z>
("Failed to obtain SubjectHandle", ex);<z>
Charset charset) {<z>
Assert.notNull(baos, "No ByteArrayOutputStream specified");<z>
);<z>
.toString(charset);<z>
bodyMono) {<z>
VALUE_NONE).map(body -><z>
<>(<z>
? (T) body : null,<z>
(),<z>
.rawStatusCode()));<z>
private String cleanLeadingSlash(String path) {<z>
;<z>
length(); i++) {<z>
(i) == '/') {<z>
= true;<z>
(i) != 127) {<z>
)) {<z>
path;<z>
);<z>
return (slash ? "/" : "");<z>
Nullable int[] types) throws InvalidDataAccessApiUsageException {<z>
{<z>
;<z>
if (types != null) {<z>
{<z>
;<z>
ClassLoader getClassLoader() {<z>
this.customClassLoader) {<z>
getClassLoader();<z>
super.getClassLoader();<z>
) {<z>
ObjectUtils.isEmpty(handlers)) {<z>
);<z>
this;<z>
() throws IllegalStateException {<z>
null) {<z>
"Can't stop StopWatch: it's not running");<z>
startTimeNanos;<z>
;<z>
currentTaskName, lastTime);<z>
if (this.keepTaskList) {<z>
.taskList.add(this.lastTaskInfo);<z>
++this.taskCount;<z>
this.currentTaskName = null;<z>
Callback callback) {<z>
= new Enhancer();<z>
.setSuperclass(type);<z>
callback);<z>
e.create();<z>
void destroySingletons() {<z>
)) {<z>
);<z>
singletonObjects) {<z>
true;<z>
;<z>
synchronized (this.disposableBeans) {<z>
);<z>
; i >= 0; i--) {<z>
disposableBeanNames[i]);<z>
.containedBeanMap.clear();<z>
.clear();<z>
);<z>
);<z>
String annotationName,<z>
classValuesAsString) {<z>
annotationName,<z>
firstDirectlyDeclared());<z>
isPresent()) {<z>
;<z>
true));<z>
, HandlerMethod handlerMethod) {<z>
handlerType = handlerMethod.getBeanType();<z>
getBean();<z>
this.exceptionHandlerCache<z>
)<z>
ex);<z>
) {<z>
entrySet()) {<z>
entry.getKey();<z>
if (advice.isApplicableToBeanType(handlerType)) {<z>
= advice.resolveBean();<z>
resolveMethodByThrowable(ex);<z>
(targetMethod != null) {<z>
null) {<z>
;<z>
);<z>
;<z>
invocable;<z>
> getScriptedObjectType(ScriptSource scriptSource)<z>
{<z>
return null;<z>
Map<?, ?> mapVal) {<z>
= new LinkedHashMap();<z>
entriesModified = false;<z>
()) {<z>
getKey();<z>
: 0);<z>
;<z>
: 0);<z>
);<z>
;<z>
;<z>
newKey != key || newKeyHash != keyHash);<z>
(entriesModified) {<z>
clear();<z>
);<z>
void locales(MockHttpServletRequest request) {<z>
"Accept-Language");<z>
null) {<z>
addPreferredLocale(Locale.getDefault());<z>
{<z>
(this.pointcutMonitor) {<z>
pointcut == null) {<z>
;<z>
.patterns != null) {<z>
patterns);<z>
this.pointcut;<z>
getLongParameter(ServletRequest request, String name)<z>
{<z>
) == null) {<z>
null;<z>
name);<z>
... elements) {<z>
"Elements must not be null");<z>
.clone();<z>
params);<z>
Nullable MimeType mimeType,<z>
<String, Object> hints) {<z>
this.ssePrettyPrinter != null &&<z>
isCompatibleWith(mimeType) &&<z>
INDENT_OUTPUT) ?<z>
;<z>
RequestPostProcessor beforeMockMvcCreated(ConfigurableMockMvcBuilder<?> builder,<z>
context) {<z>
{<z>
) {<z>
this.session);<z>
;<z>
{<z>
{<z>
);<z>
() {<z>
currentAttempts++;<z>
currentAttempts <= getMaxAttempts()) {<z>
);<z>
return STOP;<z>
MediaType> getAccept() {<z>
if (this.cachedAccept != null) {<z>
.cachedAccept;<z>
accept = super.getAccept();<z>
.cachedAccept = accept;<z>
accept;<z>
Element ele, String childEleName) {<z>
(ele, "Element must not be null");<z>
childEleName, "Element name must not be null");<z>
= ele.getChildNodes();<z>
getLength(); i++) {<z>
item(i);<z>
) {<z>
return (Element) node;<z>
return null;<z>
String name, Object value, boolean replace) {<z>
, "Header value must not be null");<z>
));<z>
replace) {<z>
setValue(value);<z>
;<z>
MediaType getContentType() {<z>
this.cachedContentType != null) {<z>
;<z>
MediaType contentType = super.getContentType();<z>
= contentType;<z>
contentType;<z>
{<z>
mappingRegistry.acquireReadLock();<z>
Collections.unmodifiableMap(<z>
entrySet().stream()<z>
.getValue().handlerMethod)));<z>
.releaseReadLock();<z>
{<z>
this.urlPathHelper == UrlPathHelper.defaultInstance) {<z>
.urlPathHelper = new UrlPathHelper();<z>
IllegalStateException {<z>
.get();<z>
(proxy == null) {<z>
new IllegalStateException(<z>
);<z>
;<z>
? extends Map> targetMapClass) {<z>
targetMapClass == null) {<z>
IllegalArgumentException("'targetMapClass' must not be null");<z>
.class.isAssignableFrom(targetMapClass)) {<z>
;<z>
targetMapClass;<z>
nextEvent() {<z>
(hasNext()) {<z>
.events.get(this.cursor);<z>
cursor++;<z>
;<z>
NoSuchElementException();<z>
newInstantiatorOf(Class<T> clazz) {<z>
;<z>
= this.strategy.newInstantiatorOf(clazz);<z>
{<z>
worthTrying = Boolean.TRUE;<z>
;<z>
catch (ObjenesisException ex) {<z>
) {<z>
= ex.getCause();<z>
instanceof ClassNotFoundException || cause instanceof IllegalAccessException) {<z>
.worthTrying = Boolean.FALSE;<z>
throw ex;<z>
(NoClassDefFoundError err) {<z>
if (currentWorthTrying == null) {<z>
;<z>
ObjenesisException(err);<z>
{<z>
: getApplicationListeners()) {<z>
);<z>
);<z>
(String listenerBeanName : listenerBeanNames) {<z>
getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);<z>
;<z>
this.earlyApplicationEvents = null;<z>
earlyEventsToProcess)) {<z>
ApplicationEvent earlyEvent : earlyEventsToProcess) {<z>
);<z>
, @Nullable Object rejectedValue, boolean bindingFailure,<z>
, @Nullable String defaultMessage) {<z>
, codes, arguments, defaultMessage);<z>
field, "Field must not be null");<z>
this.field = field;<z>
;<z>
bindingFailure = bindingFailure;<z>
(ServerWebExchange exchange) {<z>
Void> completion;<z>
(exchange);<z>
(Throwable ex) {<z>
;<z>
) {<z>
);<z>
completion;<z>
index, String[] messages) {<z>
= getUndelivered(messages, index);<z>
)) {<z>
"Dropped inbound message(s) due to closed session: " + undelivered);<z>
dir) {<z>
= dir.listFiles();<z>
{<z>
logger.isInfoEnabled()) {<z>
+ "]");<z>
0];<z>
));<z>
return files;<z>
, Date lastCompletionTime) {<z>
();<z>
.lastScheduledExecutionTime = lastScheduledExecutionTime;<z>
= lastActualExecutionTime;<z>
lastCompletionTime;<z>
> getValuesForSuffix(@Nullable String nameSuffix) {<z>
.ENGLISH) : "");<z>
);<z>
) -> {<z>
code.endsWith(suffixToUse)) {<z>
add(value);<z>
);<z>
values;<z>
Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {<z>
{<z>
null;<z>
)) {<z>
;<z>
0) {<z>
return null;<z>
source, 0);<z>
elementTypeDescriptor(firstElement), targetType);<z>
request) {<z>
;<z>
(locale == null) {<z>
;<z>
locale;<z>
, URI uri,<z>
<String, Cookie> cookies,<z>
, MultiValueMap<String, String> params,<z>
{<z>
this.servletRequest = servletRequest;<z>
;<z>
= uri;<z>
;<z>
cookies);<z>
;<z>
);<z>
remoteAddress;<z>
body;<z>
messageConverters = messageConverters;<z>
void bindTo(BindTarget target) {<z>
()) {<z>
getValue(namedParameter);<z>
if (value == null) {<z>
));<z>
bind(target, namedParameter, value);<z>
value) {<z>
;<z>
.hasText(name, "Parameter name must not be null or empty!");<z>
format(<z>
, name));<z>
this.byName);<z>
instanceof Parameter) {<z>
, (Parameter) value);<z>
value, value.getClass()));<z>
;<z>
public void setAsText(@Nullable String text) {<z>
) {<z>
(null);<z>
text.trim();<z>
(this.charsToDelete != null) {<z>
deleteAny(value, this.charsToDelete);<z>
)) {<z>
;<z>
value);<z>
{<z>
int pos = 0;<z>
this.pattern != null) {<z>
length()) {<z>
== '{') {<z>
uriVars++;<z>
++;<z>
pos) == '*') {<z>
== '*') {<z>
this.doubleWildcards++;<z>
+= 2;<z>
(".*")) {<z>
.singleWildcards++;<z>
;<z>
pos++;<z>
;<z>
public String toString() {<z>
();<z>
name != null) {<z>
() + "}";<z>
return "DefaultFormFieldPart";<z>
request, String name) {<z>
getRequiredBooleanParameters(request, name);<z>
{<z>
[0];<z>
void stopInternal() throws Exception {<z>
{<z>
stop();<z>
stopInternal();<z>
WebResponseData webResponseData() throws IOException {<z>
;<z>
this.response.getRedirectedUrl() != null ?<z>
this.response.getStatus());<z>
statusMessage = statusMessage(statusCode);<z>
, statusMessage, responseHeaders);<z>
protected void initHandlerMethods() {<z>
class);<z>
{<z>
!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {<z>
<?> beanType = null;<z>
obtainApplicationContext().getType(beanName);<z>
(Throwable ex) {<z>
logger.isTraceEnabled()) {<z>
+ beanName + "'", ex);<z>
(beanType)) {<z>
detectHandlerMethods(beanName);<z>
handlerMethodsInitialized(getHandlerMethods());<z>
{<z>
.patternsCondition,<z>
.paramsCondition, this.headersCondition,<z>
consumesCondition, this.producesCondition,<z>
options);<z>
addHeaders(HttpURLConnection connection, HttpHeaders headers) {<z>
;<z>
method.equals("DELETE")) {<z>
{<z>
.ACCEPT, "*/*");<z>
, headerValues) -> {<z>
(headerName)) {<z>
"; ");<z>
setRequestProperty(headerName, headerValue);<z>
(String headerValue : headerValues) {<z>
actualHeaderValue = headerValue != null ? headerValue : "";<z>
;<z>
});<z>
visit(String name, Object value) {<z>
instanceof Type) {<z>
);<z>
put(name, value);<z>
UriComponentsBuilder fromUriString(String uri) {<z>
);<z>
matcher(uri);<z>
.matches()) {<z>
);<z>
;<z>
userInfo = matcher.group(5);<z>
);<z>
8);<z>
(9);<z>
;<z>
group(13);<z>
opaque = false;<z>
scheme)) {<z>
(scheme.length());<z>
{<z>
true;<z>
;<z>
{<z>
) + 1);<z>
{<z>
+ 1));<z>
builder.schemeSpecificPart(ssp);<z>
) {<z>
+ uri + "] is not a valid HTTP URL");<z>
builder.userInfo(userInfo);<z>
host(host);<z>
.hasLength(port)) {<z>
;<z>
builder.path(path);<z>
);<z>
if (StringUtils.hasText(fragment)) {<z>
(fragment);<z>
builder;<z>
+ "] is not a valid URI");<z>
? extends Annotation> annotationType) {<z>
||<z>
{<z>
element.isAnnotationPresent(annotationType);<z>
getAnnotations(element).isPresent(annotationType);<z>
throws Exception {<z>
, String>>)<z>
, RequestAttributes.SCOPE_REQUEST);<z>
)) {<z>
null;<z>
;<z>
(ann != null, "No MatrixVariable annotation");<z>
;<z>
paramValues = null;<z>
equals(ValueConstants.DEFAULT_NONE)) {<z>
(pathVar)) {<z>
(name);<z>
= false;<z>
;<z>
pathParameters.values()) {<z>
(name)) {<z>
{<z>
parameter.getNestedParameterType().getName();<z>
new ServletRequestBindingException(<z>
name +<z>
"]. Use 'pathVar' attribute to disambiguate.");<z>
(params.get(name));<z>
;<z>
CollectionUtils.isEmpty(paramValues)) {<z>
;<z>
{<z>
(0);<z>
return paramValues;<z>
(Class<T> clazz) {<z>
this.cache.get(clazz);<z>
null) {<z>
= newInstantiatorOf(clazz);<z>
;<z>
null) {<z>
instantiator = newInstantiator;<z>
(ObjectInstantiator<T>) instantiator;<z>
(HttpServletRequest request, String name)<z>
{<z>
name);<z>
== null) {<z>
new IllegalStateException("No session attribute '" + name + "' found");<z>
;<z>
] getDefaultConfigLocations() {<z>
) {<z>
{DEFAULT_CONFIG_LOCATION_PREFIX + getNamespace() + DEFAULT_CONFIG_LOCATION_SUFFIX};<z>
String[] {DEFAULT_CONFIG_LOCATION};<z>
) throws IncorrectResultSizeDataAccessException {<z>
)) {<z>
EmptyResultDataAccessException(1);<z>
> 1) {<z>
());<z>
results.iterator().next();<z>
code, Locale locale) {<z>
.properties == null) {<z>
return null;<z>
.cachedMessageFormats.get(code);<z>
!= null) {<z>
get(locale);<z>
result != null) {<z>
return result;<z>
= this.properties.getProperty(code);<z>
!= null) {<z>
(localeMap == null) {<z>
ConcurrentHashMap<>();<z>
putIfAbsent(code, localeMap);<z>
existing != null) {<z>
;<z>
);<z>
locale, result);<z>
return result;<z>
return null;<z>
public TaskExecutorRegistration taskExecutor(@Nullable ThreadPoolTaskExecutor taskExecutor) {<z>
this.registration == null) {<z>
(taskExecutor) :<z>
());<z>
return this.registration;<z>
View> defaultViews) {<z>
();<z>
defaultViews != null) {<z>
.defaultViews.addAll(defaultViews);<z>
... modules) {<z>
putShort(access);<z>
modules == null) {<z>
opens.putShort(0);<z>
else {<z>
putShort(modules.length);<z>
) {<z>
module).index);<z>
++;<z>
ParamsRequestCondition getMatchingCondition(HttpServletRequest request) {<z>
expression : this.expressions) {<z>
!expression.match(request)) {<z>
;<z>
;<z>
List<TypeDescriptor> argumentTypes)<z>
throws AccessException {<z>
typeConverter = context.getTypeConverter();<z>
getTypeLocator().findType(typeName);<z>
[] ctors = type.getConstructors();<z>
));<z>
> closeMatch = null;<z>
> matchRequiringConversion = null;<z>
Constructor<?> ctor : ctors) {<z>
ctor.getParameterCount();<z>
paramCount);<z>
; i < paramCount; i++) {<z>
);<z>
;<z>
) {<z>
typeConverter);<z>
) {<z>
paramDescriptors, argumentTypes, typeConverter);<z>
if (matchInfo != null) {<z>
if (matchInfo.isExactMatch()) {<z>
(ctor);<z>
()) {<z>
;<z>
else if (matchInfo.isMatchRequiringConversion()) {<z>
= ctor;<z>
) {<z>
closeMatch);<z>
matchRequiringConversion != null) {<z>
new ReflectiveConstructorExecutor(matchRequiringConversion);<z>
null;<z>
ex) {<z>
ex);<z>
{<z>
(substring) &&<z>
(substring)) {<z>
(nullSafeGet(messageSupplier));<z>
MediaType handleNoMatch(NativeWebRequest request, String key)<z>
throws HttpMediaTypeNotAcceptableException {<z>
isUseRegisteredExtensionsOnly()) {<z>
.getMediaType("file." + key);<z>
) {<z>
;<z>
()) {<z>
;<z>
);<z>
{<z>
};<z>
@Nullable String beanName, BeanFactory owner,<z>
> ctor, Object... args) {<z>
.instantiate(ctor, args);<z>
(Consumer<DatabaseClient.Builder> builderConsumer) {<z>
);<z>
builderConsumer.accept(this);<z>
this;<z>
boolean isFile(URI uri) {<z>
).startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {<z>
.getResource(uri).isFile();<z>
());<z>
{<z>
;<z>
doResolveException(<z>
ex) {<z>
= determineViewName(ex, request);<z>
) {<z>
(request, viewName);<z>
{<z>
statusCode);<z>
, request);<z>
return null;<z>
> getTargetClass() {<z>
.targetClass;<z>
!= null) {<z>
targetClass;<z>
(this) {<z>
targetClass = this.targetClass;<z>
== null && this.beanFactory != null) {<z>
.targetBeanName);<z>
== null) {<z>
logger.isTraceEnabled()) {<z>
("Getting bean with name '" + this.targetBeanName + "' for type determination");<z>
.beanFactory.getBean(this.targetBeanName);<z>
beanInstance.getClass();<z>
= targetClass;<z>
;<z>
boolean isChainedImportOnStack(ConfigurationClass configClass) {<z>
(configClass)) {<z>
configClass.getMetadata().getClassName();<z>
.getImportingClassFor(configClassName);<z>
while (importingClass != null) {<z>
))) {<z>
;<z>
.getImportingClassFor(importingClass.getClassName());<z>
;<z>
(<z>
existing, MergedAnnotation<Annotation> candidate) {<z>
< existing.getDistance()) {<z>
;<z>
return existing;<z>
{<z>
getAccessor(message, StompHeaderAccessor.class);<z>
!= null, "No StompHeaderAccessor");<z>
.sessionId);<z>
= accessor.getCommand();<z>
= accessor.getNativeHeaders();<z>
StompHeaders.readOnlyStompHeaders(nativeHeaders);<z>
accessor.isHeartbeat();<z>
logger.isTraceEnabled()) {<z>
getDetailedLogMessage(message.getPayload()));<z>
.equals(command)) {<z>
);<z>
null) {<z>
(), message, headers);<z>
.isDebugEnabled()) {<z>
.getDetailedLogMessage(message.getPayload()) +<z>
;<z>
.RECEIPT.equals(command)) {<z>
= headers.getReceiptId();<z>
);<z>
!= null) {<z>
handleReceiptReceived();<z>
logger.isDebugEnabled()) {<z>
)));<z>
.equals(command)) {<z>
initHeartbeatTasks(headers);<z>
);<z>
(this);<z>
this, headers);<z>
equals(command)) {<z>
headers);<z>
isTraceEnabled()) {<z>
;<z>
) {<z>
;<z>
?> beanType, String beanName) {<z>
.class.isAssignableFrom(beanType)) {<z>
beanDefinition.isSingleton());<z>
, @Nullable Throwable cause) {<z>
"]: " + msg, cause);<z>
.beanClass = constructingMethod.getReturnType();<z>
null;<z>
.constructingMethod = constructingMethod;<z>
{<z>
);<z>
.isAssignableFrom(parameter.getParameterType()) &&<z>
;<z>
() {<z>
();<z>
.resourceLoader);<z>
;<z>
resourceChainRegistration != null) {<z>
;<z>
getResourceTransformers());<z>
.cacheControl != null) {<z>
this.cacheControl);<z>
.setUseLastModified(this.useLastModified);<z>
;<z>
if (this.mediaTypes != null) {<z>
.setMediaTypes(this.mediaTypes);<z>
handler;<z>
final Properties getObject() throws IOException {<z>
.singleton) {<z>
return this.singletonInstance;<z>
createProperties();<z>
public void initializeCaches() {<z>
loadCaches();<z>
synchronized (this.cacheMap) {<z>
;<z>
();<z>
);<z>
for (Cache cache : caches) {<z>
= cache.getName();<z>
(cache));<z>
(name);<z>
;<z>
boolean equals(@Nullable Object other) {<z>
(this == other) {<z>
;<z>
instanceof SuffixByteRange otherRange)) {<z>
return false;<z>
;<z>
void processGroupImports() {<z>
)) {<z>
exclusionFilter = grouping.getCandidateFilter();<z>
.getImports().forEach(entry -> {<z>
.get(entry.getMetadata());<z>
, asSourceClass(configurationClass, exclusionFilter),<z>
getImportClassName(), exclusionFilter)),<z>
, false);<z>
{<z>
;<z>
) {<z>
BeanDefinitionStoreException(<z>
);<z>
;<z>
(Map<String, ?> params) {<z>
"Parameter map must not be null");<z>
) -> {<z>
) {<z>
addParameter(key, (String) value);<z>
]) {<z>
]) value);<z>
new IllegalArgumentException("Parameter map value must be single value " +<z>
.getName() + "]");<z>
});<z>
Nullable Class<?> contextClass, HttpInputMessage inputMessage)<z>
, HttpMessageNotReadableException {<z>
);<z>
(<z>
@Qualifier("mvcContentNegotiationManager") ContentNegotiationManager contentNegotiationManager) {<z>
<>();<z>
;<z>
{<z>
, contentNegotiationManager);<z>
);<z>
);<z>
0);<z>
exceptionResolvers);<z>
;<z>
{<z>
);<z>
result == null) {<z>
.argumentResolvers) {<z>
) {<z>
;<z>
(parameter, result);<z>
result;<z>
) {<z>
getFragment());<z>
URISyntaxException ex) {<z>
, ex);<z>
) {<z>
, "Comment must not be empty");<z>
comment.split("\n");<z>
String line : lines) {<z>
("", line);<z>
return this;<z>
boolean isCompilable() {<z>
= this.children[0];<z>
left = this.children[1];<z>
right = this.children[2];<z>
isCompilable() && right.isCompilable() &&<z>
CodeFlow.isBooleanCompatible(condition.exitTypeDescriptor) &&<z>
exitTypeDescriptor != null);<z>
[] serialize(@Nullable Object object) {<z>
== null) {<z>
null;<z>
ByteArrayOutputStream(1024);<z>
)) {<z>
);<z>
flush();<z>
) {<z>
ex);<z>
return baos.toByteArray();<z>
Class<T> requiredType,<z>
TypeDescriptor typeDescriptor) throws TypeMismatchException {<z>
typeDescriptor);<z>
{<z>
.getName()) {<z>
"equals":<z>
]);<z>
:<z>
.identityHashCode(proxy);<z>
:<z>
TransactionInProgressException("Commit call not allowed within a managed transaction");<z>
case "rollback":<z>
"Rollback call not allowed within a managed transaction");<z>
case "close":<z>
null;<z>
:<z>
target;<z>
invoke(this.target, args);<z>
InvocationTargetException ex) {<z>
();<z>
HttpMethod method, @Nullable RequestCallback requestCallback,<z>
<T> responseExtractor) throws RestClientException {<z>
, method, requestCallback, responseExtractor);<z>
lexQuotedStringLiteral() {<z>
this.pos;<z>
boolean terminated = false;<z>
terminated) {<z>
this.pos++;<z>
this.charsToProcess[this.pos];<z>
) {<z>
== '\'') {<z>
++;<z>
= true;<z>
) {<z>
;<z>
this.pos++;<z>
pos));<z>
ServerHttpRequest request) {<z>
{<z>
getServletRequest();<z>
);<z>
Class<?>... typesToMatch) {<z>
(beanName, mbd, typesToMatch);<z>
hasInstantiationAwareBeanPostProcessors()) {<z>
;<z>
().smartInstantiationAware) {<z>
.predictBeanType(targetType, beanName);<z>
if (predicted != null &&<z>
) {<z>
;<z>
targetType;<z>
() {<z>
{<z>
();<z>
{<z>
isDebugEnabled()) {<z>
"Connection closed in session id=" + this.sessionId);<z>
closing) {<z>
);<z>
ConnectionLostException("Connection closed"));<z>
public MultiServerUserRegistry(SimpUserRegistry localRegistry) {<z>
, "'localRegistry' is required");<z>
= generateId();<z>
;<z>
= this.localRegistry instanceof SmartApplicationListener;<z>
<DataBuffer> source, OutputStream outputStream) {<z>
notNull(source, "'source' must not be null");<z>
);<z>
WritableByteChannel channel = Channels.newChannel(outputStream);<z>
, channel);<z>
{<z>
super("Class too large: " + className);<z>
= className;<z>
= constantPoolCount;<z>
public int compareTo(@Nullable PathPattern otherPattern) {<z>
this, otherPattern);<z>
!= null ?<z>
patternString) : result);<z>
) {<z>
getThisType(e);<z>
;<z>
);<z>
.invoke_constructor(thisType);<z>
();<z>
invoke_static(thisType, SET_THREAD_CALLBACKS, false);<z>
();<z>
end_method();<z>
setClobAsAsciiStream(<z>
asciiStream, int contentLength)<z>
SQLException {<z>
(streamAsLob) {<z>
if (asciiStream != null) {<z>
, StandardCharsets.US_ASCII);<z>
) {<z>
contentLength);<z>
paramIndex, reader);<z>
(paramIndex, (Clob) null);<z>
(wrapAsLob) {<z>
{<z>
PassThroughClob(asciiStream, contentLength));<z>
null);<z>
(contentLength >= 0) {<z>
, contentLength);<z>
ps.setAsciiStream(paramIndex, asciiStream);<z>
if (logger.isDebugEnabled()) {<z>
asciiStream != null ? "Set ASCII stream for CLOB with length " + contentLength :<z>
);<z>
> adaptCompletionStage(CompletionStage<?> future) {<z>
;<z>
) (value, ex) -> {<z>
(ex != null) {<z>
) != null) {<z>
);<z>
);<z>
result.setResult(value);<z>
return null;<z>
;<z>
result;<z>
buffer) {<z>
format(<z>
,<z>
).getNativeBuffer())));<z>
(buffer, error));<z>
return buffer;<z>
) throws SQLException {<z>
null, "'targetDataSource' is required");<z>
.hasLength(username)) {<z>
, password);<z>
().getConnection();<z>
> objectFactory) {<z>
attributes = RequestContextHolder.currentRequestAttributes();<z>
getAttribute(name, getScope());<z>
(scopedObject == null) {<z>
();<z>
, getScope());<z>
.getAttribute(name, getScope());<z>
) {<z>
retrievedObject;<z>
;<z>
{<z>
BeanDefinition.ROLE_INFRASTRUCTURE);<z>
, parserContext)) {<z>
().containsBeanDefinition(ASPECTJ_WEAVING_ENABLER_BEAN_NAME)) {<z>
def = new RootBeanDefinition(ASPECTJ_WEAVING_ENABLER_CLASS_NAME);<z>
registerBeanComponent(<z>
, ASPECTJ_WEAVING_ENABLER_BEAN_NAME));<z>
)) {<z>
(element, parserContext);<z>
{<z>
{<z>
);<z>
().onNext(this, publisher);<z>
{<z>
switch (method.getName()) {<z>
:<z>
proxy == args[0]);<z>
:<z>
;<z>
case "close":<z>
;<z>
.target, args);<z>
{<z>
;<z>
retVal instanceof Query) {<z>
<?>) retVal));<z>
retVal;<z>
(InvocationTargetException ex) {<z>
;<z>
resourceUrlPath, List<? extends Resource> locations,<z>
ResourceResolverChain chain) {<z>
return resolveUrlPathInternal(resourceUrlPath, locations, chain);<z>
) throws SQLException {<z>
this)) {<z>
return (T) this;<z>
getClass().getName() +<z>
);<z>
public void afterPropertiesSet() {<z>
beanFactory == null) {<z>
IllegalArgumentException("Property 'persistenceExceptionTranslator' is required");<z>
static String getSessionId(HttpServletRequest request) {<z>
);<z>
getSession(false);<z>
null);<z>
() {<z>
= ImageIO.getReaderMIMETypes();<z>
mediaType : readerMediaTypes) {<z>
{<z>
(MediaType.parseMediaType(mediaType));<z>
[] writerMediaTypes = ImageIO.getWriterMIMETypes();<z>
String mediaType : writerMediaTypes) {<z>
(mediaType)) {<z>
;<z>
@Nullable PropertyValues pvs) throws Throwable {<z>
pvs)) {<z>
.member;<z>
Object[] arguments;<z>
this.cached) {<z>
);<z>
) {<z>
= resolveMethodArguments(method, bean, beanName);<z>
, bean, beanName);<z>
arguments != null) {<z>
method);<z>
.invoke(bean, arguments);<z>
InvocationTargetException ex) {<z>
.getTargetException();<z>
execute() throws IOException {<z>
();<z>
);<z>
= true;<z>
;<z>
element, ParserContext parserContext) {<z>
source = parserContext.extractSource(element);<z>
getTagName(), source);<z>
parserContext.pushContainingComponent(compDefinition);<z>
= parserContext.getRegistry();<z>
)) {<z>
(<z>
);<z>
genericBeanDefinition(<z>
);<z>
getRawBeanDefinition().setSource(source);<z>
;<z>
{<z>
addPropertyReference("endpointRegistry", endpointRegistry);<z>
registerDefaultEndpointRegistry(source, parserContext);<z>
("container-factory");<z>
containerFactory)) {<z>
.addPropertyValue("containerFactoryBeanName", containerFactory);<z>
"handler-method-factory");<z>
handlerMethodFactory)) {<z>
builder.addPropertyReference("messageHandlerMethodFactory", handlerMethodFactory);<z>
(parserContext, builder,<z>
);<z>
);<z>
return null;<z>
<String, Object> model) throws Exception {<z>
(this.sourceKey != null) {<z>
get(this.sourceKey));<z>
));<z>
;<z>
{<z>
Assert.notNull(key, "Key must not be null");<z>
);<z>
) {<z>
;<z>
hitCount.incrementAndGet();<z>
;<z>
) {<z>
= context.getOperation();<z>
(!(operation instanceof CacheResultOperation cacheResultOperation)) {<z>
operation);<z>
getExceptionCacheName();<z>
{<z>
exceptionCacheName);<z>
;<z>
(WebSocketMessage message) {<z>
(message.getNativeMessage() != null) {<z>
message.getNativeMessage();<z>
.getPayload());<z>
{<z>
return new TextWebSocketFrame(byteBuf);<z>
getType())) {<z>
);<z>
(message.getType())) {<z>
byteBuf);<z>
{<z>
return new PongWebSocketFrame(byteBuf);<z>
));<z>
) {<z>
) {<z>
return false;<z>
websphereComplianceFlag;<z>
) {<z>
;<z>
String className = "com.ibm.ws.webcontainer.WebContainer";<z>
methodName = "getWebContainerProperties";<z>
String propName = "com.ibm.ws.webcontainer.removetrailingservletpathslash";<z>
= false;<z>
);<z>
(methodName).invoke(null);<z>
propName));<z>
{<z>
{<z>
ex);<z>
;<z>
websphereComplianceFlag = flag;<z>
;<z>
public void afterEach(ExtensionContext context) throws Exception {<z>
GzippedFiles.class);<z>
(gzippedFiles != null) {<z>
.created) {<z>
;<z>
element) {<z>
;<z>
addPropertyValue("parent", parseComponent(element));<z>
, "component");<z>
) {<z>
;<z>
getBeanDefinition();<z>
endTransaction() {<z>
()) {<z>
(String.format(<z>
flaggedForRollback));<z>
.transactionStatus != null,<z>
() -> "Failed to end transaction - transaction does not exist: " + this.testContext);<z>
) {<z>
;<z>
commit(this.transactionStatus);<z>
null;<z>
()) {<z>
) +<z>
+ this.testContext);<z>
(String annotationName, boolean classValuesAsString) {<z>
{<z>
classValuesAsString);<z>
(<z>
);<z>
{<z>
+ "\", " +<z>
+ "\", servletName=\"" + this.servletName + "\", " +<z>
;<z>
convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {<z>
CONNECT_MESSAGE_HEADER;<z>
>) connectAckHeaders.getHeader(name);<z>
) {<z>
+ connectAckHeaders);<z>
.class);<z>
);<z>
if (connectHeaders != null) {<z>
String> acceptVersions = connectHeaders.getAcceptVersion();<z>
.setVersion(<z>
SUPPORTED_VERSIONS)<z>
.filter(acceptVersions::contains)<z>
()<z>
orElseThrow(() -> new IllegalArgumentException(<z>
)));<z>
;<z>
!= null) {<z>
], heartbeat[1]);<z>
, 0);<z>
connectedHeaders;<z>
HttpMethod method, @Nullable RequestCallback requestCallback,<z>
... uriVariables) throws RestClientException {<z>
url, uriVariables);<z>
, method, requestCallback, responseExtractor);<z>
Object sqlProvider) {<z>
{<z>
(SqlProvider) sqlProvider).getSql();<z>
return null;<z>
Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,<z>
) {<z>
getAspectClass());<z>
getPointcut(<z>
);<z>
if (expressionPointcut == null) {<z>
null;<z>
return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,<z>
declarationOrderInAspect, aspectName);<z>
(<z>
?> targetClass) {<z>
= method;<z>
target = target;<z>
this.targetClass = targetClass;<z>
;<z>
this.caches = caches;<z>
@Nullable LockMode lockMode) throws DataAccessException {<z>
return executeWithNativeSession(session -> {<z>
!= null) {<z>
, new LockOptions(lockMode));<z>
);<z>
);<z>
public Object getTarget() {<z>
return super.getTarget();<z>
(RuntimeException ex) {<z>
if (logger.isInfoEnabled()) {<z>
+ this.objectName + "]: " + ex);<z>
ex;<z>
public void closeAll() {<z>
) {<z>
);<z>
ex) {<z>
("Could not close synchronized JMS Session after transaction", ex);<z>
Connection con : this.connections) {<z>
connectionFactory, true);<z>
);<z>
sessions.clear();<z>
.sessionsPerConnection.clear();<z>
removeAttribute(String name) {<z>
();<z>
name, "Attribute name must not be null");<z>
name);<z>
if (value instanceof HttpSessionBindingListener) {<z>
, name, value));<z>
@Nullable Object[] args) {<z>
resolveBeanClass(mbd, beanName);<z>
) && !mbd.isNonPublicAccessAllowed()) {<z>
getResourceDescription(), beanName,<z>
beanClass.getName());<z>
instanceSupplier = mbd.getInstanceSupplier();<z>
) {<z>
return obtainFromSupplier(instanceSupplier, beanName);<z>
!= null) {<z>
args);<z>
= false;<z>
boolean autowireNecessary = false;<z>
args == null) {<z>
{<z>
mbd.resolvedConstructorOrFactoryMethod != null) {<z>
= true;<z>
= mbd.constructorArgumentsResolved;<z>
if (resolved) {<z>
if (autowireNecessary) {<z>
, null, null);<z>
(beanName, mbd);<z>
(beanClass, beanName);<z>
AUTOWIRE_CONSTRUCTOR ||<z>
ObjectUtils.isEmpty(args)) {<z>
, args);<z>
mbd.getPreferredConstructors();<z>
if (ctors != null) {<z>
mbd, ctors, null);<z>
);<z>
) {<z>
context instanceof CacheInvocationContext<?> cacheInvocationContext)) {<z>
;<z>
(cacheInvocationContext);<z>
{<z>
target);<z>
cache));<z>
HttpServletResponse response, Object handler)<z>
ServletException, IOException {<z>
this.conversionService);<z>
true;<z>
) {<z>
this.definitionWrapper.isReadableProperty(property)) {<z>
definitionWrapper.getPropertyValue(property);<z>
dynamicProperties.contains(property)) {<z>
null;<z>
property);<z>
Log logger) throws Throwable {<z>
(invocation.getMethod());<z>
(name);<z>
;<z>
false;<z>
stopWatch.start(name);<z>
writeToLog(logger,<z>
null, -1));<z>
);<z>
;<z>
ex) {<z>
.isRunning()) {<z>
);<z>
true;<z>
writeToLog(logger, replacePlaceholders(<z>
);<z>
throw ex;<z>
if (!exitThroughException) {<z>
()) {<z>
;<z>
(logger, replacePlaceholders(<z>
, stopWatch.getTotalTimeMillis()));<z>
matcher) {<z>
{<z>
) request;<z>
;<z>
> getDirectPaths() {<z>
= getActivePatternsCondition();<z>
return (condition instanceof PathPatternsRequestCondition ?<z>
:<z>
getDirectPaths());<z>
task) {<z>
;<z>
;<z>
future;<z>
value) {<z>
if (value != null) {<z>
instanceof Optional ?<z>
Object::toString).orElse(null) :<z>
);<z>
return null;<z>
, boolean caseSensitive, char separator) {<z>
pos, separator);<z>
-1;<z>
< captureDescriptor.length; i++) {<z>
) {<z>
colon = i;<z>
{<z>
2);<z>
constraintPattern = null;<z>
, 1, colon - 1);<z>
{<z>
(<z>
);<z>
.constraintPattern = Pattern.compile(<z>
,<z>
.CASE_INSENSITIVE);<z>
) {<z>
, new VisibilityPredicate(sc, true));<z>
if (constructors.size() == 0)<z>
"No visible constructors in " + sc);<z>
] paramNames, Object[] values)<z>
{<z>
.length != values.length) {<z>
;<z>
-> {<z>
;<z>
queryObject);<z>
) {<z>
i]);<z>
();<z>
}));<z>
toString() {<z>
httpMethods.size() == 1) {<z>
().toString();<z>
;<z>
{<z>
= this;<z>
;<z>
&& source != original) {<z>
source;<z>
();<z>
return original;<z>
rhsType) {<z>
;<z>
, "Right-hand side type must not be null");<z>
(lhsType.isAssignableFrom(rhsType)) {<z>
true;<z>
.isPrimitive()) {<z>
);<z>
lhsType == resolvedPrimitive);<z>
primitiveTypeToWrapperMap.get(rhsType);<z>
);<z>
(ConnectionHolder connectionHolder, ConnectionFactory connectionFactory) {<z>
connectionHolder = connectionHolder;<z>
connectionFactory = connectionFactory;<z>
);<z>
properties) {<z>
.getManagedClassNames());<z>
info instanceof SmartPersistenceUnitInfo) {<z>
info).getManagedPackages());<z>
(<z>
) {<z>
() {<z>
mergedClassesAndPackages;<z>
build();<z>
, @Nullable String sql, SQLException ex) {<z>
2) {<z>
, ex);<z>
;<z>
{<z>
!= null) {<z>
beanKey);<z>
(methodNames != null) {<z>
(method.getName());<z>
this.ignoredMethods != null) {<z>
(method.getName());<z>
true;<z>
{<z>
);<z>
Throwable ex) {<z>
flushingFailed(ex);<z>
this, COMPLETED)) {<z>
.publishComplete();<z>
onComplete(processor);<z>
() {<z>
routerFunctions();<z>
;<z>
(routerFunctions);<z>
String getAsText() {<z>
[]) getValue();<z>
ObjectUtils.isEmpty(classes)) {<z>
return "";<z>
(",");<z>
Class<?> klass : classes) {<z>
.getQualifiedName(klass));<z>
sj.toString();<z>
@Nullable List<HandlerMethodArgumentResolver> argumentResolvers) {<z>
{<z>
;<z>
();<z>
addResolvers(argumentResolvers);<z>
ResultMatcher methodCall(Object obj) {<z>
{<z>
!(obj instanceof MethodInvocationInfo)) {<z>
(String.format("The supplied object [%s] is not an instance of %s. " +<z>
getName()));<z>
) obj;<z>
;<z>
result).getMethod();<z>
("Handler method", expected, actual);<z>
void assertWithDiagnostics(Runnable assertion) {<z>
);<z>
{<z>
diagnosticsLogged && logger.isErrorEnabled()) {<z>
.diagnosticsLogged = true;<z>
this);<z>
ex;<z>
TransactionAttribute parseTransactionAnnotation(AnnotationAttributes attributes) {<z>
();<z>
rbta.setPropagationBehaviorName(<z>
;<z>
> rollbackRules = new ArrayList<>();<z>
("rollbackOn")) {<z>
(new RollbackRuleAttribute(rbRule));<z>
{<z>
.add(new NoRollbackRuleAttribute(rbRule));<z>
;<z>
;<z>
, boolean allowEagerInit) {<z>
();<z>
: this.beanDefinitionNames) {<z>
(beanName)) {<z>
beanName);<z>
mbd.isAbstract() && (allowEagerInit ||<z>
isAllowEagerClassLoading()) &&<z>
.getFactoryBeanName()))) {<z>
isFactoryBean = isFactoryBean(beanName, mbd);<z>
getDecoratedDefinition();<z>
;<z>
allowEagerInit || containsSingleton(beanName));<z>
);<z>
(!isFactoryBean) {<z>
, dbd)) {<z>
(beanName, type, allowFactoryBeanInit);<z>
if (includeNonSingletons || isNonLazyDecorated ||<z>
, dbd))) {<z>
type, allowFactoryBeanInit);<z>
!matchFound) {<z>
+ beanName;<z>
);<z>
(matchFound) {<z>
result.add(beanName);<z>
) {<z>
{<z>
throw ex;<z>
= (ex instanceof CannotLoadBeanClassException ?<z>
.format("Ignoring bean class loading failure for bean '%s'", beanName) :<z>
);<z>
trace(message, ex);<z>
ex);<z>
ex) {<z>
) {<z>
isFactoryBean(beanName)) {<z>
isTypeMatch(beanName, type)) {<z>
);<z>
beanName;<z>
)) {<z>
result.add(beanName);<z>
) {<z>
trace(LogMessage.format(<z>
, ex);<z>
);<z>
public int hashCode() {<z>
name.hashCode()<z>
8)<z>
.hashCode(), 16)<z>
.hashCode(bootstrapMethodArguments), 24);<z>
throws Throwable {<z>
class)) {<z>
return method.invoke(this, args);<z>
0 &&<z>
SynchronizationType.SYNCHRONIZED) {<z>
> 1 ?<z>
?>) args[1]) :<z>
createEntityManager());<z>
(rawEntityManager);<z>
);<z>
if (args != null) {<z>
i++) {<z>
[i];<z>
(arg.getClass())) {<z>
] = query.unwrap(null);<z>
RuntimeException ex) {<z>
;<z>
(retVal instanceof EntityManager rawEntityManager) {<z>
rawEntityManager);<z>
.createApplicationManagedEntityManager(rawEntityManager, this, false);<z>
return retVal;<z>
BeanDefinitionRegistry registry,<z>
environment, @Nullable ResourceLoader resourceLoader) {<z>
= registry;<z>
);<z>
;<z>
: deduceResourceLoader(registry));<z>
.beanFactory);<z>
final void setIsolationLevel(int isolationLevel) {<z>
{<z>
("Only values of isolation constants allowed");<z>
= isolationLevel;<z>
requiresTaskScheduler() {<z>
stream()<z>
r -> r.getSockJsServiceRegistration() != null &&<z>
);<z>
) {<z>
.length];<z>
++) {<z>
notificationInfo = notificationInfos[i];<z>
;<z>
.notificationInfos = infos;<z>
SqlParameterSource paramSource,<z>
PreparedStatementCreatorFactory> customizer) {<z>
(sql);<z>
parsedSql, paramSource);<z>
customizer != null) {<z>
customizer.accept(pscf);<z>
;<z>
params);<z>
) {<z>
; i < MAX_ATTEMPTS; i++) {<z>
T result = nextOrSameInternal(temporal);<z>
temporal)) {<z>
;<z>
result;<z>
null;<z>
) {<z>
== o2) {<z>
;<z>
o1 == null || o2 == null) {<z>
return false;<z>
o1.equals(o2)) {<z>
true;<z>
.isArray()) {<z>
o1, o2);<z>
;<z>
) {<z>
.isTrue(idleReceivesPerTaskLimit != 0, "'idleReceivesPerTaskLimit' must not be 0)");<z>
synchronized (this.lifecycleMonitor) {<z>
this.idleReceivesPerTaskLimit = idleReceivesPerTaskLimit;<z>
Nullable String contextPath,<z>
Nullable SslInfo sslInfo, @Nullable InetSocketAddress remoteAddress,<z>
DataBuffer> body, ServerHttpRequest originalRequest) {<z>
contextPath, headers);<z>
method = method;<z>
? remoteAddress : originalRequest.getRemoteAddress());<z>
originalRequest.getSslInfo());<z>
.body = body;<z>
.originalRequest = originalRequest;<z>
messageSupplier) {<z>
isErrorEnabled()) {<z>
.of(messageSupplier), cause);<z>
@Nullable CacheDefaults defaults, CacheResult ann) {<z>
, ann.cacheName());<z>
=<z>
cacheResolverFactory());<z>
defaults, ann.cacheKeyGenerator());<z>
method, ann, cacheName);<z>
methodDetails);<z>
exceptionCacheResolver = null;<z>
;<z>
(StringUtils.hasText(exceptionCacheName)) {<z>
;<z>
);<z>
{<z>
UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(location);<z>
.build();<z>
getScheme() != null) {<z>
(location);<z>
("//")) {<z>
this.request.getScheme();<z>
.toUriString());<z>
path = uriComponents.getPath();<z>
(path != null) {<z>
:<z>
.getRequestURI(), path));<z>
String result = UriComponentsBuilder<z>
fromHttpRequest(new ServletServerHttpRequest(this.request))<z>
(path)<z>
.replaceQuery(uriComponents.getQuery())<z>
())<z>
).toUriString();<z>
(result);<z>
binder, MethodParameter parameter) {<z>
parameter.getParameterIndex();<z>
getExecutable().getParameterTypes();<z>
paramTypes[i + 1]));<z>
return !hasBindingResult;<z>
{<z>
produces) ?<z>
);<z>
;<z>
{<z>
();<z>
);<z>
&& right.isCompilable() &&<z>
.exitTypeDescriptor) &&<z>
exitTypeDescriptor));<z>
protected ThreadPoolExecutor createExecutor(<z>
,<z>
rejectedExecutionHandler) {<z>
corePoolSize, maxPoolSize,<z>
queue, threadFactory, rejectedExecutionHandler);<z>
{<z>
);<z>
name, value) -> {<z>
name, value)) {<z>
);<z>
});<z>
return result;<z>
Nullable BeanDefinition bd) {<z>
getAttribute(VALUE_TYPE_ATTRIBUTE);<z>
;<z>
;<z>
.setSource(extractSource(collectionEle));<z>
);<z>
target.setMergeEnabled(parseMergeAttribute(collectionEle));<z>
target, bd, defaultElementType);<z>
target;<z>
{<z>
.notNull(request, "Request must not be null");<z>
(response, "Response must not be null");<z>
).addIncludedUrl(this.resource);<z>
if (logger.isDebugEnabled()) {<z>
resource + "]");<z>
(int minPort, int maxPort) {<z>
minPort > 0, "'minPort' must be greater than 0");<z>
maxPort >= minPort, "'maxPort' must be greater than or equal to 'minPort'");<z>
maxPort <= PORT_RANGE_MAX, "'maxPort' must be less than or equal to " + PORT_RANGE_MAX);<z>
minPort;<z>
;<z>
;<z>
) {<z>
throw new IllegalStateException(String.format(<z>
, maxPort, searchCounter));<z>
findRandomPort(minPort, maxPort);<z>
;<z>
isPortAvailable(candidatePort));<z>
;<z>
?> createCacheOperationInvocationContext(<z>
<?> operation) {<z>
DefaultCacheInvocationContext<>(<z>
, target, args);<z>
{<z>
> parameterAnnotations = this.interfaceParameterAnnotations;<z>
parameterAnnotations == null) {<z>
>();<z>
))) {<z>
candidate : ifc.getMethods()) {<z>
) {<z>
.add(candidate.getParameterAnnotations());<z>
;<z>
return parameterAnnotations;<z>
{<z>
);<z>
);<z>
(suffix);<z>
session, Message<?> message) {<z>
;<z>
);<z>
) {<z>
(<z>
"Listener method could not be invoked with incoming message"), ex);<z>
catch (Exception ex) {<z>
("Listener method '" +<z>
"' threw exception", ex);<z>
String getRealPath(String path) {<z>
(path);<z>
;<z>
);<z>
();<z>
(InvalidPathException | IOException ex) {<z>
isDebugEnabled()) {<z>
debug("Could not determine real path of resource " +<z>
null ? resource : resourceLocation), ex);<z>
return null;<z>
toParent) {<z>
;<z>
;<z>
= InvokerHelper.getMetaClass(this);<z>
targetObject,<z>
) throws SpelEvaluationException {<z>
null;<z>
;<z>
) {<z>
methodResolver.resolve(<z>
, targetObject, this.name, argumentTypes);<z>
!= null) {<z>
methodExecutor;<z>
AccessException ex) {<z>
ex;<z>
argumentTypes);<z>
String className = FormatHelper.formatClassNameForMessage(<z>
: targetObject.getClass());<z>
!= null) {<z>
(<z>
SpelMessage.PROBLEM_LOCATING_METHOD, method, className);<z>
;<z>
) {<z>
this.sourceOffset = methodInfoOffset + 6;<z>
.sourceLength = methodInfoLength - 6;<z>
, Method method) {<z>
, "Bean name is required");<z>
.notNull(beanFactory, "BeanFactory is required");<z>
, "Method is required");<z>
.bean = beanName;<z>
beanFactory = beanFactory;<z>
;<z>
(beanType == null) {<z>
beanName + "'");<z>
(beanType);<z>
.method = method;<z>
.findBridgedMethod(method);<z>
.bridgedMethod);<z>
= initMethodParameters();<z>
org.springframework.protobuf.SecondMsg parseFrom(<z>
input,<z>
protobuf.ExtensionRegistryLite extensionRegistry)<z>
{<z>
input, extensionRegistry);<z>
beanClasses) {<z>
) {<z>
Class<?> beanClass : beanClasses) {<z>
beanClass, propertyName);<z>
!= null) {<z>
);<z>
return Object.class;<z>
{<z>
contains("META-INF")) {<z>
return true;<z>
(path.contains(":/")) {<z>
);<z>
("url:")) {<z>
;<z>
)) {<z>
true;<z>
return false;<z>
{<z>
;<z>
>asList(paramConditions);<z>
actualParams;<z>
AbstractPropertyBindingResult createBeanPropertyBindingResult() {<z>
),<z>
, getAutoGrowCollectionLimit());<z>
{<z>
initConversion(this.conversionService);<z>
null) {<z>
(this.messageCodesResolver);<z>
result;<z>
) {<z>
ThreadPoolTaskExecutor();<z>
.availableProcessors() * 2);<z>
.taskExecutor.setAllowCoreThreadTimeOut(true);<z>
getMessage() {<z>
);<z>
!= null, "No MethodParameter");<z>
= new StringBuilder("Validation failed for argument at index ")<z>
append(" in method: ")<z>
)<z>
append(" error(s): ");<z>
{<z>
);<z>
;<z>
, Class<T> responseType) throws RestClientException {<z>
acceptHeaderRequestCallback(responseType);<z>
responseExtractor =<z>
(), logger);<z>
requestCallback, responseExtractor);<z>
MediaType getContentType(HttpServletResponse response) {<z>
()).removeQualityValue();<z>
catch (InvalidMediaTypeException ex) {<z>
;<z>
(SubscriptionRegistry subscriptionRegistry) {<z>
subscriptionRegistry, "SubscriptionRegistry must not be null");<z>
subscriptionRegistry = subscriptionRegistry;<z>
);<z>
;<z>
);<z>
public AnnotationMBeanExporter() {<z>
setNamingStrategy(this.metadataNamingStrategy);<z>
.metadataAssembler);<z>
setAutodetectMode(AUTODETECT_ALL);<z>
throws MultipartException {<z>
request.getAttribute("fail") != null) {<z>
throw new MaxUploadSizeExceededException(1000);<z>
request instanceof MultipartHttpServletRequest) {<z>
;<z>
!= null) {<z>
throw new IllegalStateException("Already resolved");<z>
Boolean.TRUE);<z>
new AbstractMultipartHttpServletRequest(request) {<z>
) {<z>
;<z>
(String paramOrFileName) {<z>
return null;<z>
Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {<z>
element, builder.getRawBeanDefinition());<z>
parsedList);<z>
;<z>
if (StringUtils.hasText(listClass)) {<z>
);<z>
scope = element.getAttribute(SCOPE_ATTRIBUTE);<z>
if (StringUtils.hasLength(scope)) {<z>
(scope);<z>
DefaultDataBufferFactory dataBufferFactory, ByteBuffer byteBuffer) {<z>
Assert.notNull(dataBufferFactory, "DefaultDataBufferFactory must not be null");<z>
notNull(byteBuffer, "ByteBuffer must not be null");<z>
this.dataBufferFactory = dataBufferFactory;<z>
byteBuffer.slice();<z>
byteBuffer = slice;<z>
remaining();<z>
o) {<z>
Entry<?, ?> entry) {<z>
), entry.getValue());<z>
return false;<z>
, TagWriter tagWriter) throws JspException {<z>
for (Object item : optionCollection) {<z>
.forBeanPropertyAccess(item);<z>
value;<z>
{<z>
valueProperty);<z>
item instanceof Enum) {<z>
;<z>
value = item;<z>
getPropertyValue(this.labelProperty) : item);<z>
, value, label);<z>
)<z>
throws IntrospectionException {<z>
getMethods()) {<z>
containsKey(method.getName()) &&<z>
isPlainAccessor(method)) {<z>
,<z>
, null));<z>
method.getName());<z>
rejectIfEmptyOrWhitespace(<z>
, String errorCode, String defaultMessage) {<z>
field, errorCode, null, defaultMessage);<z>
MethodParameter parameter) {<z>
"MethodParameter must not be null");<z>
?> valueClass;<z>
boolean pluralize = false;<z>
"";<z>
{<z>
).getComponentType();<z>
= true;<z>
isAssignableFrom(parameter.getParameterType())) {<z>
asCollection().resolveGeneric();<z>
if (valueClass == null) {<z>
new IllegalArgumentException(<z>
;<z>
;<z>
);<z>
).getAdapter(valueClass);<z>
).isNoValue()) {<z>
reactiveSuffix = ClassUtils.getShortName(valueClass);<z>
getNestedParameterType();<z>
);<z>
reactiveSuffix);<z>
{<z>
== Optional.class || hasNullableAnnotation() ||<z>
isKotlinReflectPresent() &&<z>
getContainingClass()) &&<z>
isOptional(this)));<z>
code, @Nullable String reason) {<z>
reason)) {<z>
) {<z>
1000:<z>
NORMAL;<z>
case 1001:<z>
;<z>
1002:<z>
PROTOCOL_ERROR;<z>
:<z>
return NOT_ACCEPTABLE;<z>
:<z>
return NO_STATUS_CODE;<z>
case 1006:<z>
NO_CLOSE_FRAME;<z>
case 1007:<z>
return BAD_DATA;<z>
1008:<z>
POLICY_VIOLATION;<z>
case 1009:<z>
return TOO_BIG_TO_PROCESS;<z>
case 1010:<z>
REQUIRED_EXTENSION;<z>
1011:<z>
SERVER_ERROR;<z>
1012:<z>
;<z>
case 1013:<z>
;<z>
(code, reason);<z>
public void setDefaultProtocolHandler(@Nullable SubProtocolHandler defaultProtocolHandler) {<z>
defaultProtocolHandler = defaultProtocolHandler;<z>
)) {<z>
(Collections.singletonList(defaultProtocolHandler));<z>
boolean addTriggerToScheduler(Trigger trigger) throws SchedulerException {<z>
getKey()) != null);<z>
) {<z>
return false;<z>
("jobDetail");<z>
triggerExists) {<z>
!= null && this.jobDetails != null &&<z>
(jobDetail)) {<z>
);<z>
(trigger.getKey(), trigger);<z>
) {<z>
)) {<z>
.debug("Unexpectedly encountered existing trigger on rescheduling, assumably due to " +<z>
getMessage() + " - can safely be ignored");<z>
!this.jobDetails.contains(jobDetail) &&<z>
.getKey()) == null)) {<z>
().scheduleJob(jobDetail, trigger);<z>
(jobDetail);<z>
.scheduleJob(trigger);<z>
(ObjectAlreadyExistsException ex) {<z>
()) {<z>
logger.debug("Unexpectedly encountered existing trigger on job scheduling, assumably due to " +<z>
+ ex.getMessage() + " - can safely be ignored");<z>
this.overwriteExistingJobs) {<z>
getKey(), trigger);<z>
;<z>
@Nullable ModelAndViewContainer mavContainer,<z>
webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {<z>
forMethodParameter(parameter);<z>
(parameter.getParameterType())) {<z>
.getGeneric(1).resolve();<z>
MultipartFile.class) {<z>
;<z>
);<z>
== Part.class) {<z>
(HttpServletRequest.class);<z>
)) {<z>
servletRequest.getParts();<z>
());<z>
: parts) {<z>
getName(), part);<z>
return result;<z>
new LinkedMultiValueMap<>(0);<z>
]> parameterMap = webRequest.getParameterMap();<z>
));<z>
, values) -> {<z>
values) {<z>
add(key, value);<z>
;<z>
return result;<z>
(1).resolve();<z>
.class) {<z>
multipartRequest = MultipartResolutionDelegate.resolveMultipartRequest(webRequest);<z>
: new LinkedHashMap<>(0));<z>
{<z>
(HttpServletRequest.class);<z>
.isMultipartRequest(servletRequest)) {<z>
;<z>
.size());<z>
: parts) {<z>
{<z>
(), part);<z>
result;<z>
return new LinkedHashMap<>(0);<z>
;<z>
());<z>
{<z>
(values.length > 0) {<z>
put(key, values[0]);<z>
);<z>
result;<z>
void visitAttribute(final Attribute attribute) {<z>
isCodeAttribute()) {<z>
.nextAttribute = firstCodeAttribute;<z>
firstCodeAttribute = attribute;<z>
{<z>
firstAttribute;<z>
attribute;<z>
Class<T> type) {<z>
isAssignableFrom(type)) {<z>
type);<z>
ex) {<z>
null) {<z>
.validatorFactory.unwrap(type);<z>
ex) {<z>
{<z>
T) this.validatorFactory;<z>
ex;<z>
;<z>
{<z>
+ "] to type [" + targetType + "]");<z>
;<z>
;<z>
public void setup() {<z>
;<z>
;<z>
.registerAnnotationConfigProcessors(this.context);<z>
);<z>
.testBeanClass.equals("ResourceAnnotatedTestBean")) {<z>
= new RootBeanDefinition(ResourceAnnotatedTestBean.class);<z>
(AutowiredAnnotatedTestBean.class);<z>
setScope(BeanDefinition.SCOPE_PROTOTYPE);<z>
.overridden) {<z>
));<z>
.context.registerBeanDefinition("test", rbd);<z>
(TestBean.class));<z>
(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)<z>
, IOException {<z>
isFirstRequest = !isAsyncDispatch(request);<z>
requestToUse = request;<z>
instanceof ContentCachingRequestWrapper)) {<z>
());<z>
boolean shouldLog = shouldLog(requestToUse);<z>
&& isFirstRequest) {<z>
));<z>
.doFilter(requestToUse, response);<z>
(shouldLog && !isAsyncStarted(requestToUse)) {<z>
getAfterMessage(requestToUse));<z>
typePatternExpression, @Nullable ClassLoader classLoader) {<z>
THROW, null);<z>
.world.setBehaveInJava5Way(true);<z>
new PatternParser(typePatternExpression);<z>
);<z>
.resolve(this.world);<z>
.world, new FormalBinding[0]);<z>
.NONE, false, false);<z>
other) {<z>
this == other) {<z>
return true;<z>
() != other.getClass()) {<z>
;<z>
((ReactiveTypeDescriptor) other).reactiveType);<z>
String path) throws IOException {<z>
);<z>
) {<z>
);<z>
);<z>
);<z>
writeTagContent(TagWriter tagWriter) throws JspException {<z>
startTag("select");<z>
writeDefaultAttributes(tagWriter);<z>
{<z>
.writeAttribute("multiple", "multiple");<z>
, getSize())));<z>
getItems();<z>
null) {<z>
(items != EMPTY) {<z>
evaluate("items", items);<z>
(itemsObject != null) {<z>
String selectName = getName();<z>
= (getItemValue() != null ?<z>
, getItemValue())) : null);<z>
() != null ?<z>
))) : null);<z>
=<z>
()) {<z>
{<z>
return processFieldValue(selectName, resolvedValue, "option");<z>
);<z>
;<z>
;<z>
;<z>
;<z>
this.tagWriter = tagWriter;<z>
setAttribute(LIST_VALUE_PAGE_ATTRIBUTE, getBindStatus());<z>
;<z>
handler,<z>
final HttpHeaders handshakeHeaders, final XhrClientSockJsSession session,<z>
WebSocketSession> connectFuture) {<z>
execute(() -> {<z>
transportRequest.getHttpRequestHeaders();<z>
requestCallback = new XhrRequestCallback(handshakeHeaders);<z>
XhrRequestCallback requestCallbackAfterHandshake = new XhrRequestCallback(httpHeaders);<z>
responseExtractor = new XhrReceiveExtractor(session);<z>
while (true) {<z>
{<z>
afterTransportClosed(null);<z>
()) {<z>
"Starting XHR receive request, url=" + receiveUrl);<z>
HttpMethod.POST, requestCallback, responseExtractor);<z>
requestCallbackAfterHandshake;<z>
ex) {<z>
.isDone()) {<z>
(ex);<z>
handleTransportError(ex);<z>
getMessage()));<z>
});<z>
) {<z>
null) {<z>
;<z>
interfaces != null) {<z>
[0]);<z>
return null;<z>
configureClientOutboundChannel(ChannelRegistration registration) {<z>
configurers) {<z>
(registration);<z>
columnIndex) throws InvalidResultSetAccessException {<z>
);<z>
{<z>
;<z>
resolve(Class<?> testClass) {<z>
;<z>
.class);<z>
== null) {<z>
.isDebugEnabled()) {<z>
.debug(String.format(<z>
()));<z>
;<z>
ActiveProfiles annotation = descriptor.getAnnotation();<z>
logger.isTraceEnabled()) {<z>
.format("Retrieved @ActiveProfiles [%s] for declaring class [%s].", annotation,<z>
().getName()));<z>
return annotation.profiles();<z>
RequestPredicate predicate, HandlerFunction<T> handlerFunction) {<z>
Assert.notNull(predicate, "Predicate must not be null");<z>
);<z>
.predicate = predicate;<z>
handlerFunction = handlerFunction;<z>
throws Exception {<z>
);<z>
Object> attributesSnapshot = null;<z>
)) {<z>
HashMap<>();<z>
();<z>
.hasMoreElements()) {<z>
String) attrNames.nextElement();<z>
.startsWith(DEFAULT_STRATEGIES_PREFIX)) {<z>
));<z>
WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());<z>
.localeResolver);<z>
;<z>
(THEME_SOURCE_ATTRIBUTE, getThemeSource());<z>
flashMapManager != null) {<z>
flashMapManager.retrieveAndUpdate(request, response);<z>
!= null) {<z>
Collections.unmodifiableMap(inputFlashMap));<z>
;<z>
.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);<z>
= null;<z>
(this.parseRequestPath) {<z>
getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE);<z>
(request);<z>
request, response);<z>
request).isConcurrentHandlingStarted()) {<z>
attributesSnapshot != null) {<z>
);<z>
if (this.parseRequestPath) {<z>
previousRequestPath, request);<z>
Method candidateMethod, Class<?> declaringClass) {<z>
isResolvedTypeMatch(candidateMethod, bridgeMethod, declaringClass)) {<z>
return true;<z>
findGenericDeclaration(bridgeMethod);<z>
, candidateMethod, declaringClass));<z>
{<z>
getAdapter(input.getClass());<z>
;<z>
) {<z>
(Publisher<?>) input;<z>
null) {<z>
);<z>
);<z>
, type, null)));<z>
.payloadFlux = null;<z>
) {<z>
firstPayload(emptyBufferMono));<z>
;<z>
equals(elementType.resolve()) ?<z>
, dataMimeType) : null;<z>
()) {<z>
.from(publisher)<z>
value, elementType, encoder))<z>
);<z>
.payloadMono = firstPayload(data);<z>
this.payloadFlux = null;<z>
null;<z>
this.payloadFlux = Flux.from(publisher)<z>
)<z>
(emptyBufferMono)<z>
signal, inner) -> {<z>
);<z>
{<z>
.fromCallable(() -> data))<z>
).map(PayloadUtils::createPayload));<z>
;<z>
.class, Payload::release);<z>
() {<z>
().values()) {<z>
(ResponseCookie cookie : cookies) {<z>
;<z>
addHandlers(<z>
handlers) {<z>
(handlers != null) {<z>
;<z>
this;<z>
value) {<z>
= value.lastIndexOf('L');<z>
(idx != -1) {<z>
) {<z>
"'");<z>
adjuster;<z>
) {<z>
new IllegalArgumentException("No day-of-week before 'L' in '" + value + "'");<z>
(0, idx));<z>
);<z>
adjuster, value);<z>
'#');<z>
1) {<z>
(idx == 0) {<z>
+ value + "'");<z>
- 1) {<z>
+ "'");<z>
.substring(0, idx));<z>
), 10);<z>
{<z>
"' in '" + value +<z>
"' must be positive number ");<z>
ordinal, dayOfWeek);<z>
.DAY_OF_MONTH, adjuster, value);<z>
;<z>
subscriptionId, String dest) {<z>
create(SimpMessageType.SUBSCRIBE);<z>
(sessionId);<z>
);<z>
setDestination(dest);<z>
setNativeHeader("someSelector", "true");<z>
;<z>
, Object... routeVars) {<z>
);<z>
();<z>
;<z>
configClass, @Nullable ClassLoader classLoader) {<z>
.isAssignableFrom(configClass)) {<z>
.isDebugEnabled()) {<z>
("Ignoring request to enhance %s as it has " +<z>
));<z>
;<z>
classLoader));<z>
()) {<z>
"Successfully enhanced %s; enhanced class name is: %s",<z>
, enhancedClass.getName()));<z>
enhancedClass;<z>
Throwable exception) {<z>
isDebugEnabled()) {<z>
, exception);<z>
{<z>
InputSource(resource.getInputStream());<z>
(resource));<z>
;<z>
basePackages) {<z>
basePackages, "At least one base package must be specified");<z>
this.getApplicationStartup().start("spring.context.base-packages.scan")<z>
);<z>
scan(basePackages);<z>
();<z>
{<z>
= ContextLoader.getCurrentWebApplicationContext();<z>
) {<z>
IllegalStateException("No WebApplicationContext registered for current thread - " +<z>
;<z>
;<z>
ParserContext parserContext) {<z>
new MutablePropertyValues();<z>
getAttribute(CONTAINER_TYPE_ATTRIBUTE).startsWith("simple");<z>
;<z>
hasAttribute(CONNECTION_FACTORY_ATTRIBUTE)) {<z>
);<z>
{<z>
parserContext.getReaderContext().error(<z>
containerEle);<z>
.hasText(connectionFactoryBeanName)) {<z>
RuntimeBeanReference(connectionFactoryBeanName));<z>
;<z>
if (StringUtils.hasText(taskExecutorBeanName)) {<z>
(taskExecutorBeanName));<z>
);<z>
)) {<z>
new RuntimeBeanReference(errorHandlerBeanName));<z>
String destinationResolverBeanName = containerEle.getAttribute(DESTINATION_RESOLVER_ATTRIBUTE);<z>
{<z>
);<z>
(CACHE_ATTRIBUTE);<z>
)) {<z>
if (isSimpleContainer) {<z>
|| "consumer".equals(cache))) {<z>
(<z>
, containerEle);<z>
cache.toUpperCase());<z>
Integer acknowledgeMode = parseAcknowledgeMode(containerEle, parserContext);<z>
acknowledgeMode != null) {<z>
.SESSION_TRANSACTED) {<z>
);<z>
properties.add("sessionAcknowledgeMode", acknowledgeMode);<z>
= containerEle.getAttribute(TRANSACTION_MANAGER_ATTRIBUTE);<z>
StringUtils.hasText(transactionManagerBeanName)) {<z>
{<z>
parserContext.getReaderContext().error(<z>
;<z>
"transactionManager", new RuntimeBeanReference(transactionManagerBeanName));<z>
;<z>
)) {<z>
concurrency);<z>
);<z>
.hasText(prefetch)) {<z>
) {<z>
"maxMessagesPerTask", prefetch);<z>
;<z>
)) {<z>
add("phase", phase);<z>
;<z>
(receiveTimeout)) {<z>
(!isSimpleContainer) {<z>
, receiveTimeout);<z>
;<z>
(StringUtils.hasText(backOffBeanName)) {<z>
if (!isSimpleContainer) {<z>
;<z>
(RECOVERY_INTERVAL_ATTRIBUTE);<z>
StringUtils.hasText(recoveryInterval)) {<z>
(!isSimpleContainer) {<z>
);<z>
;<z>
{<z>
{<z>
"";<z>
;<z>
= new InputStreamReader(in, charset);<z>
];<z>
charsRead;<z>
-1) {<z>
charsRead);<z>
return out.toString();<z>
ClassNotFoundException {<z>
contains(name),<z>
name);<z>
);<z>
public void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {<z>
);<z>
);<z>
bd == null) {<z>
.isTraceEnabled()) {<z>
+ beanName + "' found in " + this);<z>
beanName);<z>
()) {<z>
) {<z>
beanDefinitionNames);<z>
);<z>
beanDefinitionNames = updatedDefinitions;<z>
);<z>
null;<z>
beanName);<z>
Void> triggerAfterCommit(TransactionSynchronizationManager synchronizationManager,<z>
{<z>
status.isNewSynchronization()) {<z>
getSynchronizations());<z>
);<z>
{<z>
.transactionManager == null) {<z>
IllegalArgumentException("Property 'transactionManager' is required");<z>
,<z>
bindingContext) {<z>
put(View.BINDING_CONTEXT_ATTRIBUTE, bindingContext);<z>
mediaType, exchange)<z>
);<z>
Class<T> responseType) throws RestClientException {<z>
responseType);<z>
responseExtractor = responseEntityExtractor(responseType);<z>
;<z>
(@Nullable RuntimeBeanReference pathMatcherRef,<z>
{<z>
pathMatcherRef != null) {<z>
.isAlias(PATH_MATCHER_BEAN_NAME)) {<z>
getRegistry().removeAlias(PATH_MATCHER_BEAN_NAME);<z>
getBeanName(), PATH_MATCHER_BEAN_NAME);<z>
isAlias(PATH_MATCHER_BEAN_NAME) &&<z>
getRegistry().containsBeanDefinition(PATH_MATCHER_BEAN_NAME)) {<z>
AntPathMatcher.class);<z>
setSource(source);<z>
(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
).registerBeanDefinition(PATH_MATCHER_BEAN_NAME, pathMatcherDef);<z>
));<z>
;<z>
) {<z>
(original != null) {<z>
));<z>
propertyValueList.add(<z>
));<z>
new ArrayList<>(0);<z>
Method bridgeMethod) {<z>
isBridge()) {<z>
return bridgeMethod;<z>
= cache.get(bridgeMethod);<z>
null) {<z>
<>();<z>
MethodFilter filter = candidateMethod -><z>
isBridgedCandidateFor(candidateMethod, bridgeMethod);<z>
(), candidateMethods::add, filter);<z>
.isEmpty()) {<z>
== 1 ?<z>
0) :<z>
(candidateMethods, bridgeMethod);<z>
if (bridgedMethod == null) {<z>
= bridgeMethod;<z>
bridgeMethod, bridgedMethod);<z>
return bridgedMethod;<z>
() {<z>
this.pathComponents) {<z>
pathComponent.verify();<z>
Object payload) {<z>
]) {<z>
);<z>
(payload.toString()));<z>
String path, String version) {<z>
)) {<z>
path;<z>
?<z>
.prefix + '/' + path);<z>
{<z>
(accessor.getReceipt() == null) {<z>
;<z>
Throwable ex) {<z>
logger.isDebugEnabled()) {<z>
.sessionId, ex);<z>
{<z>
null) {<z>
equals(paramType)) {<z>
FALSE;<z>
{<z>
+ " parameter '" + name +<z>
"primitive type. Consider declaring it as object wrapper for the corresponding primitive type.");<z>
;<z>
headersToCopy) {<z>
) {<z>
@SuppressWarnings("unchecked")<z>
get(NATIVE_HEADERS);<z>
!= null && getNativeHeaders() == null) {<z>
::setNativeHeaderValues);<z>
);<z>
(String pcExpr) {<z>
(pcExpr, " and ", " && ");<z>
replace(result, " or ", " || ");<z>
, " not ", " ! ");<z>
result;<z>
request) {<z>
session = request.getSession(false);<z>
) {<z>
.getAttributeNames();<z>
attrNames != null) {<z>
list(attrNames).stream().<z>
session::getAttribute));<z>
return Collections.emptyMap();<z>
protected void validateConfiguration() {<z>
) {<z>
throw new IllegalArgumentException("Property 'destination' or 'destinationName' is required");<z>
> type) {<z>
result -> {<z>
;<z>
handler);<z>
getClass();<z>
if (handler instanceof HandlerMethod) {<z>
.getBeanType();<z>
(actual));<z>
{<z>
);<z>
.get(handlerType);<z>
methods == null) {<z>
);<z>
, methods);<z>
= new ArrayList<>();<z>
{<z>
(handlerType)) {<z>
);<z>
{<z>
add(createInitBinderMethod(bean, method));<z>
;<z>
{<z>
();<z>
));<z>
(initBinderMethods);<z>
) {<z>
.hasLength(name)) {<z>
return "";<z>
new StringBuilder();<z>
++) {<z>
char c = name.charAt(i);<z>
Character.isUpperCase(c)) {<z>
(Character.toLowerCase(c));<z>
.append(c);<z>
;<z>
> targetClass) {<z>
isPublic(method.getModifiers())) {<z>
return null;<z>
targetClass);<z>
);<z>
operation != null) {<z>
return operation;<z>
{<z>
targetClass);<z>
(operation != null) {<z>
;<z>
null;<z>
preHandle(WebRequest request) throws DataAccessException {<z>
);<z>
WebAsyncUtils.getAsyncManager(request);<z>
)) {<z>
;<z>
TransactionSynchronizationManager.hasResource(emf)) {<z>
key, WebRequest.SCOPE_REQUEST);<z>
1 : 1);<z>
.SCOPE_REQUEST);<z>
logger.debug("Opening JPA EntityManager in OpenEntityManagerInViewInterceptor");<z>
createEntityManager();<z>
(em);<z>
.bindResource(emf, emHolder);<z>
, emHolder);<z>
;<z>
interceptor);<z>
PersistenceException ex) {<z>
, ex);<z>
final HttpHeaders getRequestHeaders(MockHttpServletRequest request) {<z>
new HttpHeaders();<z>
names = request.getHeaderNames();<z>
names.hasMoreElements()) {<z>
nextElement();<z>
request.getHeaders(name)));<z>
;<z>
throws JAXBException {<z>
getXMLStreamWriter(staxResult);<z>
{<z>
(graph, streamWriter);<z>
XMLEventWriter eventWriter = StaxUtils.getXMLEventWriter(staxResult);<z>
{<z>
graph, eventWriter);<z>
);<z>
createRequest() {<z>
() {<z>
initUri();<z>
private final HttpHeaders headers = initHeaders();<z>
HttpMethod getMethod() {<z>
;<z>
String getMethodValue() {<z>
name();<z>
{<z>
this.uri;<z>
HttpHeaders getHeaders() {<z>
headers;<z>
radix) {<z>
numberToken, radix);<z>
);<z>
catch (NumberFormatException ex) {<z>
.NOT_A_LONG, numberToken));<z>
(int defaultTimeout) {<z>
TIMEOUT_DEFAULT) {<z>
);<z>
.defaultTimeout = defaultTimeout;<z>
(<z>
Resource> result)<z>
throws IOException {<z>
);<z>
!= null) {<z>
"**");<z>
;<z>
null;<z>
String pathInJarFile = null;<z>
length()) {<z>
;<z>
ResourceUtils.JAR_URL_SEPARATOR.length());<z>
candidates) {<z>
(!currPath.startsWith(dir)) {<z>
indexOf(dir);<z>
(dirIndex != -1) {<z>
currPath = currPath.substring(dirIndex);<z>
"/") <=<z>
, "/"))) {<z>
;<z>
, currPath)) {<z>
String absoluteJarPath = servletContext.getRealPath(currPath);<z>
!= null) {<z>
, result);<z>
).match(fullPattern, currPath)) {<z>
;<z>
Deque<AnnotationTypeMapping> queue, AnnotationTypeMapping source) {<z>
(source.getAnnotationType(), false);<z>
) {<z>
(source, metaAnnotation)) {<z>
repeatableContainers.findRepeatedAnnotations(metaAnnotation);<z>
) {<z>
repeatedAnnotation : repeatedAnnotations) {<z>
repeatedAnnotation)) {<z>
;<z>
metaAnnotation);<z>
beanDefinition) {<z>
defaultRefreshCheckDelay;<z>
Object attributeValue = beanDefinition.getAttribute(REFRESH_CHECK_DELAY_ATTRIBUTE);<z>
attributeValue instanceof Number) {<z>
);<z>
{<z>
;<z>
(attributeValue != null) {<z>
("Invalid refresh check delay attribute [" +<z>
"] with value '" + attributeValue +<z>
"': needs to be of type Number or String");<z>
return refreshCheckDelay;<z>
setFlaggedForRollback(boolean flaggedForRollback) {<z>
this.transactionStatus != null, () -><z>
);<z>
flaggedForRollback = flaggedForRollback;<z>
,<z>
DataBufferFactory dataBufferFactory, boolean continueOnError, boolean ignoreFailedDrops,<z>
@Nullable String separator, String blockCommentStartDelimiter,<z>
blockCommentEndDelimiter) throws ScriptException {<z>
(connection, resource, dataBufferFactory, continueOnError,<z>
commentPrefix }, separator,<z>
blockCommentStartDelimiter, blockCommentEndDelimiter);<z>
protected StandardWebSocketSession createWebSocketSession(<z>
Empty<Void> completionSink) {<z>
(<z>
, DefaultDataBufferFactory.sharedInstance, completionSink);<z>
ApplicationContext context) {<z>
initApplicationContext(context);<z>
ScriptTemplateConfig viewConfig = autodetectViewConfig();<z>
null) {<z>
engine = viewConfig.getEngine();<z>
!= null) {<z>
.engineSupplier = viewConfig.getEngineSupplier();<z>
) != null) {<z>
.engineName = viewConfig.getEngineName();<z>
() != null) {<z>
.scripts = viewConfig.getScripts();<z>
viewConfig.getRenderObject() != null) {<z>
= viewConfig.getRenderObject();<z>
null) {<z>
viewConfig.getRenderFunction();<z>
() == null) {<z>
? viewConfig.getContentType() : DEFAULT_CONTENT_TYPE);<z>
if (this.charset == null) {<z>
? viewConfig.getCharset() : DEFAULT_CHARSET);<z>
{<z>
= viewConfig.getResourceLoaderPath();<z>
? resourceLoaderPath : DEFAULT_RESOURCE_LOADER_PATH);<z>
&& viewConfig.isSharedEngine() != null) {<z>
.isSharedEngine();<z>
= 0;<z>
.engine != null) {<z>
;<z>
if (this.engineSupplier != null) {<z>
;<z>
null) {<z>
engineCount++;<z>
.isTrue(engineCount == 1,<z>
;<z>
sharedEngine)) {<z>
null,<z>
"script engine using 'engineName' or 'engineSupplier' , not 'engine'.");<z>
else if (this.engine != null) {<z>
.engine);<z>
this.engineName != null) {<z>
));<z>
());<z>
&& this.engine != null) {<z>
this.engine,<z>
;<z>
) {<z>
;<z>
= name;<z>
._name_ = name;<z>
= birthdate;<z>
.nationality = nationality;<z>
arrayContainer = new ArrayContainer();<z>
new HashMap<>();<z>
;<z>
put("tuesday", "dienstag");<z>
"mittwoch");<z>
testMap.put("thursday", "donnerstag");<z>
"freitag");<z>
put("saturday", "samstag");<z>
.put("sunday", "sonntag");<z>
);<z>
;<z>
(false);<z>
);<z>
);<z>
add(2);<z>
;<z>
;<z>
(5);<z>
6);<z>
.add(7);<z>
.add(8);<z>
);<z>
10);<z>
mapOfNumbersUpToTen.put(1,"one");<z>
put(2,"two");<z>
3,"three");<z>
;<z>
.put(5,"five");<z>
,"six");<z>
"seven");<z>
;<z>
"nine");<z>
);<z>
public void cancel() {<z>
if (rsWriteLogger.isTraceEnabled()) {<z>
.state + "]");<z>
(this.subscription != null) {<z>
subscription.cancel();<z>
Flux<Payload> payloads) {<z>
> responseRef = new AtomicReference<>();<z>
= createHeaders(firstPayload, frameType, responseRef);<z>
= new AtomicBoolean();<z>
(true));<z>
(buffers, headers);<z>
messageHandler.handleMessage(message))<z>
.doFinally(s -> {<z>
)) {<z>
firstPayload.release();<z>
) != null ?<z>
"Expected response"))));<z>
> expectedType) {<z>
, "'attributeName' must not be null or empty");<z>
Object value = get(attributeName);<z>
attributeName, value);<z>
value);<z>
expectedType.isArray() &&<z>
value)) {<z>
expectedType.getComponentType(), 1);<z>
value);<z>
value = array;<z>
);<z>
T) value;<z>
LocalSessionFactoryBuilder setJtaTransactionManager(Object jtaTransactionManager) {<z>
Assert.notNull(jtaTransactionManager, "Transaction manager reference must not be null");<z>
) {<z>
);<z>
webspherePresent) {<z>
put(AvailableSettings.JTA_PLATFORM,<z>
"org.hibernate.engine.transaction.jta.platform.internal.WebSphereExtendedJtaPlatform");<z>
JtaTransactionManager jtaTm = (JtaTransactionManager) jtaTransactionManager;<z>
== null) {<z>
new IllegalArgumentException(<z>
"Can only apply JtaTransactionManager which has a TransactionManager reference set");<z>
.put(AvailableSettings.JTA_PLATFORM,<z>
getTransactionManager(), jtaTm.getUserTransaction(),<z>
)));<z>
{<z>
).put(AvailableSettings.JTA_PLATFORM,<z>
, null, null));<z>
IllegalArgumentException(<z>
));<z>
);<z>
().put(AvailableSettings.CONNECTION_HANDLING,<z>
;<z>
;<z>
extends T> targetType) {<z>
conversionService, "ConversionService must not be null");<z>
;<z>
.conversionService = conversionService;<z>
targetType;<z>
(Collection<?> collection) {<z>
) {<z>
;<z>
boolean hasCandidate = false;<z>
Object candidate = null;<z>
for (Object elem : collection) {<z>
(!hasCandidate) {<z>
= true;<z>
= elem;<z>
(candidate != elem) {<z>
;<z>
return true;<z>
List<Element> definitions, ParserContext parserContext) {<z>
());<z>
(Element element : definitions) {<z>
element, parserContext));<z>
return defs;<z>
{<z>
= serializerCache.get(type);<z>
) {<z>
serializer = SerializersKt.serializer(type);<z>
())) {<z>
);<z>
.put(type, serializer);<z>
return serializer;<z>
getObject() throws BeansException {<z>
;<z>
()) {<z>
getSingletonInstance();<z>
targetName == null) {<z>
"Using non-singleton proxies with singleton targets is often undesirable. " +<z>
);<z>
();<z>
{<z>
;<z>
) {<z>
i);<z>
advisor.getAdvice() == advice) {<z>
;<z>
-1;<z>
resolveStringValue(String strVal) {<z>
.resolveEmbeddedValue(strVal);<z>
{<z>
evaluate(value, this.exprContext);<z>
) : null);<z>
value;<z>
(<z>
annotation, @Nullable AnnotatedElement annotatedElement) {<z>
annotation)) {<z>
return annotation;<z>
, annotation).synthesize();<z>
default false;<z>
.RUNTIME)<z>
{})<z>
getNativeBuffer() {<z>
;<z>
.byteBuffer.limit(readableByteCount());<z>
byteBuffer;<z>
, int maxHeadersSize,<z>
Charset headersCharset) {<z>
sink -> {<z>
);<z>
(parser::onSinkCancel);<z>
));<z>
subscribe(parser);<z>
);<z>
javaMailProperties) {<z>
this.javaMailProperties = javaMailProperties;<z>
(this) {<z>
null;<z>
, String destination, LocalSimpSession session) {<z>
, "Id must not be null");<z>
.hasText(destination, "Destination must not be empty");<z>
.notNull(session, "Session must not be null");<z>
id;<z>
.destination = destination;<z>
session;<z>
beanName)<z>
{<z>
= existingBean;<z>
()) {<z>
;<z>
== null) {<z>
;<z>
result = current;<z>
return result;<z>
,<z>
String joinpointIdentification) {<z>
null) {<z>
txAttr = new DelegatingTransactionAttribute(txAttr) {<z>
String getName() {<z>
joinpointIdentification;<z>
TransactionStatus status = null;<z>
if (txAttr != null) {<z>
if (tm != null) {<z>
tm.getTransaction(txAttr);<z>
) {<z>
debug("Skipping transactional joinpoint [" + joinpointIdentification +<z>
);<z>
, status);<z>
public PropertyNamingStrategy namingStrategyInstance(MapperConfig<?> config,<z>
implClass) {<z>
.createBean(implClass);<z>
public MethodVisitor visitMethod(<z>
access,<z>
name,<z>
final String descriptor,<z>
final String signature,<z>
) {<z>
cv != null) {<z>
, name, descriptor, signature, exceptions);<z>
;<z>
{<z>
String destination = ele.getAttribute(DESTINATION_ATTRIBUTE);<z>
(!StringUtils.hasText(destination)) {<z>
).error(<z>
ele);<z>
configValues.add("destinationName", destination);<z>
.hasAttribute(SUBSCRIPTION_ATTRIBUTE)) {<z>
subscription = ele.getAttribute(SUBSCRIPTION_ATTRIBUTE);<z>
) {<z>
.error(<z>
, ele);<z>
);<z>
(ele.hasAttribute(SELECTOR_ATTRIBUTE)) {<z>
getAttribute(SELECTOR_ATTRIBUTE);<z>
!StringUtils.hasText(selector)) {<z>
parserContext.getReaderContext().error(<z>
, ele);<z>
);<z>
(CONCURRENCY_ATTRIBUTE)) {<z>
(CONCURRENCY_ATTRIBUTE);<z>
(concurrency)) {<z>
).error(<z>
ele);<z>
configValues.add("concurrency", concurrency);<z>
{<z>
.getRequest();<z>
(request)) {<z>
;<z>
if (isEmpty()) {<z>
this;<z>
request) && !this.bodyRequired) {<z>
return EMPTY_CONDITION;<z>
> result = getMatchingExpressions(exchange);<z>
new ConsumesRequestCondition(result) : null;<z>
) {<z>
;<z>
(batch.length);<z>
: batch) {<z>
batchValues.add(matchInParameterValuesWithInsertColumns(args));<z>
batchValues);<z>
{<z>
()) {<z>
false;<z>
DeferredResultHandler resultHandlerToUse;<z>
) {<z>
if (isSetOrExpired()) {<z>
;<z>
= result;<z>
resultHandlerToUse = this.resultHandler;<z>
{<z>
;<z>
.resultHandler = null;<z>
handleResult(result);<z>
return true;<z>
FileNotFoundException {<z>
resourceLocation, "Resource location must not be null");<z>
(resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {<z>
);<z>
+ "]";<z>
.getDefaultClassLoader();<z>
.getSystemResource(path));<z>
if (url == null) {<z>
new FileNotFoundException(description +<z>
" cannot be resolved to absolute file path because it does not exist");<z>
return getFile(url, description);<z>
getFile(new URL(resourceLocation));<z>
MalformedURLException ex) {<z>
;<z>
(@Nullable Object source) {<z>
{<z>
getEmptyValue();<z>
);<z>
) {<z>
;<z>
)) {<z>
;<z>
getReturnType();<z>
) {<z>
componentType = returnType.getComponentType();<z>
componentType) &&<z>
Repeatable.class)) {<z>
;<z>
return NONE;<z>
private static boolean collectionCompare(<z>
bindStatus) {<z>
{<z>
;<z>
(ClassCastException ex) {<z>
;<z>
) {<z>
, port, new StompReactorNettyCodec());<z>
forLog(client.getLogger()));<z>
return client;<z>
mediaTypes) {<z>
) {<z>
.emptyList();<z>
MimeTypeUtils.tokenize(mediaTypes);<z>
());<z>
) {<z>
) {<z>
);<z>
;<z>
elementType,<z>
String, Object> hints) {<z>
;<z>
Duration maxAge) {<z>
CacheControl cc = new CacheControl();<z>
cc.maxAge = maxAge;<z>
cc;<z>
publishComplete() {<z>
.get();<z>
{<z>
);<z>
.publishComplete(this);<z>
Object handler)<z>
ServletException, IOException {<z>
.SC_FORBIDDEN);<z>
, CodeFlow cf) {<z>
(this.member.getModifiers());<z>
();<z>
().replace('.', '/');<z>
if (!isStatic) {<z>
descriptor == null) {<z>
;<z>
))) {<z>
.visitTypeInsn(CHECKCAST, classDesc);<z>
(descriptor != null) {<z>
(POP);<z>
this.member instanceof Method method) {<z>
();<z>
);<z>
),<z>
), isInterface);<z>
this.member.getName(),<z>
)));<z>
, RequestedContentTypeResolver resolver) {<z>
, headers);<z>
expressions.size() > 1) {<z>
.sort(this.expressions);<z>
resolver != null ? resolver : DEFAULT_CONTENT_TYPE_RESOLVER;<z>
DeferredImportSelector selector) {<z>
metadata)) {<z>
;<z>
(ServerHttpRequest request) {<z>
return new DefaultSockJsFrameFormat("<script>\np(\"%s\");\n</script>\r\n") {<z>
(String content) {<z>
content);<z>
) {<z>
.IDENTIFIER)) {<z>
methodOrPropertyName = takeToken();<z>
();<z>
) {<z>
nullSafeNavigation, methodOrPropertyName.stringValue(),<z>
);<z>
true;<z>
),<z>
methodOrPropertyName.endPos, args));<z>
;<z>
;<z>
{<z>
(this.holderActive) {<z>
, this.resourceObject);<z>
();<z>
beanName, Class<T> expectedType) {<z>
== null) {<z>
throw new IllegalStateException(<z>
+ " retrieval");<z>
);<z>
BeansException {<z>
this.target == null) {<z>
;<z>
this.target);<z>
return this.target;<z>
(String name) {<z>
> attributes = attributes();<z>
containsKey(name)) {<z>
;<z>
.empty();<z>
? extends BeanPostProcessor> c) {<z>
(c);<z>
(success) {<z>
;<z>
success;<z>
) {<z>
notNull(location, "Location must not be null");<z>
)) {<z>
protocolResolver.resolve(location, this);<z>
(resource != null) {<z>
resource;<z>
.startsWith("/")) {<z>
return getResourceByPath(location);<z>
if (location.startsWith(CLASSPATH_URL_PREFIX)) {<z>
), getClassLoader());<z>
location);<z>
url));<z>
{<z>
getResourceByPath(location);<z>
, List<SqlParameter> declaredParameters)<z>
throws DataAccessException {<z>
<>();<z>
);<z>
>();<z>
) {<z>
.isResultsParameter()) {<z>
parameter instanceof SqlReturnResultSet) {<z>
resultSetParameters.add(parameter);<z>
);<z>
.add(parameter);<z>
, cs -> {<z>
execute();<z>
;<z>
logger.isTraceEnabled()) {<z>
"CallableStatement.execute() returned '" + retVal + "'");<z>
("CallableStatement.getUpdateCount() returned " + updateCount);<z>
createResultsMap();<z>
1) {<z>
cs, updateCountParameters, resultSetParameters, updateCount));<z>
extractOutputParameters(cs, callParameters));<z>
return resultsMap;<z>
;<z>
"No result map");<z>
;<z>
)<z>
DataAccessException {<z>
);<z>
() {<z>
;<z>
);<z>
()) {<z>
.nextElement();<z>
);<z>
;<z>
) throws IOException {<z>
outputStream == null) {<z>
);<z>
.outputStream;<z>
Nullable Class<?>... actualInterfaces)<z>
throws IOException, ScriptCompilationException {<z>
= evaluateScript(scriptSource);<z>
{<z>
;<z>
(Class<?> requestedIfc : actualInterfaces) {<z>
((Class<?>) script) :<z>
{<z>
adaptationRequired = true;<z>
adaptationRequired) {<z>
, scriptSource, actualInterfaces);<z>
Class) {<z>
?>) script;<z>
);<z>
ex) {<z>
throw new ScriptCompilationException(<z>
getName(), ex);<z>
(InstantiationException ex) {<z>
new ScriptCompilationException(<z>
;<z>
IllegalAccessException ex) {<z>
ScriptCompilationException(<z>
, ex);<z>
catch (InvocationTargetException ex) {<z>
(<z>
(), ex.getTargetException());<z>
return script;<z>
containingBean) {<z>
= ele.getAttribute(ID_ATTRIBUTE);<z>
ele.getAttribute(NAME_ATTRIBUTE);<z>
>();<z>
hasLength(nameAttr)) {<z>
);<z>
);<z>
beanName = id;<z>
()) {<z>
remove(0);<z>
{<z>
+ beanName +<z>
" as aliases");<z>
null) {<z>
;<z>
, beanName, containingBean);<z>
{<z>
.hasText(beanName)) {<z>
containingBean != null) {<z>
.generateBeanName(<z>
, true);<z>
);<z>
);<z>
!= null &&<z>
length() > beanClassName.length() &&<z>
{<z>
(beanClassName);<z>
isTraceEnabled()) {<z>
.trace("Neither XML 'id' nor 'name' specified - " +<z>
;<z>
) {<z>
ele);<z>
null;<z>
toStringArray(aliases);<z>
, aliasesArray);<z>
null;<z>
visit(Object vfsResource) {<z>
this.pathMatcher.match(this.subPattern,<z>
.length()))) {<z>
;<z>
) {<z>
synchronized (this.mutex) {<z>
.FAILURE;<z>
;<z>
FailureCallback callback;<z>
) != null) {<z>
(callback);<z>
) {<z>
ManagedScheduledExecutorService executor = (ManagedScheduledExecutorService) scheduledExecutor;<z>
.concurrent.Trigger() {<z>
) {<z>
(trigger.nextExecutionTime(le != null ?<z>
:<z>
new SimpleTriggerContext()));<z>
LastExecution lastExecution, Date scheduledRunTime) {<z>
false;<z>
;<z>
?>> converters,<z>
manager, List<Object> requestResponseBodyAdvice) {<z>
);<z>
, @Nullable Object... args) throws BeansException {<z>
args != null) {<z>
(<z>
;<z>
getBean(requiredType);<z>
(<z>
int referenceKind,<z>
String owner,<z>
,<z>
descriptor,<z>
isInterface) {<z>
int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;<z>
owner, name, descriptor, referenceKind);<z>
get(hashCode);<z>
{<z>
.tag == tag<z>
hashCode<z>
.data == referenceKind<z>
&& entry.owner.equals(owner)<z>
)<z>
descriptor)) {<z>
return entry;<z>
entry = entry.next;<z>
) {<z>
descriptor).index);<z>
else {<z>
.put112(<z>
name, descriptor, isInterface).index);<z>
(<z>
);<z>
IllegalStateException {<z>
{<z>
modelKey);<z>
if (value == null) {<z>
modelKey + "]");<z>
) {<z>
+ "] retrieved via key [" +<z>
;<z>
value;<z>
: model.entrySet()) {<z>
.getValue();<z>
&&<z>
), value)) {<z>
return value;<z>
;<z>
) {<z>
class) ||<z>
.getDeclaringClass(), SendTo.class) ||<z>
) ||<z>
) ||<z>
;<z>
() {<z>
this.parameterName + "' for method parameter type " +<z>
this.parameterType + " is " +<z>
);<z>
startAsync() {<z>
,<z>
;<z>
);<z>
(isAsyncStarted()) {<z>
);<z>
);<z>
timeout != null) {<z>
timeout);<z>
ContentChunkInfo> result) {<z>
)) {<z>
isTraceEnabled()) {<z>
"Unexpected syntax for @import link at index " + position);<z>
position;<z>
{<z>
result.getResponse().getStatus();<z>
HttpStatus status = HttpStatus.valueOf(statusValue);<z>
.series();<z>
(<z>
)<z>
IOException {<z>
;<z>
!= null) {<z>
null) {<z>
encoding);<z>
(isForceResponseEncoding()) {<z>
(encoding);<z>
filterChain.doFilter(request, response);<z>
bean, String beanName) {<z>
new ProxyFactory();<z>
.copyFrom(this);<z>
setTarget(bean);<z>
;<z>
getPathSegments() {<z>
ArrayList<>();<z>
this.pathComponents) {<z>
addAll(pathComponent.getPathSegments());<z>
return result;<z>
public InetSocketAddress getHost() {<z>
);<z>
if (value == null) {<z>
null;<z>
null;<z>
0;<z>
));<z>
(separator != -1) {<z>
separator);<z>
(separator + 1);<z>
portString);<z>
ex) {<z>
null) {<z>
value;<z>
host, port);<z>
) {<z>
)) {<z>
= createJdbcTemplate(dataSource);<z>
();<z>
) {<z>
!this.initedViaDeclaredInitMethod) ||<z>
.postProcessedAfterInit) {<z>
new RuntimeException("Factory didn't initialize lifecycle object correctly");<z>
Class<?> paramType, NativeWebRequest request)<z>
Exception {<z>
);<z>
(value != null) {<z>
;<z>
.getNativeRequest(ServletRequest.class);<z>
(servletRequest != null) {<z>
= HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE;<z>
)<z>
) servletRequest.getAttribute(attr);<z>
;<z>
return null;<z>
, PropertySource<?> propertySource) {<z>
, propertySource);<z>
this.propertySourceList) {<z>
);<z>
(relativePropertySourceName);<z>
addAtIndex(index + 1, propertySource);<z>
readMono(ResolvableType elementType,<z>
Map<String, Object> hints) {<z>
Hints.SUPPRESS_LOGGING_HINT, true);<z>
partReader.read(elementType, inputMessage, allHints)<z>
collectMultimap(Part::name)<z>
.doOnNext(map -><z>
(hints) + "Parsed " +<z>
() ?<z>
!traceOn) :<z>
))<z>
);<z>
boolean includeArgs,<z>
useLongReturnAndArgumentTypeName) {<z>
) {<z>
++) {<z>
[i], useLongReturnAndArgumentTypeName);<z>
< size - 1) {<z>
;<z>
(types.length != 0) {<z>
;<z>
{<z>
.enterpriseConcurrentScheduler) {<z>
, true), trigger);<z>
ErrorHandler errorHandler =<z>
getDefaultErrorHandler(true));<z>
();<z>
RejectedExecutionException ex) {<z>
task, ex);<z>
String attrName) {<z>
, "ServletContext must not be null");<z>
attr = sc.getAttribute(attrName);<z>
if (attr == null) {<z>
null;<z>
attr instanceof RuntimeException) {<z>
;<z>
attr instanceof Error) {<z>
) attr;<z>
if (attr instanceof Exception) {<z>
new IllegalStateException((Exception) attr);<z>
{<z>
("Context attribute is not of type WebApplicationContext: " + attr);<z>
(WebApplicationContext) attr;<z>
public UndertowServerHttpRequest(HttpServerExchange exchange, DataBufferFactory bufferFactory)<z>
{<z>
(exchange.getRequestHeaders()));<z>
.exchange = exchange;<z>
body = new RequestBodyPublisher(exchange, bufferFactory);<z>
body.registerListeners(exchange);<z>
() {<z>
super.afterCommit();<z>
.getTransaction().commit();<z>
catch (RuntimeException ex) {<z>
;<z>
void printStackTrace(PrintWriter pw) {<z>
.isEmpty(this.messageExceptions)) {<z>
;<z>
+ "; message exception details (" +<z>
messageExceptions.length + ") are:");<z>
.length; i++) {<z>
subEx = this.messageExceptions[i];<z>
+ 1) + ":");<z>
subEx.printStackTrace(pw);<z>
{<z>
Assert.notNull(clazz, "Class must not be null");<z>
notNull(generics, "Generics array must not be null");<z>
.getTypeParameters();<z>
== generics.length, "Mismatched number of generics specified");<z>
.length];<z>
; i++) {<z>
generic = generics[i];<z>
.getType() : null);<z>
argument : variables[i]);<z>
new SyntheticParameterizedType(clazz, arguments);<z>
variables, generics));<z>
onApplicationEventInternal(ApplicationEvent event) {<z>
if (this.delegate == null) {<z>
(<z>
);<z>
.onApplicationEvent(event);<z>
{<z>
{<z>
.create(StompCommand.ERROR);<z>
getHeaderInitializer() != null) {<z>
(accessor);<z>
(this.sessionId);<z>
getUser();<z>
user != null) {<z>
user);<z>
errorText);<z>
true);<z>
;<z>
handleInboundMessage(errorMessage);<z>
batchValues) {<z>
()) {<z>
;<z>
(),<z>
) {<z>
ps, int i) throws SQLException {<z>
getInsertTypes());<z>
int getBatchSize() {<z>
.size();<z>
);<z>
() {<z>
2);<z>
;<z>
&& jcacheImplPresent) {<z>
;<z>
.toStringArray(result);<z>
MultipartResolver lookupMultipartResolver() {<z>
;<z>
= getMultipartResolverBeanName();<z>
&& wac.containsBean(beanName)) {<z>
(logger.isDebugEnabled()) {<z>
+ beanName + "' for MultipartFilter");<z>
;<z>
defaultMultipartResolver;<z>
(<z>
{<z>
decorateWebSocketHandler(subProtocolWebSocketHandler);<z>
=<z>
getTransportRegistration(), messageBrokerTaskScheduler);<z>
ApplicationContext applicationContext = getApplicationContext();<z>
(applicationContext != null) {<z>
);<z>
registry);<z>
);<z>
, @Nullable Class<?> type) {<z>
Assert.notNull(beanFactory, "BeanFactory must not be null");<z>
, "Bean name must not be null");<z>
this.beanFactory = beanFactory;<z>
name;<z>
resolvedType = type;<z>
== null) {<z>
);<z>
"Unresolvable bean type - explicitly specify the aspect class");<z>
);<z>
public int compareTo(LifecycleGroupMember other) {<z>
);<z>
;<z>
otherPhase);<z>
Class<? extends Number> numberClass,<z>
NumberFormat numberFormat, boolean allowEmpty) throws IllegalArgumentException {<z>
{<z>
);<z>
numberClass;<z>
.numberFormat = numberFormat;<z>
= allowEmpty;<z>
(<z>
Class<T> requiredType) {<z>
) {<z>
();<z>
requiredType.isInstance(headerAccessor)) {<z>
;<z>
;<z>
Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {<z>
, sourceType, targetType);<z>
ex) {<z>
,<z>
() : "null")),<z>
));<z>
exceptionType) {<z>
;<z>
.keySet()) {<z>
(mappedException.isAssignableFrom(exceptionType)) {<z>
);<z>
)) {<z>
size() > 1) {<z>
new ExceptionDepthComparator(exceptionType));<z>
);<z>
;<z>
exchange) {<z>
;<z>
exchange.getResponse();<z>
responseHeaders = response.getHeaders();<z>
get(HttpHeaders.VARY);<z>
null) {<z>
VARY, VARY_HEADERS);<z>
header : VARY_HEADERS) {<z>
header)) {<z>
, header);<z>
request)) {<z>
return true;<z>
.ACCESS_CONTROL_ALLOW_ORIGIN) != null) {<z>
("Skip: response already contains \"Access-Control-Allow-Origin\"");<z>
return true;<z>
isPreFlightRequest(request);<z>
config == null) {<z>
preFlightRequest) {<z>
);<z>
return false;<z>
return true;<z>
preFlightRequest);<z>
void validateMergedContextConfiguration(MergedContextConfiguration mergedConfig) {<z>
if (mergedConfig.hasLocations()) {<z>
format("Test class [%s] has been configured with @ContextConfiguration's 'locations' " +<z>
getLocations()),<z>
;<z>
);<z>
throw new IllegalStateException(msg);<z>
Object value, Class<?> paramType) {<z>
if (value == null) {<z>
{<z>
return Boolean.FALSE;<z>
)) {<z>
getSimpleName() +<z>
+<z>
"Consider declaring it as object wrapper for the corresponding primitive type.");<z>
value;<z>
@Nullable ServerWebExchange exchange, String requestPath,<z>
locations, ResourceResolverChain chain) {<z>
);<z>
> submit(Callable<T> task) {<z>
= getScheduledExecutor();<z>
T> taskToUse = task;<z>
.errorHandler;<z>
errorHandler != null) {<z>
DelegatingErrorHandlingCallable<>(task, errorHandler);<z>
executor.submit(taskToUse);<z>
ex) {<z>
task, ex);<z>
, Matcher<? super Integer> matcher) {<z>
{<z>
cookie = getCookie(result, name);<z>
, cookie.getVersion(), matcher);<z>
Annotation>> asyncAnnotationTypes) {<z>
= null;<z>
> asyncAnnotationType : asyncAnnotationTypes) {<z>
, true);<z>
;<z>
null) {<z>
new ComposablePointcut(cpc);<z>
result.union(cpc);<z>
= result.union(mpc);<z>
? result : Pointcut.TRUE);<z>
(@Nullable Object other) {<z>
if (this == other) {<z>
return true;<z>
RuntimeBeanReference that)) {<z>
;<z>
that.beanType &&<z>
toParent == that.toParent);<z>
, boolean allowNullValues) {<z>
(allowNullValues);<z>
"Cache must not be null");<z>
= jcache;<z>
{<z>
) {<z>
empty();<z>
this.handlerAdapters != null) {<z>
{<z>
)) {<z>
return handlerAdapter.handle(exchange, handler);<z>
new IllegalStateException("No HandlerAdapter: " + handler));<z>
TcpConnection<byte[]> connection) {<z>
this.connection = connection;<z>
logger.isDebugEnabled()) {<z>
.sessionId);<z>
accessor = createHeaderAccessor(StompCommand.CONNECT);<z>
;<z>
getAcceptVersion() == null) {<z>
.setAcceptVersion("1.1,1.2");<z>
, EMPTY_PAYLOAD);<z>
;<z>
XmlMappingException {<z>
eventReader);<z>
);<z>
{<z>
, false);<z>
encode(Publisher<? extends DataBuffer> inputStream,<z>
elementType, @Nullable MimeType mimeType,<z>
<String, Object> hints) {<z>
inputStream);<z>
hints)) {<z>
, hints));<z>
flux;<z>
void visitEnd() {<z>
.of(this.annotations);<z>
SimpleAnnotationMetadata(this.className, this.access,<z>
, this.superClassName, this.independentInnerClass,<z>
);<z>
TransactionStatus status) {<z>
-> {<z>
ex)) {<z>
();<z>
);<z>
{<z>
(session);<z>
;<z>
);<z>
getNegotiatedExtensions();<z>
{<z>
standardExtensions.size());<z>
Extension standardExtension : standardExtensions) {<z>
));<z>
.extensions);<z>
= Collections.emptyList();<z>
user == null) {<z>
.user = session.getUserPrincipal();<z>
() {<z>
(<z>
.textPlainOnly()),<z>
ResourceHttpMessageWriter()<z>
;<z>
> input, ResolvableType elementType,<z>
, Object> hints) {<z>
maxInMemorySize)<z>
, elementType, mimeType, hints));<z>
{<z>
if (logger.isDebugEnabled()) {<z>
);<z>
ctx -> {<z>
.bind(name, object);<z>
return null;<z>
);<z>
(@Nullable ConfigurableBeanFactory factory,<z>
) {<z>
factory, registry);<z>
, boolean includeNonSingletons, boolean allowEagerInit) {<z>
> resolved = type.resolve();<z>
) {<z>
;<z>
type, includeNonSingletons, allowEagerInit);<z>
,<z>
,<z>
String blockCommentEndDelimiter) throws ScriptException {<z>
false;<z>
false;<z>
= false;<z>
i++) {<z>
(i);<z>
if (inEscape) {<z>
= false;<z>
c == '\\') {<z>
inEscape = true;<z>
) {<z>
!inSingleQuote;<z>
'"')) {<z>
!inDoubleQuote;<z>
if (!inSingleQuote && !inDoubleQuote) {<z>
{<z>
true;<z>
{<z>
.indexOf('\n', i);<z>
(indexOfNextNewline > i) {<z>
indexOfNextNewline;<z>
blockCommentStartDelimiter, i)) {<z>
(blockCommentEndDelimiter, i);<z>
i) {<z>
() - 1;<z>
throw new ScriptParseException(<z>
resource);<z>
return false;<z>
getAnnotationAttributes(<z>
annotation) {<z>
(annotatedElement, annotation, false, false);<z>
(<z>
) {<z>
return (contextCustomizers != null ?<z>
.unmodifiableSet(contextCustomizers) : EMPTY_CONTEXT_CUSTOMIZERS);<z>
,<z>
valueExtractor) {<z>
extractedValue)) {<z>
true;<z>
instanceof Class && extractedValue instanceof String) {<z>
;<z>
[] && extractedValue instanceof String[]) {<z>
String[]) extractedValue);<z>
instanceof Annotation) {<z>
extractedValue, valueExtractor);<z>
return false;<z>
() {<z>
<String, String> params =<z>
().getQueryParams();<z>
()) {<z>
).toUri();<z>
this.url;<z>
status) {<z>
{<z>
unbindResourceIfPossible(this.dataSource);<z>
= false;<z>
this.connectionHolder.hasConnection()) {<z>
);<z>
(null);<z>
this.connectionHolder.reset();<z>
(<z>
, RSocketStrategies strategies) {<z>
Object data = this.setupData;<z>
CollectionUtils.isEmpty(this.setupMetadata));<z>
hasMetadata && data == null) {<z>
;<z>
= Mono.empty();<z>
) {<z>
data.getClass());<z>
;<z>
just(data));<z>
map(value -> {<z>
getClass());<z>
;<z>
;<z>
(), type, dataMimeType, HINTS);<z>
;<z>
;<z>
) {<z>
metaMimeType, strategies)<z>
this.setupRouteVars)<z>
;<z>
(() -><z>
EMPTY_BYTE_ARRAY));<z>
switchIfEmpty(emptyBuffer);<z>
emptyBuffer);<z>
return Mono.zip(dataMono, metaMono)<z>
), tuple.getT2()))<z>
.class, DataBufferUtils::release)<z>
class, Payload::release);<z>
,<z>
HttpMessageNotReadableException {<z>
).getContentType();<z>
) != null ?<z>
charset);<z>
), charset);<z>
tokenizeToStringArray(body, "&");<z>
);<z>
String pair : pairs) {<z>
);<z>
idx == -1) {<z>
, charset), null);<z>
charset);<z>
), charset);<z>
(name, value);<z>
result;<z>
) {<z>
lifecycleMonitor) {<z>
isRunning()) {<z>
);<z>
{<z>
"Starting " + serverName + "...");<z>
running = true;<z>
();<z>
();<z>
();<z>
millis = stopWatch.getTotalTimeMillis();<z>
logger.isDebugEnabled()) {<z>
;<z>
(Throwable ex) {<z>
ex);<z>
initCorsConfiguration() {<z>
;<z>
addAllowedMethod("*");<z>
emptyList());<z>
);<z>
config.setAllowCredentials(true);<z>
setMaxAge(ONE_YEAR);<z>
config.addAllowedHeader("*");<z>
;<z>
getTarget() throws Exception {<z>
lazyTarget == null) {<z>
logger.debug("Initializing lazy target object");<z>
this.lazyTarget = createObject();<z>
return this.lazyTarget;<z>
boolean isRemoteHost(String targetUrl) {<z>
) {<z>
;<z>
;<z>
{<z>
false;<z>
) {<z>
.equals(host)) {<z>
false;<z>
;<z>
transaction) {<z>
HibernateTransactionObject) transaction;<z>
;<z>
sessionHolder =<z>
));<z>
(null);<z>
null;<z>
{<z>
getDataSource());<z>
sessionHolder, connectionHolder);<z>
(ServletRequest request, String name)<z>
{<z>
== null) {<z>
null;<z>
name);<z>
{<z>
key instanceof String) {<z>
));<z>
) {<z>
.targetMap.get(caseInsensitiveKey);<z>
;<z>
{<z>
exchange, "HttpServerExchange is required");<z>
String requestURL = exchange.getRequestURL();<z>
exchange.getQueryString();<z>
+ "?" + query : requestURL);<z>
;<z>
, int end, boolean isLink) {<z>
.start = start;<z>
= end;<z>
= isLink;<z>
RequestMatcher contentType(MediaType expectedContentType) {<z>
return request -> {<z>
getHeaders().getContentType();<z>
"Content type not set", actualContentType != null);<z>
, actualContentType);<z>
parameterSource) {<z>
checkCompiled();<z>
);<z>
);<z>
) {<z>
(av != null) {<z>
;<z>
@Nullable String attributeValue) throws JspException {<z>
{<z>
;<z>
,<z>
.class.getClassLoader())<z>
ClassUtils.isPresent(GROOVY_XML_CONTEXT_LOADER_CLASS_NAME,<z>
getClassLoader());<z>
SmartContextLoader xmlLoader;<z>
annotationConfigLoader;<z>
public DelegatingSmartContextLoader() {<z>
if (groovyPresent) {<z>
GROOVY_XML_CONTEXT_LOADER_CLASS_NAME,<z>
);<z>
);<z>
Throwable ex) {<z>
IllegalStateException("Failed to enable support for Groovy scripts; "<z>
;<z>
();<z>
= new AnnotationConfigContextLoader();<z>
String catalogName,<z>
String tableName) throws SQLException {<z>
.tableColumnMetaDataUsed = true;<z>
(databaseMetaData, catalogName, schemaName, tableName);<z>
Object result, ConcurrentResultMethodParameter returnType) {<z>
) () -> {<z>
Exception) {<z>
;<z>
(result instanceof Throwable) {<z>
;<z>
result;<z>
;<z>
(ServletInvocableHandlerMethod.this.returnValueHandlers != null) {<z>
;<z>
returnType = returnType;<z>
registerWebSocketHandlers(WebSocketHandlerRegistry registry) {<z>
this.configurers) {<z>
);<z>
() {<z>
(this.scheduledExecutor == null) {<z>
;<z>
();<z>
() {<z>
;<z>
;<z>
;<z>
Object other) {<z>
this == other) {<z>
;<z>
(other instanceof CloseStatus otherStatus)) {<z>
false;<z>
&&<z>
, otherStatus.reason));<z>
<?> requiredType) {<z>
&& !requiredType.isInstance(autowiringValue)) {<z>
factory = (ObjectFactory<?>) autowiringValue;<z>
)) {<z>
getClassLoader(),<z>
(factory));<z>
getObject();<z>
return autowiringValue;<z>
{<z>
(pvs.isEmpty()) {<z>
= null;<z>
> original;<z>
pvs instanceof MutablePropertyValues) {<z>
(MutablePropertyValues) pvs;<z>
.isConverted()) {<z>
;<z>
ex) {<z>
BeanCreationException(<z>
, "Error setting property values", ex);<z>
original = mpvs.getPropertyValueList();<z>
getPropertyValues());<z>
;<z>
if (converter == null) {<z>
converter = bw;<z>
, mbd, converter);<z>
());<z>
;<z>
{<z>
) {<z>
pv);<z>
();<z>
= pv.getValue();<z>
{<z>
);<z>
== null) {<z>
+ pv);<z>
MethodParameter(writeMethod, 0), true);<z>
);<z>
= resolvedValue;<z>
&&<z>
!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);<z>
) {<z>
, converter);<z>
if (resolvedValue == originalValue) {<z>
{<z>
pv.setConvertedValue(convertedValue);<z>
;<z>
originalValue instanceof TypedStringValue &&<z>
TypedStringValue) originalValue).isDynamic() &&<z>
|| ObjectUtils.isArray(convertedValue))) {<z>
;<z>
.add(pv);<z>
= true;<z>
pv, convertedValue));<z>
&& !resolveNecessary) {<z>
.setConverted();<z>
;<z>
catch (BeansException ex) {<z>
(<z>
"Error setting property values", ex);<z>
copyConfigurationFrom(ConfigurableBeanFactory otherFactory) {<z>
.copyConfigurationFrom(otherFactory);<z>
otherFactory instanceof DefaultListableBeanFactory otherListableFactory) {<z>
otherListableFactory.allowBeanDefinitionOverriding;<z>
otherListableFactory.allowEagerClassLoading;<z>
otherListableFactory.dependencyComparator;<z>
());<z>
.resolvableDependencies);<z>
ae, CacheOperation operation) {<z>
) {<z>
("Invalid cache annotation configuration on '" +<z>
toString() + "'. Both 'key' and 'keyGenerator' attributes have been set. " +<z>
;<z>
)) {<z>
"Invalid cache annotation configuration on '" +<z>
.toString() + "'. Both 'cacheManager' and 'cacheResolver' attributes have been set. " +<z>
;<z>
) throws NamingException {<z>
if (logger.isDebugEnabled()) {<z>
debug("Rebinding JNDI object with name [" + name + "]");<z>
(ctx -> {<z>
.rebind(name, object);<z>
return null;<z>
});<z>
MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,<z>
{<z>
)<z>
=<z>
>) request.getAttribute(<z>
.SCOPE_REQUEST);<z>
matrixVariables)) {<z>
);<z>
;<z>
= parameter.getParameterAnnotation(MatrixVariable.class);<z>
null, "No MatrixVariable annotation");<z>
();<z>
equals(ValueConstants.DEFAULT_NONE)) {<z>
(pathVariable);<z>
{<z>
emptyMap();<z>
putAll(mapForPathVariable);<z>
matrixVariables.values()) {<z>
forEach((name, values) -> {<z>
) {<z>
name, value);<z>
);<z>
.toSingleValueMap() : map);<z>
,<z>
? extends HttpMessageConverter<?>> converterType) {<z>
class)) {<z>
converterType)) {<z>
, parameter, targetType, converterType);<z>
body;<z>
public EmptyBodyCheckingHttpInputMessage(HttpInputMessage inputMessage) throws IOException {<z>
);<z>
);<z>
.markSupported()) {<z>
mark(1);<z>
);<z>
inputStream.reset();<z>
;<z>
.read();<z>
== -1) {<z>
.body = null;<z>
.body = pushbackInputStream;<z>
(b);<z>
T> elementTypeRef) {<z>
-><z>
,<z>
(elementTypeRef))));<z>
annotationParser) {<z>
true;<z>
notNull(annotationParser, "TransactionAnnotationParser must not be null");<z>
singleton(annotationParser);<z>
, String> queryParams) {<z>
queryParams, "'queryParams' must not be null");<z>
= queryParams;<z>
this;<z>
) {<z>
this.properties == null) {<z>
return null;<z>
properties.getProperty(code);<z>
Object invokeAdviceMethod(<z>
Nullable Throwable ex)<z>
{<z>
, jpMatch, returnValue, ex));<z>
[] args) throws Throwable {<z>
init();<z>
fci = fastClassInfo;<z>
, args);<z>
(InvocationTargetException ex) {<z>
getTargetException();<z>
ex) {<z>
if (fastClassInfo.i1 < 0)<z>
;<z>
;<z>
, String variableName) {<z>
(this.capturedVariableNames == null) {<z>
= new ArrayList<>();<z>
capturedVariableNames.contains(variableName)) {<z>
new PatternParseException(pos, this.pathPatternData,<z>
ILLEGAL_DOUBLE_CAPTURE, variableName);<z>
this.capturedVariableNames.add(variableName);<z>
payloads) {<z>
)<z>
signal, innerFlux) -> {<z>
= signal.get();<z>
firstPayload == null ? innerFlux :<z>
.REQUEST_CHANNEL, innerFlux);<z>
);<z>
{<z>
);<z>
, "No DataSource set");<z>
;<z>
extends ApplicationEvent> eventFactory) {<z>
(hasApplicationContext()) {<z>
publishEvent(eventFactory.apply(this));<z>
public ViewResolutionResultHandler viewResolutionResultHandler(<z>
"webFluxAdapterRegistry") ReactiveAdapterRegistry reactiveAdapterRegistry,<z>
contentTypeResolver) {<z>
ViewResolverRegistry registry = getViewResolverRegistry();<z>
> resolvers = registry.getViewResolvers();<z>
ViewResolutionResultHandler handler = new ViewResolutionResultHandler(<z>
;<z>
(registry.getDefaultViews());<z>
());<z>
return handler;<z>
T> beanType) {<z>
Collectors.toList());<z>
()) {<z>
null;<z>
() == 1) {<z>
;<z>
+<z>
);<z>
) {<z>
(defaultCodecs, "'defaultCodecs' is required");<z>
;<z>
.customCodecs = new DefaultCustomCodecs();<z>
)<z>
ConnectionFactoryLookupFailureException {<z>
Assert.notNull(connectionFactoryName, "ConnectionFactory name must not be null");<z>
connectionFactoryName, key -> {<z>
throw new ConnectionFactoryLookupFailureException(<z>
"' registered");<z>
);<z>
private String unescape(String inString) {<z>
));<z>
int pos = 0;<z>
);<z>
while (index >= 0) {<z>
.append(inString, pos, index);<z>
()) {<z>
("Illegal escape sequence at index " + index + ": " + inString);<z>
charAt(index + 1);<z>
'r') {<z>
.append('\r');<z>
c == 'n') {<z>
sb.append('\n');<z>
) {<z>
':');<z>
{<z>
('\\');<z>
": " + inString);<z>
pos = index + 2;<z>
indexOf('\\', pos);<z>
;<z>
toString();<z>
[] defaultViews) {<z>
.HIGHEST_PRECEDENCE);<z>
if (this.contentNegotiatingResolver != null) {<z>
!ObjectUtils.isEmpty(defaultViews) &&<z>
))) {<z>
.contentNegotiatingResolver.getDefaultViews());<z>
Arrays.asList(defaultViews));<z>
(views);<z>
;<z>
;<z>
;<z>
(this.contentNegotiationManager != null) {<z>
.contentNegotiationManager);<z>
.contentNegotiatingResolver;<z>
void registerBeanDefinitions(<z>
, BeanDefinitionRegistry registry) {<z>
registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);<z>
enableAspectJAutoProxy =<z>
attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);<z>
!= null) {<z>
{<z>
.forceAutoProxyCreatorToUseClassProxying(registry);<z>
) {<z>
AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);<z>
Employee employee() {<z>
= new Employee();<z>
);<z>
;<z>
employee.setCompany("Acme Widgets, Inc.");<z>
employee;<z>
final void init() throws ServletException {<z>
(getServletConfig(), this.requiredProperties);<z>
.isEmpty()) {<z>
bw = PropertyAccessorFactory.forBeanPropertyAccess(this);<z>
ServletContextResourceLoader(getServletContext());<z>
resourceLoader, getEnvironment()));<z>
(bw);<z>
pvs, true);<z>
{<z>
(logger.isErrorEnabled()) {<z>
+ getServletName() + "'", ex);<z>
;<z>
);<z>
) {<z>
.closeLock.tryLock()) {<z>
(getTimeSinceSendStarted() > getSendTimeLimit()) {<z>
;<z>
;<z>
);<z>
()) {<z>
this.overflowStrategy) {<z>
TERMINATE:<z>
format = "Buffer size %d bytes for session '%s' exceeds the allowed limit %d";<z>
getId(), getBufferSizeLimit());<z>
;<z>
:<z>
;<z>
) > getBufferSizeLimit()) {<z>
);<z>
message == null) {<z>
());<z>
;<z>
{<z>
));<z>
new IllegalStateException("Unexpected OverflowStrategy: " + this.overflowStrategy);<z>
.unlock();<z>
public void onSubscribe(Subscription s) {<z>
subscription == null) {<z>
= s;<z>
subscription.request(1);<z>
;<z>
(ConfigurableListableBeanFactory beanFactory) {<z>
(CONVERSION_SERVICE_BEAN_NAME) &&<z>
.class)) {<z>
beanFactory.setConversionService(<z>
));<z>
beanFactory.hasEmbeddedValueResolver()) {<z>
getEnvironment().resolvePlaceholders(strVal));<z>
, false);<z>
: weaverAwareNames) {<z>
;<z>
);<z>
();<z>
();<z>
Mono<Void> close(CloseStatus status) {<z>
));<z>
));<z>
(IOException ex) {<z>
return Mono.error(ex);<z>
();<z>
) {<z>
)) {<z>
null;<z>
;<z>
(getPatternParser() != null) {<z>
getPatternParser());<z>
);<z>
= new UrlBasedCorsConfigurationSource();<z>
(corsConfigurations);<z>
this.pathMatcher);<z>
.urlPathHelper);<z>
(source);<z>
other) {<z>
other.jackson2JsonDecoder;<z>
jackson2JsonEncoder;<z>
jackson2SmileDecoder;<z>
.jackson2SmileEncoder;<z>
protobufDecoder = other.protobufDecoder;<z>
= other.protobufEncoder;<z>
;<z>
.jaxb2Encoder;<z>
.kotlinSerializationJsonDecoder;<z>
other.kotlinSerializationJsonEncoder;<z>
other.codecConsumer;<z>
.maxInMemorySize;<z>
= other.enableLoggingRequestDetails;<z>
registerDefaults;<z>
addAll(other.typedReaders);<z>
.addAll(other.objectReaders);<z>
;<z>
(other.objectWriters);<z>
) {<z>
;<z>
(this.notificationFilter);<z>
;<z>
nullSafeHashCode(this.mappedObjectNames);<z>
return hashCode;<z>
) {<z>
);<z>
;<z>
if (host != null) {<z>
host.trim();<z>
idx;<z>
if (host.startsWith("[")) {<z>
(']');<z>
+ rawHostHeader);<z>
;<z>
);<z>
(idx != -1) {<z>
length(), 10);<z>
;<z>
putShort(final int shortValue) {<z>
int currentLength = length;<z>
> data.length) {<z>
2);<z>
byte[] currentData = data;<z>
8);<z>
shortValue;<z>
;<z>
return this;<z>
request) {<z>
.getHeaders();<z>
getMethod() == HttpMethod.OPTIONS<z>
(HttpHeaders.ORIGIN)<z>
headers.containsKey(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD));<z>
() {<z>
= getMethod();<z>
!= null, "Method must not be null");<z>
return HttpMethod.valueOf(method);<z>
,<z>
{<z>
(classValuesAsString, nestedAnnotationsAsMap);<z>
(element).stream(annotationName)<z>
(MergedAnnotationPredicates.unique(MergedAnnotation::getMetaTypes))<z>
)<z>
::nullIfEmpty, adaptations));<z>
) {<z>
(startPos, endPos, arguments);<z>
.name = methodName;<z>
nullSafe = nullSafe;<z>
Supplier<? extends CharSequence> messageSupplier) {<z>
isDebugEnabled()) {<z>
));<z>
Object value) {<z>
(getHeader(name) == null) {<z>
(name, value);<z>
NotFound(String message, String statusText,<z>
@Nullable Charset charset) {<z>
body, charset);<z>
{<z>
wac = getWebApplicationContext();<z>
ConfigurableApplicationContext cac)) {<z>
throw new IllegalStateException("WebApplicationContext does not support refresh: " + wac);<z>
);<z>
{<z>
name = this.root + lookupName;<z>
)) {<z>
.debug("Static JNDI lookup: [" + name + "]");<z>
)) {<z>
.environment);<z>
get(name);<z>
if (found == null) {<z>
)) {<z>
"/";<z>
()) {<z>
boundName.startsWith(name)) {<z>
;<z>
NameNotFoundException(<z>
+<z>
) + "]");<z>
return found;<z>
boolean processNumberedReference() {<z>
);<z>
'x' || referenceChar == 'X');<z>
isHexNumberedReference ?<z>
2)) :<z>
(getReferenceSubstring(3), 16));<z>
;<z>
true;<z>
) {<z>
return false;<z>
, ValueExtractor valueExtractor) {<z>
];<z>
++) {<z>
i] = i;<z>
); i++) {<z>
i);<z>
;<z>
) {<z>
]] = resolved;<z>
result;<z>
AbstractListenerWriteProcessor<T> processor, Throwable ex) {<z>
COMPLETED)) {<z>
();<z>
();<z>
(ex);<z>
().onError(processor, ex);<z>
(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {<z>
();<z>
, this.methodName);<z>
method == null) {<z>
+ this.methodName);<z>
) != Type[].class) {<z>
IllegalStateException(<z>
method);<z>
= method;<z>
public ConfigurableConversionService getConversionService() {<z>
;<z>
if (cs == null) {<z>
(this) {<z>
this.conversionService;<z>
{<z>
);<z>
;<z>
return cs;<z>
) {<z>
.notNull(prefix, "No prefix given");<z>
.notNull(namespaceUri, "No namespaceUri given");<z>
.DEFAULT_NS_PREFIX.equals(prefix)) {<z>
.defaultNamespaceUri = namespaceUri;<z>
put(prefix, namespaceUri);<z>
> prefixes =<z>
));<z>
);<z>
getContentAsString() throws IllegalStateException, UnsupportedEncodingException {<z>
.characterEncoding != null,<z>
;<z>
(this.content == null) {<z>
null;<z>
.characterEncoding);<z>
value, ParserContext parserContext) {<z>
if ("on".equals(value)) {<z>
return true;<z>
("off".equals(value)) {<z>
false;<z>
();<z>
ASPECTJ_AOP_XML_RESOURCE) != null);<z>
throws URISyntaxException {<z>
);<z>
.getRequestURL();<z>
query = request.getQueryString();<z>
hasText(query)) {<z>
append(query);<z>
.toString());<z>
> decoders) {<z>
;<z>
.mutate()<z>
decoders(list -> {<z>
.clear();<z>
decoders);<z>
();<z>
loadWebAppConfigurationClass() {<z>
extends Annotation>) ClassUtils.forName(WEB_APP_CONFIGURATION_ANNOTATION_CLASS_NAME,<z>
.getClassLoader());<z>
| LinkageError ex) {<z>
throw new IllegalStateException(<z>
);<z>
PhaseEvent event) {<z>
getDelegates(event.getFacesContext())) {<z>
event);<z>
void registerBean(<z>
... customizers) {<z>
);<z>
final Object key) {<z>
()) {<z>
) {<z>
) {<z>
.evict(key);<z>
;<z>
key);<z>
MethodParameter parameter) {<z>
(parameter.getParameterType())) {<z>
();<z>
.length == 2) {<z>
1].toClass());<z>
return false;<z>
) {<z>
= true;<z>
; c++) {<z>
getChild(c);<z>
)) {<z>
) {<z>
(!inlineList.isConstant()) {<z>
= false;<z>
instanceof InlineMap inlineMap) {<z>
()) {<z>
= false;<z>
2 == 0 && child instanceof PropertyOrFieldReference)) {<z>
;<z>
if (isConstant) {<z>
>();<z>
int childCount = getChildCount();<z>
++) {<z>
(c++);<z>
= getChild(c);<z>
key = null;<z>
value = null;<z>
if (keyChild instanceof Literal literal) {<z>
;<z>
) {<z>
();<z>
instanceof Literal literal) {<z>
literal.getLiteralValue().getValue();<z>
instanceof InlineList inlineList) {<z>
.getConstantValue();<z>
{<z>
.getConstantValue();<z>
);<z>
);<z>
stream)<z>
throws ParserConfigurationException, SAXException, IOException {<z>
newInstance();<z>
true);<z>
);<z>
;<z>
.parse(stream);<z>
afterLast() throws InvalidResultSetAccessException {<z>
.resultSet.afterLast();<z>
{<z>
);<z>
request) {<z>
;<z>
) != null);<z>
(request) != null);<z>
.getMatchingCondition(request) != null);<z>
);<z>
CorsConfiguration getCorsConfiguration(ServerWebExchange exchange) {<z>
.pathWithinApplication();<z>
) {<z>
(path)) {<z>
);<z>
null;<z>
attributeValue) {<z>
);<z>
).isEmpty()) {<z>
this;<z>
attributeValue);<z>
ApplicationContext createApplicationContext() {<z>
;<z>
>[] configClasses = getConfigClasses();<z>
"No Spring configuration provided through getConfigClasses()");<z>
(configClasses);<z>
return context;<z>
, TypeDescriptor targetType) {<z>
text = (String) source;<z>
) {<z>
;<z>
Object result;<z>
;<z>
IllegalArgumentException ex) {<z>
throw ex;<z>
catch (Throwable ex) {<z>
("Parse attempt failed for value [" + text + "]", ex);<z>
));<z>
.isAssignableTo(targetType)) {<z>
(result, resultType, targetType);<z>
;<z>
{<z>
getThreadPoolExecutor();<z>
);<z>
;<z>
return future;<z>
) {<z>
;<z>
, WebSocketHandler handler) {<z>
();<z>
(<z>
contextView -> {<z>
logger.isDebugEnabled()) {<z>
.debug("Connecting to " + url);<z>
> protocols = handler.getSubProtocols();<z>
builder = createConnectionBuilder(url);<z>
(protocols, headers, builder);<z>
builder.setClientNegotiation(negotiation);<z>
addNotifier(<z>
, Object>() {<z>
(WebSocketChannel channel, Object attachment) {<z>
, contextView),<z>
;<z>
Object attachment) {<z>
completion.tryEmitError(<z>
));<z>
;<z>
.asMono();<z>
);<z>
brokerChannel,<z>
{<z>
);<z>
brokerChannel);<z>
.class, cargs, null);<z>
.hasAttribute("user-destination-prefix")) {<z>
;<z>
messageConverter);<z>
MESSAGING_TEMPLATE_BEAN_NAME;<z>
, context, source);<z>
RuntimeBeanReference(name);<z>
<MimeType> mimeTypes) {<z>
<>(mimeTypes.size());<z>
mimeType : mimeTypes) {<z>
add(MediaType.asMediaType(mimeType));<z>
return mediaTypes;<z>
{<z>
null) {<z>
logger.isInfoEnabled()) {<z>
instanceof SimpleDriverDataSource) {<z>
.format("Shutting down embedded database: url='%s'",<z>
);<z>
);<z>
.databaseConfigurer != null) {<z>
);<z>
dataSource = null;<z>
) {<z>
.initialize(mappedClass);<z>
mappedClass);<z>
();<z>
{<z>
;<z>
String name : this.constructorParameterNames) {<z>
name);<z>
constructorParameterTypes = new TypeDescriptor[paramCount];<z>
{<z>
));<z>
V> callable) {<z>
);<z>
.notNull(executorName, "Executor name must not be null");<z>
= executorName;<z>
timeout;<z>
, BeanDefinitionBuilder builder) {<z>
.doParse(element, parserContext, builder);<z>
defaultValue = element.getAttribute(DEFAULT_VALUE);<z>
element.getAttribute(DEFAULT_REF);<z>
StringUtils.hasLength(defaultValue)) {<z>
if (StringUtils.hasLength(defaultRef)) {<z>
).error("<jndi-lookup> element is only allowed to contain either " +<z>
element);<z>
addPropertyValue(DEFAULT_OBJECT, defaultValue);<z>
(defaultRef)) {<z>
));<z>
Nullable Object value) {<z>
;<z>
name, "Attribute name must not be null");<z>
value != null) {<z>
;<z>
);<z>
, @Nullable HttpHeaders responseHeaders,<z>
{<z>
,<z>
statusText, responseHeaders, responseBody, responseCharset);<z>
) {<z>
.notNull(resultHandler, "DeferredResultHandler is required");<z>
) {<z>
resultToHandle;<z>
{<z>
) {<z>
= this.result;<z>
RESULT_NONE) {<z>
= resultHandler;<z>
resultToHandle);<z>
) {<z>
.debug("Failed to process async result", ex);<z>
, String name) {<z>
name);<z>
instanceof String[] values) {<z>
0] : null);<z>
value != null) {<z>
value.toString();<z>
name + "_";<z>
parameters.keySet()) {<z>
) {<z>
) {<z>
(paramName.endsWith(suffix)) {<z>
;<z>
(prefix.length());<z>
null;<z>
HttpMessage message) {<z>
getContentType();<z>
null) {<z>
"boundary");<z>
(boundary != null) {<z>
length();<z>
) {<z>
(1, len - 1);<z>
return boundary.getBytes(this.headersCharset);<z>
;<z>
, Object property) throws ELException {<z>
(base == null) {<z>
;<z>
;<z>
(beanName)) {<z>
true);<z>
wac.getType(beanName);<z>
;<z>
propertyNames) {<z>
) {<z>
null;<z>
;<z>
.length; i++) {<z>
]);<z>
return result;<z>
TransactionSynchronizationManager synchronizationManager,<z>
Nullable Object transaction, Object suspendedResources) throws TransactionException {<z>
new TransactionSuspensionNotSupportedException(<z>
).getName() + "] does not support transaction suspension");<z>
{<z>
null) {<z>
.getMessageOrBuilder();<z>
else {<z>
return blah_;<z>
afterMessageHandled(<z>
) {<z>
task = getNextMessageTask(message);<z>
{<z>
);<z>
resource) {<z>
{<z>
.emptyList();<z>
;<z>
HttpRange range : ranges) {<z>
resource));<z>
1) {<z>
resource);<z>
= 0;<z>
: regions) {<z>
.getCount();<z>
{<z>
+<z>
;<z>
;<z>
registerEndpoint(Class<?> endpointClass) {<z>
ServerContainer serverContainer = getServerContainer();<z>
serverContainer != null,<z>
"i.e. after the ServletContext has been fully initialized?");<z>
(logger.isDebugEnabled()) {<z>
;<z>
endpointClass);<z>
) {<z>
("Failed to register @ServerEndpoint class: " + endpointClass, ex);<z>
DataAccessException {<z>
validateNamedParameters(paramMap);<z>
);<z>
= new MapSqlParameterSource(paramMap);<z>
= NamedParameterUtils.substituteNamedParameters(parsedSql, paramSource);<z>
parsedSql, paramSource, getDeclaredParameters());<z>
, context);<z>
, rowMapper);<z>
ExceptionHandlerExceptionResolver() {<z>
();<z>
.add(new ByteArrayHttpMessageConverter());<z>
StringHttpMessageConverter());<z>
{<z>
;<z>
catch (Error err) {<z>
AllEncompassingFormHttpMessageConverter());<z>
originalBeanName(String name) {<z>
.notNull(name, "'name' must not be null");<z>
= name.indexOf(GENERATED_BEAN_NAME_SEPARATOR);<z>
: name);<z>
cf,<z>
synchedLocalTransactionAllowed)<z>
throws JMSException {<z>
doGetTransactionalSession(cf, new ResourceFactory() {<z>
public Session getSession(JmsResourceHolder holder) {<z>
, existingCon);<z>
) {<z>
existingCon : holder.getConnection());<z>
() throws JMSException {<z>
);<z>
) throws JMSException {<z>
synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE);<z>
{<z>
;<z>
;<z>
public void discard() {<z>
if (this.output != null) {<z>
.output);<z>
jakarta.servlet.http.Cookie cookie) {<z>
expires = null;<z>
1) {<z>
* 1000);<z>
(), cookie.getValue());<z>
;<z>
());<z>
.setExpiryDate(expires);<z>
setPath(cookie.getPath());<z>
(cookie.getSecure());<z>
.isHttpOnly()) {<z>
;<z>
);<z>
synchronized Object newPrototypeInstance() {<z>
());<z>
freshTargetSource();<z>
(this, targetSource, freshAdvisorChain());<z>
)) {<z>
= targetSource.getTargetClass();<z>
!= null) {<z>
));<z>
);<z>
createAopProxy());<z>
public FilteredRouterFunction(<z>
,<z>
, S> filterFunction) {<z>
= routerFunction;<z>
= filterFunction;<z>
{<z>
);<z>
map(connectionToUse -> {<z>
(connection == null) {<z>
null, connectionToUse);<z>
.connection =<z>
) : connectionToUse);<z>
return this.connection;<z>
this::prepareConnection);<z>
() {<z>
;<z>
for (ServletWebSocketHandlerRegistration registration : this.registrations) {<z>
);<z>
, patterns) -> {<z>
{<z>
(pattern, httpHandler);<z>
);<z>
WebSocketHandlerMapping hm = new WebSocketHandlerMapping();<z>
hm.setUrlMap(urlMap);<z>
(this.order);<z>
!= null) {<z>
urlPathHelper);<z>
;<z>
{<z>
(PropertyAccessor.PROPERTY_KEY_SUFFIX) ?<z>
(PropertyAccessor.PROPERTY_KEY_PREFIX_CHAR) : -1);<z>
, separatorIndex) : propertyPath);<z>
obj) {<z>
super.findOrder(obj);<z>
order != null) {<z>
order;<z>
);<z>
public MappingJackson2XmlHttpMessageConverter(ObjectMapper objectMapper) {<z>
("application", "xml", StandardCharsets.UTF_8),<z>
"xml", StandardCharsets.UTF_8),<z>
);<z>
, "XmlMapper required");<z>
,<z>
, String aspectName) {<z>
aspectInstanceFactory.getAspectMetadata().getAspectClass();<z>
candidateAspectClass);<z>
?> aspectJAnnotation =<z>
AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);<z>
) {<z>
return null;<z>
!isAspect(candidateAspectClass)) {<z>
+<z>
"' in class [" +<z>
) + "]");<z>
.isDebugEnabled()) {<z>
candidateAdviceMethod);<z>
springAdvice;<z>
{<z>
AtPointcut:<z>
)) {<z>
;<z>
;<z>
AtAround:<z>
= new AspectJAroundAdvice(<z>
, aspectInstanceFactory);<z>
case AtBefore:<z>
new AspectJMethodBeforeAdvice(<z>
);<z>
case AtAfter:<z>
= new AspectJAfterAdvice(<z>
aspectInstanceFactory);<z>
case AtAfterReturning:<z>
springAdvice = new AspectJAfterReturningAdvice(<z>
candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);<z>
);<z>
afterReturningAnnotation.returning())) {<z>
afterReturningAnnotation.returning());<z>
case AtAfterThrowing:<z>
= new AspectJAfterThrowingAdvice(<z>
, expressionPointcut, aspectInstanceFactory);<z>
.getAnnotation();<z>
))) {<z>
afterThrowingAnnotation.throwing());<z>
UnsupportedOperationException(<z>
candidateAdviceMethod);<z>
(aspectName);<z>
.setDeclarationOrder(declarationOrder);<z>
);<z>
null) {<z>
setArgumentNamesFromStringArray(argNames);<z>
calculateArgumentBindings();<z>
springAdvice;<z>
(UserTransaction userTransaction) {<z>
this();<z>
"UserTransaction must not be null");<z>
userTransaction = userTransaction;<z>
() {<z>
if (this.attributeSource == null) {<z>
);<z>
{<z>
, "'locales' must not be empty");<z>
;<z>
return this;<z>
ordered) {<z>
this.descriptor, ordered);<z>
, null);<z>
(result));<z>
, @Nullable Class<T> type) {<z>
{<z>
;<z>
= null;<z>
) {<z>
element)) {<z>
) {<z>
;<z>
element;<z>
return value;<z>
ClassLoader getAspectClassLoader() {<z>
if (this.beanFactory instanceof ConfigurableBeanFactory) {<z>
getBeanClassLoader();<z>
return ClassUtils.getDefaultClassLoader();<z>
ClientHttpResponse intercept(<z>
execution) throws IOException {<z>
HttpHeaders headers = request.getHeaders();<z>
{<z>
;<z>
return execution.execute(request, body);<z>
String[] headers) {<z>
= parseExpressions(consumes, headers);<z>
> 1) {<z>
.expressions);<z>
lastModifiedTimestamp) {<z>
(lastModifiedTimestamp < 0) {<z>
false;<z>
ifModifiedSince = parseDateHeader(HttpHeaders.IF_MODIFIED_SINCE);<z>
1) {<z>
false;<z>
1000 * 1000);<z>
true;<z>
RequestEntity<?> entity) {<z>
if (entity instanceof RequestEntity.UriTemplateRequestEntity) {<z>
>) entity;<z>
.getVars() != null) {<z>
(), ext.getVars());<z>
{<z>
(), ext.getVarsMap());<z>
"No variables specified for URI template: " + ext.getUriTemplate());<z>
();<z>
] annotations) {<z>
) {<z>
annotationFilter.matches(annotation)) {<z>
.findRepeatedAnnotations(annotation);<z>
if (repeatedAnnotations != null) {<z>
);<z>
annotation);<z>
Nullable long[] heartbeat) {<z>
null || heartbeat.length != 2) {<z>
IllegalArgumentException("Heart-beat array must be of length 2, not " +<z>
heartbeat.length : "null"));<z>
"," + heartbeat[1];<z>
) {<z>
("Heart-beat values cannot be negative: " + value);<z>
HEARTBEAT, value);<z>
statusCode, String statusText,<z>
] responseBody, @Nullable Charset responseCharset) {<z>
;<z>
this.rawStatusCode = statusCode;<z>
= statusText;<z>
responseHeaders;<z>
new byte[0]);<z>
);<z>
) {<z>
0;<z>
) {<z>
), position);<z>
-1) {<z>
();<z>
))) {<z>
++;<z>
charAt(position) == '\'') {<z>
;<z>
) == '"') {<z>
(position, '"', content, result);<z>
extractUnquotedLink(position, content, result);<z>
DataBuffer dataBuffer) throws IOException {<z>
= dataBuffer.asByteBuffer();<z>
.remaining();<z>
();<z>
input);<z>
return len;<z>
?> expectedMap) {<z>
size());<z>
::add);<z>
);<z>
name) {<z>
name == null) {<z>
null;<z>
trim().toUpperCase());<z>
IllegalArgumentException ex) {<z>
EnclosingConfiguration.class);<z>
{<z>
(<z>
, ex.getMessage()));<z>
null;<z>
public static void registerAutoProxyCreatorIfNecessary(<z>
) {<z>
(<z>
extractSource(sourceElement));<z>
;<z>
beanDefinition, parserContext);<z>
) {<z>
null) {<z>
getType().equalsIgnoreCase("multipart");<z>
> values : map.values()) {<z>
{<z>
value instanceof String)) {<z>
;<z>
;<z>
metaDataSchemaNameToUse(@Nullable String schemaName) {<z>
)) {<z>
(schemaName);<z>
null;<z>
String propertyName) {<z>
, getRootClass());<z>
) + propertyName,<z>
;<z>
) {<z>
= new ArrayList<>();<z>
i++) {<z>
.clear();<z>
attributes.get(i));<z>
(aliases);<z>
() > 1) {<z>
aliases);<z>
String getFilename(Object part) {<z>
part instanceof Resource resource) {<z>
getFilename();<z>
&& this.multipartCharset != null) {<z>
.multipartCharset.name());<z>
return filename;<z>
null;<z>
TagWriter tagWriter) throws JspException {<z>
.tagWriter = tagWriter;<z>
startTag(FORM_TAG);<z>
tagWriter);<z>
resolveAction());<z>
(tagWriter, METHOD_ATTRIBUTE, getHttpMethod());<z>
(tagWriter, TARGET_ATTRIBUTE, getTarget());<z>
));<z>
);<z>
);<z>
getOnreset());<z>
, getAutocomplete());<z>
tagWriter.forceBlock();<z>
getMethod())) {<z>
(getMethod());<z>
inputName = getMethodParam();<z>
= "hidden";<z>
startTag(INPUT_TAG);<z>
inputType);<z>
(tagWriter, NAME_ATTRIBUTE, inputName);<z>
));<z>
endTag();<z>
modelAttribute = resolveModelAttribute();<z>
.REQUEST_SCOPE);<z>
previousNestedPath =<z>
PageContext.REQUEST_SCOPE);<z>
NESTED_PATH_VARIABLE_NAME,<z>
, PageContext.REQUEST_SCOPE);<z>
return EVAL_BODY_INCLUDE;<z>
public static MediaType asMediaType(MimeType mimeType) {<z>
MediaType mediaType) {<z>
return mediaType;<z>
));<z>
T> Map<String, T> qualifiedBeansOfType(<z>
beanType, String qualifier) throws BeansException {<z>
BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, beanType);<z>
;<z>
for (String beanName : candidateBeans) {<z>
::equals, beanName, beanFactory)) {<z>
getBean(beanName, beanType));<z>
;<z>
{<z>
(message == null) {<z>
;<z>
) getJmsMessageConverter().fromMessage(message);<z>
) {<z>
+ "'", ex);<z>
NativeWebRequest request) throws Exception {<z>
binderMethod : this.binderMethods) {<z>
binderMethod, dataBinder)) {<z>
null, dataBinder);<z>
!= null) {<z>
IllegalStateException(<z>
binderMethod);<z>
intervalTaskReference(String runnableBeanName,<z>
ParserContext parserContext) {<z>
genericBeanDefinition(<z>
);<z>
;<z>
interval);<z>
: ZERO_INITIAL_DELAY);<z>
builder);<z>
void setMessageTypeIfNotSet(SimpMessageType messageType) {<z>
if (getMessageType() == null) {<z>
, messageType);<z>
Mono<Resource> apply(ServerRequest request) {<z>
.requestPath().pathWithinApplication();<z>
.pattern.matches(pathContainer)) {<z>
return Mono.empty();<z>
extractPathWithinPattern(pathContainer);<z>
(pathContainer.value());<z>
(path.contains("%")) {<z>
path, StandardCharsets.UTF_8);<z>
(path) || isInvalidPath(path)) {<z>
;<z>
= this.location.createRelative(path);<z>
isResourceUnderLocation(resource)) {<z>
Mono.just(resource);<z>
();<z>
(IOException ex) {<z>
(ex);<z>
StompBrokerRelayMessageHandler getMessageHandler(SubscribableChannel brokerChannel) {<z>
StompBrokerRelayMessageHandler(<z>
getClientInboundChannel(), getClientOutboundChannel(),<z>
, getDestinationPrefixes());<z>
(this.relayHost);<z>
setRelayPort(this.relayPort);<z>
;<z>
.clientPasscode);<z>
systemLogin);<z>
;<z>
.systemHeartbeatSendInterval != null) {<z>
(this.systemHeartbeatSendInterval);<z>
) {<z>
handler.setSystemHeartbeatReceiveInterval(this.systemHeartbeatReceiveInterval);<z>
this.virtualHost != null) {<z>
handler.setVirtualHost(this.virtualHost);<z>
!= null) {<z>
this.tcpClient);<z>
null) {<z>
setTaskScheduler(this.taskScheduler);<z>
);<z>
handler;<z>
parameterNameDiscoverer) {<z>
this.methodParameter != null) {<z>
(parameterNameDiscoverer);<z>
> requiredType, PropertyEditor propertyEditor) {<z>
== null) {<z>
new HashMap<>();<z>
.overriddenDefaultEditors.put(requiredType, propertyEditor);<z>
boolean exists() {<z>
getURL();<z>
(ResourceUtils.isFileURL(url)) {<z>
exists();<z>
= url.openConnection();<z>
);<z>
=<z>
? (HttpURLConnection) con : null);<z>
{<z>
code = httpCon.getResponseCode();<z>
== HttpURLConnection.HTTP_OK) {<z>
return true;<z>
) {<z>
false;<z>
getContentLengthLong() > 0) {<z>
true;<z>
(httpCon != null) {<z>
.disconnect();<z>
;<z>
);<z>
return true;<z>
IOException ex) {<z>
return false;<z>
SockJsFrame frame) throws IOException {<z>
()) {<z>
.frameFormat;<z>
response;<z>
&& response != null) {<z>
String formattedFrame = frameFormat.format(frame);<z>
()) {<z>
trace("Writing to HTTP response: " + formattedFrame);<z>
formattedFrame.getBytes(SockJsFrame.CHARSET));<z>
flush();<z>
Annotation> MergedAnnotation<A> findMergedAnnotationOnBean(<z>
A> annotationType, boolean allowFactoryBeanInit) {<z>
);<z>
null) {<z>
MergedAnnotation<A> annotation =<z>
SearchStrategy.TYPE_HIERARCHY).get(annotationType);<z>
annotation.isPresent()) {<z>
return annotation;<z>
)) {<z>
beanName);<z>
hasBeanClass()) {<z>
();<z>
) {<z>
> annotation =<z>
TYPE_HIERARCHY).get(annotationType);<z>
) {<z>
;<z>
);<z>
(factoryMethod != null) {<z>
MergedAnnotation<A> annotation =<z>
;<z>
(annotation.isPresent()) {<z>
;<z>
missing();<z>
(Object webSocket, boolean isProtected) {<z>
, isProtected);<z>
(Exception ex) {<z>
HandshakeFailureException("Failed to create TyrusServletWriter", ex);<z>
String name) throws NamingException {<z>
) {<z>
"Looking up JNDI object with name [" + name + "]");<z>
ctx -> ctx.lookup(name));<z>
== null) {<z>
new NameNotFoundException(<z>
;<z>
result;<z>
, Map<String, ?> params) {<z>
String url = getContextPath() + relativeUrl;<z>
().toASCIIString();<z>
(this.response != null) {<z>
url);<z>
;<z>
createContainerManagedEntityManager(<z>
synchronizedWithTransaction) {<z>
.notNull(emf, "EntityManagerFactory must not be null");<z>
emfInfo) {<z>
);<z>
rawEntityManager, emfInfo, true, synchronizedWithTransaction);<z>
(properties) ?<z>
: emf.createEntityManager());<z>
, null, null, true, synchronizedWithTransaction);<z>
String name, MethodParameter parameter, NativeWebRequest request)<z>
Exception {<z>
(name, parameter);<z>
prepareConnection(Connection con) throws JMSException {<z>
) {<z>
.setClientID(getClientId());<z>
this.aggregatedExceptionListener != null) {<z>
con.setExceptionListener(this.aggregatedExceptionListener);<z>
isReconnectOnException()) {<z>
listenerToUse = getExceptionListener();<z>
()) {<z>
.aggregatedExceptionListener = new AggregatedExceptionListener();<z>
.aggregatedExceptionListener.delegates.add(this);<z>
null) {<z>
.delegates.add(listenerToUse);<z>
this.aggregatedExceptionListener;<z>
);<z>
String> resolveSessionIds(ServerWebExchange exchange) {<z>
.getRequest().getCookies();<z>
);<z>
null) {<z>
();<z>
;<z>
DataBuffer decode(DataBuffer buffer, ResolvableType elementType,<z>
) {<z>
()) {<z>
) + " bytes");<z>
buffer;<z>
(SqlParameter... sqlParameters) {<z>
SqlParameter sqlParameter : sqlParameters) {<z>
null) {<z>
);<z>
;<z>
() {<z>
= new StringBuilder("SimpleMailMessage: ");<z>
.append("; ");<z>
.append("; ");<z>
.append("; ");<z>
cc)).append("; ");<z>
);<z>
append("; ");<z>
);<z>
append(this.text);<z>
toString();<z>
T data) {<z>
data);<z>
.cancel();<z>
"Illegal onNext without demand"));<z>
String escapeSockJsSpecialChars(char[] characters) {<z>
);<z>
for (char c : characters) {<z>
(c)) {<z>
;<z>
(c).toLowerCase();<z>
.length()); i++) {<z>
('0');<z>
(hex);<z>
.append(c);<z>
toString();<z>
{<z>
>();<z>
)) {<z>
().values());<z>
());<z>
return result;<z>
dependencyConsumer) throws BeansException {<z>
= getIfAvailable();<z>
) {<z>
dependencyConsumer.accept(dependency);<z>
?> getTargetType() {<z>
Object targetTypeValue = this.targetType;<z>
)) {<z>
("Typed String value does not carry a resolved target type");<z>
?>) targetTypeValue;<z>
(<z>
name,<z>
final String descriptor,<z>
Handle bootstrapMethodHandle,<z>
... bootstrapMethodArguments) {<z>
, bootstrapMethodArguments);<z>
return addConstantDynamicOrInvokeDynamicReference(<z>
, bootstrapMethod.index);<z>
() {<z>
aspectOf();<z>
, this.cacheResolver, this.cacheManager);<z>
return cacheAspect;<z>
method, URI uri,<z>
Void>> requestCallback) {<z>
;<z>
return this.httpClient<z>
method.name()))<z>
())<z>
outbound)))<z>
, connection) -> {<z>
, connection));<z>
));<z>
()<z>
{<z>
responseRef.get();<z>
response != null) {<z>
response.releaseAfterCancel(method);<z>
);<z>
void doCleanupAfterCompletion(Object transaction) {<z>
JmsTransactionObject) transaction;<z>
unbindResource(obtainConnectionFactory());<z>
();<z>
clear();<z>
A extends Annotation> Set<A> getMergedRepeatableAnnotations(<z>
, Class<A> annotationType) {<z>
(element, annotationType, null);<z>
() {<z>
;<z>
{<z>
));<z>
;<z>
run() {<z>
.currentTimeMillis();<z>
: sessions.values()) {<z>
)) {<z>
;<z>
()) {<z>
create(SimpMessageType.HEARTBEAT);<z>
());<z>
getUser();<z>
user != null) {<z>
user);<z>
;<z>
.setLeaveMutable(true);<z>
);<z>
;<z>
{<z>
= request.getMethod();<z>
= request.getURI();<z>
" " + uri + " [DefaultWebClient]";<z>
);<z>
, Blackhole bh) {<z>
String path : data.requestPaths) {<z>
;<z>
pattern : data.patterns) {<z>
, path)) {<z>
);<z>
(path));<z>
;<z>
(Element valueEle) {<z>
notNull(valueEle, "Element must not be null");<z>
= new StringBuilder();<z>
NodeList nl = valueEle.getChildNodes();<z>
; i++) {<z>
nl.item(i);<z>
) {<z>
(item.getNodeValue());<z>
return sb.toString();<z>
private void addConventionAnnotationValues() {<z>
); i++) {<z>
;<z>
.getName());<z>
this;<z>
> 0) {<z>
attribute.getName());<z>
)) {<z>
.annotationValueMappings[i] = mapped;<z>
.annotationValueSource[i] = mapping;<z>
= mapping.source;<z>
{<z>
.sessionFuture.setException(ex);<z>
.sessionHandler.handleTransportError(this, ex);<z>
(Throwable ex2) {<z>
if (logger.isDebugEnabled()) {<z>
, ex2);<z>
) {<z>
null) {<z>
.defaultCookies.size());<z>
new ArrayList<>(values)));<z>
copy);<z>
null;<z>
type, Writer writer) throws Exception {<z>
(type instanceof ParameterizedType) {<z>
, type, writer);<z>
).toJson(object, writer);<z>
(ResultSet rs, int rownum) throws SQLException {<z>
;<z>
[0]));<z>
(COLUMN_NAMES[1]));<z>
return cust;<z>
transform(ServerWebExchange exchange, Resource resource,<z>
transformerChain) {<z>
(resource, Resource.class);<z>
null) {<z>
()) {<z>
getLogPrefix() + "Resource resolved from cache");<z>
return Mono.just(cachedResource);<z>
resource)<z>
.put(resource, transformed));<z>
,<z>
> hints) {<z>
.maxMessageSize)<z>
));<z>
public int hashCode() {<z>
OBJECT : sort);<z>
{<z>
i++) {<z>
hashCode + valueBuffer.charAt(i));<z>
;<z>
public AspectJMethodBeforeAdvice(<z>
AspectJExpressionPointcut pointcut, AspectInstanceFactory aif) {<z>
(aspectJBeforeAdviceMethod, pointcut, aif);<z>
environment, ResourceLoader resourceLoader,<z>
BeanNameGenerator beanNameGenerator, BeanDefinitionRegistry registry) {<z>
environment;<z>
resourceLoader = resourceLoader;<z>
;<z>
registry = registry;<z>
{<z>
NONE) {<z>
;<z>
ResolvableType[] generics = getGenerics();<z>
{<z>
.isWildcardWithoutBounds()) {<z>
return true;<z>
;<z>
(resolved != null) {<z>
{<z>
genericInterface instanceof Class) {<z>
.hasGenerics()) {<z>
;<z>
ex) {<z>
).hasUnresolvableGenerics();<z>
false;<z>
public boolean needsReload(<z>
loader, ResourceBundle bundle, long loadTime) {<z>
{<z>
bundle);<z>
return true;<z>
false;<z>
{<z>
(logger.isDebugEnabled()) {<z>
" with: " + values);<z>
GeneratedKeyHolder();<z>
)) {<z>
update(<z>
con -> {<z>
PreparedStatement ps = prepareStatementForGeneratedKeys(con);<z>
, values, getInsertTypes());<z>
;<z>
);<z>
.tableMetaDataContext.isGetGeneratedKeysSimulated()) {<z>
throw new InvalidDataAccessResourceUsageException(<z>
);<z>
.length < 1) {<z>
throw new InvalidDataAccessApiUsageException("Generated Key Name(s) not specified. " +<z>
"Using the generated keys features requires specifying the name(s) of the generated column(s)");<z>
) {<z>
throw new InvalidDataAccessApiUsageException(<z>
(getGeneratedKeyNames()));<z>
);<z>
final String keyQuery = this.tableMetaDataContext.getSimpleQueryForGetGeneratedKey(<z>
getGeneratedKeyNames()[0]);<z>
, "Query for simulating get generated keys must not be null");<z>
) {<z>
= getJdbcTemplate().queryForObject(<z>
;<z>
>(2);<z>
);<z>
(keys);<z>
(ConnectionCallback<Object>) con -> {<z>
;<z>
con.prepareStatement(getInsertString());<z>
));<z>
();<z>
ps);<z>
null;<z>
ResultSet rs = null;<z>
con.createStatement();<z>
keyStmt.executeQuery(keyQuery);<z>
()) {<z>
= rs.getLong(1);<z>
HashMap<>(2);<z>
);<z>
().add(keys);<z>
JdbcUtils.closeResultSet(rs);<z>
(keyStmt);<z>
;<z>
});<z>
return keyHolder;<z>
) {<z>
isEmpty(this.arguments)) {<z>
);<z>
: this.method.getParameterCount());<z>
.length;<z>
0; i < paramCount; i++) {<z>
Object value = null;<z>
> paramCount && i == paramCount - 1) {<z>
.arguments, i, argsCount);<z>
i) {<z>
this.arguments[i];<z>
("a" + i, value);<z>
+ i, value);<z>
i] != null) {<z>
[i], value);<z>
serverState) {<z>
incrementAndGet();<z>
) {<z>
0];<z>
[uniqueNumber % serverState.destinationIds.length];<z>
)) {<z>
.session = serverState.sessionIds[0];<z>
.sessionIds.length];<z>
valueOf(uniqueNumber);<z>
(serverState.specialization) ?<z>
"/**/" + this.findDestination : this.findDestination;<z>
, subscribeDestination);<z>
session, subscription);<z>
info, Method method) {<z>
);<z>
)) {<z>
Parameter parameter : method.getParameters()) {<z>
get(RequestBody.class);<z>
) {<z>
.getBoolean("required"));<z>
> getFiles(String name) {<z>
this.multipartFiles.get(name);<z>
if (multipartFiles != null) {<z>
multipartFiles;<z>
);<z>
Nullable Context ctx) {<z>
ctx != null) {<z>
.close();<z>
{<z>
;<z>
] args, @Nullable Locale locale) {<z>
== null) {<z>
;<z>
== null) {<z>
);<z>
args;<z>
ObjectUtils.isEmpty(args)) {<z>
locale);<z>
) {<z>
;<z>
(args, locale);<z>
resolveCode(code, locale);<z>
{<z>
{<z>
format(argsToUse);<z>
;<z>
null) {<z>
;<z>
{<z>
return formatMessage(commonMessage, args, locale);<z>
return getMessageFromParent(code, argsToUse, locale);<z>
String toString() {<z>
= new StringBuilder("CacheInvocationContext{");<z>
);<z>
this.target);<z>
toString(this.args));<z>
toString(this.allParameters));<z>
'}');<z>
);<z>
public Builder localAddress(InetSocketAddress localAddress) {<z>
;<z>
localAddress;<z>
;<z>
httpRequest) throws IOException {<z>
httpRequest);<z>
);<z>
) {<z>
HttpHeaders httpHeaders = httpRequest.getHeaders();<z>
.getHeaders();<z>
!requestHeaders.isEmpty()) {<z>
));<z>
() < 0) {<z>
.setContentLength(0L);<z>
;<z>
(this.requestEntity instanceof RequestEntity ?<z>
;<z>
httpRequest.getHeaders();<z>
= this.requestEntity.getHeaders();<z>
= requestHeaders.getContentType();<z>
messageConverter : getMessageConverters()) {<z>
) {<z>
> genericConverter =<z>
) messageConverter;<z>
)) {<z>
.isEmpty()) {<z>
<>(values)));<z>
, requestContentType, genericConverter);<z>
requestBodyType, requestContentType, httpRequest);<z>
canWrite(requestBodyClass, requestContentType)) {<z>
requestHeaders.isEmpty()) {<z>
));<z>
requestContentType, messageConverter);<z>
write(<z>
httpRequest);<z>
message = "No HttpMessageConverter for " + requestBodyClass.getName();<z>
{<z>
"\"";<z>
RestClientException(message);<z>
{<z>
= returnType.getMethodAnnotation(ModelAttribute.class);<z>
.value())) {<z>
ann.value();<z>
getMethod();<z>
;<z>
getContainingClass();<z>
.resolveReturnType(method, containingClass);<z>
resolvedType, returnValue);<z>
) {<z>
== NONE) {<z>
;<z>
generics = this.generics;<z>
== null) {<z>
{<z>
type).getTypeParameters();<z>
length];<z>
{<z>
);<z>
(this.type instanceof ParameterizedType) {<z>
type).getActualTypeArguments();<z>
;<z>
{<z>
i], this.variableResolver);<z>
().getGenerics();<z>
this.generics = generics;<z>
generics;<z>
,<z>
ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {<z>
(returnValue == null) {<z>
.setRequestHandled(true);<z>
<?>) returnValue;<z>
{<z>
);<z>
.startCallableProcessing(webAsyncTask, mavContainer);<z>
Map<String, T> beansOfTypeIncludingAncestors(<z>
boolean includeNonSingletons, boolean allowEagerInit)<z>
BeansException {<z>
, "ListableBeanFactory must not be null");<z>
new LinkedHashMap<>(4);<z>
);<z>
instanceof HierarchicalBeanFactory hbf) {<z>
) instanceof ListableBeanFactory) {<z>
parentResult = beansOfTypeIncludingAncestors(<z>
, type, includeNonSingletons, allowEagerInit);<z>
-> {<z>
!hbf.containsLocalBean(beanName)) {<z>
put(beanName, beanInstance);<z>
);<z>
result;<z>
) throws IOException, ClassNotFoundException {<z>
inputStream.defaultReadObject();<z>
!= null) {<z>
= new MethodParameter(<z>
.parameterIndex);<z>
MethodParameter(<z>
, this.parameterIndex);<z>
Throwable ex) {<z>
IllegalStateException("Could not find original class structure", ex);<z>
call() throws Exception {<z>
.call();<z>
) {<z>
this.errorHandler.handleError(ex);<z>
return null;<z>
) throws ObjectStreamException {<z>
this.beanName != null) {<z>
beanFactory, this.beanName);<z>
;<z>
(MvcResult mvcResult) {<z>
MockMvcServerClientHttpResponse(mvcResult);<z>
mvcResult.getResponse();<z>
header : servletResponse.getHeaderNames()) {<z>
servletResponse.getHeaders(header)) {<z>
add(header, value);<z>
(servletResponse.getForwardedUrl() != null) {<z>
);<z>
()) {<z>
=<z>
, cookie.getValue())<z>
()))<z>
.domain(cookie.getDomain())<z>
getPath())<z>
())<z>
cookie.isHttpOnly())<z>
build();<z>
(), httpCookie);<z>
);<z>
sharedInstance.wrap(bytes);<z>
.just(dataBuffer));<z>
;<z>
String> pathVariables() {<z>
"unchecked")<z>
<String, String>) attributes()<z>
URI_TEMPLATE_VARIABLES_ATTRIBUTE);<z>
!= null) {<z>
pathVariables;<z>
emptyMap();<z>
message, String statusText,<z>
) {<z>
statusText, headers, body, charset);<z>
protected HandlerMethod handleNoMatch(Set<RequestMappingInfo> infos,<z>
) throws Exception {<z>
, exchange);<z>
isEmpty()) {<z>
null;<z>
exchange.getRequest();<z>
if (helper.hasMethodsMismatch()) {<z>
);<z>
= helper.getAllowedMethods();<z>
httpMethod)) {<z>
getConsumablePatchMediaTypes();<z>
handler = new HttpOptionsHandler(methods, mediaTypes);<z>
return new HandlerMethod(handler, HTTP_OPTIONS_HANDLE_METHOD);<z>
;<z>
)) {<z>
helper.getConsumableMediaTypes();<z>
MediaType contentType;<z>
.getContentType();<z>
ex) {<z>
.getMessage());<z>
getMethod());<z>
{<z>
.getProducibleMediaTypes();<z>
ArrayList<>(mediaTypes));<z>
{<z>
ServerWebInputException(<z>
"Unsatisfied query parameter conditions: " + helper.getParamConditions() +<z>
;<z>
return null;<z>
,String> parameters) {<z>
{<z>
();<z>
key, value);<z>
) {<z>
this.extractedMatrixVariables == null) {<z>
>();<z>
unmodifiableMultiValueMap(parameters));<z>
BindMarkersFactory getBindMarkers(ConnectionFactory connectionFactory) {<z>
.getMetadata();<z>
metadata.getName());<z>
if (r2dbcDialect != null) {<z>
return r2dbcDialect;<z>
)) {<z>
().contains(it)) {<z>
get(it);<z>
;<z>
private void setupJmsListenerContainer(AbstractMessageListenerContainer listenerContainer) {<z>
(getId())) {<z>
;<z>
getDestination() != null) {<z>
;<z>
{<z>
;<z>
) {<z>
());<z>
) != null) {<z>
);<z>
;<z>
readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {<z>
);<z>
resetAdviceMonitor();<z>
char[] charBuffer) {<z>
int currentOffset = utfOffset;<z>
;<z>
= 0;<z>
[] classBuffer = classFileBuffer;<z>
currentOffset < endOffset) {<z>
];<z>
((currentByte & 0x80) == 0) {<z>
currentByte & 0x7F);<z>
currentByte & 0xE0) == 0xC0) {<z>
] =<z>
));<z>
else {<z>
[strLength++] =<z>
(char)<z>
) << 12)<z>
& 0x3F) << 6)<z>
] & 0x3F));<z>
0, strLength);<z>
> linksToAdd) {<z>
start = index + 1;<z>
endKey, start);<z>
(new ContentChunkInfo(start, end));<z>
);<z>
message) {<z>
|| this.logger.isWarnEnabled()) {<z>
);<z>
refreshDestination() {<z>
();<z>
destName != null) {<z>
;<z>
destResolver instanceof CachingDestinationResolver) {<z>
(destName);<z>
> getMimeTypes(ResolvableType elementType) {<z>
;<z>
<MimeType> result = null;<z>
().entrySet()) {<z>
getKey().isAssignableFrom(elementClass)) {<z>
);<z>
keySet());<z>
);<z>
getNextIfNecessary() {<z>
null) {<z>
();<z>
reference == null) {<z>
.get();<z>
@Nullable Class<?> superType) {<z>
null) {<z>
null;<z>
);<z>
getAnnotations());<z>
request, @Nullable Object handler) {<z>
handler == null) {<z>
null);<z>
) {<z>
;<z>
request, handler);<z>
()) {<z>
request, handler);<z>
;<z>
(WebsocketInbound inbound) {<z>
HttpHeaders();<z>
nettyHeaders = inbound.headers();<z>
entry -> {<z>
getKey();<z>
getAll(name));<z>
;<z>
;<z>
() {<z>
false);<z>
Instant.now();<z>
) {<z>
(LeakAwareDataBuffer::isAllocated)) {<z>
))) {<z>
50);<z>
InterruptedException ex) {<z>
stream()<z>
(LeakAwareDataBuffer::isAllocated)<z>
.map(LeakAwareDataBuffer::leakError)<z>
));<z>
"Leaked error: ", it));<z>
) + " buffer leaks detected (see logs above)");<z>
BeanDefinitionDecorator findDecoratorForNode(Node node, ParserContext parserContext) {<z>
null;<z>
node);<z>
node instanceof Element) {<z>
get(localName);<z>
if (node instanceof Attr) {<z>
.attributeDecorators.get(localName);<z>
).fatal(<z>
getName() + "]", node);<z>
null) {<z>
parserContext.getReaderContext().fatal("Cannot locate BeanDefinitionDecorator for " +<z>
" [" + localName + "]", node);<z>
decorator;<z>
public WebHttpHandlerBuilder filter(WebFilter... filters) {<z>
{<z>
(Arrays.asList(filters));<z>
updateFilters();<z>
;<z>
(AnnotatedElement element,<z>
) {<z>
element).stream()<z>
annotationTypes))<z>
.toAnnotationSet());<z>
{<z>
headers == null) {<z>
HttpHeaders();<z>
.headers;<z>
(@Nullable String message, HttpStatus statusCode,<z>
) {<z>
statusCode) {<z>
case BAD_REQUEST:<z>
message != null ?<z>
:<z>
(statusText, headers, body, charset);<z>
:<z>
return message != null ?<z>
body, charset) :<z>
charset);<z>
:<z>
!= null ?<z>
) :<z>
, body, charset);<z>
:<z>
message != null ?<z>
, headers, body, charset) :<z>
headers, body, charset);<z>
case METHOD_NOT_ALLOWED:<z>
?<z>
charset) :<z>
body, charset);<z>
NOT_ACCEPTABLE:<z>
return message != null ?<z>
:<z>
, headers, body, charset);<z>
CONFLICT:<z>
null ?<z>
:<z>
, headers, body, charset);<z>
GONE:<z>
?<z>
, statusText, headers, body, charset) :<z>
;<z>
UNSUPPORTED_MEDIA_TYPE:<z>
message != null ?<z>
, charset) :<z>
headers, body, charset);<z>
TOO_MANY_REQUESTS:<z>
!= null ?<z>
, statusText, headers, body, charset) :<z>
(statusText, headers, body, charset);<z>
UNPROCESSABLE_ENTITY:<z>
!= null ?<z>
headers, body, charset) :<z>
, headers, body, charset);<z>
?<z>
, headers, body, charset) :<z>
, headers, body, charset);<z>
> getBindMarkers(String identifier) {<z>
.parameters.getMarker(identifier);<z>
== null) {<z>
;<z>
new ArrayList<>();<z>
NamedParameters.NamedParameter parameter : parameters) {<z>
;<z>
return markers;<z>
<ServerResponse, ServerResponse> filterFunction) {<z>
(filterFunction, "HandlerFilterFunction must not be null");<z>
this.filterFunctions.add(filterFunction);<z>
;<z>
Publisher<? extends DataBuffer>> body) {<z>
.from(body)<z>
)<z>
.class, DataBufferUtils::release));<z>
public boolean supportsEventType(ResolvableType eventType) {<z>
(this.delegate instanceof GenericApplicationListener) {<z>
);<z>
instanceof SmartApplicationListener) {<z>
();<z>
));<z>
);<z>
SessionFactory lookupSessionFactory() {<z>
{<z>
) + "' for OpenSessionInViewFilter");<z>
(getServletContext());<z>
;<z>
void setProperty(String name, Object value) {<z>
.currentBeanDefinition != null) {<z>
value);<z>
{<z>
= WebAsyncUtils.createAsyncWebRequest(servletRequest, servletResponse);<z>
asyncRequestTimeout);<z>
servletRequest);<z>
asyncWebRequest);<z>
return asyncManager;<z>
{<z>
;<z>
(mapType.isInterface()) {<z>
.class == mapType) {<z>
);<z>
mapType || NavigableMap.class == mapType) {<z>
>();<z>
else if (MultiValueMap.class == mapType) {<z>
LinkedMultiValueMap();<z>
"Unsupported Map interface: " + mapType.getName());<z>
class == mapType) {<z>
, "Cannot create EnumMap for unknown key type");<z>
EnumMap(asEnumType(keyType));<z>
mapType)) {<z>
getName());<z>
accessibleConstructor(mapType).newInstance();<z>
) {<z>
;<z>
targetClass, boolean hasIntroductions) {<z>
instanceof IntroductionAdvisor) {<z>
.matches(targetClass);<z>
else if (advisor instanceof PointcutAdvisor pca) {<z>
(), targetClass, hasIntroductions);<z>
return true;<z>
String content) {<z>
.hasText(content, "Content must not be empty");<z>
"o".equals(content)) {<z>
.type = SockJsFrameType.OPEN;<z>
content = content;<z>
{<z>
;<z>
this.content = content;<z>
== 'a') {<z>
SockJsFrameType.MESSAGE;<z>
) > 1 ? content : "a[]");<z>
charAt(0) == 'm') {<z>
type = SockJsFrameType.MESSAGE;<z>
> 1 ? content : "null");<z>
) == 'c') {<z>
.type = SockJsFrameType.CLOSE;<z>
: "c[]");<z>
("Unexpected SockJS frame type in content \"" + content + "\"");<z>
headers, byte[] body,<z>
@Nullable HttpRequest request) {<z>
, headers, body, charset,<z>
);<z>
,<z>
> attributes) {<z>
, config, wsHandler, attributes);<z>
(<z>
<? extends Annotation> container) {<z>
(null, repeatable, container);<z>
throws IOException {<z>
();<z>
resource);<z>
props;<z>
) {<z>
.delegate instanceof ChangePathPatternParserVisitor.Target) {<z>
;<z>
{<z>
);<z>
(prefix);<z>
);<z>
) {<z>
null) {<z>
);<z>
Publisher<T>> S readWithMessageReaders(<z>
Context context, ResolvableType elementType,<z>
,<z>
> errorFunction,<z>
<S> emptySupplier) {<z>
(elementType)) {<z>
);<z>
getHeaders().getContentType())<z>
);<z>
.stream()<z>
, contentType))<z>
.findFirst()<z>
(BodyExtractors::<T>cast)<z>
map(readerFunction)<z>
{<z>
)<z>
getReadableMediaTypes(elementType).stream())<z>
);<z>
return errorFunction.apply(<z>
;<z>
});<z>
{<z>
.startTag("button");<z>
;<z>
("type", getType());<z>
);<z>
if (isDisabled()) {<z>
;<z>
);<z>
tagWriter = tagWriter;<z>
return EVAL_BODY_INCLUDE;<z>
type) {<z>
annotation, "MergedAnnotation must not be null");<z>
, "Type must not be null");<z>
.isAnnotation(), "Type must be an annotation");<z>
.annotation = annotation;<z>
type;<z>
forAnnotationType(type);<z>
Map<String, Object> getUserAttributes() {<z>
== null) {<z>
new HashMap<>();<z>
return this.userAttributes;<z>
{<z>
get(targetClass);<z>
) {<z>
eligible;<z>
{<z>
false;<z>
this.advisor, targetClass);<z>
, eligible);<z>
return eligible;<z>
(<z>
typeProvider, @Nullable VariableResolver variableResolver) {<z>
{<z>
typeProvider);<z>
type == null) {<z>
NONE;<z>
if (type instanceof Class) {<z>
;<z>
;<z>
);<z>
);<z>
(cachedType == null) {<z>
.hash);<z>
cachedType, cachedType);<z>
.resolved;<z>
;<z>
throws IOException {<z>
) {<z>
new IOException("Stream closed");<z>
.index) {<z>
;<z>
;<z>
) {<z>
) {<z>
path;<z>
);<z>
normalizedPath;<z>
) == -1) {<z>
;<z>
indexOf(':');<z>
= "";<z>
!= -1) {<z>
0, prefixIndex + 1);<z>
FOLDER_SEPARATOR)) {<z>
"";<z>
(prefixIndex + 1);<z>
) {<z>
FOLDER_SEPARATOR;<z>
= pathToUse.substring(1);<z>
= delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);<z>
>(pathArray.length);<z>
;<z>
1; i >= 0; i--) {<z>
element = pathArray[i];<z>
(element)) {<z>
) {<z>
tops++;<z>
> 0) {<z>
tops--;<z>
;<z>
length == pathElements.size()) {<z>
return normalizedPath;<z>
tops; i++) {<z>
TOP_PATH);<z>
{<z>
.addFirst(CURRENT_PATH);<z>
= collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);<z>
prefix + joined;<z>
) {<z>
= this.values;<z>
{<z>
.targetMap.values());<z>
;<z>
return values;<z>
throws BeanInstantiationException {<z>
clazz, "Class must not be null");<z>
)) {<z>
clazz, "Specified class is an interface");<z>
<T> ctor;<z>
clazz.getDeclaredConstructor();<z>
) {<z>
);<z>
) {<z>
(clazz, "No default constructor found", ex);<z>
(LinkageError err) {<z>
new BeanInstantiationException(clazz, "Unresolvable class definition", err);<z>
instantiateClass(ctor);<z>
(<z>
, MethodMetadata beanMethodMetadata, String derivedBeanName) {<z>
.annotationMetadata = configClass.getMetadata();<z>
beanMethodMetadata;<z>
this.derivedBeanName = derivedBeanName;<z>
(configClass.getResource());<z>
setLenientConstructorResolution(false);<z>
, boolean read, boolean write) {<z>
;<z>
.length; i++) {<z>
= properties[i];<z>
(read) {<z>
);<z>
) {<z>
add(pd.getWriteMethod());<z>
methods.remove(null);<z>
[methods.size()]);<z>
MediaType> getAcceptedMediaTypes(ServerWebExchange exchange) throws NotAcceptableStatusException {<z>
> result = exchange.getAttribute(MEDIA_TYPES_ATTRIBUTE);<z>
== null) {<z>
.resolveMediaTypes(exchange);<z>
.put(MEDIA_TYPES_ATTRIBUTE, result);<z>
return result;<z>
Nullable HttpServletRequest request, String requestPath) {<z>
if (request != null) {<z>
);<z>
(StringUtils.hasText(codingKey)) {<z>
+ codingKey;<z>
requestPath;<z>
Nullable String[] array2) {<z>
) {<z>
return array2;<z>
array2)) {<z>
;<z>
+ array2.length];<z>
0, array1.length);<z>
array1.length, array2.length);<z>
return newArr;<z>
response) throws Exception {<z>
request.getMethod())) {<z>
(5);<z>
;<z>
,<z>
completionMono) {<z>
, completionMono);<z>
, ParserContext parserContext) {<z>
);<z>
transactionAttributeMap =<z>
size());<z>
));<z>
) {<z>
String name = methodEle.getAttribute(METHOD_NAME_ATTRIBUTE);<z>
;<z>
);<z>
= new RuleBasedTransactionAttribute();<z>
getAttribute(PROPAGATION_ATTRIBUTE);<z>
= methodEle.getAttribute(ISOLATION_ATTRIBUTE);<z>
.getAttribute(TIMEOUT_ATTRIBUTE);<z>
);<z>
(StringUtils.hasText(propagation)) {<z>
setPropagationBehaviorName(RuleBasedTransactionAttribute.PREFIX_PROPAGATION + propagation);<z>
)) {<z>
+ isolation);<z>
hasText(timeout)) {<z>
setTimeoutString(timeout);<z>
(StringUtils.hasText(readOnly)) {<z>
;<z>
ArrayList<>(1);<z>
.hasAttribute(ROLLBACK_FOR_ATTRIBUTE)) {<z>
methodEle.getAttribute(ROLLBACK_FOR_ATTRIBUTE);<z>
rollbackRules, rollbackForValue);<z>
.hasAttribute(NO_ROLLBACK_FOR_ATTRIBUTE)) {<z>
NO_ROLLBACK_FOR_ATTRIBUTE);<z>
rollbackRules, noRollbackForValue);<z>
.setRollbackRules(rollbackRules);<z>
, attribute);<z>
(NameMatchTransactionAttributeSource.class);<z>
(attrEle));<z>
);<z>
;<z>
{<z>
= event.getThrowable();<z>
isDebugEnabled()) {<z>
null ? ex : "<no Throwable>"));<z>
;<z>
this.responseAsyncListener, event);<z>
handleTimeoutOrError(event);<z>
() {<z>
{<z>
synchronizationManager.unbindResource(this.resourceKey);<z>
();<z>
{<z>
null;<z>
new ArrayList<>(2);<z>
searchIndex = 0;<z>
{<z>
indexOf(PROPERTY_KEY_PREFIX, searchIndex);<z>
searchIndex = -1;<z>
if (keyStart != -1) {<z>
));<z>
1) {<z>
) {<z>
.substring(0, keyStart);<z>
);<z>
)) ||<z>
)) {<z>
() - 1);<z>
keys.add(key);<z>
keyEnd + PROPERTY_KEY_SUFFIX.length();<z>
propertyName);<z>
(!keys.isEmpty()) {<z>
canonicalName += PROPERTY_KEY_PREFIX +<z>
) +<z>
= StringUtils.toStringArray(keys);<z>
;<z>
BeanDefinitionBuilder addConstructorArgReference(String beanName) {<z>
).addIndexedArgumentValue(<z>
constructorArgIndex++, new RuntimeBeanReference(beanName));<z>
this;<z>
BindException {<z>
()) {<z>
new BindException(getBindingResult());<z>
,<z>
valueResolver) {<z>
BeanDefinitionVisitor(valueResolver);<z>
[] beanNames = beanFactoryToProcess.getBeanDefinitionNames();<z>
) {<z>
this.beanFactory))) {<z>
.getBeanDefinition(curName);<z>
;<z>
) {<z>
.getMessage(), ex);<z>
);<z>
beanFactoryToProcess.addEmbeddedValueResolver(valueResolver);<z>
<SourceClass> getAnnotations() {<z>
> result = new LinkedHashSet<>();<z>
{<z>
>) this.source;<z>
getDeclaredAnnotations()) {<z>
);<z>
().startsWith("java")) {<z>
(annType, DEFAULT_EXCLUSION_FILTER));<z>
{<z>
)) {<z>
"java")) {<z>
(className));<z>
catch (Throwable ex) {<z>
return result;<z>
Nullable Locale locale) {<z>
this.targetMap = new LinkedHashMap<>(<z>
.DEFAULT_LOAD_FACTOR), CollectionUtils.DEFAULT_LOAD_FACTOR) {<z>
containsKey(Object key) {<z>
return LinkedCaseInsensitiveMap.this.containsKey(key);<z>
) {<z>
.this.removeEldestEntry(eldest);<z>
doRemove) {<z>
);<z>
;<z>
= CollectionUtils.newHashMap(expectedSize);<z>
.getDefault());<z>
getHttpRequestHeaders(@Nullable HttpHeaders webSocketHttpHeaders) {<z>
== null || webSocketHttpHeaders == null) {<z>
webSocketHttpHeaders;<z>
httpHeaders = new HttpHeaders();<z>
getHttpHeaderNames()) {<z>
);<z>
!= null) {<z>
, values);<z>
return httpHeaders;<z>
{<z>
systemSubscriptions.clear();<z>
null) {<z>
subscriptions);<z>
) {<z>
> functions = obtainApplicationContext()<z>
)<z>
.orderedStream()<z>
RouterFunction<?>)router)<z>
.collect(Collectors.toList());<z>
());<z>
Object getAttribute(String name, int scope) {<z>
== SCOPE_REQUEST) {<z>
{<z>
new IllegalStateException(<z>
);<z>
getAttribute(name);<z>
false);<z>
{<z>
getAttribute(name);<z>
) {<z>
, value);<z>
;<z>
catch (IllegalStateException ex) {<z>
;<z>
boolean equals(Object o) {<z>
o) {<z>
;<z>
(!(o instanceof CompositeCronField other)) {<z>
false;<z>
) &&<z>
.value.equals(other.value);<z>
void initHandlerMethods() {<z>
(String beanName : getCandidateBeanNames()) {<z>
.startsWith(SCOPED_TARGET_NAME_PREFIX)) {<z>
processCandidateBean(beanName);<z>
getHandlerMethods());<z>
messageCreator) throws JmsException {<z>
-> {<z>
destination = resolveDestinationName(session, destinationName);<z>
);<z>
);<z>
] arguments) {<z>
(arguments)) {<z>
return new Object[0];<z>
()) {<z>
.getParameterCount() == arguments.length) {<z>
[] paramTypes = method.getParameterTypes();<z>
.length - 1;<z>
];<z>
) {<z>
= arguments[varargIndex];<z>
(varargArray)) {<z>
Object[arguments.length];<z>
varargIndex);<z>
?> targetElementType = varargType.getComponentType();<z>
int varargLength = Array.getLength(varargArray);<z>
);<z>
, 0, varargLength);<z>
newVarargArray;<z>
;<z>
return arguments;<z>
String text) throws IllegalArgumentException {<z>
.hasText(text)) {<z>
.trim();<z>
(ResourceUtils.CLASSPATH_URL_PREFIX)) {<z>
= new ClassPathResource(<z>
);<z>
getURI());<z>
catch (IOException ex) {<z>
));<z>
uri));<z>
URISyntaxException ex) {<z>
;<z>
);<z>
{<z>
()) {<z>
= createHibernateTemplate(sessionFactory);<z>
ClientHttpResponse getClientHttpResponse(<z>
] requestBody) {<z>
mockMvc<z>
).headers(requestHeaders))<z>
)<z>
getResponse();<z>
);<z>
[] body = servletResponse.getContentAsByteArray();<z>
, status);<z>
.putAll(getResponseHeaders(servletResponse));<z>
return clientResponse;<z>
{<z>
(StandardCharsets.UTF_8);<z>
(body, HttpStatus.INTERNAL_SERVER_ERROR);<z>
{<z>
0) {<z>
= AnnotatedElementUtils.getMergedAnnotationAttributes(<z>
, this.valueAnnotationType);<z>
attr != null) {<z>
attr);<z>
null;<z>
(Resource resource) throws IOException {<z>
Properties props = new Properties();<z>
resource);<z>
;<z>
HandlerMethod handlerMethod) {<z>
?> handlerType = handlerMethod.getBeanType();<z>
.sessionAttributesHandlerCache.get(handlerType);<z>
== null) {<z>
) {<z>
.get(handlerType);<z>
{<z>
new SessionAttributesHandler(handlerType);<z>
result);<z>
;<z>
(<z>
) {<z>
{<z>
).clear();<z>
.transactionData, resourceKey);<z>
JMSException, MessageConversionException {<z>
(object instanceof Message)) {<z>
"] - only [" +<z>
() + "] is handled by this converter");<z>
(Message<?>) object;<z>
MessageHeaders headers = input.getHeaders();<z>
AbstractMessageSendingTemplate.CONVERSION_HINT_HEADER);<z>
);<z>
headerMapper.fromHeaders(headers, reply);<z>
return reply;<z>
{<z>
.annotationParsers) {<z>
if (parser.isCandidateClass(targetClass)) {<z>
;<z>
;<z>
) {<z>
)) {<z>
{<z>
"Expected byte[] payload. Ignoring " + message + ".");<z>
message);<z>
();<z>
)) {<z>
isWarnEnabled()) {<z>
);<z>
ORIGINAL_DESTINATION);<z>
if (origDestination != null) {<z>
);<z>
);<z>
accessor.setDestination(origDestination);<z>
)) {<z>
;<z>
accessor, session);<z>
this.eventPublisher != null) {<z>
;<z>
;<z>
;<z>
[]>) message, user));<z>
SimpAttributesContextHolder.resetAttributes();<z>
[]) message.getPayload();<z>
command) && getErrorHandler() != null) {<z>
>) message);<z>
errorMessage != null) {<z>
StompHeaderAccessor.class);<z>
"No StompHeaderAccessor");<z>
getPayload();<z>
message);<z>
null) {<z>
, session);<z>
task.run());<z>
accessor, payload);<z>
{<z>
).getId(),<z>
cookies, this.body);<z>
new DelegatingServerWebExchange(<z>
.exchange, this.messageReaders);<z>
this.messageReaders);<z>
add(String key, String value) {<z>
];<z>
0, this.tags.length);<z>
] = new FlightRecorderTag(key, value);<z>
;<z>
TransactionManager lookupTransactionManager(String transactionManagerName)<z>
throws TransactionSystemException {<z>
{<z>
;<z>
class);<z>
(NamingException ex) {<z>
throw new TransactionSystemException(<z>
);<z>
context,<z>
Nullable Set<String> exposedContextBeanNames) {<z>
;<z>
);<z>
.webApplicationContext = context;<z>
exposedContextBeanNames;<z>
extends T> elementClass) {<z>
elementClass.equals(DataBuffer.class) ?<z>
;<z>
flux.onErrorMap(UnsupportedMediaTypeException.class, ERROR_MAPPER)<z>
.class, DECODING_MAPPER);<z>
?> message) throws IOException {<z>
)) {<z>
(this + " supports text messages only.");<z>
!= State.OPEN) {<z>
);<z>
TextMessage) message).getPayload();<z>
).encode(payload);<z>
.substring(1);<z>
messageToSend = new TextMessage(payload);<z>
if (logger.isTraceEnabled()) {<z>
;<z>
;<z>
private boolean isDataMimeTypeSupported(MimeType dataMimeType) {<z>
<?> encoder : getEncoders()) {<z>
()) {<z>
encodable.isCompatibleWith(dataMimeType)) {<z>
;<z>
false;<z>
enumValues, String constant, boolean caseSensitive) {<z>
<?> candidate : enumValues) {<z>
.toString().equals(constant) :<z>
.equalsIgnoreCase(constant)) {<z>
true;<z>
false;<z>
ReactiveHttpOutputMessage> fromDataBuffers(<z>
T publisher) {<z>
notNull(publisher, "'publisher' must not be null");<z>
(publisher);<z>
int startPos, int endPos) {<z>
= tokenKind;<z>
startPos = startPos;<z>
endPos;<z>
boolean caseSensitive, char separator) {<z>
super(pos, separator);<z>
this.len = literalText.length;<z>
.caseSensitive = caseSensitive;<z>
) {<z>
text = literalText;<z>
[literalText.length];<z>
this.len; i++) {<z>
[i]);<z>
ParserContext parserContext) {<z>
;<z>
String txAspectClassName = TransactionManagementConfigUtils.TRANSACTION_ASPECT_CLASS_NAME;<z>
().containsBeanDefinition(txAspectBeanName)) {<z>
= new RootBeanDefinition();<z>
);<z>
("aspectOf");<z>
element, def);<z>
BeanComponentDefinition(def, txAspectBeanName));<z>
toString() {<z>
(logger.isDebugEnabled()) {<z>
this) +<z>
;<z>
"'}";<z>
String buildErrorMessage() {<z>
StringBuilder msg = new StringBuilder(80);<z>
)).append("' has no matching field.");<z>
ObjectUtils.isEmpty(getPossibleMatches())) {<z>
;<z>
appendHintMessage(msg);<z>
msg.toString();<z>
elementNamespace, String elementLocalName) {<z>
, dataHandler);<z>
UUID.randomUUID() + "@" + host;<z>
"<" + contentId + ">", dataHandler);<z>
, StandardCharsets.UTF_8);<z>
+ contentId;<z>
codecConfigurer) {<z>
;<z>
;<z>
.enableLoggingRequestDetails = false;<z>
().stream()<z>
filter(LoggingCodecSupport.class::isInstance)<z>
{<z>
) reader).isEnableLoggingRequestDetails()) {<z>
;<z>
});<z>
{<z>
isTrue(defaultInitialCapacity > 0, "'defaultInitialCapacity' should be larger than 0");<z>
;<z>
defaultInitialCapacity = defaultInitialCapacity;<z>
Configuration getConfiguration() {<z>
.configuration == null) {<z>
);<z>
.configuration;<z>
viewResolvers,<z>
{<z>
getSharedInstance());<z>
pattern, RequestPredicate predicate,<z>
ServerResponse> handlerFunction) {<z>
, handlerFunction);<z>
AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) {<z>
);<z>
element, parserContext.getReaderContext());<z>
) {<z>
null;<z>
parserContext.getRegistry());<z>
new GenericBeanDefinition();<z>
(this.scriptFactoryClassName);<z>
));<z>
element.getLocalName());<z>
.getAttribute(SCOPE_ATTRIBUTE);<z>
(scope)) {<z>
bd.setScope(scope);<z>
.getAttribute(AUTOWIRE_ATTRIBUTE);<z>
().getAutowireMode(autowire);<z>
AUTOWIRE_AUTODETECT) {<z>
autowireMode = AbstractBeanDefinition.AUTOWIRE_BY_TYPE;<z>
{<z>
;<z>
bd.setAutowireMode(autowireMode);<z>
String dependsOn = element.getAttribute(DEPENDS_ON_ATTRIBUTE);<z>
if (StringUtils.hasLength(dependsOn)) {<z>
StringUtils.tokenizeToStringArray(<z>
BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS));<z>
();<z>
String initMethod = element.getAttribute(INIT_METHOD_ATTRIBUTE);<z>
{<z>
(initMethod);<z>
!= null) {<z>
;<z>
)) {<z>
.getAttribute(DESTROY_METHOD_ATTRIBUTE);<z>
(destroyMethod);<z>
) != null) {<z>
.setDestroyMethodName(beanDefinitionDefaults.getDestroyMethodName());<z>
REFRESH_CHECK_DELAY_ATTRIBUTE);<z>
) {<z>
refreshCheckDelay));<z>
= element.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE);<z>
) {<z>
));<z>
bd.getConstructorArgumentValues();<z>
int constructorArgNum = 0;<z>
(StringUtils.hasLength(engine)) {<z>
;<z>
, value);<z>
element.hasAttribute(SCRIPT_INTERFACES_ATTRIBUTE)) {<z>
addIndexedArgumentValue(<z>
getAttribute(SCRIPT_INTERFACES_ATTRIBUTE), "java.lang.Class[]");<z>
.hasAttribute(CUSTOMIZER_REF_ATTRIBUTE)) {<z>
CUSTOMIZER_REF_ATTRIBUTE);<z>
StringUtils.hasText(customizerBeanName)) {<z>
("Attribute 'customizer-ref' has empty value", element);<z>
++, new RuntimeBeanReference(customizerBeanName));<z>
(element, bd);<z>
bd;<z>
<ConstructorArgumentValues.ValueHolder> gas) {<z>
) {<z>
= resolveValue(valueHolder.getValue());<z>
getValue())) {<z>
valueHolder.setValue(newVal);<z>
, Matcher<? super Integer> matcher) {<z>
return result -> {<z>
, name);<z>
cookie.getMaxAge(), matcher);<z>
Nullable MessageCodesResolver messageCodesResolver) {<z>
;<z>
this.messageCodesResolver = messageCodesResolver;<z>
!= null && messageCodesResolver != null) {<z>
.setMessageCodesResolver(messageCodesResolver);<z>
) {<z>
.hashCode();<z>
hashCode();<z>
hashCode();<z>
;<z>
public int getSerializedSize() {<z>
;<z>
!= -1) return size;<z>
= 0;<z>
(bitField0_ & 0x00000001) == 0x00000001)) {<z>
+= com.google.protobuf.CodedOutputStream<z>
(1, blah_);<z>
).getSerializedSize();<z>
memoizedSerializedSize = size;<z>
;<z>
) {<z>
: this.segments) {<z>
{<z>
;<z>
return true;<z>
public boolean isFile() {<z>
);<z>
.isFileURL(url)) {<z>
return true;<z>
path) != null);<z>
(MalformedURLException ex) {<z>
return false;<z>
throws InvalidResultSetAccessException {<z>
;<z>
) {<z>
;<z>
(<z>
sink, AsynchronousFileChannel channel, long position) {<z>
.sink = sink;<z>
.channel = channel;<z>
new AtomicLong(position);<z>
private void logExecutorWarning(MethodParameter returnType) {<z>
{<z>
synchronized (this) {<z>
(this.taskExecutorWarning) {<z>
;<z>
logger.warn("\n!!!\n" +<z>
"The " + executorTypeName + " currently in use is not suitable under load.\n" +<z>
+<z>
().getName() + "\n" +<z>
+ "\n" +<z>
;<z>
.taskExecutorWarning = false;<z>
toQualifiedName(QName qName) {<z>
getPrefix();<z>
!StringUtils.hasLength(prefix)) {<z>
();<z>
getLocalPart();<z>
input, String encoding) {<z>
);<z>
);<z>
);<z>
length(); i++) {<z>
;<z>
(character, encoding)) {<z>
HtmlCharacterEntityReferences.DECIMAL_REFERENCE_START);<z>
((int) character);<z>
);<z>
;<z>
();<z>
{<z>
IdGenerator idGenerator = getIdGenerator();<z>
(idGenerator != null) {<z>
.setIdGenerator(idGenerator);<z>
));<z>
> consumer) {<z>
;<z>
);<z>
;<z>
] getParameterNames(Method method) {<z>
) == 0) {<z>
String[0];<z>
);<z>
(annotation == null) {<z>
return null;<z>
);<z>
nameTokens.countTokens() > 0) {<z>
.countTokens()];<z>
i++) {<z>
.nextToken();<z>
;<z>
return null;<z>
body) {<z>
(response));<z>
> result = applyStatusHandlers(response);<z>
).switchIfEmpty(body) : body);<z>
webRequest) {<z>
getNativeResponse(HttpServletResponse.class);<z>
"No HttpServletResponse");<z>
ServletServerHttpResponse(response);<z>
Object[] args) throws Throwable {<z>
();<z>
fci = fastClassInfo;<z>
.i2, obj, args);<z>
e) {<z>
.getTargetException();<z>
BeanCreationException {<z>
object;<z>
object = factory.getObject();<z>
{<z>
());<z>
) {<z>
, ex);<z>
if (object == null) {<z>
(isSingletonCurrentlyInCreation(beanName)) {<z>
(<z>
"FactoryBean which is currently in creation returned null from getObject");<z>
= new NullBean();<z>
return object;<z>
{<z>
Matcher matcher = PATTERN.matcher(message);<z>
matcher.find()) {<z>
= matcher.group();<z>
match)) {<z>
IllegalArgumentException("Placeholder [" + match + "] is not valid");<z>
ResponseEntity<Object> handleHttpMediaTypeNotSupported(<z>
request) {<z>
;<z>
(mediaTypes)) {<z>
);<z>
request instanceof ServletWebRequest servletWebRequest) {<z>
) {<z>
;<z>
request);<z>
> registerAnnotationConfigProcessors(<z>
{<z>
= unwrapDefaultListableBeanFactory(registry);<z>
!= null) {<z>
getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {<z>
setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);<z>
() instanceof ContextAnnotationAutowireCandidateResolver)) {<z>
new ContextAnnotationAutowireCandidateResolver());<z>
<>(8);<z>
(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {<z>
new RootBeanDefinition(ConfigurationClassPostProcessor.class);<z>
);<z>
));<z>
(!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {<z>
class);<z>
setSource(source);<z>
AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));<z>
)) {<z>
= new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);<z>
);<z>
def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));<z>
registry.containsBeanDefinition(JSR250_ANNOTATION_PROCESSOR_BEAN_NAME)) {<z>
);<z>
);<z>
);<z>
setSource(source);<z>
);<z>
ex) {<z>
.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {<z>
= new RootBeanDefinition();<z>
(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,<z>
.getClassLoader()));<z>
{<z>
throw new IllegalStateException(<z>
"Cannot load optional framework class: " + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);<z>
(source);<z>
, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));<z>
) {<z>
RootBeanDefinition(EventListenerMethodProcessor.class);<z>
;<z>
, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));<z>
) {<z>
class);<z>
source);<z>
EVENT_LISTENER_FACTORY_BEAN_NAME));<z>
;<z>
<DataBuffer> content) {<z>
reactiveResponse = reactiveResponse;<z>
content = Flux.from(content);<z>
(reactiveResponse.getHeaders());<z>
.readOnlyHttpHeaders(headers);<z>
TransactionSynchronization> getSynchronizations() throws IllegalStateException {<z>
transactionContext.getSynchronizations();<z>
) {<z>
;<z>
{<z>
;<z>
>(synchs);<z>
AnnotationAwareOrderComparator.sort(sortedSynchs);<z>
);<z>
resource) {<z>
);<z>
resourceRef = resource;<z>
if (resourceRef instanceof InfrastructureProxy) {<z>
();<z>
(aopAvailable) {<z>
ScopedProxyUnwrapper.unwrapIfNecessary(resourceRef);<z>
resourceRef;<z>
getLookupPathForRequest(HttpServletRequest request) {<z>
;<z>
(request)) {<z>
;<z>
);<z>
if (StringUtils.hasLength(rest)) {<z>
rest;<z>
pathWithinApp;<z>
TypeDescriptor elementTypeDescriptor) {<z>
elementTypeDescriptor == null) {<z>
return null;<z>
(elementTypeDescriptor.resolvableType),<z>
null, elementTypeDescriptor.getAnnotations());<z>
Map<String, DataSource> dataSources) {<z>
dataSources != null) {<z>
.putAll(dataSources);<z>
{<z>
source = source;<z>
Class) {<z>
;<z>
) source).getAnnotationMetadata();<z>
) {<z>
headers = getHeaders();<z>
.headers(fields -> {<z>
));<z>
(HttpHeaders.ACCEPT)) {<z>
.ACCEPT, "*/*");<z>
;<z>
project) {<z>
String baseline = String.join(":",<z>
, baselineVersion);<z>
;<z>
baselineDependency);<z>
protected void doCommit(DefaultTransactionStatus status) {<z>
.getTransaction();<z>
getResourceHolder().getOriginalSession();<z>
session != null) {<z>
) {<z>
;<z>
.commit();<z>
catch (TransactionRolledBackException ex) {<z>
;<z>
(JMSException ex) {<z>
ex);<z>
getTransactionAwareConnectionProxy(Connection target) {<z>
3);<z>
;<z>
QueueConnection) {<z>
.class);<z>
) {<z>
classes.add(TopicConnection.class);<z>
Connection.class.getClassLoader(),<z>
;<z>
List<Advisor> advisors) {<z>
) {<z>
boolean foundAspectJAdvice = false;<z>
{<z>
isAspectJAdvice(advisor)) {<z>
;<z>
contains(ExposeInvocationInterceptor.ADVISOR)) {<z>
ADVISOR);<z>
;<z>
return false;<z>
String getBeanName(MethodInvocation mi) throws IllegalStateException {<z>
(!(mi instanceof ProxyMethodInvocation pmi)) {<z>
("MethodInvocation is not a Spring ProxyMethodInvocation: " + mi);<z>
.getUserAttribute(BEAN_NAME_ATTRIBUTE);<z>
) {<z>
("Cannot get bean name; not set on MethodInvocation: " + mi);<z>
beanName;<z>
public AnnotationAsyncExecutionAspect asyncAdvisor() {<z>
);<z>
exceptionHandler);<z>
return asyncAspect;<z>
) throws Throwable {<z>
)<z>
LockedException();<z>
return super.invoke(invocation);<z>
O> context) {<z>
).resolveCaches(context);<z>
cache = extractFrom(caches);<z>
if (cache == null) {<z>
+ context.getOperation());<z>
;<z>
public StringArrayPropertyEditor(<z>
) {<z>
this.separator = separator;<z>
.charsToDelete = charsToDelete;<z>
emptyArrayAsNull;<z>
this.trimValues = trimValues;<z>
> batchArgs, final int batchSize,<z>
throws DataAccessException {<z>
)) {<z>
;<z>
[]>) ps -> {<z>
new ArrayList<>();<z>
));<z>
;<z>
: batchArgs) {<z>
);<z>
++;<z>
) {<z>
.addBatch();<z>
size()) {<z>
(logger.isTraceEnabled()) {<z>
: (n / batchSize) + 1;<z>
/ batchSize)) * batchSize;<z>
+ items + " items");<z>
(ps.executeBatch());<z>
;<z>
{i});<z>
size()][];<z>
i < result1.length; i++) {<z>
i);<z>
return result1;<z>
{<z>
).cleanupParameters();<z>
});<z>
;<z>
;<z>
{<z>
.view = viewName;<z>
!= null) {<z>
(model);<z>
;<z>
> inputStream,<z>
, @Nullable MediaType mediaType, ReactiveHttpOutputMessage message,<z>
Map<String, Object> hints) {<z>
;<z>
).setContentType(mediaType);<z>
() : getDefaultCharset();<z>
(form -> {<z>
form, hints);<z>
String value = serializeForm(form, charset);<z>
;<z>
bufferFactory().wrap(byteBuffer);<z>
(byteBuffer.remaining());<z>
);<z>
;<z>
Message<?> message) throws MessagingException {<z>
());<z>
destination)) {<z>
message;<z>
=<z>
.getAccessor(message, SimpMessageHeaderAccessor.class);<z>
);<z>
accessor.getSessionId() == null) {<z>
return null;<z>
);<z>
()) {<z>
.trace("Checking unresolved user destination: " + destination);<z>
create(SimpMessageType.MESSAGE);<z>
keySet()) {<z>
.contains(name)) {<z>
.getFirstNativeHeader(name));<z>
if (destination != null) {<z>
.setDestination(destination);<z>
.setHeader(SimpMessageHeaderAccessor.IGNORE_ERROR, true);<z>
(), newAccessor.getMessageHeaders());<z>
) throws IllegalStateException {<z>
value = getProperty(key);<z>
) {<z>
("Required key '" + key + "' not found");<z>
value;<z>
public void rollbackToSavepoint(Object savepoint) throws TransactionException {<z>
= getConnectionHolderForSavepoint();<z>
savepoint);<z>
;<z>
) {<z>
"Could not roll back to JDBC savepoint", ex);<z>
AttributeList getAttributes(String[] attrNames) {<z>
;<z>
managedResourceClassLoader);<z>
super.getAttributes(attrNames);<z>
);<z>
private void filterArray(Object[] result) {<z>
{<z>
Entry<?,?> entry) {<z>
entry);<z>
() throws JMSException {<z>
.lifecycleMonitor) {<z>
.running = false;<z>
notifyAll();<z>
()) {<z>
);<z>
(Object jobObject) throws Exception {<z>
if (jobObject instanceof Job) {<z>
return (Job) jobObject;<z>
if (jobObject instanceof Runnable) {<z>
;<z>
throw new IllegalArgumentException(<z>
jobObject.getClass().getName() +<z>
"]: only [org.quartz.Job] and [java.lang.Runnable] supported.");<z>
match(HttpServletRequest request, String pattern) {<z>
"This HandlerMapping requires a PathPattern");<z>
(this.config).build();<z>
);<z>
.getPatternsCondition() != null ?<z>
(<z>
next(),<z>
.getResolvedLookupPath(request),<z>
)) : null);<z>
StompHeaders headers) {<z>
();<z>
) && receiptId == null) {<z>
;<z>
);<z>
receiptId;<z>
> defaultSupplier) {<z>
.instanceSupplier = null;<z>
this.defaultSupplier = defaultSupplier;<z>
singletonInstance = instance;<z>
throws Exception {<z>
isDebugEnabled()) {<z>
();<z>
=<z>
(new PrintWriter(stringWriter));<z>
;<z>
;<z>
ClassLoader classLoader) {<z>
.serialization = new SerializationDelegate(classLoader);<z>
)) {<z>
);<z>
<?> implementationClass) {<z>
, "Method must not be null");<z>
, implementationClass);<z>
(methodParameter);<z>
(Row row, RowMetadata rowMetadata) {<z>
.getColumnNames();<z>
int columnCount = columns.size();<z>
);<z>
= 0;<z>
column : columns) {<z>
;<z>
row, index++);<z>
obj);<z>
mapOfColValues;<z>
brokerChannel) {<z>
null && this.brokerRelayRegistration == null) {<z>
;<z>
!= null) {<z>
);<z>
this.pathMatcher);<z>
handler.setCacheLimit(this.cacheLimit);<z>
;<z>
handler;<z>
;<z>
{<z>
location.getClass()) {<z>
;<z>
resourcePath;<z>
locationPath;<z>
(resource instanceof UrlResource) {<z>
();<z>
());<z>
instanceof ClassPathResource classPathResource) {<z>
classPathResource.getPath();<z>
));<z>
();<z>
());<z>
if (locationPath.equals(resourcePath)) {<z>
return true;<z>
"/");<z>
));<z>
,<z>
Message<?> message) {<z>
().getPatterns();<z>
(patterns)) {<z>
.next();<z>
extractUriTemplateVariables(pattern, lookupDestination);<z>
{<z>
MessageHeaderAccessor.class);<z>
, "Mutable MessageHeaderAccessor required");<z>
DESTINATION_TEMPLATE_VARIABLES_HEADER, vars);<z>
(message);<z>
, lookupDestination, message);<z>
;<z>
@Nullable String descriptor) {<z>
) {<z>
.element().add(descriptor);<z>
afterPropertiesSet() {<z>
{<z>
.add(new NoOpCacheManager());<z>
, SqlParameterSource paramSource, RowCallbackHandler rch)<z>
throws DataAccessException {<z>
(sql, paramSource), rch);<z>
) {<z>
findInterfaceMethod(iface);<z>
{<z>
;<z>
;<z>
String> filter) throws IOException {<z>
getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {<z>
;<z>
if (existingClass != null) {<z>
(configClass.isImported()) {<z>
isImported()) {<z>
mergeImportedBy(configClass);<z>
.remove(configClass);<z>
configClass::equals);<z>
asSourceClass(configClass, filter);<z>
, sourceClass, filter);<z>
!= null);<z>
.put(configClass, configClass);<z>
registry, boolean useDefaultFilters,<z>
Nullable ResourceLoader resourceLoader) {<z>
"BeanDefinitionRegistry must not be null");<z>
this.registry = registry;<z>
) {<z>
;<z>
(environment);<z>
);<z>
ParserContext parserContext,<z>
specificContainerProperties) {<z>
RootBeanDefinition containerDef = new RootBeanDefinition();<z>
.extractSource(containerEle));<z>
;<z>
.addPropertyValues(specificContainerProperties);<z>
= new RootBeanDefinition();<z>
.extractSource(containerEle));<z>
.setBeanClassName("org.springframework.jms.listener.endpoint.JmsActivationSpecConfig");<z>
(commonContainerProperties);<z>
));<z>
, configDef);<z>
;<z>
, ServletResponse response, FilterChain chain)<z>
{<z>
);<z>
) {<z>
;<z>
= other.applicationContext;<z>
);<z>
(other.exceptionHandlers);<z>
= other.sessionManager;<z>
this.codecConfigurer = other.codecConfigurer;<z>
other.localeContextResolver;<z>
= other.forwardedHeaderTransformer;<z>
.httpHandlerDecorator = other.httpHandlerDecorator;<z>
pw) {<z>
(pw) {<z>
+ "; nested PropertyAccessException details (" +<z>
") are:");<z>
{<z>
) + ":");<z>
pw);<z>
resolvePrimitiveClassName(@Nullable String name) {<z>
result = null;<z>
<= 7) {<z>
);<z>
return result;<z>
) {<z>
);<z>
.state(viewClass != null, "No view class");<z>
;<z>
<? extends Resource> locations) {<z>
!= null ?<z>
) :<z>
));<z>
void initializeSession() {<z>
this.sessionInitialized) {<z>
();<z>
.state(con != null, "No transactional JMS Connection");<z>
con), con);<z>
catch (JMSException ex) {<z>
throw new CannotCreateTransactionException(<z>
ex);<z>
true;<z>
) {<z>
>();<z>
.registration != null) {<z>
;<z>
.paths) {<z>
"/**");<z>
new SockJsHttpRequestHandler(sockJsService, this.webSocketHandler);<z>
);<z>
for (String path : this.paths) {<z>
handler;<z>
this.handshakeHandler != null) {<z>
);<z>
new WebSocketHttpRequestHandler(this.webSocketHandler);<z>
interceptors = getInterceptors();<z>
if (interceptors.length > 0) {<z>
.asList(interceptors));<z>
add(handler, path);<z>
mappings;<z>
Map<String, Object> result) {<z>
);<z>
);<z>
value, result);<z>
dataBuffers) {<z>
notEmpty(dataBuffers, "DataBuffer List must not be empty");<z>
::readableByteCount).sum();<z>
allocateBuffer(capacity);<z>
;<z>
(DataBufferUtils::release);<z>
return result;<z>
static BeanDefinition registerOrEscalateApcAsRequired(<z>
, BeanDefinitionRegistry registry, @Nullable Object source) {<z>
"BeanDefinitionRegistry must not be null");<z>
(registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {<z>
);<z>
{<z>
getBeanClassName());<z>
int requiredPriority = findPriorityForClass(cls);<z>
) {<z>
setBeanClassName(cls.getName());<z>
return null;<z>
RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);<z>
(source);<z>
;<z>
ROLE_INFRASTRUCTURE);<z>
AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);<z>
return beanDefinition;<z>
private boolean isInfrastructureBean(@Nullable String beanName) {<z>
beanFactory.containsBeanDefinition(beanName)) {<z>
beanFactory.getBeanDefinition(beanName);<z>
.ROLE_INFRASTRUCTURE);<z>
;<z>
public void setCc(InternetAddress cc) throws MessagingException {<z>
, "Cc address must not be null");<z>
);<z>
Message.RecipientType.CC, cc);<z>
Matcher<? super String> matcher) {<z>
result -> {<z>
);<z>
(response), matcher);<z>
b) {<z>
);<z>
= b.cacheWide;<z>
beforeInvocation = b.beforeInvocation;<z>
void emitBindCallbacks(ClassEmitter ce) {<z>
ce.begin_method(Constants.PRIVATE_FINAL_STATIC,<z>
);<z>
= e.make_local();<z>
);<z>
;<z>
;<z>
make_label();<z>
);<z>
e.getfield(BOUND_FIELD);<z>
(CodeEmitter.NE, end);<z>
load_local(me);<z>
(1);<z>
(BOUND_FIELD);<z>
;<z>
.invoke_virtual(THREAD_LOCAL, THREAD_LOCAL_GET);<z>
.dup();<z>
e.make_label();<z>
);<z>
;<z>
(STATIC_CALLBACKS_FIELD);<z>
dup();<z>
;<z>
.pop();<z>
e.goTo(end);<z>
found_callback);<z>
;<z>
me);<z>
();<z>
i >= 0; i--) {<z>
i != 0) {<z>
;<z>
aaload(i);<z>
e.checkcast(callbackTypes[i]);<z>
(i));<z>
mark(end);<z>
return_value();<z>
e.end_method();<z>
(HttpClientResponse response) {<z>
instanceof reactor.netty.ChannelOperationsId id) {<z>
asShortText());<z>
return null;<z>
attributeName, String defaultValue) {<z>
(attributeName);<z>
value.isEmpty()) {<z>
= defaultValue;<z>
;<z>
{<z>
;<z>
);<z>
this.charsToProcess.length;<z>
this.pos = 0;<z>
static WebApplicationContext findWebApplicationContext(ServletContext sc) {<z>
= getWebApplicationContext(sc);<z>
) {<z>
String> attrNames = sc.getAttributeNames();<z>
attrNames.hasMoreElements()) {<z>
();<z>
(attrName);<z>
(attrValue instanceof WebApplicationContext) {<z>
wac != null) {<z>
"No unique WebApplicationContext found: more than one " +<z>
);<z>
) attrValue;<z>
;<z>
modelAttribute(Object attribute) {<z>
"Attribute must not be null");<z>
) attribute).isEmpty()) {<z>
;<z>
Conventions.getVariableName(attribute), attribute);<z>
Exception {<z>
);<z>
engine.resolveTemplate(getUrl());<z>
(IOException ex) {<z>
;<z>
;<z>
throws EvaluationException {<z>
notNull(context, "EvaluationContext is required");<z>
compiledAst;<z>
compiledAst != null) {<z>
).getValue(), context);<z>
null) {<z>
expectedResultType);<z>
T) result;<z>
catch (Throwable ex) {<z>
) {<z>
.compiledAst = null;<z>
this.interpretedCount.set(0);<z>
.EXCEPTION_RUNNING_COMPILED_EXPRESSION);<z>
new ExpressionState(context, this.configuration);<z>
;<z>
checkCompile(expressionState);<z>
);<z>
() {<z>
)) {<z>
);<z>
forEach((name, values) -> {<z>
isEmpty(values)) {<z>
length() != 0) {<z>
('&');<z>
(name);<z>
) {<z>
) != 0) {<z>
queryBuilder.append('&');<z>
queryBuilder.append(name);<z>
) {<z>
.toString());<z>
});<z>
();<z>
null;<z>
pathIndex, PathPattern.MatchingContext matchingContext) {<z>
) {<z>
return false;<z>
.determineRemainingPath) {<z>
remainingPathIndex = matchingContext.pathLength;<z>
return true;<z>
JMException {<z>
null, "No MBeanServer set");<z>
ObjectName actualObjectName;<z>
this.registeredBeans) {<z>
ObjectInstance registeredBean = null;<z>
, objectName);<z>
catch (InstanceAlreadyExistsException ex) {<z>
== RegistrationPolicy.IGNORE_EXISTING) {<z>
)) {<z>
;<z>
RegistrationPolicy.REPLACE_EXISTING) {<z>
(logger.isDebugEnabled()) {<z>
+ "]");<z>
);<z>
(mbean, objectName);<z>
InstanceNotFoundException ex2) {<z>
isInfoEnabled()) {<z>
;<z>
throw ex;<z>
;<z>
getObjectName() : null);<z>
if (actualObjectName == null) {<z>
objectName;<z>
add(actualObjectName);<z>
(actualObjectName, mbean);<z>
BeanFactory beanFactory) throws BeansException {<z>
beanFactory instanceof ConfigurableBeanFactory) {<z>
(ConfigurableBeanFactory) beanFactory).getTypeConverter();<z>
SimpleTypeConverter) {<z>
;<z>
{<z>
) {<z>
.logPrefix +<z>
);<z>
request(this.publisher, n);<z>
) throws JMSException, MessageConversionException {<z>
.marshaller != null, "No Marshaller set");<z>
targetType) {<z>
case TEXT:<z>
marshaller);<z>
BYTES:<z>
, session, this.marshaller);<z>
, this.targetType);<z>
) {<z>
+ "]", ex);<z>
() {<z>
() -> {<z>
compareAndSet(false, true)) {<z>
this.connection));<z>
);<z>
});<z>
BeanFactory beanFactory, @Nullable ControllerAdvice controllerAdvice) {<z>
beanName, "Bean name must contain text");<z>
;<z>
) -> "BeanFactory [" + beanFactory +<z>
);<z>
= beanName;<z>
);<z>
.beanType = getBeanType(beanName, beanFactory);<z>
(controllerAdvice != null ? createBeanTypePredicate(controllerAdvice) :<z>
));<z>
beanFactory = beanFactory;<z>
ResourceArrayPropertyEditor(<z>
, @Nullable PropertyResolver propertyResolver) {<z>
, propertyResolver, true);<z>
{<z>
= ele.getAttribute(RESOURCE_ATTRIBUTE);<z>
) {<z>
);<z>
);<z>
);<z>
false;<z>
.toURI(location).isAbsolute();<z>
{<z>
if (absoluteLocation) {<z>
, actualResources);<z>
isTraceEnabled()) {<z>
);<z>
{<z>
(<z>
;<z>
;<z>
location);<z>
{<z>
(relativeResource);<z>
actualResources.add(relativeResource);<z>
();<z>
).getReader().loadBeanDefinitions(<z>
);<z>
) {<z>
location + "]");<z>
{<z>
ex);<z>
ex) {<z>
getReaderContext().error(<z>
+ location + "]", ele, ex);<z>
new Resource[0]);<z>
, extractSource(ele));<z>
target, Deque<Session> sessionList) {<z>
;<z>
(SessionProxy.class);<z>
instanceof QueueSession) {<z>
class);<z>
instanceof TopicSession) {<z>
TopicSession.class);<z>
(),<z>
));<z>
, UnsupportedEncodingException {<z>
notNull(cc, "Cc address must not be null");<z>
) != null ?<z>
) :<z>
(cc, personal));<z>
context) throws EvaluationException {<z>
(context, "EvaluationContext is required");<z>
compiledAst;<z>
) {<z>
context);<z>
(Throwable ex) {<z>
) {<z>
= null;<z>
(0);<z>
);<z>
.configuration);<z>
expressionState);<z>
);<z>
return result;<z>
() {<z>
if (this.taskScheduler == null) {<z>
);<z>
);<z>
if (this.triggerTasks != null) {<z>
TriggerTask task : this.triggerTasks) {<z>
;<z>
this.cronTasks != null) {<z>
) {<z>
scheduleCronTask(task));<z>
!= null) {<z>
{<z>
addScheduledTask(scheduleFixedRateTask(task));<z>
this.fixedDelayTasks != null) {<z>
task : this.fixedDelayTasks) {<z>
(scheduleFixedDelayTask(task));<z>
) {<z>
!= null) {<z>
toString();<z>
();<z>
TransportRequest transportRequest,<z>
, final HttpHeaders headers, final XhrClientSockJsSession session,<z>
final SettableListenableFuture<WebSocketSession> connectFuture) {<z>
isTraceEnabled()) {<z>
+ url);<z>
clientCallback = new ClientCallback<>() {<z>
ClientConnection connection) {<z>
;<z>
(HttpHeaders.HOST);<z>
url.getHost());<z>
;<z>
;<z>
,<z>
, connectFuture));<z>
{<z>
);<z>
;<z>
Marshaller marshaller, Unmarshaller unmarshaller) {<z>
.notNull(marshaller, "Marshaller must not be null");<z>
, "Unmarshaller must not be null");<z>
.marshaller = marshaller;<z>
= unmarshaller;<z>
beanThatBroadcasts) {<z>
= beanThatBroadcasts;<z>
.class);<z>
!beans.isEmpty()) {<z>
new IllegalStateException("Shouldn't have found any BeanThatListens instances");<z>
{<z>
.matches(annotationType) ||<z>
)) {<z>
;<z>
RepeatableContainers.none())<z>
annotationType).withNonMergedAttributes()<z>
;<z>
) {<z>
= new StringBuilder();<z>
builder.append(this.firstPos);<z>
.append('-');<z>
if (this.lastPos != null) {<z>
);<z>
.toString();<z>
) {<z>
this.future;<z>
if (future != null) {<z>
future.cancel(true);<z>
final View UNRESOLVED_VIEW = new View() {<z>
) {<z>
;<z>
, HttpServletResponse response) {<z>
protected void removeSingleton(String beanName) {<z>
{<z>
.removeSingleton(beanName);<z>
(beanName);<z>
newValue) {<z>
;<z>
(this.collection instanceof List list) {<z>
null) {<z>
newValue, TypeDescriptor.forObject(newValue),<z>
));<z>
set(this.index, newValue);<z>
INDEXING_NOT_SUPPORTED_FOR_TYPE,<z>
;<z>
Consumer<T> consumer) {<z>
this.content);<z>
);<z>
return this.bodySpec;<z>
result) {<z>
result.getClass());<z>
adapter != null) {<z>
new EventPublicationSubscriber());<z>
true;<z>
false;<z>
HttpServletRequest request, @Nullable String extension) {<z>
StringUtils.hasText(extension)) {<z>
;<z>
(Locale.ENGLISH);<z>
extension)) {<z>
return true;<z>
.getAttribute(HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE);<z>
endsWith("." + extension)) {<z>
;<z>
)) {<z>
HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE;<z>
MediaType>) request.getAttribute(name);<z>
) {<z>
;<z>
request, extension);<z>
;<z>
{<z>
();<z>
.state(url != null, "'url' not set");<z>
(url, locale);<z>
true;<z>
FileNotFoundException ex) {<z>
return false;<z>
catch (ParseException ex) {<z>
;<z>
IOException ex) {<z>
+ "]", ex);<z>
filename) {<z>
) == -1) {<z>
return filename;<z>
escaped = false;<z>
new StringBuilder();<z>
filename.length() ; i++) {<z>
);<z>
escaped && c == '"') {<z>
;<z>
.append(c);<z>
escaped && c == '\\');<z>
) {<z>
) - 1);<z>
sb.toString();<z>
(int index) {<z>
index) {<z>
)) {<z>
SHORT;<z>
DateFormat.MEDIUM;<z>
;<z>
: return DateFormat.FULL;<z>
1;<z>
"'");<z>
processingInstruction(String target, String data) {<z>
= getParent();<z>
, data);<z>
.appendChild(pi);<z>
public UndertowXhrTransport(OptionMap optionMap) throws IOException {<z>
.notNull(optionMap, "OptionMap is required");<z>
optionMap;<z>
.getInstance();<z>
(optionMap);<z>
, 1024, -1, 2);<z>
) {<z>
(), "Already immutable");<z>
) {<z>
);<z>
null) {<z>
;<z>
nativeHeaders);<z>
1));<z>
values.add(value);<z>
true);<z>
{<z>
.getResource(this);<z>
null) {<z>
name);<z>
.remove(name);<z>
null;<z>
getModelAttributes(<z>
model, ServerWebExchange exchange) {<z>
{<z>
containsKey(SPRING_MACRO_REQUEST_CONTEXT_ATTRIBUTE)) {<z>
throw new IllegalStateException(<z>
+<z>
);<z>
HashMap<>());<z>
put(SPRING_MACRO_REQUEST_CONTEXT_ATTRIBUTE, new RequestContext(<z>
getRequestDataValueProcessor()));<z>
super.getModelAttributes(attributes, exchange);<z>
getModelAttributes(model, exchange);<z>
public int size() {<z>
.names();<z>
int size = 0;<z>
)) {<z>
;<z>
nextElement();<z>
;<z>
(String... commentPrefixes) {<z>
(commentPrefixes, "'commentPrefixes' must not be null or empty");<z>
noNullElements(commentPrefixes, "'commentPrefixes' must not contain null elements");<z>
.commentPrefixes = commentPrefixes;<z>
(AspectJExpressionPointcut pointcut) {<z>
,<z>
declarationOrder, this.aspectName);<z>
null ? advice : EMPTY_ADVICE);<z>
static TemporalAdjuster weekdayNearestTo(int dayOfMonth) {<z>
return temporal -> {<z>
Type.DAY_OF_MONTH.get(temporal);<z>
temporal.get(ChronoField.DAY_OF_WEEK);<z>
||<z>
- 1) ||<z>
&& current == dayOfMonth + 1) ||<z>
current == 3)) {<z>
return temporal;<z>
count = 0;<z>
++ < CronExpression.MAX_ATTEMPTS) {<z>
dayOfMonth);<z>
().adjustInto(temporal);<z>
get(temporal);<z>
dayOfMonth) {<z>
(ChronoField.DAY_OF_WEEK);<z>
== 6) {<z>
if (dayOfMonth != 1) {<z>
ChronoUnit.DAYS);<z>
ChronoUnit.DAYS);<z>
(dayOfWeek == 7) {<z>
;<z>
;<z>
null;<z>
) {<z>
beanDefinition.getParentName();<z>
parentName != null) {<z>
= resolveStringValue(parentName);<z>
)) {<z>
.setParentName(resolvedName);<z>
undeliveredMessages, String message) {<z>
" for session "<z>
+ ": " + message, sessionId, null);<z>
= undeliveredMessages;<z>
) {<z>
if (sqlProvider instanceof SqlProvider) {<z>
).getSql();<z>
null;<z>
(HttpServerRequest request) {<z>
) {<z>
) ?<z>
) request).asLongText() :<z>
());<z>
;<z>
, HttpServletRequest request) {<z>
path;<z>
startsWith("/")) {<z>
request);<z>
;<z>
request);<z>
= StringUtils.applyRelativePath(requestPath, path);<z>
(absolutePath);<z>
) {<z>
deferredProperties.values()) {<z>
instanceof List) {<z>
.value);<z>
if (dp.value instanceof Map) {<z>
, ?>) dp.value);<z>
apply();<z>
;<z>
) {<z>
&&<z>
) &&<z>
) &&<z>
.getPropertyEditorClass()) &&<z>
() == otherPd.isConstrained());<z>
throws IOException, ClassNotFoundException {<z>
;<z>
ConcurrentHashMap<>(32);<z>
(Matcher<? super T> matcher) {<z>
-> {<z>
getRequest();<z>
);<z>
(), matcher);<z>
final synchronized void compile() throws InvalidDataAccessApiUsageException {<z>
(!isCompiled()) {<z>
) {<z>
;<z>
;<z>
IllegalArgumentException ex) {<z>
(ex.getMessage());<z>
compileInternal();<z>
;<z>
) {<z>
) ? "function" : "procedure") +<z>
" [" + getProcedureName() + "] compiled");<z>
(BeanDefinition definition) {<z>
;<z>
.SCOPE_PROTOTYPE);<z>
AnnotatedBeanDefinition annDef) {<z>
);<z>
= null;<z>
annTypes) {<z>
getMetadata().getMetaAnnotationTypes(annType);<z>
("jakarta.inject.Scope")) {<z>
null) {<z>
new IllegalStateException("Found ambiguous scope annotations on bean class [" +<z>
+ "]: " + found + ", " + annType);<z>
annType;<z>
= resolveScopeName(annType);<z>
if (scopeName == null) {<z>
new IllegalStateException(<z>
+ annType);<z>
metadata.setScopeName(scopeName);<z>
;<z>
JmsException {<z>
execute(session -> {<z>
(session, destinationName);<z>
;<z>
;<z>
}, false);<z>
{<z>
) {<z>
;<z>
return this.mapping.isSynthesizable();<z>
throws BeansException {<z>
(isCache()) {<z>
();<z>
private boolean maybeBindThisJoinPoint() {<z>
[0] == ProceedingJoinPoint.class)) {<z>
(0, THIS_JOIN_POINT);<z>
;<z>
false;<z>
String path, ServerWebExchange exchange) {<z>
().getPath();<z>
StringUtils.applyRelativePath(requestPath, path));<z>
StringUtils.cleanPath(absolutePath);<z>
{<z>
null) {<z>
;<z>
) {<z>
getDefaultContentType(t);<z>
{<z>
MediaType mediaType = getDefaultContentType(t);<z>
null ? mediaType : contentTypeToUse);<z>
null) {<z>
(contentTypeToUse.getCharset() == null) {<z>
Charset defaultCharset = getDefaultCharset();<z>
if (defaultCharset != null) {<z>
, defaultCharset);<z>
.setContentType(contentTypeToUse);<z>
(HttpHeaders.TRANSFER_ENCODING)) {<z>
headers.getContentType());<z>
(contentLength != null) {<z>
contentLength);<z>
@Nullable ApplicationContext parent)<z>
{<z>
(parent);<z>
paths, "Path array must not be null");<z>
notNull(clazz, "Class argument must not be null");<z>
= new Resource[paths.length];<z>
i < paths.length; i++) {<z>
);<z>
;<z>
determineCharset() {<z>
();<z>
contentType != null) {<z>
getCharset();<z>
charset != null) {<z>
return charset;<z>
encoding = this.multipartRequest.getCharacterEncoding();<z>
.forName(encoding) : FORM_CHARSET);<z>
Nullable String requestingBeanName)<z>
NoSuchBeanDefinitionException {<z>
unitName != null ? unitName : "");<z>
isEmpty()) {<z>
this.defaultPersistenceUnitName;<z>
)) {<z>
, requestingBeanName);<z>
return findDefaultEntityManagerFactory(requestingBeanName);<z>
request, ServerHttpResponse response) {<z>
pathWithinApplication().value();<z>
)<z>
startsWith(entry.getKey()))<z>
()<z>
{<z>
;<z>
);<z>
response);<z>
() -> {<z>
);<z>
();<z>
;<z>
public void setDefaultProfiles(String... profiles) {<z>
.notNull(profiles, "Profile array must not be null");<z>
defaultProfiles) {<z>
.clear();<z>
profiles) {<z>
;<z>
.defaultProfiles.add(profile);<z>
result) throws Exception {<z>
request = result.getRequest();<z>
, request.isAsyncStarted());<z>
;<z>
asyncResult = result.getAsyncResult(0);<z>
IllegalStateException ex) {<z>
"Async result", asyncResult);<z>
timeZoneString) {<z>
;<z>
.startsWith("GMT")) {<z>
IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'");<z>
;<z>
() {<z>
type instanceof TypeVariable) {<z>
(this.variableResolver == null) {<z>
true;<z>
.type;<z>
= this.variableResolver.resolveVariable(variable);<z>
.isUnresolvableTypeVariable()) {<z>
true;<z>
false;<z>
> resolveUrlPathInternal(String resourceUrlPath,<z>
ResourceResolverChain chain) {<z>
RESOLVED_URL_PATH_CACHE_KEY_PREFIX + resourceUrlPath;<z>
String.class);<z>
if (cachedUrlPath != null) {<z>
("Path resolved from cache");<z>
cachedUrlPath);<z>
)<z>
);<z>
throws JmsException {<z>
defaultQueue = getDefaultQueue();<z>
!= null) {<z>
action);<z>
(getRequiredDefaultDestinationName(), action);<z>
Method getPreparedMethod() throws IllegalStateException {<z>
if (this.methodObject == null) {<z>
IllegalStateException("prepare() must be called prior to invoke() on MethodInvoker");<z>
;<z>
> beanClass, int autowireMode, boolean dependencyCheck) {<z>
);<z>
);<z>
setAutowireMode(autowireMode);<z>
&& getResolvedAutowireMode() != AUTOWIRE_CONSTRUCTOR) {<z>
(DEPENDENCY_CHECK_OBJECTS);<z>
{<z>
dataSource);<z>
(lazyInit);<z>
();<z>
(MethodParameter methodParam, @Nullable RequestPart requestPart) {<z>
requestPart.name() : "");<z>
(partName.isEmpty()) {<z>
methodParam.getParameterName();<z>
null) {<z>
new IllegalArgumentException("Request part name for argument type [" +<z>
() +<z>
);<z>
;<z>
metadataReaderFactory)<z>
throws IOException {<z>
().getClassName();<z>
world.resolve(className);<z>
.typePattern.matchesStatically(resolvedType);<z>
{<z>
element.hasAttribute("validator")) {<z>
element.getAttribute("validator"));<z>
) {<z>
validatorDef = new RootBeanDefinition(<z>
);<z>
validatorDef.setSource(source);<z>
validatorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
validatorDef);<z>
(new BeanComponentDefinition(validatorDef, validatorName));<z>
RuntimeBeanReference(validatorName);<z>
null;<z>
) {<z>
{<z>
) {<z>
return true;<z>
;<z>
applyTransactionTimeout(Query query, EntityManagerFactory emf) {<z>
;<z>
&& emHolder.hasTimeout()) {<z>
int) emHolder.getTimeToLiveInMillis();<z>
);<z>
(IllegalArgumentException ex) {<z>
throws ParseException {<z>
>();<z>
= context.getExpressionPrefix();<z>
.getExpressionSuffix();<z>
;<z>
) {<z>
(prefix, startIdx);<z>
(prefixIndex >= startIdx) {<z>
if (prefixIndex > startIdx) {<z>
)));<z>
;<z>
afterPrefixIndex);<z>
== -1) {<z>
new ParseException(expressionString, prefixIndex,<z>
+ "' for expression starting at character " +<z>
;<z>
{<z>
(expressionString, prefixIndex,<z>
suffix +<z>
);<z>
prefix.length(), suffixIndex);<z>
);<z>
expr.isEmpty()) {<z>
,<z>
"No expression defined within delimiter '" + prefix + suffix +<z>
prefixIndex);<z>
context));<z>
();<z>
(startIdx)));<z>
startIdx = expressionString.length();<z>
(new Expression[0]);<z>
(Class<?> clazz) {<z>
);<z>
return true;<z>
) {<z>
;<z>
) {<z>
index.get(stereotype);<z>
if (candidates != null) {<z>
.parallelStream()<z>
(t -> t.match(basePackage))<z>
type)<z>
());<z>
();<z>
String key) {<z>
.getProperty(key);<z>
value == null) {<z>
key);<z>
{<z>
"': " + ex);<z>
value;<z>
ConverterRegistry converterRegistry) {<z>
NumberToNumberConverterFactory());<z>
);<z>
.class, new ObjectToStringConverter());<z>
));<z>
.class, new ObjectToStringConverter());<z>
new NumberToCharacterConverter());<z>
(new CharacterToNumberFactory());<z>
(new StringToBooleanConverter());<z>
String.class, new ObjectToStringConverter());<z>
StringToEnumConverterFactory());<z>
converterRegistry));<z>
converterRegistry.addConverterFactory(new IntegerToEnumConverterFactory());<z>
));<z>
);<z>
);<z>
new StringToCharsetConverter());<z>
String.class, new ObjectToStringConverter());<z>
());<z>
String.class, new ObjectToStringConverter());<z>
StringToPropertiesConverter());<z>
(new PropertiesToStringConverter());<z>
new StringToUUIDConverter());<z>
));<z>
) {<z>
.delegate.trySplit();<z>
split != null) {<z>
UnmodifiableEntrySpliterator<>(split);<z>
null;<z>
{<z>
;<z>
{<z>
.FORWARD_REQUEST_URI_ATTRIBUTE);<z>
null) {<z>
.getRequestURI();<z>
;<z>
public String toString() {<z>
(this)<z>
)<z>
, ObjectUtils.nullSafeToString(this.locations))<z>
ObjectUtils.nullSafeToString(this.classes))<z>
contextInitializerClasses))<z>
)<z>
this.propertySourceLocations))<z>
this.propertySourceProperties))<z>
.append("contextCustomizers", this.contextCustomizers)<z>
contextLoader))<z>
)<z>
;<z>
) {<z>
= new ByteArrayOutputStream(256);<z>
store(os, null);<z>
toString(StandardCharsets.ISO_8859_1);<z>
catch (IOException ex) {<z>
);<z>
public void destroy() {<z>
this.properlyDestroyed = true;<z>
Thread thread = new Thread() {<z>
void run() {<z>
(applicationContext.getBean("messageSource") instanceof StaticMessageSource,<z>
;<z>
getBean("service2");<z>
properlyDestroyed = false;<z>
ex) {<z>
();<z>
join();<z>
(InterruptedException ex) {<z>
interrupt();<z>
{<z>
null) {<z>
= separator.trim();<z>
) {<z>
) {<z>
.length()));<z>
int opcode, final Label label) {<z>
) {<z>
, label);<z>
expressions) {<z>
"Must specify at least one profile");<z>
= new Profiles[expressions.length];<z>
; i++) {<z>
= parseExpression(expressions[i]);<z>
expressions, parsed);<z>
(SerializationConfig config,<z>
) {<z>
;<z>
static boolean exists(Object vfsResource) {<z>
Boolean) invokeVfsMethod(VIRTUAL_FILE_METHOD_EXISTS, vfsResource);<z>
ex) {<z>
;<z>
() {<z>
.jackson2JsonDecoder == null) {<z>
jackson2JsonDecoder = new Jackson2JsonDecoder();<z>
.jackson2JsonDecoder;<z>
(final Object... args) throws BeansException {<z>
optional) {<z>
.beanName, args);<z>
= new DependencyDescriptor(this.descriptor) {<z>
{<z>
beanFactory.getBean(beanName, args);<z>
null);<z>
result == null) {<z>
descriptor.getResolvableType());<z>
result;<z>
.visitTypeInsn(CHECKCAST, "[S");<z>
mv.visitTypeInsn(CHECKCAST, "[B");<z>
mv.visitTypeInsn(CHECKCAST, "[C");<z>
mv.visitTypeInsn(CHECKCAST, "java/util/List");<z>
"get", "(Ljava/lang/Object;)Ljava/lang/Object;", true);<z>
servletContext) throws BeansException {<z>
null) {<z>
;<z>
;<z>
{<z>
new StringBuilder();<z>
);<z>
: getConverterStrings()) {<z>
).append('\n');<z>
builder.toString();<z>
public ConstructorArgumentValues getConstructorArgumentValues() {<z>
(this.constructorArgumentValues == null) {<z>
();<z>
.constructorArgumentValues;<z>
(HttpServletRequest request) throws IOException {<z>
= new ByteArrayOutputStream(1024);<z>
writer = new OutputStreamWriter(bos, FORM_CHARSET);<z>
request.getParameterMap();<z>
);) {<z>
= entryIterator.next();<z>
getKey();<z>
asList(entry.getValue());<z>
; valueIterator.hasNext();) {<z>
.next();<z>
(name, FORM_CHARSET));<z>
{<z>
'=');<z>
);<z>
{<z>
;<z>
.hasNext()) {<z>
;<z>
;<z>
(bos.toByteArray());<z>
in, OutputStream out) throws IOException {<z>
Assert.notNull(in, "No input byte array specified");<z>
notNull(out, "No OutputStream specified");<z>
in);<z>
(out);<z>
{<z>
new StringBuilder("class [");<z>
);<z>
).append(this.scope);<z>
.append(this.abstractFlag);<z>
this.lazyInit);<z>
this.autowireMode);<z>
).append(this.dependencyCheck);<z>
).append(this.autowireCandidate);<z>
;<z>
(this.factoryBeanName);<z>
append(this.factoryMethodName);<z>
(this.initMethodName);<z>
).append(this.destroyMethodName);<z>
) {<z>
resource.getDescription());<z>
);<z>
Publisher<DataBuffer> input, ResolvableType elementType,<z>
Map<String, Object> hints) {<z>
this.maxInMemorySize)<z>
mimeType, hints)));<z>
) throws TransactionException {<z>
conHolder = getConnectionHolderForSavepoint();<z>
) {<z>
NestedTransactionNotSupportedException(<z>
"Cannot create a nested transaction because savepoints are not supported by your JDBC driver");<z>
conHolder.isRollbackOnly()) {<z>
(<z>
;<z>
conHolder.createSavepoint();<z>
{<z>
);<z>
static int computeAnnotationsSize(<z>
final AnnotationWriter lastRuntimeVisibleAnnotation,<z>
,<z>
lastRuntimeVisibleTypeAnnotation,<z>
lastRuntimeInvisibleTypeAnnotation) {<z>
;<z>
lastRuntimeVisibleAnnotation != null) {<z>
lastRuntimeVisibleAnnotation.computeAnnotationsSize(<z>
;<z>
if (lastRuntimeInvisibleAnnotation != null) {<z>
.computeAnnotationsSize(<z>
);<z>
if (lastRuntimeVisibleTypeAnnotation != null) {<z>
computeAnnotationsSize(<z>
RUNTIME_VISIBLE_TYPE_ANNOTATIONS);<z>
) {<z>
computeAnnotationsSize(<z>
;<z>
return size;<z>
property, boolean ignoreCase, boolean ascending) {<z>
;<z>
;<z>
.ascending = ascending;<z>
Matcher<? super Integer> matcher)<z>
{<z>
encoding, NodeList.class);<z>
.expression;<z>
getLength() : 0, matcher);<z>
, int position, String message) {<z>
);<z>
this.expressionString = expressionString;<z>
position = position;<z>
(String value, String charset) {<z>
, charset, null);<z>
) {<z>
(ex);<z>
transaction) {<z>
JtaTransactionObject txObject = (JtaTransactionObject) transaction;<z>
.STATUS_NO_TRANSACTION);<z>
{<z>
("JTA failure on getStatus", ex);<z>
Nullable Object rootObject)<z>
throws EvaluationException {<z>
(String.class);<z>
setValue(List<String> value) {<z>
headers.getValuesList(this.key);<z>
.put(this.key, value);<z>
previousValues;<z>
@Nullable TimeZone timeZone) {<z>
.notNull(locale, "Locale must not be null");<z>
;<z>
this.timeZone = timeZone;<z>
afterCompletion(<z>
response, Object handler, Exception ex)<z>
{<z>
request.getAttribute("test1y") == null) {<z>
ServletException("Wrong interceptor order");<z>
("test2y") == null) {<z>
;<z>
);<z>
) {<z>
.lifecycleMonitor) {<z>
this.maxMessagesPerTask;<z>
public Predicate<String> getCandidateFilter() {<z>
;<z>
this.deferredImports) {<z>
;<z>
selectorFilter != null) {<z>
or(selectorFilter);<z>
return mergedFilter;<z>
) {<z>
method;<z>
null) {<z>
;<z>
;<z>
.isPublic(methodModifiers) ||<z>
))) {<z>
false;<z>
) {<z>
isCompilable()) {<z>
return false;<z>
return true;<z>
mv, CodeFlow cf) {<z>
this.cachedReadAccessor;<z>
accessorToUse instanceof CompilablePropertyAccessor)) {<z>
;<z>
Label skipIfNull = null;<z>
this.nullSafe) {<z>
;<z>
();<z>
();<z>
visitJumpInsn(IFNONNULL, continueLabel);<z>
(mv, this.exitTypeDescriptor);<z>
visitJumpInsn(GOTO, skipIfNull);<z>
(continueLabel);<z>
name, mv, cf);<z>
this.exitTypeDescriptor);<z>
{<z>
mv, this.originalPrimitiveExitTypeDescriptor);<z>
{<z>
visitLabel(skipIfNull);<z>
XmlMappingException {<z>
marshaller = createMarshaller();<z>
{<z>
.setAttachmentMarshaller(new Jaxb2AttachmentMarshaller(mimeContainer));<z>
isStaxResult(result)) {<z>
graph, result);<z>
marshal(graph, result);<z>
JAXBException ex) {<z>
);<z>
) throws IOException {<z>
new ArrayList<>(classNames.length);<z>
) {<z>
, filter));<z>
;<z>
(HttpServletRequest request) {<z>
();<z>
.contains(FORM_CONTENT_TYPE) &&<z>
;<z>
{<z>
);<z>
part, "'part' must not be null");<z>
) {<z>
class);<z>
isEmpty()) {<z>
headers -> {<z>
headers());<z>
).getFilename();<z>
, filename);<z>
});<z>
{<z>
contentType(contentType);<z>
return builder;<z>
?,?> publisherEntity) {<z>
publisherEntity);<z>
{<z>
;<z>
.parts.add(name, builder);<z>
return builder;<z>
partBody;<z>
partHeaders = null;<z>
HttpEntity<?> httpEntity) {<z>
);<z>
HttpHeaders();<z>
);<z>
= part;<z>
instanceof Publisher) {<z>
(name, partHeaders, partBody);<z>
) {<z>
(contentType);<z>
.parts.add(name, builder);<z>
builder;<z>
beanName) throws BeansException {<z>
afterInitialization) {<z>
;<z>
bean;<z>
) {<z>
this.timeoutScheduler != null) {<z>
if (logger.isTraceEnabled()) {<z>
+ this.timeoutValue + " ms.");<z>
.timeoutValue);<z>
);<z>
(logger.isTraceEnabled()) {<z>
logger.trace("Connect timeout task not scheduled (no TaskScheduler configured).");<z>
() {<z>
inUse = true;<z>
<E> iterator : this.iterators) {<z>
.hasNext()) {<z>
return true;<z>
false;<z>
<T> typeReference) {<z>
(typeReference));<z>
ERROR_MAPPER)<z>
.onErrorMap(DecodingException.class, DECODING_MAPPER);<z>
boolean inCreation) {<z>
beanName, "Bean name must not be null");<z>
if (!inCreation) {<z>
inCreationCheckExclusions.add(beanName);<z>
.inCreationCheckExclusions.remove(beanName);<z>
{<z>
Proxy.newProxyInstance(<z>
.class.getClassLoader(),<z>
class},<z>
;<z>
int indentAmount) {<z>
transformer, "Transformer must not be null");<z>
< 0) {<z>
+ indentAmount);<z>
, "yes");<z>
));<z>
IllegalArgumentException ignored) {<z>
() {<z>
StompDecoder();<z>
{<z>
.headerInitializer);<z>
> codec = new StompReactorNettyCodec(decoder);<z>
this.relayPort, codec);<z>
()));<z>
return client;<z>
void afterSingletonsInstantiated() {<z>
.beanFactory;<z>
null, "No ConfigurableListableBeanFactory set");<z>
class);<z>
for (String beanName : beanNames) {<z>
beanName)) {<z>
> type = null;<z>
AutoProxyUtils.determineTargetClass(beanFactory, beanName);<z>
Throwable ex) {<z>
)) {<z>
"Could not resolve target class for bean with name '" + beanName + "'", ex);<z>
) {<z>
)) {<z>
determineTargetClass(<z>
);<z>
) {<z>
= targetClass;<z>
(Throwable ex) {<z>
) {<z>
);<z>
processBean(beanName, type);<z>
Throwable ex) {<z>
throw new BeanInitializationException("Failed to process @EventListener " +<z>
+ beanName + "'", ex);<z>
status, @Nullable String reason) {<z>
"");<z>
notNull(status, "HttpStatus is required");<z>
;<z>
reason;<z>
Object o) {<z>
?, ?> entry) {<z>
, Restructure.NEVER);<z>
ref.get() : null);<z>
{<z>
, otherEntry.getValue());<z>
return false;<z>
(ExpressionState state) throws EvaluationException {<z>
();<z>
.getValueInternal(state).getValue();<z>
.leftActualDescriptor = CodeFlow.toDescriptorFromObject(left);<z>
= CodeFlow.toDescriptorFromObject(right);<z>
) {<z>
|| rightNumber instanceof BigDecimal) {<z>
, BigDecimal.class);<z>
class);<z>
;<z>
Double || rightNumber instanceof Double) {<z>
.doubleValue());<z>
{<z>
);<z>
instanceof BigInteger || rightNumber instanceof BigInteger) {<z>
;<z>
.class);<z>
rightBigInteger) <= 0);<z>
Long || rightNumber instanceof Long) {<z>
) <= rightNumber.longValue());<z>
|| rightNumber instanceof Integer) {<z>
<= rightNumber.intValue());<z>
instanceof Short || rightNumber instanceof Short) {<z>
());<z>
instanceof Byte || rightNumber instanceof Byte) {<z>
());<z>
;<z>
<= 0);<z>
int... args) {<z>
= 0;<z>
) {<z>
;<z>
sum;<z>
ServerWebExchange exchange,<z>
chain) {<z>
(exchange, requestPath, locations)<z>
(() -> {<z>
);<z>
!= null) {<z>
;<z>
);<z>
));<z>
public String getPersistenceUnitName() {<z>
persistenceUnitInfo != null) {<z>
.persistenceUnitInfo.getPersistenceUnitName();<z>
();<z>
protected void cancel() {<z>
isTraceEnabled()) {<z>
"cancel [" + this.state + "]");<z>
this.subscription != null) {<z>
cancel();<z>
{<z>
descriptor.getSerialName());<z>
INSTANCE)) {<z>
;<z>
++) {<z>
.getElementDescriptor(i);<z>
, alreadyProcessed)) {<z>
return true;<z>
false;<z>
<WebSession> updateLastAccessTime(WebSession session) {<z>
() -> {<z>
.class, session);<z>
;<z>
session;<z>
);<z>
(StreamSinkChannel destination) {<z>
this.count > 0) {<z>
this.position, this.count);<z>
) {<z>
position += len;<z>
.count -= len;<z>
();<z>
.success();<z>
ex) {<z>
ex);<z>
static ParsedSql parseSqlStatement(String sql) {<z>
, "SQL must not be null");<z>
();<z>
new StringBuilder(sql);<z>
;<z>
statement = sql.toCharArray();<z>
;<z>
unnamedParameterCount = 0;<z>
totalParameterCount = 0;<z>
int escapes = 0;<z>
;<z>
i < statement.length) {<z>
;<z>
.length) {<z>
;<z>
{<z>
i = skipToPosition;<z>
if (i >= statement.length) {<z>
= statement[i];<z>
|| c == '&') {<z>
i + 1;<z>
[j] == ':') {<z>
i = i + 2;<z>
;<z>
length && statement[j] == '{') {<z>
{<z>
++;<z>
(j >= statement.length) {<z>
(<z>
"Non-terminated named parameter declaration at position " + i +<z>
;<z>
':' || statement[j] == '{') {<z>
throw new InvalidDataAccessApiUsageException(<z>
"Parameter name contains invalid character '" + statement[j] +<z>
);<z>
i > 2) {<z>
);<z>
(<z>
, parameter);<z>
= addNamedParameter(<z>
1, parameter);<z>
;<z>
statement[j])) {<z>
j++;<z>
> 1) {<z>
);<z>
namedParameterCount = addNewNamedParameter(<z>
, parameter);<z>
addNamedParameter(<z>
);<z>
;<z>
) {<z>
int j = i + 1;<z>
j] == ':') {<z>
.deleteCharAt(i - escapes);<z>
escapes++;<z>
= i + 2;<z>
i++;<z>
new ParsedSql(sqlToUse.toString());<z>
(ParameterHolder ph : parameterList) {<z>
ph.getEndIndex());<z>
);<z>
(unnamedParameterCount);<z>
parsedSql.setTotalParameterCount(totalParameterCount);<z>
;<z>
Marshaller createMarshaller() {<z>
.createMarshaller();<z>
;<z>
;<z>
{<z>
convertJaxbException(ex);<z>
.Entry<?, ?> entry) {<z>
;<z>
instanceof String strVal) {<z>
(REF_PREFIX)) {<z>
;<z>
REF_PREFIX)) {<z>
;<z>
;<z>
return val;<z>
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)<z>
{<z>
beanName, "'beanName' must not be empty");<z>
;<z>
beanDefinition);<z>
configurer) {<z>
;<z>
.notNull(configurer, "MockMvcConfigurer must not be null");<z>
;<z>
(<z>
Class<? extends TransformerFactory> transformerFactoryClass) {<z>
null) {<z>
transformerFactoryClass).newInstance();<z>
) {<z>
);<z>
TransformerFactory.newInstance();<z>
IncorrectResultSizeDataAccessException {<z>
) {<z>
);<z>
size() > 1) {<z>
, results.size());<z>
.iterator().next();<z>
loadBeanDefinitionsForConfigurationClass(<z>
ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {<z>
{<z>
configClass.getBeanName();<z>
.registry.containsBeanDefinition(beanName)) {<z>
.removeBeanDefinition(beanName);<z>
().getClassName());<z>
{<z>
configClass);<z>
.getBeanMethods()) {<z>
;<z>
));<z>
;<z>
Object... providedArgs) throws Exception {<z>
getMethodParameters();<z>
isEmpty(parameters)) {<z>
;<z>
= new Object[parameters.length];<z>
< parameters.length; i++) {<z>
parameter = parameters[i];<z>
.initParameterNameDiscovery(this.parameterNameDiscoverer);<z>
);<z>
[i] != null) {<z>
(parameter)) {<z>
MethodArgumentResolutionException(<z>
parameter, formatArgumentError(parameter, "No suitable resolver"));<z>
(parameter, message);<z>
catch (Exception ex) {<z>
{<z>
;<z>
toGenericString())) {<z>
;<z>
throw ex;<z>
;<z>
T> responseType)<z>
{<z>
);<z>
<T> responseExtractor =<z>
, getMessageConverters());<z>
POST, requestCallback, responseExtractor);<z>
> publisher) {<z>
) {<z>
;<z>
!= null) {<z>
.onComplete();<z>
);<z>
{<z>
new AbstractXmlRequestMatcher() {<z>
matchInternal(MockClientHttpRequest request) throws Exception {<z>
expectedXmlContent, request.getBodyAsString());<z>
() {<z>
(this.handler == null) {<z>
;<z>
),<z>
LOWEST_PRECEDENCE);<z>
protected void doFilterInternal(<z>
)<z>
{<z>
response);<z>
(request, attributes);<z>
filterChain.doFilter(request, response);<z>
resetContextHolders();<z>
.isTraceEnabled()) {<z>
trace("Cleared thread-bound request context: " + request);<z>
();<z>
(String style) {<z>
;<z>
0));<z>
convertStyleCharacter(style.charAt(1));<z>
) {<z>
void setMatchOptionalTrailingSeparator(boolean matchOptionalTrailingSeparator) {<z>
;<z>
caseSensitive) {<z>
);<z>
void setPathOptions(PathContainer.Options pathOptions) {<z>
;<z>
void raiseError() {<z>
(<z>
;<z>
throws IllegalStateException {<z>
null) {<z>
IllegalStateException("ApplicationEventMulticaster not initialized - " +<z>
this);<z>
;<z>
(@Nullable Object other) {<z>
other) {<z>
;<z>
other instanceof DefaultIntroductionAdvisor otherAdvisor)) {<z>
;<z>
);<z>
init(EndpointConfig config) {<z>
);<z>
applicationContext instanceof ConfigurableApplicationContext) {<z>
=<z>
ConfigurableApplicationContext) applicationContext).getBeanFactory();<z>
beanFactory.autowireBean(this);<z>
other) {<z>
;<z>
{<z>
;<z>
length < other.parameterTypes.length) {<z>
1;<z>
.parameterTypes.length) {<z>
;<z>
parameterTypes.length; i++) {<z>
));<z>
{<z>
result;<z>
;<z>
CacheMethodDetails<CacheRemoveAll> methodDetails, CacheResolver cacheResolver) {<z>
, cacheResolver);<z>
.getCacheAnnotation();<z>
;<z>
arguments) throws Throwable {<z>
(arguments, "Argument array passed to proceed cannot be null");<z>
length) {<z>
+<z>
.getArguments().length + " arguments to proceed, " +<z>
+ " arguments");<z>
;<z>
.invocableClone(arguments).proceed();<z>
binderMethods,<z>
initializer) {<z>
);<z>
emptyList());<z>
{<z>
);<z>
.getOriginalSession();<z>
{<z>
)) {<z>
debug("Rolling back JMS transaction on Session [" + session + "]");<z>
session.rollback();<z>
ex) {<z>
("Could not roll back JMS transaction", ex);<z>
RequestCallback requestCallback,<z>
responseExtractor) throws RestClientException {<z>
"URI is required");<z>
"HttpMethod is required");<z>
null;<z>
);<z>
{<z>
request);<z>
request.execute();<z>
(url, method, response);<z>
extractData(response) : null);<z>
catch (IOException ex) {<z>
= url.toString();<z>
();<z>
;<z>
.name() +<z>
ex.getMessage(), ex);<z>
(response != null) {<z>
.close();<z>
throws IllegalArgumentException {<z>
text)) {<z>
);<z>
(AddressException ex) {<z>
getMessage());<z>
setValue(null);<z>
mi) throws Throwable {<z>
;<z>
ex) {<z>
) {<z>
);<z>
throw ex;<z>
) {<z>
StringBuilder builder = new StringBuilder("<");<z>
(this.status);<z>
) {<z>
;<z>
).getReasonPhrase());<z>
);<z>
body = getBody();<z>
= getHeaders();<z>
null) {<z>
builder.append(body);<z>
.append(',');<z>
;<z>
.append('>');<z>
toString();<z>
) {<z>
notNull(next, "next statement must not be null");<z>
);<z>
.next = next;<z>
this.timeout = timeout;<z>
) {<z>
)) {<z>
, key);<z>
!= null) {<z>
(logger.isTraceEnabled()) {<z>
+ cache.getName() + "'");<z>
;<z>
;<z>
printStackTrace(PrintStream ps) {<z>
ps) {<z>
ps);<z>
(this.relatedCauses != null) {<z>
(Throwable relatedCause : this.relatedCauses) {<z>
.println("Related cause:");<z>
ps);<z>
{<z>
beanClass, SearchStrategy.TYPE_HIERARCHY)<z>
).withNonMergedAttributes();<z>
!ann.isPresent()) {<z>
return null;<z>
) ann.getSource();<z>
;<z>
)) {<z>
target.getName() + "' must be public");<z>
metadata.ManagedResource();<z>
Object> map = ann.asMap();<z>
(map.size());<z>
.forEach((attrName, attrValue) -> {<z>
(attrName)) {<z>
Object value = attrValue;<z>
) {<z>
.resolveStringValue((String) value);<z>
(new PropertyValue(attrName, value));<z>
);<z>
.setPropertyValues(new MutablePropertyValues(list));<z>
return bean;<z>
DatabaseMetaDataCallback<T> action)<z>
MetaDataAccessException {<z>
null;<z>
DataSourceUtils.getConnection(dataSource);<z>
;<z>
getMetaData();<z>
ex) {<z>
DataSourceUtils.isConnectionTransactional(con, dataSource)) {<z>
;<z>
con = null;<z>
("Failed to obtain DatabaseMetaData from transactional Connection - " +<z>
"retrying against fresh Connection", ex);<z>
getConnection();<z>
);<z>
ex;<z>
(metaData == null) {<z>
"] was null");<z>
processMetaData(metaData);<z>
catch (CannotGetJdbcConnectionException ex) {<z>
, ex);<z>
catch (SQLException ex) {<z>
;<z>
(AbstractMethodError err) {<z>
MetaDataAccessException(<z>
);<z>
(con, dataSource);<z>
Void> invalidate() {<z>
EXPIRED);<z>
getAttributes().clear();<z>
);<z>
Mono.empty();<z>
> wsListener) {<z>
;<z>
= baseDir;<z>
wsListener = wsListener;<z>
public Object getAspectCreationMutex() {<z>
beanFactory.isSingleton(this.name)) {<z>
null;<z>
instanceof ConfigurableBeanFactory) {<z>
.beanFactory).getSingletonMutex();<z>
;<z>
resolvedArgs) {<z>
getDetailedErrorMessage(bean, message));<z>
sb.append("Resolved arguments: \n");<z>
; i++) {<z>
.append("] ");<z>
i] == null) {<z>
);<z>
getName()).append("] ");<z>
[i]).append("]\n");<z>
);<z>
ServerWebExchange exchange) {<z>
;<z>
result = null;<z>
(PathPattern pattern : this.patterns) {<z>
.matches(lookupPath)) {<z>
new TreeSet<>());<z>
);<z>
return result;<z>
{<z>
().isBlockTag()) {<z>
;<z>
RestClientException {<z>
= headersExtractor();<z>
, null, headersExtractor, uriVariables);<z>
());<z>
SimpleMailMessage original) {<z>
(original, "'original' message argument must not be null");<z>
.getFrom();<z>
.replyTo = original.getReplyTo();<z>
copyOrNull(original.getTo());<z>
());<z>
= copyOrNull(original.getBcc());<z>
original.getSentDate();<z>
();<z>
original.getText();<z>
, boolean proxyTargetClass) {<z>
;<z>
ts);<z>
classLoader = this.beanClassLoader;<z>
{<z>
setInterfaces(interfaces);<z>
;<z>
) {<z>
;<z>
{<z>
;<z>
);<z>
introduction = new DelegatingIntroductionInterceptor(ts);<z>
);<z>
;<z>
return proxyFactory.getProxy(classLoader);<z>
() throws JMSException {<z>
(this.originalDisableMessageID != null) {<z>
this.originalDisableMessageID);<z>
null;<z>
!= null) {<z>
originalDisableMessageTimestamp);<z>
;<z>
(this.originalDeliveryDelay != null) {<z>
originalDeliveryDelay);<z>
null;<z>
updateStompCommandAsServerMessage() {<z>
messageType = getMessageType();<z>
) {<z>
"Unexpected message type " + messageType);<z>
);<z>
equals(command)) {<z>
;<z>
.equals(command)) {<z>
throw new IllegalStateException("Unexpected STOMP command " + command);<z>
);<z>
== null) {<z>
messageIdCounter.getAndIncrement();<z>
, messageId);<z>
configurers) {<z>
configurers)) {<z>
1) {<z>
("Only one TransactionManagementConfigurer may exist");<z>
).next();<z>
this.txManager = configurer.annotationDrivenTransactionManager();<z>
Nullable TimeUnit timeUnit) {<z>
"period must not be negative");<z>
);<z>
);<z>
) {<z>
reason.getReasonPhrase());<z>
afterConnectionClosed(this.wsSession, closeStatus);<z>
{<z>
if (logger.isWarnEnabled()) {<z>
, ex);<z>
) throws JspException {<z>
"option");<z>
);<z>
writeOptionalAttributes(tagWriter);<z>
().getEditor());<z>
;<z>
);<z>
(isSelected(value)) {<z>
, SELECTED_ATTRIBUTE);<z>
)) {<z>
tagWriter.writeAttribute(DISABLED_ATTRIBUTE, "disabled");<z>
tagWriter.appendValue(label);<z>
();<z>
JspException {<z>
if (this.bindStatus == null) {<z>
String nestedPath = getNestedPath();<z>
getPath());<z>
(PropertyAccessor.NESTED_PROPERTY_SEPARATOR)) {<z>
pathToUse.length() - 1);<z>
getRequestContext(), pathToUse, false);<z>
this.bindStatus;<z>
String name) {<z>
if (isVariableName(name)) {<z>
name;<z>
.forName(name, getAspectClassLoader());<z>
(Throwable ex) {<z>
+ name +<z>
+ ex);<z>
statusCode, String statusText,<z>
) {<z>
body, responseCharset);<z>
String includedUrl) {<z>
);<z>
) {<z>
add(includedUrl);<z>
{<z>
getValue();<z>
== null) {<z>
return "";<z>
this.numberFormat != null) {<z>
value);<z>
);<z>
] boundary) {<z>
>();<z>
(mediaType != null) {<z>
(mediaType.getParameters());<z>
boundary, StandardCharsets.US_ASCII));<z>
getCharset();<z>
!charset.equals(StandardCharsets.UTF_8) &&<z>
StandardCharsets.US_ASCII) ) {<z>
;<z>
!= null ? mediaType : MediaType.MULTIPART_FORM_DATA);<z>
params);<z>
mediaType;<z>
Exception {<z>
for (DeferredResultProcessingInterceptor interceptor : this.interceptors) {<z>
{<z>
.handleTimeout(request, deferredResult)){<z>
() {<z>
(getDistance() == 0) {<z>
;<z>
.mapping.getRoot();<z>
rootMapping, this.classLoader, this.source,<z>
aggregateIndex, this.resolvedRootMirrors);<z>
final String value) {<z>
new AbstractJdbc4SqlXmlValue() {<z>
{<z>
(value);<z>
String name) {<z>
)) {<z>
);<z>
(name);<z>
maybeEatBeanReference() {<z>
FACTORY_BEAN_REF)) {<z>
beanRefToken = takeToken();<z>
Token beanNameToken = null;<z>
;<z>
) {<z>
beanNameToken = eatToken(TokenKind.IDENTIFIER);<z>
stringValue();<z>
(peekToken(TokenKind.LITERAL_STRING)) {<z>
beanNameToken = eatToken(TokenKind.LITERAL_STRING);<z>
stringValue();<z>
);<z>
SpelMessage.INVALID_BEAN_REFERENCE);<z>
BeanReference beanReference;<z>
getKind() == TokenKind.FACTORY_BEAN_REF) {<z>
.FACTORY_BEAN_REF.tokenChars) + beanName;<z>
, beanNameString);<z>
;<z>
push(beanReference);<z>
;<z>
return false;<z>
map) {<z>
) {<z>
map.forEach(this::put);<z>
Object[] getInterceptors(<z>
FormattingConversionService mvcConversionService,<z>
{<z>
.interceptors == null) {<z>
new InterceptorRegistry();<z>
;<z>
);<z>
.addInterceptor(new ResourceUrlProviderExposingInterceptor(mvcResourceUrlProvider));<z>
;<z>
);<z>
> value) {<z>
(o -> {<z>
(o instanceof Collection) {<z>
o);<z>
, o);<z>
;<z>
;<z>
TransactionException {<z>
.isSynchronizationActive()) {<z>
);<z>
Object suspendedResources = null;<z>
transaction != null) {<z>
(transaction);<z>
;<z>
;<z>
= TransactionSynchronizationManager.isCurrentTransactionReadOnly();<z>
false);<z>
isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();<z>
null);<z>
= TransactionSynchronizationManager.isActualTransactionActive();<z>
TransactionSynchronizationManager.setActualTransactionActive(false);<z>
SuspendedResourcesHolder(<z>
);<z>
{<z>
doResumeSynchronization(suspendedSynchronizations);<z>
throw ex;<z>
{<z>
transaction);<z>
new SuspendedResourcesHolder(suspendedResources);<z>
return null;<z>
(ClientRequest request, HttpHeaders headers) {<z>
= request.getRequestHeaders();<z>
.forEach((key, values) -> {<z>
) {<z>
;<z>
});<z>
exception) {<z>
isDebugEnabled()) {<z>
valueOf(message), exception);<z>
Object value) {<z>
value instanceof String str) {<z>
return doEvaluate(str);<z>
] values) {<z>
actuallyResolved = false;<z>
Object[values.length];<z>
.length; i++) {<z>
;<z>
);<z>
) {<z>
;<z>
i] = resolvedValue;<z>
? resolvedValues : values);<z>
return value;<z>
processHandlerException(HttpServletRequest request, HttpServletResponse response,<z>
Nullable Object handler, Exception ex) throws Exception {<z>
HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);<z>
ModelAndView exMv = null;<z>
handlerExceptionResolvers != null) {<z>
for (HandlerExceptionResolver resolver : this.handlerExceptionResolvers) {<z>
handler, ex);<z>
if (exMv != null) {<z>
) {<z>
{<z>
request.setAttribute(EXCEPTION_ATTRIBUTE, ex);<z>
;<z>
)) {<z>
);<z>
) {<z>
);<z>
)) {<z>
exMv, ex);<z>
)) {<z>
"Using resolved error view: " + exMv);<z>
request, ex, getServletName());<z>
;<z>
;<z>
?> loadClass(String name) throws ClassNotFoundException {<z>
name)) {<z>
.loadClass(name);<z>
.loadClass(name);<z>
@Nullable Class<T> requiredType) {<z>
(requiredType != null) {<z>
response)) {<z>
T) response;<z>
response instanceof ServletResponseWrapper wrapper) {<z>
);<z>
;<z>
Exception adaptExceptionIfNecessary(MethodInvocation methodInvocation, ResourceException ex) {<z>
), ex.getClass())) {<z>
return ex;<z>
InternalResourceException(ex);<z>
IOException {<z>
{<z>
ClassReader(is);<z>
ex) {<z>
throw new NestedIOException("ASM ClassReader failed to parse class file - " +<z>
, ex);<z>
?> sourceClass) {<z>
{<z>
null;<z>
());<z>
()) &&<z>
: null);<z>
public void setAsText(String text) throws IllegalArgumentException {<z>
text)) {<z>
setValue(Charset.forName(text));<z>
null);<z>
, Object> model,<z>
ServerWebExchange exchange) {<z>
{<z>
) {<z>
;<z>
(views);<z>
MediaType bestMediaType;<z>
() -> mediaTypes);<z>
(NotAcceptableStatusException ex) {<z>
();<z>
statusCode.isError()) {<z>
logger.isDebugEnabled()) {<z>
.getReason());<z>
;<z>
;<z>
if (bestMediaType != null) {<z>
(View view : views) {<z>
) {<z>
.isCompatibleWith(bestMediaType)) {<z>
);<z>
throw new NotAcceptableStatusException(mediaTypes);<z>
(State oldState, State newState) {<z>
oldState, newState);<z>
result && rsWriteLogger.isTraceEnabled()) {<z>
) + oldState + " -> " + newState);<z>
return result;<z>
[] arguments) {<z>
;<z>
boolean isVarargs = false;<z>
{<z>
?>) member;<z>
);<z>
.isVarArgs();<z>
;<z>
method.getParameterTypes());<z>
= method.isVarArgs();<z>
(isVarargs) {<z>
;<z>
;<z>
{<z>
]);<z>
childCount - 1]);<z>
paramDescriptors.length - 1];<z>
getExitDescriptor())) {<z>
, paramDescriptors[p]);<z>
= arrayType.substring(1);<z>
p, arrayType);<z>
;<z>
{<z>
;<z>
;<z>
);<z>
, child, arrayType);<z>
.insertArrayStore(mv, arrayType);<z>
++;<z>
.length;i++) {<z>
, paramDescriptors[i]);<z>
int mappingIndex) {<z>
annotationIndex];<z>
if (mappingIndex == 0) {<z>
(MergedAnnotation<A>) root;<z>
?<z>
.INFO : IntrospectionFailureLogger.DEBUG);<z>
(<z>
get(mappingIndex), root, logger);<z>
isolationLevel)<z>
SystemException {<z>
) {<z>
InvalidIsolationLevelException(<z>
"switch 'allowCustomIsolationLevels' to 'true'");<z>
value) {<z>
;<z>
) {<z>
oldKey);<z>
(oldKeyValue != null) {<z>
oldKeyValue;<z>
= oldKey;<z>
key, value);<z>
(ServerRequest request) {<z>
.method();<z>
)) {<z>
.build()<z>
.map(response -> response);<z>
.equals(method)) {<z>
new HeadMethodResource(this.resource);<z>
headResource).build()<z>
.map(response -> response);<z>
)) {<z>
)<z>
(SUPPORTED_METHODS)<z>
));<z>
status(HttpStatus.METHOD_NOT_ALLOWED)<z>
allow(SUPPORTED_METHODS)<z>
(BodyInserters.empty());<z>
?> clazz) {<z>
(path, "Path must not be null");<z>
StringUtils.cleanPath(path);<z>
.clazz = clazz;<z>
InitBinderBindingContext bindingContext,<z>
) {<z>
List<InvocableHandlerMethod> modelMethods =<z>
.methodResolver.getModelAttributeMethods(handlerMethod);<z>
=<z>
);<z>
{<z>
;<z>
)<z>
{<z>
session);<z>
).mergeAttributes(attributes);<z>
);<z>
, exchange)<z>
aVoid -><z>
forEach(name -> {<z>
name)) {<z>
(name);<z>
.addAttribute(name, value);<z>
;<z>
;<z>
{<z>
&& transactionFactory != null &&<z>
()) {<z>
+<z>
;<z>
this.xaResource = xaResource;<z>
() {<z>
null) {<z>
"Property 'dataSource' is required");<z>
= false;<z>
long beginTime = System.currentTimeMillis();<z>
(this.timeout);<z>
;<z>
{<z>
= null;<z>
Statement stmt = null;<z>
this.dataSource.getConnection();<z>
con == null) {<z>
new CannotGetJdbcConnectionException("Failed to execute validation: " +<z>
.dataSource);<z>
(this.validationQuery == null) {<z>
= con.isValid(this.interval);<z>
.createStatement();<z>
.execute(this.validationQuery);<z>
true;<z>
{<z>
latestEx = ex;<z>
()) {<z>
null) {<z>
ex);<z>
.debug("Validation check threw exception", ex);<z>
.isInfoEnabled()) {<z>
1000;<z>
interval) {<z>
+ this.interval +<z>
);<z>
.closeStatement(stmt);<z>
con);<z>
{<z>
sleep(this.interval);<z>
{<z>
throw new CannotGetJdbcConnectionException(<z>
latestEx);<z>
{<z>
currentTimeMillis() - beginTime)) / 1000;<z>
info("Database startup detected after " + duration + " seconds");<z>
catch (InterruptedException ex) {<z>
();<z>
) {<z>
== null) {<z>
false;<z>
getClass();<z>
||<z>
value)) {<z>
return false;<z>
;<z>
value);<z>
throws SAXException {<z>
()) {<z>
StartDocument startDocument = (StartDocument) event;<z>
();<z>
.hasLength(xmlVersion)) {<z>
;<z>
)) {<z>
= startDocument.getCharacterEncodingScheme();<z>
contentHandler = getContentHandler();<z>
null) {<z>
event.getLocation();<z>
) {<z>
public int getColumnNumber() {<z>
;<z>
public int getLineNumber() {<z>
getLineNumber() : -1);<z>
getPublicId() {<z>
location.getPublicId() : null);<z>
String getSystemId() {<z>
) : null);<z>
{<z>
;<z>
() {<z>
return encoding;<z>
);<z>
contentHandler.startDocument();<z>
parameterIndex, int nestingLevel) {<z>
Assert.notNull(constructor, "Constructor must not be null");<z>
;<z>
;<z>
this.nestingLevel = nestingLevel;<z>
(CloseableHttpAsyncClient client,<z>
> contextProvider) {<z>
.notNull(client, "Client must not be null");<z>
(contextProvider, "ContextProvider must not be null");<z>
;<z>
client = client;<z>
();<z>
?> targetPayloadType) {<z>
= null;<z>
SmartMessageConverter smartConverter) {<z>
message, targetPayloadType, parameter);<z>
if (this.converter != null) {<z>
;<z>
(result == null) {<z>
new MessageConversionException(message, "No converter found from actual payload type '" +<z>
(message.getPayload()) + "' to expected payload type '" +<z>
(targetPayloadType) + "'");<z>
result;<z>
, Throwable cause) {<z>
, cause);<z>
;<z>
null;<z>
(MessageDigest messageDigest, int len) {<z>
null) {<z>
len == 0) {<z>
{<z>
IllegalArgumentException("len must be 0 or greater: " + len);<z>
.currentBufferLength) {<z>
, this.currentBufferLength - this.nextIndexInCurrentBuffer);<z>
nextIndexInCurrentBuffer, bytesToCopy);<z>
;<z>
;<z>
{<z>
.next();<z>
;<z>
;<z>
;<z>
);<z>
final TopicConnectionFactory cf,<z>
existingCon, final boolean synchedLocalTransactionAllowed)<z>
throws JMSException {<z>
doGetTransactionalSession(cf, new ResourceFactory() {<z>
holder) {<z>
class, existingCon);<z>
(JmsResourceHolder holder) {<z>
.getConnection(TopicConnection.class));<z>
JMSException {<z>
return cf.createTopicConnection();<z>
public Session createSession(Connection con) throws JMSException {<z>
con).createTopicSession(<z>
synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE);<z>
{<z>
return synchedLocalTransactionAllowed;<z>
;<z>
getManagedMetric(Method method) throws InvalidMetadataException {<z>
SearchStrategy.TYPE_HIERARCHY)<z>
ManagedMetric.class).withNonMergedAttributes();<z>
.metadata.ManagedMetric.class);<z>
actualSize) {<z>
;<z>
this.expectedSize = expectedSize;<z>
actualSize = actualSize;<z>
?> message) {<z>
(handlerMethod);<z>
{<z>
);<z>
.invoke(message)<z>
, message)))<z>
handleReturnValue(returnValue, invocable, message))<z>
-> {<z>
initExceptionHandlerMethod(handlerMethod, ex);<z>
(exHandler == null) {<z>
(ex);<z>
{<z>
getShortLogMessage());<z>
(message, ex)<z>
)))<z>
exHandler, message));<z>
;<z>
private ResponseBodyProcessor createBodyProcessor() {<z>
== null) {<z>
();<z>
return new ResponseBodyProcessor(this.responseChannel);<z>
status) {<z>
status.getTransaction();<z>
;<z>
()) {<z>
;<z>
();<z>
(SQLException ex) {<z>
translateException("JDBC rollback", ex);<z>
CronExpression(<z>
seconds,<z>
minutes,<z>
CronField hours,<z>
daysOfMonth,<z>
months,<z>
daysOfWeek,<z>
{<z>
;<z>
= expression;<z>
clazz) {<z>
.notNull(clazz, "Class must not be null");<z>
.getName();<z>
);<z>
Field field : fields) {<z>
(ReflectionUtils.isPublicStaticFinal(field)) {<z>
);<z>
(null);<z>
;<z>
) {<z>
) throws SAXException {<z>
{<z>
getText().toCharArray();<z>
, ch.length);<z>
enhancer, Callback[] callbacks) {<z>
);<z>
Object proxyInstance = null;<z>
)) {<z>
, enhancer.getUseCache());<z>
catch (Throwable ex) {<z>
+<z>
, ex);<z>
proxyInstance == null) {<z>
> ctor = (this.constructorArgs != null ?<z>
.constructorArgTypes) :<z>
);<z>
;<z>
proxyInstance = (this.constructorArgs != null ?<z>
;<z>
) {<z>
"Unable to instantiate proxy using Objenesis, " +<z>
"and regular proxy instantiation via default constructor fails as well", ex);<z>
) proxyInstance).setCallbacks(callbacks);<z>
proxyInstance;<z>
, TokenKind possible2, TokenKind possible3) {<z>
Token t = peekToken();<z>
null) {<z>
return false;<z>
t.kind == possible3);<z>
getNString(int columnIndex) throws InvalidResultSetAccessException {<z>
return this.resultSet.getNString(columnIndex);<z>
(SQLException se) {<z>
;<z>
setAsText(String text) {<z>
hasText(text)) {<z>
.parseMediaType(text));<z>
setValue(null);<z>
, Class<?>[] paramTypes) {<z>
getMethod(methodName, paramTypes);<z>
NoSuchMethodException ex) {<z>
;<z>
public InterceptorRegistration addInterceptor(HandlerInterceptor interceptor) {<z>
);<z>
;<z>
registration;<z>
(TransactionSynchronization synchronization)<z>
IllegalStateException {<z>
(synchronization, "TransactionSynchronization must not be null");<z>
.get();<z>
null) {<z>
"Transaction synchronization is not active");<z>
synchs.add(synchronization);<z>
WebSocketHandler handler, String... paths) {<z>
Assert.notNull(handler, "WebSocketHandler must not be null");<z>
.notEmpty(paths, "Paths must not be empty");<z>
);<z>
this;<z>
static void registerPostProcessor(<z>
BeanDefinitionBuilder builder, String beanName) {<z>
.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
;<z>
, beanName);<z>
holder));<z>
protected void refreshConnectionUntilSuccessful() {<z>
backOff.start();<z>
(isRunning()) {<z>
) {<z>
);<z>
;<z>
closeConnection(con);<z>
debug("Successfully refreshed JMS Connection");<z>
catch (Exception ex) {<z>
) {<z>
;<z>
msg = new StringBuilder();<z>
("Could not refresh JMS Connection for destination '");<z>
append("' - retrying using ");<z>
);<z>
getMessage());<z>
logger.isDebugEnabled()) {<z>
, ex);<z>
;<z>
)) {<z>
error("Stopping container for destination '" + getDestinationDescription() +<z>
;<z>
();<z>
) {<z>
= ann.annotationType();<z>
annotationType.getName();<z>
(annotationName)) {<z>
EMPTY_OBJECT_ARRAY;<z>
(ann, Validated.class);<z>
{<z>
validatedAnn.value();<z>
(hints);<z>
).startsWith("Valid")) {<z>
getValue(ann);<z>
);<z>
null;<z>
(String field) {<z>
();<z>
();<z>
(field);<z>
FieldError error : fieldErrors) {<z>
isMatchingFieldError(fixedField, error)) {<z>
(error);<z>
;<z>
(boolean registerDefaultEditors) {<z>
) {<z>
registerDefaultEditors();<z>
(this);<z>
void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration,<z>
, List<ContextConfigurationAttributes> attributesList) {<z>
) {<z>
,<z>
)));<z>
ContextConfigurationAttributes attributes =<z>
ContextConfigurationAttributes(declaringClass, contextConfiguration);<z>
logger.isTraceEnabled()) {<z>
;<z>
(attributes);<z>
boolean readOnly) {<z>
)) {<z>
readOnly);<z>
{<z>
.ORIGIN);<z>
== null) {<z>
return false;<z>
();<z>
getScheme();<z>
host = request.getServerName();<z>
port = request.getServerPort();<z>
, originUrl.getScheme()) &&<z>
(host, originUrl.getHost()) &&<z>
)));<z>
response, int seconds, boolean mustRevalidate) {<z>
{<z>
currentTimeMillis() + seconds * 1000L);<z>
HEADER_EXPIRES)) {<z>
);<z>
) {<z>
String headerValue = "max-age=" + seconds;<z>
mustRevalidate || this.alwaysMustRevalidate) {<z>
headerValue += ", must-revalidate";<z>
setHeader(HEADER_CACHE_CONTROL, headerValue);<z>
response.containsHeader(HEADER_PRAGMA)) {<z>
response.setHeader(HEADER_PRAGMA, "");<z>
(MethodParameter parameter) {<z>
(MatrixVariable.class);<z>
isAssignableFrom(parameter.getParameterType()) &&<z>
()));<z>
toUri() {<z>
.encodeState.isEncoded()) {<z>
URI(toUriString());<z>
);<z>
{<z>
1) {<z>
;<z>
(), getFragment());<z>
(URISyntaxException ex) {<z>
ex.getMessage(), ex);<z>
throws IOException {<z>
, "Cannot send redirect - response is already committed");<z>
, "Redirect URL must not be null");<z>
, url);<z>
);<z>
;<z>
... populators) {<z>
populators, "DatabasePopulators must not be null");<z>
();<z>
));<z>
RequestMappingInfo addCustomCondition(RequestCondition<?> customCondition) {<z>
return new RequestMappingInfo(this.name,<z>
patternsCondition,<z>
this.paramsCondition, this.headersCondition,<z>
this.producesCondition,<z>
(customCondition), this.options);<z>
valueEnd) {<z>
sort = sort;<z>
.valueBuffer = valueBuffer;<z>
valueBegin = valueBegin;<z>
;<z>
<?> requestMessage) {<z>
).sendAndReceive(<z>
createMessageCreator(requestMessage));<z>
jmsMessage);<z>
(JmsException ex) {<z>
ex);<z>
void registerListeners() throws SchedulerException {<z>
= getScheduler().getListenerManager();<z>
this.schedulerListeners != null) {<z>
this.schedulerListeners) {<z>
listener);<z>
if (this.globalJobListeners != null) {<z>
: this.globalJobListeners) {<z>
listener);<z>
) {<z>
{<z>
listenerManager.addTriggerListener(listener);<z>
public Object getObject() throws BeansException {<z>
this.targetBeanWrapper;<z>
target != null) {<z>
targetBeanName != null &&<z>
&&<z>
{<z>
"' is still in creation due to a circular " +<z>
;<z>
this.beanFactory != null, "No BeanFactory available");<z>
!= null, "No target bean name specified");<z>
.getBean(this.targetBeanName);<z>
forBeanPropertyAccess(bean);<z>
.propertyPath != null, "No property path specified");<z>
(this.propertyPath);<z>
{<z>
);<z>
= emf;<z>
;<z>
DataAccessException {<z>
) session -> {<z>
;<z>
);<z>
queryObject.setProperties(valueBean);<z>
.list();<z>
);<z>
<T> clazz) {<z>
T> ctor = findPrimaryConstructor(clazz);<z>
if (ctor != null) {<z>
return ctor;<z>
getConstructors();<z>
length == 1) {<z>
T>) ctors[0];<z>
){<z>
();<z>
if (ctors.length == 1) {<z>
[0];<z>
clazz.getDeclaredConstructor();<z>
catch (NoSuchMethodException ex) {<z>
);<z>
method) {<z>
()) ||<z>
)) {<z>
setAccessible(true);<z>
afterPropertiesSet() {<z>
afterPropertiesSet();<z>
null) {<z>
("Property 'columnName' is required");<z>
targetTypeName)<z>
{<z>
this.readerContext.getBeanClassLoader();<z>
;<z>
(!StringUtils.hasText(targetTypeName)) {<z>
(value);<z>
(classLoader != null) {<z>
;<z>
value, targetType);<z>
);<z>
typedValue;<z>
BeansException {<z>
optional) {<z>
.descriptor, this.beanName);<z>
this.beanName, null, null);<z>
) {<z>
descriptor.getResolvableType());<z>
;<z>
) {<z>
if (logger.isDebugEnabled()) {<z>
profile + "'");<z>
profile);<z>
();<z>
this.activeProfiles) {<z>
this.activeProfiles.add(profile);<z>
ModelAndViewContainer mavContainer,<z>
WebDataBinderFactory binderFactory) throws Exception {<z>
= parameter.getParameterType();<z>
(paramType)) {<z>
webRequest)) {<z>
new IllegalStateException(<z>
+ "]: " + webRequest);<z>
;<z>
paramType)) {<z>
, paramType);<z>
));<z>
{<z>
joiner = new StringJoiner(", ");<z>
: acceptableCharsets) {<z>
;<z>
));<z>
{<z>
.isEmpty() ?<z>
Collectors.toList()) :<z>
;<z>
{<z>
RequestedContentTypeResolver resolver : resolvers) {<z>
.resolveMediaTypes(exchange);<z>
mediaTypes.equals(RequestedContentTypeResolver.MEDIA_TYPE_ALL_LIST)) {<z>
return mediaTypes;<z>
;<z>
) {<z>
(isoCode)) {<z>
return COUNTRY_AT;<z>
.isoCode.equals(isoCode)) {<z>
COUNTRY_NL;<z>
{<z>
;<z>
{<z>
return COUNTRY_US;<z>
null;<z>
public void initialize() {<z>
{<z>
);<z>
this.lifecycleMonitor) {<z>
.taskExecutor == null) {<z>
this.taskExecutor = createDefaultTaskExecutor();<z>
(this.taskExecutor instanceof SchedulingTaskExecutor &&<z>
this.taskExecutor).prefersShortLivedTasks() &&<z>
{<z>
maxMessagesPerTask = 10;<z>
();<z>
{<z>
{<z>
case VOID:<z>
return "void";<z>
case BOOLEAN:<z>
"boolean";<z>
case CHAR:<z>
;<z>
:<z>
"byte";<z>
SHORT:<z>
;<z>
:<z>
;<z>
case FLOAT:<z>
return "float";<z>
:<z>
"long";<z>
case DOUBLE:<z>
return "double";<z>
case ARRAY:<z>
());<z>
--i) {<z>
"[]");<z>
);<z>
OBJECT:<z>
:<z>
valueEnd).replace('/', '.');<z>
AssertionError();<z>
Object value) {<z>
) {<z>
"' header is read-only");<z>
;<z>
{<z>
name))) {<z>
;<z>
(name, value);<z>
) {<z>
;<z>
remove(name);<z>
String createInvocationTraceName(MethodInvocation invocation) {<z>
Method method = invocation.getMethod();<z>
();<z>
getThis())) {<z>
;<z>
);<z>
method.getName() + getSuffix();<z>
PatternsRequestCondition other) {<z>
isEmptyPathMapping()) {<z>
;<z>
{<z>
return this;<z>
)) {<z>
other;<z>
> result = new LinkedHashSet<>();<z>
patterns.isEmpty()) {<z>
pattern1 : this.patterns) {<z>
other.patterns) {<z>
pathMatcher.combine(pattern1, pattern2));<z>
result, this);<z>
(HttpStatus.Series expected) {<z>
;<z>
exchangeResult.assertWithDiagnostics(() -><z>
));<z>
;<z>
UriComponentsBuilder uri(URI uri) {<z>
(uri, "URI must not be null");<z>
= uri.getScheme();<z>
isOpaque()) {<z>
;<z>
resetHierarchicalComponents();<z>
null) {<z>
= uri.getRawUserInfo();<z>
!= null) {<z>
;<z>
{<z>
);<z>
uri.getRawPath())) {<z>
.pathBuilder = new CompositePathComponentBuilder();<z>
.getRawPath());<z>
{<z>
clear();<z>
());<z>
);<z>
{<z>
();<z>
return this;<z>
{<z>
path, "Path must not be null");<z>
);<z>
;<z>
filePath = this.file.toPath();<z>
initSessionCookie(<z>
ServerWebExchange exchange, String id, Duration maxAge) {<z>
this.cookieName, id)<z>
) + "/")<z>
maxAge)<z>
)<z>
.getURI().getScheme()))<z>
("Lax");<z>
null) {<z>
);<z>
build();<z>
{<z>
!= null) {<z>
.setLocation(new LocatorLocationAdapter(locator));<z>
boolean supportsParameter(MethodParameter parameter) {<z>
.class);<z>
.isAssignableFrom(parameter.getParameterType()) &&<z>
hasText(requestParam.name()));<z>
, String> initCookies() {<z>
.defaultCookies == null) {<z>
LinkedMultiValueMap<>(3);<z>
;<z>
public void convertAndSend(<z>
MessagePostProcessor postProcessor)<z>
{<z>
session -> {<z>
;<z>
postProcessor.postProcessMessage(msg);<z>
);<z>
SQLException ex) {<z>
);<z>
sqlState == null) {<z>
ex.getNextException();<z>
nestedEx != null) {<z>
= nestedEx.getSQLState();<z>
;<z>
{<z>
matches = null;<z>
: this.patterns) {<z>
getMatchingPattern(pattern, lookupPath);<z>
{<z>
());<z>
(match);<z>
== null) {<z>
Collections.emptyList();<z>
.size() > 1) {<z>
this.pathMatcher.getPatternComparator(lookupPath));<z>
return matches;<z>
) {<z>
"Name must not be null");<z>
(value, "Value must not be null");<z>
.name = name;<z>
equals;<z>
= value;<z>
Nullable String port) {<z>
= port;<z>
(port != null) {<z>
;<z>
return this;<z>
() {<z>
peekToken();<z>
(t == null) {<z>
return false;<z>
TokenKind.LITERAL_INT) {<z>
);<z>
t.kind == TokenKind.LITERAL_LONG) {<z>
startPos, t.endPos, 10));<z>
.LITERAL_HEXINT) {<z>
, 16));<z>
(t.kind == TokenKind.LITERAL_HEXLONG) {<z>
t.endPos, 16));<z>
{<z>
, false));<z>
(t.kind == TokenKind.LITERAL_REAL_FLOAT) {<z>
, true));<z>
peekIdentifierToken("true")) {<z>
startPos, t.endPos, true));<z>
else if (peekIdentifierToken("false")) {<z>
.endPos, false));<z>
LITERAL_STRING) {<z>
t.stringValue()));<z>
;<z>
nextToken();<z>
;<z>
) throws EvaluationException {<z>
state).getValue();<z>
).getValue();<z>
) {<z>
.getStartPosition(),<z>
SpelMessage.BETWEEN_RIGHT_OPERAND_MUST_BE_TWO_ELEMENT_LIST);<z>
<?>) right;<z>
Object low = list.get(0);<z>
;<z>
state.getTypeComparator();<z>
left, high) <= 0);<z>
(SpelEvaluationException ex) {<z>
;<z>
;<z>
handleStartElement() throws SAXException {<z>
() != null) {<z>
);<z>
) {<z>
(); i++) {<z>
.reader.getNamespaceURI(i));<z>
{<z>
(i);<z>
i);<z>
)) {<z>
prefix, namespace);<z>
,<z>
;<z>
(qName), getAttributes());<z>
matches, ServerWebExchange exchange) {<z>
mappings) {<z>
);<z>
match != null) {<z>
));<z>
parserContext, BeanDefinitionBuilder builder) {<z>
getTransactionManagerName(element));<z>
, ATTRIBUTES_ELEMENT);<z>
> 1) {<z>
.getReaderContext().error(<z>
, element);<z>
size() == 1) {<z>
(0);<z>
attributeSourceElement, parserContext);<z>
, attributeSourceDefinition);<z>
("transactionAttributeSource",<z>
("org.springframework.transaction.annotation.AnnotationTransactionAttributeSource"));<z>
private SpelNodeImpl[] maybeEatMethodArgs() {<z>
{<z>
return null;<z>
();<z>
);<z>
(TokenKind.RPAREN);<z>
toArray(new SpelNodeImpl[0]);<z>
{<z>
= "weblogic.servlet.internal.WebAppServletContext";<z>
, "getSecurityContext");<z>
= "weblogic.servlet.security.internal.SecurityModule";<z>
= method(className, "getCurrentUser",<z>
type("weblogic.servlet.security.internal.ServletSecurityContext"),<z>
;<z>
;<z>
className, "getProvider");<z>
.getReturnType().getDeclaredMethod("getAnonymousSubject");<z>
{<z>
("No compatible WebSocket version found", ex);<z>
HttpServletResponse response) {<z>
);<z>
isEmpty(allFlashMaps)) {<z>
return null;<z>
FlashMap> mapsToRemove = getExpiredFlashMaps(allFlashMaps);<z>
allFlashMaps, request);<z>
!= null) {<z>
add(match);<z>
)) {<z>
request);<z>
!= null) {<z>
mutex) {<z>
request);<z>
allFlashMaps != null) {<z>
);<z>
, response);<z>
);<z>
allFlashMaps, request, response);<z>
return match;<z>
WebSocketHandlerAdapter webFluxWebSocketHandlerAdapter() {<z>
new WebSocketHandlerAdapter(initWebSocketService());<z>
int defaultOrder = adapter.getOrder();<z>
1);<z>
adapter;<z>
() throws IllegalArgumentException {<z>
?> ifc : this.interfaces) {<z>
advice instanceof DynamicIntroductionAdvice &&<z>
(ifc)) {<z>
("DynamicIntroductionAdvice [" + this.advice + "] " +<z>
+ "] specified for introduction");<z>
Reference<K, V> ref) {<z>
boolean needsResize;<z>
();<z>
);<z>
toPurge = Collections.emptySet();<z>
) {<z>
= new HashSet<>();<z>
null) {<z>
toPurge.add(ref);<z>
;<z>
);<z>
.resizeThreshold);<z>
false;<z>
;<z>
) {<z>
;<z>
;<z>
Reference<K, V>[] restructured =<z>
references);<z>
i++) {<z>
.references[i];<z>
resizing) {<z>
= null;<z>
(ref != null) {<z>
) {<z>
entry = ref.get();<z>
) {<z>
.getHash(), restructured);<z>
this.referenceManager.createReference(<z>
), restructured[index]);<z>
getNext();<z>
if (resizing) {<z>
;<z>
;<z>
max(countAfterRestructure, 0));<z>
;<z>
exceptionConstructor, BeansException cause) {<z>
paramTypes = exceptionConstructor.getParameterTypes();<z>
args = new Object[paramTypes.length];<z>
paramTypes.length; i++) {<z>
.class == paramTypes[i]) {<z>
);<z>
(cause)) {<z>
i] = cause;<z>
BeanUtils.instantiateClass(exceptionConstructor, args);<z>
) {<z>
, "Class must not be null");<z>
.notNull(method, "Method must not be null");<z>
clazz == method.getDeclaringClass()) {<z>
true;<z>
method.getName();<z>
;<z>
(clazz, methodName, paramTypes) != null;<z>
public static Msg parseFrom(<z>
ByteString data,<z>
)<z>
.InvalidProtocolBufferException {<z>
PARSER.parseFrom(data, extensionRegistry);<z>
, String> getMultipartParameterContentTypes() {<z>
.multipartParameterContentTypes == null) {<z>
;<z>
.multipartParameterContentTypes;<z>
sourceType, TypeDescriptor targetType) {<z>
.notNull(targetType, "Target type to convert to cannot be null");<z>
{<z>
null, "Source must be [null] if source type == [null]");<z>
;<z>
)) {<z>
new IllegalArgumentException("Source to convert from must be an instance of [" +<z>
).getName() + "]");<z>
converter = getConverter(sourceType, targetType);<z>
converter != null) {<z>
source, sourceType, targetType);<z>
;<z>
return handleConverterNotFound(source, sourceType, targetType);<z>
Element containerEle, Element listenerEle, ParserContext parserContext,<z>
commonContainerProperties, PropertyValues specificContainerProperties) {<z>
);<z>
.extractSource(containerEle));<z>
().addPropertyValues(commonContainerProperties);<z>
.addPropertyValues(specificContainerProperties);<z>
containerType = containerEle.getAttribute(CONTAINER_TYPE_ATTRIBUTE);<z>
(CONTAINER_CLASS_ATTRIBUTE);<z>
.hasLength(containerClass)) {<z>
;<z>
"default")) {<z>
;<z>
containerType.startsWith("simple")) {<z>
containerDef.setBeanClassName("org.springframework.jms.listener.SimpleMessageListenerContainer");<z>
().error(<z>
);<z>
);<z>
return containerDef;<z>
String> parameterNames,<z>
Integer, Parameter> remainderByIndex) {<z>
.size());<z>
{<z>
parameterName);<z>
) {<z>
(<z>
;<z>
parameterName, parameter);<z>
);<z>
Nullable Principal principal) {<z>
;<z>
.userCallback != null) {<z>
userCallback.accept(principal);<z>
public HttpServerErrorException(<z>
) {<z>
body, charset);<z>
{<z>
;<z>
= new TransferSimpUser();<z>
>(4);<z>
requestMappingHandlerAdapter(<z>
@Qualifier("mvcContentNegotiationManager") ContentNegotiationManager contentNegotiationManager,<z>
Qualifier("mvcConversionService") FormattingConversionService conversionService,<z>
Qualifier("mvcValidator") Validator validator) {<z>
();<z>
(contentNegotiationManager);<z>
.setMessageConverters(getMessageConverters());<z>
setWebBindingInitializer(getConfigurableWebBindingInitializer(conversionService, validator));<z>
setCustomArgumentResolvers(getArgumentResolvers());<z>
(getReturnValueHandlers());<z>
(jackson2Present) {<z>
new JsonViewRequestBodyAdvice()));<z>
;<z>
= getAsyncSupportConfigurer();<z>
!= null) {<z>
configurer.getTaskExecutor());<z>
(configurer.getTimeout() != null) {<z>
configurer.getTimeout());<z>
setCallableInterceptors(configurer.getCallableInterceptors());<z>
));<z>
return adapter;<z>
ConnectionFactoryMetadata metadata, boolean suppressClose) {<z>
ConnectionFactory() {<z>
<? extends Connection> create() {<z>
(target);<z>
ConnectionFactoryMetadata getMetadata() {<z>
;<z>
});<z>
.notNull(target, "Connection must not be null");<z>
(metadata, "ConnectionFactoryMetadata must not be null");<z>
;<z>
Mono.just(target);<z>
.suppressClose = suppressClose;<z>
target);<z>
ClassLoader determinePointcutClassLoader() {<z>
ConfigurableBeanFactory) {<z>
beanFactory).getBeanClassLoader();<z>
this.pointcutDeclarationScope != null) {<z>
();<z>
;<z>
int status) {<z>
{<z>
status;<z>
{<z>
exitMessage, "exitMessage must not be empty");<z>
);<z>
(exitMessage, PLACEHOLDER_EXCEPTION,<z>
;<z>
exitMessage;<z>
> createInstance() {<z>
this.sourceSet == null) {<z>
);<z>
<Object> result = null;<z>
) {<z>
.targetSetClass);<z>
.size());<z>
<?> valueType = null;<z>
targetSetClass != null) {<z>
().resolveGeneric();<z>
null) {<z>
;<z>
.sourceSet) {<z>
(elem, valueType));<z>
sourceSet);<z>
;<z>
? extends DataBuffer> publisher, long maxByteCount) {<z>
.notNull(publisher, "Publisher must not be null");<z>
>= 0, "'maxByteCount' must be a positive number");<z>
defer(() -> {<z>
countDown = new AtomicLong(maxByteCount);<z>
)<z>
.map(buffer -> {<z>
.readableByteCount());<z>
< 0) {<z>
;<z>
(0, length);<z>
buffer;<z>
get() <= 0);<z>
);<z>
XhrClientSockJsSession(TransportRequest request, WebSocketHandler handler,<z>
> connectFuture) {<z>
handler, connectFuture);<z>
;<z>
;<z>
);<z>
;<z>
.headers);<z>
sendHeaders.setContentType(MediaType.APPLICATION_JSON);<z>
);<z>
void triggerFlush() {<z>
()) {<z>
synchronization.flush();<z>
handleGetObject(String key) {<z>
;<z>
{<z>
;<z>
) {<z>
applicationContext = getApplicationContext();<z>
);<z>
;<z>
catch (BeansException ex) {<z>
+<z>
ex);<z>
Object toStoreValue(@Nullable Object userValue) {<z>
userValue == null) {<z>
{<z>
return NullValue.INSTANCE;<z>
new IllegalArgumentException(<z>
"Cache '" + getName() + "' is configured to not allow null values but null was provided");<z>
userValue;<z>
?>... parameterTypes)<z>
NoSuchMethodException {<z>
.getDeclaredConstructor(parameterTypes);<z>
;<z>
return ctor;<z>
{<z>
;<z>
headers;<z>
();<z>
getResourceBundle() {<z>
.request.getSession(false);<z>
) {<z>
Config.FMT_LOCALIZATION_CONTEXT);<z>
if (lcObject instanceof LocalizationContext) {<z>
);<z>
, getLocale(), lcBundle);<z>
, getLocale());<z>
(SimpMessageHeaderAccessor accessor) {<z>
() != null) {<z>
);<z>
) {<z>
) {<z>
.MAX_VALUE;<z>
if (key == Attr.PARENT) {<z>
return this.source;<z>
return null;<z>
,<z>
HttpServletResponse response, Context context) {<z>
= HttpStatus.resolve(this.statusCode);<z>
ModelAndView mav;<z>
) {<z>
.name, status);<z>
name);<z>
.addAllObjects(this.model);<z>
;<z>
task) {<z>
cancelTask();<z>
.interceptors) {<z>
task);<z>
RESPONSE_HANDLED) {<z>
{<z>
result;<z>
) {<z>
return ex;<z>
RESULT_NONE;<z>
(HttpServletRequest request) {<z>
) &&<z>
ORIGIN) != null &&<z>
!= null);<z>
) {<z>
(WebAsyncManager.this) {<z>
.concurrentResult = RESULT_NONE;<z>
= processingContext;<z>
;<z>
.asyncWebRequest.startAsync();<z>
logger.isDebugEnabled()) {<z>
logger.debug("Started async request");<z>
RootBeanDefinition original) {<z>
(original);<z>
.decoratedDefinition;<z>
this.qualifiedElement = original.qualifiedElement;<z>
.allowCaching = original.allowCaching;<z>
.isFactoryMethodUnique;<z>
targetType = original.targetType;<z>
;<z>
void addAdvisors(Collection<Advisor> advisors) {<z>
if (isFrozen()) {<z>
new AopConfigException("Cannot add advisor: Configuration is frozen.");<z>
isEmpty(advisors)) {<z>
advisor : advisors) {<z>
{<z>
validateIntroductionAdvisor((IntroductionAdvisor) advisor);<z>
"Advisor must not be null");<z>
add(advisor);<z>
);<z>
(Locale locale) {<z>
, "Locale must not be null");<z>
addFirst(locale);<z>
;<z>
) {<z>
context.canPutToCache(result)) {<z>
.getCaches()) {<z>
.key, result);<z>
, Resource resource) {<z>
int count = 0;<z>
) {<z>
debug("Loading from YAML: " + resource);<z>
())) {<z>
object : yaml.loadAll(reader)) {<z>
(object), callback)) {<z>
++;<z>
resolutionMethod == ResolutionMethod.FIRST_FOUND) {<z>
if (logger.isDebugEnabled()) {<z>
count > 1 ? "s" : "") +<z>
resource);<z>
{<z>
ex);<z>
0);<z>
replaceQuery(@Nullable String query) {<z>
;<z>
null) {<z>
query(query);<z>
resetSchemeSpecificPart();<z>
;<z>
newValue)<z>
throws AccessException {<z>
target instanceof Map, "Target must be a Map");<z>
>) target;<z>
newValue);<z>
String> customEnumSet) {<z>
size());<z>
) {<z>
.next()));<z>
(String beanName, T beanInstance) {<z>
, "Bean name must not be null");<z>
beanName;<z>
= beanInstance;<z>
(<z>
[] classFileBuffer,<z>
classFileOffset,<z>
int classFileLength) {<z>
);<z>
)<z>
throws XmlMappingException, IOException {<z>
if (this.streamDriver != null) {<z>
streamDriver.createWriter(writer), dataHolder);<z>
(writer), dataHolder);<z>
> cookies,<z>
HttpServletResponse, ModelAndView> writeFunction) {<z>
, cookies);<z>
);<z>
writeFunction;<z>
{<z>
;<z>
();<z>
), initialDelay, TimeUnit.MILLISECONDS);<z>
(RejectedExecutionException ex) {<z>
"] did not accept task: " + task, ex);<z>
> typeVariable, ResolvableType contextType) {<z>
;<z>
(contextType.hasGenerics()) {<z>
);<z>
) {<z>
;<z>
= contextType.getSuperType();<z>
superType != ResolvableType.NONE) {<z>
resolvedType = resolveVariable(typeVariable, superType);<z>
{<z>
resolvedType;<z>
ifc : contextType.getInterfaces()) {<z>
, ifc);<z>
{<z>
;<z>
return ResolvableType.NONE;<z>
context,<z>
) {<z>
.getPropertySources();<z>
));<z>
inputStream) throws IOException {<z>
(inputStream, this.classLoader);<z>
;<z>
ClassNotFoundException ex) {<z>
("Failed to deserialize object type", ex);<z>
protected JsonEncoding getJsonEncoding(@Nullable MimeType mimeType) {<z>
) != null) {<z>
= mimeType.getCharset();<z>
());<z>
(result != null) {<z>
;<z>
return JsonEncoding.UTF8;<z>
{<z>
);<z>
(semicolonIndex == -1) {<z>
requestUri;<z>
StringBuilder(requestUri);<z>
-1) {<z>
semicolonIndex + 1);<z>
slashIndex == -1) {<z>
(0, semicolonIndex);<z>
);<z>
= sb.indexOf(";", semicolonIndex);<z>
sb.toString();<z>
(boolean classToString, boolean annotationsToMap) {<z>
.class);<z>
result, Adapt.CLASS_TO_STRING, classToString);<z>
(result, Adapt.ANNOTATION_TO_MAP, annotationsToMap);<z>
;<z>
private void maybeBindReferencePointcutParameter() {<z>
if (this.numberOfRemainingUnboundArguments > 1) {<z>
("Still " + this.numberOfRemainingUnboundArguments<z>
+ " unbound args at reference pointcut binding stage, with no way to determine between them");<z>
varNames = new ArrayList<>();<z>
(this.pointcutExpression, " ");<z>
i < tokens.length; i++) {<z>
tokens[i];<z>
startsWith("!")) {<z>
substring(1);<z>
('(');<z>
) {<z>
);<z>
(tokens.length < i + 2) {<z>
;<z>
.charAt(0) != '(') {<z>
i);<z>
.numTokensConsumed;<z>
.contains(toMatch)) {<z>
varName = maybeExtractVariableName(body.text);<z>
) {<z>
(varName);<z>
(varNames.size() > 1) {<z>
size() +<z>
" candidate reference pointcut variables but only one unbound argument slot");<z>
1) {<z>
.length; j++) {<z>
) {<z>
));<z>
, AsyncContext context,<z>
int bufferSize)<z>
, URISyntaxException {<z>
bufferSize);<z>
factory;<z>
= bufferSize;<z>
) {<z>
notNull(sessionHandler, "StompSessionHandler must not be null");<z>
notNull(connectHeaders, "StompHeaders must not be null");<z>
.toString();<z>
sessionHandler;<z>
connectHeaders = connectHeaders;<z>
requestProcessor) {<z>
, "Function must not be null");<z>
request));<z>
BeanWiringInfo buildWiringInfo(Object beanInstance, Configurable annotation) {<z>
))) {<z>
());<z>
().isEmpty()) {<z>
;<z>
(beanInstance), true);<z>
) {<z>
, "MessageConverter must not be null");<z>
jmsMessageConverter = jmsMessageConverter;<z>
true;<z>
String getValue(EvaluationContext context) throws EvaluationException {<z>
;<z>
Expression expression : this.expressions) {<z>
class);<z>
value != null) {<z>
.append(value);<z>
.toString();<z>
final void setInputFrameFromDescriptor(<z>
symbolTable,<z>
int access,<z>
descriptor,<z>
maxLocals) {<z>
];<z>
[0];<z>
;<z>
0) {<z>
Constants.ACC_CONSTRUCTOR) == 0) {<z>
inputLocals[inputLocalIndex++] =<z>
(symbolTable.getClassName());<z>
} else {<z>
inputLocalIndex++] = UNINITIALIZED_THIS;<z>
)) {<z>
abstractType =<z>
argumentType.getDescriptor(), 0);<z>
] = abstractType;<z>
{<z>
] = TOP;<z>
while (inputLocalIndex < maxLocals) {<z>
;<z>
afterPropertiesSet() {<z>
configuration;<z>
{<z>
.byProvider(this.providerClass);<z>
) {<z>
bootstrap.providerResolver(this.validationProviderResolver);<z>
configuration = bootstrap.configure();<z>
= Validation.byDefaultProvider();<z>
validationProviderResolver != null) {<z>
.validationProviderResolver);<z>
;<z>
applicationContext != null) {<z>
("externalClassLoader", ClassLoader.class);<z>
applicationContext.getClassLoader());<z>
ex) {<z>
;<z>
(targetInterpolator == null) {<z>
();<z>
targetInterpolator));<z>
) {<z>
(this.traversableResolver);<z>
constraintValidatorFactory;<z>
null) {<z>
.applicationContext.getAutowireCapableBeanFactory());<z>
{<z>
(targetConstraintValidatorFactory);<z>
this.parameterNameDiscoverer != null) {<z>
, configuration);<z>
mappingStreams = null;<z>
.mappingLocations != null) {<z>
<>(this.mappingLocations.length);<z>
{<z>
InputStream stream = location.getInputStream();<z>
(stream);<z>
addMapping(stream);<z>
IOException ex) {<z>
closeMappingStreams(mappingStreams);<z>
("Cannot read mapping resource: " + location);<z>
forEach(configuration::addProperty);<z>
postProcessConfiguration(configuration);<z>
.buildValidatorFactory();<z>
;<z>
mappingStreams);<z>
)<z>
{<z>
"Unsupported message type [" + message.getClass() +<z>
);<z>
{<z>
method = methodCache.get(clazz);<z>
method == null) {<z>
getMethod("newBuilder");<z>
(clazz, method);<z>
);<z>
(ServletRequest request) {<z>
(RequestPath) request.getAttribute(PATH_ATTRIBUTE);<z>
path, "Expected parsed RequestPath in request attribute \"" + PATH_ATTRIBUTE + "\".");<z>
;<z>
MethodMatcher mm2, ClassFilter cf2) {<z>
return (mm1 instanceof IntroductionAwareMethodMatcher || mm2 instanceof IntroductionAwareMethodMatcher ?<z>
:<z>
, cf1, mm2, cf2));<z>
A findAnnotationOnBean(<z>
Class<A> annotationType, boolean allowFactoryBeanInit)<z>
throws NoSuchBeanDefinitionException {<z>
beanName, annotationType, allowFactoryBeanInit);<z>
, final long value) {<z>
hash(tag, value);<z>
hashCode);<z>
(entry != null) {<z>
== value) {<z>
;<z>
.next;<z>
int index = constantPoolCount;<z>
);<z>
;<z>
, value, hashCode));<z>
{<z>
= headers.getAll(this.key);<z>
value);<z>
return previousValues;<z>
) {<z>
);<z>
: protocols) {<z>
toLowerCase());<z>
) {<z>
IllegalStateException) {<z>
ex);<z>
IllegalArgumentException) {<z>
), ex);<z>
if (ex instanceof EntityNotFoundException) {<z>
(EntityNotFoundException) ex);<z>
(ex instanceof NoResultException) {<z>
, ex);<z>
NonUniqueResultException) {<z>
getMessage(), 1, ex);<z>
ex instanceof QueryTimeoutException) {<z>
), ex);<z>
{<z>
getMessage(), ex);<z>
) {<z>
.getMessage(), ex);<z>
if (ex instanceof OptimisticLockException) {<z>
);<z>
ex instanceof EntityExistsException) {<z>
), ex);<z>
ex instanceof TransactionRequiredException) {<z>
;<z>
) {<z>
return new JpaSystemException(ex);<z>
null;<z>
inbound, ByteBufAllocator alloc) {<z>
response = response;<z>
());<z>
(adapter);<z>
inbound = inbound;<z>
alloc);<z>
public static CustomAutowireConfigurer customAutowireConfigurer() {<z>
= new CustomAutowireConfigurer();<z>
{<z>
ComponentScanParserTests.CustomAnnotation.class);<z>
}});<z>
;<z>
Void> doResumeSynchronization(TransactionSynchronizationManager synchronizationManager,<z>
<TransactionSynchronization> suspendedSynchronizations) {<z>
;<z>
return Flux.fromIterable(suspendedSynchronizations)<z>
synchronization -> synchronization.resume()<z>
(synchronization))).then();<z>
int paramIndex, @Nullable byte[] content)<z>
SQLException {<z>
if (content != null) {<z>
getConnection().createBlob();<z>
);<z>
.add(blob);<z>
paramIndex, blob);<z>
) null);<z>
(logger.isDebugEnabled()) {<z>
content != null ? "Copied bytes into temporary BLOB with length " + content.length :<z>
"Set BLOB to null");<z>
id) throws DataAccessException {<z>
executeWithNativeSession(session -> {<z>
entity, id);<z>
return null;<z>
});<z>
> MultiValueMap<K, V> unmodifiableMultiValueMap(<z>
> targetMap) {<z>
(targetMap, "'targetMap' must not be null");<z>
instanceof UnmodifiableMultiValueMap) {<z>
;<z>
);<z>
[]> getParameterMap() {<z>
multipartParameterNames == null) {<z>
initializeMultipart();<z>
.isEmpty()) {<z>
);<z>
getParameterMap());<z>
.multipartParameterNames) {<z>
paramMap.containsKey(paramName)) {<z>
));<z>
paramMap;<z>
checkNotLocked( Lockable mixin) {<z>
locked()) {<z>
();<z>
initServletContext(ServletContext servletContext) {<z>
this.messageSource != null) {<z>
.getJstlAwareMessageSource(servletContext, this.messageSource);<z>
;<z>
{<z>
=<z>
isAfterAdvice(advisor2));<z>
advisor1) - getAspectDeclarationOrder(advisor2);<z>
if (oneOrOtherIsAfterAdvice) {<z>
{<z>
;<z>
if (adviceDeclarationOrderDelta == 0) {<z>
return SAME_PRECEDENCE;<z>
return HIGHER_PRECEDENCE;<z>
(adviceDeclarationOrderDelta < 0) {<z>
;<z>
{<z>
return SAME_PRECEDENCE;<z>
return LOWER_PRECEDENCE;<z>
locale) throws NoSuchMessageException {<z>
null) {<z>
(resolvable, locale);<z>
null) {<z>
), locale);<z>
getCodes();<z>
[0] : "");<z>
locale);<z>
) {<z>
();<z>
notNull(name, "Attribute name must not be null");<z>
null) {<z>
.attributes.put(name, value);<z>
value != oldValue) {<z>
oldValue instanceof HttpSessionBindingListener) {<z>
;<z>
HttpSessionBindingListener) {<z>
;<z>
name);<z>
static boolean isValidExpression(@Nullable String expression) {<z>
null) {<z>
;<z>
(expression);<z>
true;<z>
IllegalArgumentException ex) {<z>
false;<z>
... paths) {<z>
{<z>
= (ObjectUtils.isEmpty(paths) ?<z>
);<z>
(paths) ?<z>
PatternsRequestCondition(<z>
null, this.options.getPathMatcher(),<z>
this.options.useTrailingSlashMatch(),<z>
.getFileExtensions()));<z>
;<z>
Boolean matchTargetType(String typeName) {<z>
).equals(typeName)) {<z>
;<z>
(typeName)) {<z>
return false;<z>
typeName.startsWith("java")) {<z>
, getClass().getClassLoader());<z>
);<z>
Throwable ex) {<z>
return null;<z>
{<z>
(this.readOnlyHeaders != null) {<z>
;<z>
headersWritten) {<z>
= HttpHeaders.readOnlyHttpHeaders(this.headers);<z>
readOnlyHeaders;<z>
headers;<z>
ConnectionHandle getJdbcConnection(EntityManager entityManager, boolean readOnly)<z>
{<z>
;<z>
, String name) {<z>
(request, name);<z>
(ServletRequestBindingException ex) {<z>
return new long[0];<z>
> type) {<z>
();<z>
(name, "Parameter name must not be null or empty!");<z>
LinkedHashMap<>(this.byName);<z>
));<z>
sqlSupplier, this.filterFunction);<z>
public void enableLoggingRequestDetails(boolean enable) {<z>
{<z>
enable;<z>
);<z>
initWriters();<z>
, Map<String, Object> result) {<z>
{<z>
this.registrations.get(mimeType);<z>
!= null) {<z>
);<z>
())) {<z>
iterator();<z>
(iterator.hasNext()) {<z>
;<z>
TypeDescriptor sourceType, TypeDescriptor targetType) {<z>
, "Target type to convert to cannot be null");<z>
if (sourceType == null) {<z>
true;<z>
getConverter(sourceType, targetType);<z>
);<z>
String value) {<z>
notNull(key, "'key' must not be null");<z>
notNull(value, "'value' must not be null");<z>
headers.header(key, value);<z>
;<z>
void afterPropertiesSet() {<z>
addCustomResolver(new RSocketRequesterMethodArgumentResolver());<z>
();<z>
((composite, handler) -> {<z>
(RSocketFrameTypeMessageCondition.CONNECT_CONDITION)) {<z>
returnType = handler.getReturnType();<z>
> 0) {<z>
throw new IllegalStateException(<z>
);<z>
;<z>
<String> beanNamesFound) {<z>
.size() + ": " +<z>
));<z>
numberOfBeansFound = beanNamesFound.size();<z>
beanNamesFound;<z>
boolean determineRequiredStatus(MergedAnnotation<?> ann) {<z>
((AnnotationAttributes)<z>
);<z>
ExpressionState state) throws EvaluationException {<z>
);<z>
(state).getValue();<z>
rightNumber) {<z>
|| rightNumber instanceof BigDecimal) {<z>
class);<z>
.class);<z>
(rightBigDecimal));<z>
Double || rightNumber instanceof Double) {<z>
"D";<z>
doubleValue());<z>
rightNumber instanceof Float) {<z>
"F";<z>
) * rightNumber.floatValue());<z>
{<z>
);<z>
.convertNumberToTargetClass(rightNumber, BigInteger.class);<z>
));<z>
|| rightNumber instanceof Long) {<z>
.exitTypeDescriptor = "J";<z>
);<z>
isIntegerForNumericOp(rightNumber)) {<z>
= "I";<z>
.intValue());<z>
;<z>
instanceof Integer repeats) {<z>
text.repeat(repeats));<z>
.MULTIPLY, leftOperand, rightOperand);<z>
<? extends CharSequence> messageSupplier) {<z>
(this.log.isInfoEnabled()) {<z>
messageSupplier));<z>
(ResolvableType actualType, ResolvableType elementType, ServerHttpRequest request,<z>
Object> hints) {<z>
, request, hints);<z>
) {<z>
new StringBuilder();<z>
maxAge != null) {<z>
));<z>
{<z>
);<z>
) {<z>
, "no-store");<z>
if (this.mustRevalidate) {<z>
appendDirective(headerValue, "must-revalidate");<z>
if (this.noTransform) {<z>
);<z>
) {<z>
);<z>
if (this.cachePrivate) {<z>
(headerValue, "private");<z>
if (this.proxyRevalidate) {<z>
);<z>
sMaxAge != null) {<z>
.sMaxAge.getSeconds());<z>
!= null) {<z>
+ this.staleIfError.getSeconds());<z>
staleWhileRevalidate != null) {<z>
.getSeconds());<z>
return headerValue.toString();<z>
{<z>
new UnsupportedOperationException(<z>
);<z>
TransactionDefinition definition)<z>
, TransactionException {<z>
;<z>
!= TransactionDefinition.TIMEOUT_DEFAULT) {<z>
getTimeout());<z>
ISOLATION_DEFAULT);<z>
previousIsolationLevel = null;<z>
;<z>
) {<z>
equals(<z>
getConnectionHandlingMode().getReleaseMode())) {<z>
preparedCon = session.connection();<z>
definition);<z>
(isolationLevelNeeded) {<z>
InvalidIsolationLevelException(<z>
"Hibernate connection release mode is set to ON_CLOSE.");<z>
.getTransaction().begin();<z>
, definition.isReadOnly());<z>
(definition instanceof ResourceTransactionDefinition &&<z>
)) {<z>
;<z>
{<z>
;<z>
SessionTransactionData(<z>
isReadOnly());<z>
,<z>
) {<z>
then(Mono.defer(() -> {<z>
status.isNewTransaction()) {<z>
(status.isDebug()) {<z>
"Initiating transaction rollback");<z>
doRollback(synchronizationManager, status);<z>
Void> beforeCompletion = Mono.empty();<z>
)) {<z>
)) {<z>
"Participating transaction failed - marking existing transaction as rollback-only");<z>
= doSetRollbackOnly(synchronizationManager, status);<z>
debug("Should roll back transaction but cannot - no transaction available");<z>
beforeCompletion;<z>
ErrorPredicates.RUNTIME_OR_ERROR, ex -> triggerAfterCompletion(<z>
, TransactionSynchronization.STATUS_UNKNOWN)<z>
(ex)))<z>
)))<z>
ex)))<z>
cleanupAfterCompletion(synchronizationManager, status));<z>
.Parser parser,<z>
) {<z>
);<z>
(int initialSize, int resizeThreshold) {<z>
.referenceManager = createReferenceManager();<z>
initialSize;<z>
references = createReferenceArray(initialSize);<z>
resizeThreshold = resizeThreshold;<z>
) {<z>
== other) {<z>
;<z>
super.equals(other)) {<z>
false;<z>
;<z>
status);<z>
extends Message> apply(DataBuffer input) {<z>
= new ArrayList<>();<z>
int remainingBytesToRead;<z>
int chunkBytesToRead;<z>
null) {<z>
readMessageSize(input)) {<z>
;<z>
.messageBytesToRead > this.maxMessageSize) {<z>
throw new DataBufferLimitException(<z>
+ ") exceeds " +<z>
.maxMessageSize + ")");<z>
this.messageBytesToRead);<z>
));<z>
readableByteCount() - chunkBytesToRead;<z>
[chunkBytesToRead];<z>
(bytesToWrite, 0, chunkBytesToRead);<z>
bytesToWrite);<z>
chunkBytesToRead;<z>
messageBytesToRead == 0) {<z>
asByteBuffer());<z>
(this.output);<z>
.output = null;<z>
toClass())<z>
stream, extensionRegistry)<z>
build();<z>
);<z>
remainingBytesToRead > 0);<z>
return messages;<z>
catch (DecodingException ex) {<z>
ex;<z>
catch (IOException ex) {<z>
, ex);<z>
{<z>
.getMessage(), ex);<z>
input);<z>
public void setup() {<z>
new Jackson2ObjectMapperBuilder();<z>
build();<z>
();<z>
jsonEncoder = new Jackson2JsonEncoder(objectMapper);<z>
forClass(Project.class);<z>
.projectCount);<z>
LineNumberReader lineNumberReader, @Nullable String[] commentPrefixes,<z>
) throws IOException {<z>
lineNumberReader.readLine();<z>
StringBuilder scriptBuilder = new StringBuilder();<z>
!= null) {<z>
(blockCommentEndDelimiter)) ||<z>
) {<z>
.length() > 0) {<z>
);<z>
.append(currentStatement);<z>
();<z>
, separator);<z>
);<z>
(String name, @Nullable Object value) {<z>
Assert.notNull(name, "Name must not be null");<z>
name = name;<z>
= value;<z>
) {<z>
> frames = Flux.from(messages)<z>
message -> {<z>
logger.isTraceEnabled()) {<z>
() + "Sending " + message);<z>
map(this::toFrame);<z>
()<z>
frames)<z>
;<z>
Session session) throws JMSException {<z>
Object delegate = getDelegate();<z>
delegate != this) {<z>
instanceof SessionAwareMessageListener) {<z>
;<z>
).onMessage(message, session);<z>
) {<z>
message);<z>
(message);<z>
;<z>
convertedMessage);<z>
(methodName, listenerArguments);<z>
null) {<z>
session);<z>
.trace("No result object given - no result to handle");<z>
EvaluationException {<z>
;<z>
();<z>
instanceof Number rightNumber) {<z>
(leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {<z>
, BigDecimal.class);<z>
;<z>
(rightBigDecimal));<z>
Double || rightNumber instanceof Double) {<z>
= "D";<z>
);<z>
rightNumber instanceof Float) {<z>
.exitTypeDescriptor = "F";<z>
());<z>
(leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {<z>
BigInteger.class);<z>
, BigInteger.class);<z>
remainder(rightBigInteger));<z>
instanceof Long || rightNumber instanceof Long) {<z>
this.exitTypeDescriptor = "J";<z>
) % rightNumber.longValue());<z>
CodeFlow.isIntegerForNumericOp(rightNumber)) {<z>
;<z>
) % rightNumber.intValue());<z>
rightNumber.doubleValue());<z>
rightOperand);<z>
) {<z>
(this.propertyValue, "addAll", values);<z>
values) {<z>
;<z>
retVal;<z>
AccessException {<z>
Object implicitVar = resolveImplicitVariable(name);<z>
{<z>
new TypedValue(implicitVar);<z>
));<z>
> decoders,<z>
,<z>
DataBufferFactory bufferFactory, MetadataExtractor metadataExtractor) {<z>
Collections.unmodifiableList(encoders);<z>
= Collections.unmodifiableList(decoders);<z>
routeMatcher = routeMatcher;<z>
adapterRegistry = adapterRegistry;<z>
bufferFactory = bufferFactory;<z>
= metadataExtractor;<z>
) {<z>
TokenKind.MINUS, TokenKind.NOT)) {<z>
t = takeToken();<z>
= eatUnaryExpression();<z>
null, "No node");<z>
NOT) {<z>
.endPos, expr);<z>
.PLUS) {<z>
, expr);<z>
;<z>
, t.endPos, expr);<z>
TokenKind.INC, TokenKind.DEC)) {<z>
t = takeToken();<z>
SpelNodeImpl expr = eatUnaryExpression();<z>
.getKind() == TokenKind.INC) {<z>
t.endPos, false, expr);<z>
, expr);<z>
;<z>
Method method) {<z>
();<z>
[types.length];<z>
< types.length; x++) {<z>
);<z>
return signature;<z>
ProtobufJavaFormatSupport() {<z>
();<z>
;<z>
);<z>
(FormatFactory.Formatter.HTML);<z>
, @Nullable ReactiveAdapter adapter) {<z>
) {<z>
(adapter.isNoValue()) {<z>
return true;<z>
);<z>
type) {<z>
).length == 1) {<z>
;<z>
;<z>
info(Object message) {<z>
isInfoEnabled()) {<z>
(String.valueOf(message));<z>
(Type type) {<z>
switch (type) {<z>
FormatStyle.SHORT);<z>
ofLocalizedTime(FormatStyle.SHORT);<z>
.SHORT);<z>
) {<z>
{<z>
;<z>
{<z>
;<z>
.equals("Ljava/lang/Boolean"));<z>
HttpHeaders headers) throws IOException {<z>
headers);<z>
body != null) {<z>
);<z>
setEntity(requestEntity);<z>
);<z>
);<z>
> T beanOfTypeIncludingAncestors(<z>
type, boolean includeNonSingletons, boolean allowEagerInit)<z>
{<z>
(lbf, type, includeNonSingletons, allowEagerInit);<z>
beansOfType);<z>
Nullable Object returnValue, MethodParameter returnType) {<z>
returnValue != null) {<z>
.getClass();<z>
Type type = getHttpEntityType(returnType);<z>
!= null ? type : Object.class);<z>
returnType, type).toClass();<z>
TypeConverter tc) throws SQLException {<z>
, "Mapped constructor was not initialized");<z>
[] args;<z>
{<z>
.constructorParameterNames.length];<z>
.length; i++) {<z>
(this.constructorParameterNames[i]);<z>
= this.constructorParameterTypes[i];<z>
;<z>
);<z>
= new Object[0];<z>
(this.mappedConstructor, args);<z>
{<z>
; i++) {<z>
))) {<z>
;<z>
;<z>
eventType) {<z>
: resolveDefaultEventType(event));<z>
executor = getTaskExecutor();<z>
{<z>
!= null) {<z>
, event));<z>
event);<z>
protected void doInitialize() throws JMSException {<z>
(!this.connectLazily) {<z>
establishSharedConnection();<z>
JMSException ex) {<z>
("Could not connect on initialization - registering message consumers lazily", ex);<z>
initializeConsumers();<z>
(PathMatcher pathMatcher) {<z>
Assert.notNull(pathMatcher, "PathMatcher must not be null");<z>
pathMatcher = pathMatcher;<z>
instanceof UrlBasedCorsConfigurationSource urlConfigSource) {<z>
);<z>
Result staxResult) throws XmlMappingException {<z>
(staxResult);<z>
streamWriter != null) {<z>
(graph, streamWriter);<z>
staxResult);<z>
eventWriter != null) {<z>
graph, eventWriter);<z>
;<z>
, @Nullable Object source) {<z>
getRegistry().containsBeanDefinition(RESOURCE_URL_PROVIDER)) {<z>
new RootBeanDefinition(ResourceUrlProvider.class);<z>
setSource(source);<z>
urlProvider.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
registerBeanDefinition(RESOURCE_URL_PROVIDER, urlProvider);<z>
RESOURCE_URL_PROVIDER));<z>
interceptor = new RootBeanDefinition(ResourceUrlProviderExposingInterceptor.class);<z>
.setSource(source);<z>
);<z>
.class);<z>
setSource(source);<z>
;<z>
);<z>
.addIndexedArgumentValue(1, interceptor);<z>
mappedInterceptor);<z>
;<z>
private static String getSanitizedPath(final StringBuilder path) {<z>
indexOf("//");<z>
(index >= 0) {<z>
StringBuilder(path);<z>
) {<z>
sanitized.deleteCharAt(index);<z>
, index);<z>
toString();<z>
;<z>
getSourceLocation() {<z>
== null) {<z>
;<z>
this.sourceLocation;<z>
private Msg(<z>
.google.protobuf.CodedInputStream input,<z>
extensionRegistry)<z>
google.protobuf.InvalidProtocolBufferException {<z>
initFields();<z>
SuppressWarnings("unused")<z>
= 0;<z>
.google.protobuf.UnknownFieldSet.Builder unknownFields =<z>
();<z>
;<z>
done) {<z>
tag = input.readTag();<z>
(tag) {<z>
0:<z>
;<z>
default: {<z>
unknownFields,<z>
)) {<z>
true;<z>
10: {<z>
;<z>
input.readBytes();<z>
18: {<z>
null;<z>
& 0x00000002) == 0x00000002)) {<z>
toBuilder();<z>
);<z>
null) {<z>
blah_);<z>
= subBuilder.buildPartial();<z>
|= 0x00000002;<z>
protobuf.InvalidProtocolBufferException e) {<z>
.setUnfinishedMessage(this);<z>
) {<z>
.google.protobuf.InvalidProtocolBufferException(<z>
()).setUnfinishedMessage(this);<z>
finally {<z>
);<z>
);<z>
) {<z>
.getAttribute(UrlPathHelper.PATH_ATTRIBUTE);<z>
!= null) {<z>
return lookupPath;<z>
.getAttribute(PATH_ATTRIBUTE);<z>
{<z>
pathWithinApplication();<z>
IllegalArgumentException(<z>
"Neither a pre-parsed RequestPath nor a pre-resolved String lookupPath is available.");<z>
ServerWebExchange exchange) {<z>
();<z>
.getFormData();<z>
exchange.getMultipartData();<z>
(queryParams), formData, multipartData)<z>
map(tuple -> {<z>
> result = new TreeMap<>();<z>
addBindValue(result, key, values));<z>
values));<z>
key, values));<z>
return result;<z>
);<z>
getIfUnique() throws BeansException {<z>
descriptorToUse = new DependencyDescriptor(this.descriptor) {<z>
isRequired() {<z>
return false;<z>
Object> matchingBeans) {<z>
return null;<z>
if (this.optional) {<z>
;<z>
null);<z>
(ScopeNotActiveException ex) {<z>
return null;<z>
statusText) {<z>
)) {<z>
statusCode.getReasonPhrase();<z>
+ statusText;<z>
public static QueueSession getTransactionalQueueSession(final QueueConnectionFactory cf,<z>
final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed)<z>
JMSException {<z>
doGetTransactionalSession(cf, new ResourceFactory() {<z>
{<z>
QueueSession.class, existingCon);<z>
public Connection getConnection(JmsResourceHolder holder) {<z>
QueueConnection.class));<z>
createConnection() throws JMSException {<z>
);<z>
Connection con) throws JMSException {<z>
);<z>
isSynchedLocalTransactionAllowed() {<z>
return synchedLocalTransactionAllowed;<z>
, true);<z>
) {<z>
();<z>
sessionId).append("]; ");<z>
.userName).append("]; ");<z>
);<z>
.append("status=[");<z>
(!wasFailure()) {<z>
"OK");<z>
.append(this.failureCause);<z>
(']');<z>
.toString();<z>
(BeanDefinition bd, String scriptFactoryBeanName,<z>
) {<z>
);<z>
;<z>
);<z>
().clear();<z>
0, scriptSource);<z>
;<z>
;<z>
{<z>
Symbol.TYPE_TAG, value);<z>
;<z>
(entry != null) {<z>
.value.equals(value)) {<z>
entry.index;<z>
= entry.next;<z>
TYPE_TAG, value, hashCode));<z>
decode(DataBuffer dataBuffer, ResolvableType elementType,<z>
hints) {<z>
(logger.isDebugEnabled()) {<z>
+ " bytes");<z>
if (dataBuffer instanceof NettyDataBuffer) {<z>
);<z>
ByteBuf byteBuf;<z>
dataBuffer.readableByteCount()];<z>
);<z>
= Unpooled.wrappedBuffer(bytes);<z>
release(dataBuffer);<z>
byteBuf;<z>
String getAsText() {<z>
();<z>
(clazz != null) {<z>
getQualifiedName(clazz);<z>
;<z>
protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {<z>
.handlerMappings != null) {<z>
) {<z>
(request);<z>
if (handler != null) {<z>
return handler;<z>
;<z>
(Throwable ex) {<z>
complete = true;<z>
failure = ex;<z>
;<z>
;<z>
private AspectJAnnotationType determineAnnotationType(A annotation) {<z>
;<z>
) {<z>
;<z>
;<z>
request) {<z>
CorsUtils.isPreFlightRequest(request)) {<z>
;<z>
this.expressions) {<z>
!expression.match(request)) {<z>
null;<z>
return this;<z>
boolean equals(@Nullable Object other) {<z>
== other) {<z>
;<z>
.equals(other)) {<z>
return false;<z>
otherEntity = (RequestEntity<?>) other;<z>
, otherEntity.method) &&<z>
otherEntity.url));<z>
<Method> candidateMethods, Method bridgeMethod) {<z>
)) {<z>
return null;<z>
previousMethod = null;<z>
true;<z>
{<z>
bridgeMethod.getDeclaringClass())) {<z>
return candidateMethod;<z>
(previousMethod != null) {<z>
sameSig = sameSig &&<z>
);<z>
= candidateMethod;<z>
;<z>
{<z>
getServerContainer();<z>
serverContainer != null, "No ServerContainer set");<z>
.isDebugEnabled()) {<z>
;<z>
serverContainer.addEndpoint(endpointConfig);<z>
{<z>
;<z>
MediaType getMediaTypeForResource(Resource resource) {<z>
(resource, "Resource must not be null");<z>
mediaType = null;<z>
resource.getFilename();<z>
StringUtils.getFilenameExtension(filename);<z>
if (extension != null) {<z>
lookupMediaType(extension);<z>
{<z>
(null);<z>
;<z>
(<z>
{<z>
, body, charset, null);<z>
public Object invoke() throws InvocationTargetException, IllegalAccessException {<z>
();<z>
= getPreparedMethod();<z>
(preparedMethod.getModifiers())) {<z>
new IllegalArgumentException("Target method must not be non-static without a target");<z>
;<z>
invoke(targetObject, getArguments());<z>
Object cloneArray(Object array) {<z>
{<z>
array).clone();<z>
instanceof byte[]) {<z>
[]) array).clone();<z>
instanceof char[]) {<z>
.clone();<z>
{<z>
);<z>
) {<z>
;<z>
]) {<z>
[]) array).clone();<z>
long[]) {<z>
;<z>
{<z>
).clone();<z>
]) array).clone();<z>
?> message, StompHeaderAccessor accessor) {<z>
(message, accessor);<z>
(SimpMessageHeaderAccessor.IGNORE_ERROR) == null) {<z>
();<z>
;<z>
{<z>
message, ex);<z>
throws IOException {<z>
{<z>
resourceLoader).getResources(locationPattern);<z>
locationPattern);<z>
String name) {<z>
);<z>
;<z>
(cookies != null) {<z>
cookie : cookies) {<z>
(cookie.getName())) {<z>
;<z>
;<z>
RunNotifier notifier) {<z>
) {<z>
notifier.fireTestIgnored(getDescription());<z>
super.run(notifier);<z>
, @Nullable DataSource dataSource) {<z>
) {<z>
return false;<z>
ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);<z>
connectionEquals(conHolder, con));<z>
?> controllerType) {<z>
;<z>
wac != null) {<z>
RequestMappingHandlerMapping.class);<z>
RequestMappingHandlerMapping mapping : map.values()) {<z>
(controllerType)) {<z>
mapping.getPathPrefix(controllerType);<z>
(prefix != null) {<z>
return prefix;<z>
return "";<z>
String[] list) {<z>
();<z>
{<z>
1);<z>
], replacement);<z>
value;<z>
) {<z>
.notNull(destination, "Destination must not be null");<z>
=<z>
getAccessor(message, SimpMessageHeaderAccessor.class);<z>
{<z>
isMutable()) {<z>
.setDestination(destination);<z>
;<z>
.setImmutable();<z>
sendInternal(message);<z>
) MessageHeaderAccessor.getMutableAccessor(message);<z>
);<z>
.wrap(message);<z>
);<z>
simpAccessor.setDestination(destination);<z>
);<z>
(), simpAccessor.getMessageHeaders());<z>
(message);<z>
ch) {<z>
> 255) {<z>
return false;<z>
;<z>
BeanDefinitionBuilder builder) {<z>
;<z>
builder.addPropertyValue("ignoreUnresolvablePlaceholders",<z>
));<z>
(SYSTEM_PROPERTIES_MODE_ATTRIBUTE);<z>
if (StringUtils.hasLength(systemPropertiesModeName) &&<z>
(SYSTEM_PROPERTIES_MODE_DEFAULT)) {<z>
);<z>
(element.hasAttribute("value-separator")) {<z>
);<z>
)) {<z>
element.getAttribute("trim-values"));<z>
("null-value")) {<z>
;<z>
> void metadataToExtract(<z>
<String, Object>> mapper) {<z>
type), mapper);<z>
freshTargetSource() {<z>
{<z>
return this.targetSource;<z>
this.beanFactory == null) {<z>
"No BeanFactory available anymore (probably due to serialization) " +<z>
+ "'");<z>
) {<z>
);<z>
.getBean(this.targetName);<z>
target : new SingletonTargetSource(target));<z>
public boolean absolute(int row) throws InvalidResultSetAccessException {<z>
.absolute(row);<z>
(SQLException se) {<z>
throw new InvalidResultSetAccessException(se);<z>
> clazz, HttpInputMessage inputMessage)<z>
IOException, HttpMessageNotReadableException {<z>
);<z>
(value, clazz);<z>
(result == null) {<z>
(<z>
+ value + "' to " + clazz,<z>
;<z>
result;<z>
State currentState, HttpHeaders headers) {<z>
isFormField(headers)) {<z>
(new FormFieldState(headers));<z>
requestToken();<z>
!this.streaming) {<z>
headers));<z>
;<z>
{<z>
(contentSink);<z>
changeState(currentState, newState)) {<z>
l -> requestToken());<z>
;<z>
);<z>
DefaultParts.part(headers, streamingContent));<z>
BeanDefinition bd, String scriptFactoryBeanName, String scriptedObjectBeanName) {<z>
scriptBeanFactory) {<z>
)) {<z>
.registerBeanDefinition(<z>
);<z>
=<z>
.class);<z>
=<z>
);<z>
scriptFactory.getScriptInterfaces();<z>
interfaces;<z>
) {<z>
bd, interfaces);<z>
ObjectUtils.addObjectToArray(interfaces, configInterface);<z>
createScriptedObjectBeanDefinition(<z>
, scriptedInterfaces);<z>
);<z>
(refreshCheckDelay >= 0) {<z>
BeanDefinition.SCOPE_PROTOTYPE);<z>
, objectBd);<z>
optionsForAllow(URI url) throws RestClientException {<z>
;<z>
headersExtractor);<z>
) : Collections.emptySet());<z>
>... rawConditions) {<z>
new RequestConditionHolder[rawConditions.length];<z>
rawConditions.length; i++) {<z>
(rawConditions[i]);<z>
;<z>
<T> HttpMessageWriter<T> findWriter(<z>
, @Nullable MediaType mediaType) {<z>
.stream()<z>
elementType, mediaType))<z>
findFirst()<z>
::<T>cast)<z>
) -> new IllegalStateException(<z>
+ "\""));<z>
value) {<z>
int radix = 10;<z>
index = 0;<z>
boolean negative = false;<z>
) {<z>
= true;<z>
++;<z>
, index)) {<z>
;<z>
16;<z>
value.startsWith("#", index)) {<z>
index++;<z>
;<z>
) {<z>
index++;<z>
8;<z>
value.substring(index), radix);<z>
.negate() : result);<z>
@Nullable AnnotationTypeMapping source,<z>
Nullable Annotation ann) {<z>
(source, annotationType, ann));<z>
Exception ex) {<z>
);<z>
(failureLogger.isEnabled()) {<z>
.getName(),<z>
() : null), ex);<z>
extends DataBuffer> dataBuffers) {<z>
dataBuffers = dataBuffers.stream()<z>
)<z>
(Collectors.toList());<z>
dataBuffers), this);<z>
selector) {<z>
Assert.notNull(id, "Subscription id must not be null");<z>
(destination, "Subscription destination must not be null");<z>
= id;<z>
.selector = selector;<z>
= destination;<z>
isPattern = isPattern;<z>
guessPropertyTypeFromEditors(String propertyName) {<z>
customEditorsForPath != null) {<z>
.customEditorsForPath.get(propertyName);<z>
) {<z>
new ArrayList<>();<z>
, "", propertyName);<z>
{<z>
();<z>
= this.customEditorsForPath.get(strippedName);<z>
(editorHolder != null) {<z>
getRegisteredType();<z>
return null;<z>
HttpServletRequest request, HttpServletResponse response, Object handler)<z>
{<z>
request);<z>
asyncManager.hasConcurrentResult()) {<z>
;<z>
request, response);<z>
getBeanFactory(Object enhancedConfigInstance) {<z>
.getClass(), BEAN_FACTORY_FIELD);<z>
null, "Unable to find generated bean factory field");<z>
enhancedConfigInstance);<z>
, "BeanFactory has not been injected into @Configuration class");<z>
(beanFactory instanceof ConfigurableBeanFactory,<z>
);<z>
beanFactory;<z>
getContainer(HttpServletRequest request) {<z>
) {<z>
SERVER_CONTAINER_ATTR);<z>
(container instanceof WsServerContainer,<z>
"ServletContext attribute 'jakarta.websocket.server.ServerContainer' not found.");<z>
serverContainer = (WsServerContainer) container;<z>
;<z>
serverContainer;<z>
ann, Class<T> beanClass) {<z>
(!ann.isPresent()) {<z>
;<z>
.instantiateClass(beanClass);<z>
= PropertyAccessorFactory.forBeanPropertyAccess(bean);<z>
);<z>
bean;<z>
) {<z>
(importedResource, "Imported resource must not be null");<z>
this.importedResource = importedResource;<z>
;<z>
= source;<z>
, Class<?> targetType) {<z>
.notNull(sourceType, "Source type must not be null");<z>
;<z>
this.sourceType = sourceType;<z>
targetType = targetType;<z>
{<z>
session -> {<z>
resolveDestinationName(session, destinationName);<z>
);<z>
}, true);<z>
locale) {<z>
(locale == null) {<z>
.locale = locale;<z>
);<z>
final StringBuilder getAttributeDescription() {<z>
= getDefinitionDescription();<z>
.hasText(this.qualifier)) {<z>
'\'');<z>
.labels.isEmpty()) {<z>
).append(this.labels);<z>
;<z>
String string) throws IOException {<z>
"\n");<z>
) {<z>
line);<z>
.append('\n');<z>
= this.outputMessage.getBody();<z>
));<z>
flush();<z>
ex) {<z>
.sendFailed = true;<z>
throw ex;<z>
);<z>
UnsupportedMediaTypeStatusException(@Nullable String reason) {<z>
, reason);<z>
this.contentType = null;<z>
supportedMediaTypes = Collections.emptyList();<z>
;<z>
.method = null;<z>
(@Nullable T source) {<z>
source == null) {<z>
null;<z>
defaultMessage = source.getDefaultMessage();<z>
(defaultMessage != null) {<z>
);<z>
FieldError fieldError) {<z>
;<z>
) {<z>
);<z>
T) new FieldError(<z>
fieldError.isBindingFailure(),<z>
, fieldError.getArguments(), defaultMessage);<z>
(T) new ObjectError(<z>
, defaultMessage);<z>
) {<z>
.remove(HttpHeaders.CONTENT_DISPOSITION);<z>
(HttpHeaders.CONTENT_ENCODING);<z>
);<z>
.remove(HttpHeaders.CONTENT_LENGTH);<z>
CONTENT_LOCATION);<z>
CONTENT_RANGE);<z>
);<z>
ConsumesRequestCondition other, ServerWebExchange exchange) {<z>
.expressions.isEmpty()) {<z>
0;<z>
isEmpty()) {<z>
1;<z>
.expressions.isEmpty()) {<z>
return -1;<z>
get(0));<z>
visitFrame(<z>
final int type,<z>
final int numLocal,<z>
[] local,<z>
,<z>
) {<z>
if (mv != null) {<z>
local, numStack, stack);<z>
(PlaceOfBirth placeOfBirth2) {<z>
placeOfBirth2;<z>
new PlaceOfBirth[] { placeOfBirth2 };<z>
placeOfBirth2);<z>
WebAsyncManager asyncManager, String key) {<z>
= asyncManager.getCallableInterceptor(key);<z>
) {<z>
false;<z>
(AsyncRequestInterceptor) cpi).bindEntityManager();<z>
;<z>
Map<String, ?> matchingBeans) {<z>
Comparator<Object> dependencyComparator = getDependencyComparator();<z>
= (dependencyComparator instanceof OrderComparator ?<z>
.INSTANCE);<z>
);<z>
(@Nullable Class<?> clazz) {<z>
class.isAssignableFrom(clazz) &&<z>
.class.isAssignableFrom(clazz)) ||<z>
clazz)));<z>
) {<z>
this.left instanceof ChangePathPatternParserVisitor.Target target) {<z>
.changeParser(parser);<z>
ChangePathPatternParserVisitor.Target target) {<z>
.changeParser(parser);<z>
String name) throws AccessException {<z>
) {<z>
return false;<z>
? clazz : target.getClass());<z>
) && name.equals("length")) {<z>
return true;<z>
;<z>
.containsKey(cacheKey)) {<z>
true;<z>
;<z>
null) {<z>
);<z>
typeDescriptor = new TypeDescriptor(property);<z>
);<z>
method, typeDescriptor));<z>
.put(cacheKey, typeDescriptor);<z>
;<z>
target);<z>
null) {<z>
field);<z>
(field, typeDescriptor));<z>
);<z>
true;<z>
false;<z>
,<z>
? extends Annotation> containerAnnotationType) {<z>
?<z>
.of(annotationType, containerAnnotationType) :<z>
));<z>
repeatableContainers)<z>
(annotationType)<z>
.firstRunOf(MergedAnnotation::getAggregateIndex))<z>
map(MergedAnnotation::withNonMergedAttributes)<z>
;<z>
public DefaultTransactionDefinition(TransactionDefinition other) {<z>
getPropagationBehavior();<z>
= other.getIsolationLevel();<z>
.timeout = other.getTimeout();<z>
;<z>
getName();<z>
typeProvider,<z>
) {<z>
type;<z>
.typeProvider = typeProvider;<z>
variableResolver = variableResolver;<z>
.componentType = null;<z>
hash;<z>
= resolveClass();<z>
() {<z>
return new AbstractJsonPathRequestMatcher() {<z>
MockClientHttpRequest request) {<z>
.getBodyAsString());<z>
static boolean isEmpty(String[] patterns) {<z>
(!ObjectUtils.isEmpty(patterns)) {<z>
) {<z>
{<z>
false;<z>
;<z>
findDeclaredMethod(final Class type,<z>
methodName, final Class[] parameterTypes)<z>
NoSuchMethodException {<z>
Class cl = type;<z>
cl != null) {<z>
.getDeclaredMethod(methodName, parameterTypes);<z>
NoSuchMethodException e) {<z>
();<z>
);<z>
) {<z>
(!defaultUriVariables.isEmpty()) {<z>
;<z>
(defaultUriVariables);<z>
);<z>
map;<z>
.equals(EncodingMode.VALUES_ONLY)) {<z>
encodeUriVariables(uriVars);<z>
;<z>
createUri(uric);<z>
<A> methodDetails, CacheResolver cacheResolver) {<z>
notNull(methodDetails, "CacheMethodDetails must not be null");<z>
, "CacheResolver must not be null");<z>
methodDetails = methodDetails;<z>
;<z>
methodDetails.getMethod());<z>
(String annotationName, boolean classValuesAsString) {<z>
if (this.nestedAnnotationsAsMap) {<z>
(annotationName, classValuesAsString);<z>
AnnotatedElementUtils.getMergedAnnotationAttributes(this.introspectedMethod,<z>
;<z>
... validationHints) {<z>
) {<z>
validationHints)), errors);<z>
protected void applyContentType(HttpServletResponse response) {<z>
null) {<z>
);<z>
@Nullable Session session) {<z>
!= null) {<z>
.close();<z>
{<z>
.error("Failed to release Hibernate Session", ex);<z>
) {<z>
headers);<z>
variables::get;<z>
this.sendTo = sendTo;<z>
sendToUser;<z>
(int poolSize) {<z>
poolSize > 0, "'poolSize' must be 1 or higher");<z>
{<z>
.scheduledExecutor).setCorePoolSize(poolSize);<z>
poolSize = poolSize;<z>
opcode, final String type) {<z>
) {<z>
);<z>
(ServerHttpResponse outputMessage) {<z>
);<z>
getHeaders();<z>
{<z>
TEXT_EVENT_STREAM);<z>
public Component getObject() throws Exception {<z>
> 0) {<z>
children) {<z>
);<z>
this.parent;<z>
(@Nullable Object value) {<z>
(value instanceof Number) {<z>
, this.numberClass));<z>
value);<z>
loader) {<z>
;<z>
.lastIndexOf('.', lparen);<z>
.trim();<z>
);<z>
, loader));<z>
(ClassNotFoundException | NoSuchMethodException ex) {<z>
throw new CodeGenerationException(ex);<z>
<DataBuffer> read(<z>
int bufferSize, OpenOption... options) {<z>
);<z>
(bufferFactory, "BufferFactory must not be null");<z>
> 0, "'bufferSize' must be > 0");<z>
if (options.length > 0) {<z>
for (OpenOption option : options) {<z>
,<z>
;<z>
open(path, options),<z>
;<z>
) {<z>
protected JCacheOperationSource getCacheOperationSource() {<z>
return cacheOperationSource;<z>
throws DataAccessException {<z>
-> {<z>
checkWriteOperationAllowed(session);<z>
, replicationMode);<z>
return null;<z>
});<z>
(<z>
cacheResolver,<z>
@Nullable Supplier<KeyGenerator> keyGenerator) {<z>
);<z>
cacheResolver);<z>
SingletonSupplier.ofNullable(exceptionCacheResolver);<z>
);<z>
boolean isCurrency(int column) throws InvalidResultSetAccessException {<z>
);<z>
(SQLException se) {<z>
se);<z>
getResponseHeaders() {<z>
)) {<z>
return HttpHeaders.EMPTY;<z>
headers = new HttpHeaders();<z>
;<z>
return headers;<z>
HttpServerRequest request, NettyDataBufferFactory bufferFactory)<z>
{<z>
);<z>
(bufferFactory, "DataBufferFactory must not be null");<z>
= request;<z>
= bufferFactory;<z>
public T decode(M message) throws DecodeException {<z>
;<z>
) {<z>
{<z>
throw new DecodeException((String) message,<z>
"Unable to decode websocket message using ConversionService", ex);<z>
instanceof ByteBuffer) {<z>
message,<z>
ex);<z>
ex;<z>
T> extractData(ClientHttpResponse response) throws IOException {<z>
) {<z>
.delegate.extractData(response);<z>
()).body(body);<z>
()).build();<z>
> submitListenable(Callable<T> task) {<z>
ListenableFutureTask<>(task);<z>
execute(future, TIMEOUT_INDEFINITE);<z>
;<z>
String headerName, String... headerValues) {<z>
: headerValues) {<z>
headers.add(headerName, headerValue);<z>
return this;<z>
[] proxiedUserInterfaces(Object proxy) {<z>
.getClass().getInterfaces();<z>
= 0;<z>
proxy instanceof SpringProxy) {<z>
nonUserIfcCount++;<z>
if (proxy instanceof Advised) {<z>
++;<z>
if (proxy instanceof DecoratingProxy) {<z>
++;<z>
.length - nonUserIfcCount);<z>
"JDK proxy must implement one or more interfaces");<z>
userInterfaces;<z>
private MockHttpServletRequestBuilder initRequestBuilder(<z>
byte[] bytes) {<z>
HttpHeaders.CONTENT_TYPE);<z>
(contentType, "multipart/")) {<z>
= MockMvcRequestBuilders.request(httpMethod, uri);<z>
(!ObjectUtils.isEmpty(bytes)) {<z>
content(bytes);<z>
requestBuilder;<z>
(uri);<z>
);<z>
toString())<z>
)<z>
;<z>
, Collections.emptyMap())<z>
(part -><z>
.join(part.content())<z>
-> {<z>
readableByteCount()];<z>
buffer.read(partBytes);<z>
(buffer);<z>
FilePart ?<z>
.filename(), partBytes) :<z>
);<z>
part.headers());<z>
);<z>
)<z>
(TIMEOUT);<z>
requestBuilder;<z>
exhaustiveCollectionCompare(<z>
candidateValue, BindStatus bindStatus) {<z>
HashMap<>();<z>
PropertyEditor editor = null;<z>
(candidateValue instanceof String);<z>
) {<z>
getClass());<z>
{<z>
null && element != null && candidateIsString) {<z>
));<z>
candidateValue, editor, convertedValueCache)) {<z>
return true;<z>
return false;<z>
(Message<?> message) {<z>
(message, MessageHeaderAccessor.class);<z>
) {<z>
StompHeaderAccessor) accessor;<z>
;<z>
getHeaders());<z>
(messageType)) {<z>
= convertConnectAcktoStompConnected(stompAccessor);<z>
.DISCONNECT_ACK.equals(messageType)) {<z>
);<z>
(receipt != null) {<z>
StompCommand.RECEIPT);<z>
;<z>
StompCommand.ERROR);<z>
.setMessage("Session closed.");<z>
equals(messageType)) {<z>
= StompHeaderAccessor.createForHeartbeat();<z>
.getCommand())) {<z>
();<z>
;<z>
ClassLoader classLoader) {<z>
(className, classLoader);<z>
true;<z>
catch (IllegalAccessError err) {<z>
("Readability mismatch in inheritance hierarchy of class [" +<z>
;<z>
) {<z>
false;<z>
fields) {<z>
String field : fields) {<z>
objectName, field);<z>
Exception {<z>
invoke();<z>
) {<z>
) {<z>
();<z>
) instanceof Error) {<z>
getTargetException();<z>
;<z>
Nullable Map<?, ?> context) {<z>
(this.rowMapper != null) {<z>
this.rowMapper;<z>
;<z>
this.rowMapperClass);<z>
int countNumberOfUnboundPrimitiveArguments() {<z>
int count = 0;<z>
++) {<z>
()) {<z>
;<z>
count;<z>
WebApplicationContext createRootApplicationContext() {<z>
configClasses = getRootConfigClasses();<z>
(configClasses)) {<z>
= new AnnotationConfigWebApplicationContext();<z>
);<z>
;<z>
return null;<z>
void doJoinTransaction(boolean enforce) {<z>
jta) {<z>
.joinTransaction();<z>
"Joined JTA transaction");<z>
{<z>
enforce) {<z>
logger.debug("No JTA transaction to join: " + ex);<z>
;<z>
) {<z>
target) &&<z>
{<z>
enlistInCurrentTransaction();<z>
.debug("Joined local transaction");<z>
!enforce) {<z>
logger.debug("No local transaction to join");<z>
throw new TransactionRequiredException("No local transaction to join");<z>
Type type) {<z>
source == null) {<z>
length();<z>
; i++) {<z>
);<z>
{<z>
(i + 2) < length) {<z>
1);<z>
.charAt(i + 2);<z>
;<z>
.digit(hex2, 16);<z>
{<z>
new IllegalArgumentException("Invalid encoded sequence \"" +<z>
;<z>
2;<z>
new IllegalArgumentException("Invalid encoded sequence \"" +<z>
+ "\"");<z>
)) {<z>
+ ch + "' for " +<z>
() + " in \"" + source + "\"");<z>
final int doStartTagInternal() throws ServletException, JspException {<z>
);<z>
{<z>
;<z>
EVAL_BODY_INCLUDE;<z>
SKIP_BODY;<z>
Builder clearFoo() {<z>
0x00000001);<z>
foo_ = getDefaultInstance().getFoo();<z>
;<z>
this;<z>
, Message<?> message) {<z>
{<z>
handlerMethod.getShortLogMessage());<z>
.createWithResolvedBean();<z>
;<z>
{<z>
;<z>
setMessageMethodArgumentResolvers(this.argumentResolvers);<z>
invocable.invoke(message);<z>
();<z>
()) {<z>
.isAsyncReturnValue(returnValue, returnType)) {<z>
.returnValueHandlers.toListenableFuture(returnValue, returnType);<z>
{<z>
));<z>
message);<z>
catch (Exception ex) {<z>
ex, message);<z>
(Throwable ex) {<z>
Exception handlingException =<z>
);<z>
handlerMethod, handlingException, message);<z>
session, MessageChannel outputChannel) {<z>
) < MINIMUM_WEBSOCKET_MESSAGE_SIZE) {<z>
(MINIMUM_WEBSOCKET_MESSAGE_SIZE);<z>
, getMessageSizeLimit()));<z>
void visitEnd() {<z>
(<z>
this.annotationType, this.attributes);<z>
this.consumer.accept(annotation);<z>
<?> collection) {<z>
{<z>
;<z>
> candidate = null;<z>
{<z>
val != null) {<z>
{<z>
getClass();<z>
!= val.getClass()) {<z>
return null;<z>
candidate;<z>
build() {<z>
>();<z>
(this.strategies != null) {<z>
);<z>
if (this.favorPathExtension) {<z>
PathExtensionContentNegotiationStrategy strategy;<z>
useRegisteredExtensionsOnly()) {<z>
this.servletContext, this.mediaTypes);<z>
;<z>
setIgnoreUnknownExtensions(this.ignoreUnknownPathExtensions);<z>
.useRegisteredExtensionsOnly != null) {<z>
;<z>
.add(strategy);<z>
favorParameter) {<z>
strategy = new ParameterContentNegotiationStrategy(this.mediaTypes);<z>
.parameterName);<z>
!= null) {<z>
;<z>
(true);<z>
(strategy);<z>
) {<z>
);<z>
null) {<z>
defaultNegotiationStrategy);<z>
ContentNegotiationManager(strategies);<z>
{<z>
(<z>
(this.mediaTypes));<z>
contentNegotiationManager;<z>
{<z>
;<z>
(bcc);<z>
(Message.RecipientType.BCC, bcc);<z>
name) {<z>
headers.get(name);<z>
header != null) {<z>
();<z>
Collections.emptyList();<z>
(@Nullable String path) {<z>
path == null) {<z>
;<z>
uriVar = false;<z>
i++) {<z>
(i);<z>
|| c == '?') {<z>
return true;<z>
c == '{') {<z>
;<z>
) {<z>
return true;<z>
false;<z>
() {<z>
key);<z>
class);<z>
.getMapValueTypeDescriptor(value));<z>
(ObjectMapper mapper, MimeType... mimeTypes) {<z>
mapper, mimeTypes);<z>
.APPLICATION_NDJSON, MediaType.APPLICATION_STREAM_JSON));<z>
ssePrettyPrinter = initSsePrettyPrinter();<z>
) {<z>
"Failed to complete: " + ex.getMessage());<z>
(this.exchange.isResponseStarted()) {<z>
this.logPrefix + "Closing connection");<z>
getConnection().close();<z>
(IOException ex2) {<z>
logPrefix + "Setting HttpServerExchange status to 500 Server Error");<z>
setStatusCode(500);<z>
.exchange.endExchange();<z>
String beanName) {<z>
beanType, beanName);<z>
= findResourceMetadata(beanName, beanType, null);<z>
.checkConfigMembers(beanDefinition);<z>
void partComplete(boolean finalPart) {<z>
(finalPart) {<z>
;<z>
> targetClass) {<z>
new MethodCacheKey(method);<z>
.methodCache.get(cacheKey);<z>
) {<z>
this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(<z>
this, method, targetClass);<z>
;<z>
cached;<z>
{<z>
)) {<z>
.forCurrentTransaction().flatMap(synchronizationManager -> {<z>
(this.connectionFactory);<z>
= false;<z>
.connectionHolder.hasConnection()) {<z>
), this.connectionFactory);<z>
();<z>
});<z>
);<z>
addJobToScheduler(JobDetail jobDetail) throws SchedulerException {<z>
null) {<z>
.addJob(jobDetail, true);<z>
return true;<z>
false;<z>
) {<z>
(mpvs);<z>
mpvs);<z>
mpvs);<z>
mpvs);<z>
Void context, Throwable throwable) {<z>
payload);<z>
.cancel();<z>
).onError(throwable);<z>
() {<z>
"' for method parameter type " +<z>
() + " is " +<z>
"present but converted to null" : "not present");<z>
throws JspException {<z>
));<z>
(id != null) {<z>
);<z>
) : null);<z>
();<z>
) throws Exception {<z>
);<z>
) {<z>
= true;<z>
= invokeWithTargetException();<z>
{<z>
null) {<z>
());<z>
-> {<z>
ENGLISH);<z>
put(lowerCaseExtension, mediaType);<z>
, lowerCaseExtension);<z>
);<z>
;<z>
allFileExtensions.addAll(allFileExtensions);<z>
boolean contextRelative) {<z>
url);<z>
.contextRelative = contextRelative;<z>
setExposePathVariables(false);<z>
) {<z>
= exchange;<z>
model = model;<z>
;<z>
CodeFlow cf, @Nullable SpelNodeImpl operand) {<z>
if (operand instanceof OpPlus plus) {<z>
());<z>
;<z>
!= null) {<z>
cf.enterCompilationScope();<z>
cf);<z>
cf.lastDescriptor())) {<z>
, "java/lang/String");<z>
();<z>
, "java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);<z>
) {<z>
Blob blob : this.temporaryBlobs) {<z>
free();<z>
(SQLException ex) {<z>
);<z>
(Clob clob : this.temporaryClobs) {<z>
clob.free();<z>
ex) {<z>
ex);<z>
msg) {<z>
);<z>
; i++) {<z>
'\'');<z>
i]);<z>
this.possibleMatches.length - 2) {<z>
.append("', ");<z>
.possibleMatches.length - 2) {<z>
"', or ");<z>
.append("'?");<z>
@Nullable Object key, int hash) {<z>
> currRef = ref;<z>
) {<z>
() == hash) {<z>
= currRef.get();<z>
null) {<z>
= entry.getKey();<z>
) {<z>
;<z>
getNext();<z>
;<z>
() throws Exception {<z>
(this.contextHandler.isRunning()) {<z>
);<z>
)) {<z>
.setStopTimeout(5000);<z>
.stop();<z>
);<z>
(Exception ex) {<z>
) {<z>
new LinkedMultiValueMap<>();<z>
= getURI().getRawQuery();<z>
null) {<z>
);<z>
(matcher.find()) {<z>
(matcher.group(1));<z>
.group(2);<z>
.group(3);<z>
));<z>
(name, value);<z>
;<z>
(<z>
, Object identifier, @Nullable Throwable cause) {<z>
, identifier,<z>
+ persistentClassName + "] with identifier [" + identifier +<z>
cause);<z>
(<z>
Object[] values)<z>
{<z>
paramNames.length != values.length)) {<z>
new IllegalArgumentException("Length of paramNames array must match length of values array");<z>
?>>) session -> {<z>
> queryObject = session.getNamedQuery(queryName);<z>
);<z>
!= null) {<z>
i < values.length; i++) {<z>
i], values[i]);<z>
return queryObject.list();<z>
;<z>
@Nullable Object returnValue, MethodParameter returnType,<z>
BindingContext context) {<z>
notNull(handler, "'handler' is required");<z>
);<z>
handler;<z>
this.returnValue = returnValue;<z>
ResolvableType.forMethodParameter(returnType);<z>
BindingContext());<z>
message) {<z>
);<z>
.expressionString = null;<z>
= position;<z>
String field) {<z>
{<z>
(fixedField(field));<z>
if (value != null) {<z>
.getClass();<z>
.fieldTypes.get(field);<z>
) {<z>
notNull(body, "Body must not be null");<z>
);<z>
.body = body;<z>
this;<z>
> targetClass) {<z>
PointcutExpression pointcutExpression = obtainPointcutExpression();<z>
couldMatchJoinPointsInType(targetClass);<z>
ReflectionWorldException ex) {<z>
("PointcutExpression matching rejected target class - trying fallback expression", ex);<z>
;<z>
if (fallbackExpression != null) {<z>
targetClass);<z>
(Throwable ex) {<z>
("PointcutExpression matching rejected target class", ex);<z>
return false;<z>
InvocableHandlerMethod> handlerMethods,<z>
attributeHandler) {<z>
{<z>
handlerMethods) {<z>
add(new ModelMethod(handlerMethod));<z>
binderFactory;<z>
attributeHandler;<z>
Flux<Object> read(<z>
<String, Object> hints) {<z>
);<z>
elementType);<z>
;<z>
, hints)<z>
(limitTracker::afterLineParsed)<z>
bufferUntil(String::isEmpty)<z>
(lines -> {<z>
, hints);<z>
Mono.empty());<z>
});<z>
, int nestingLevel) {<z>
ResolvableType nested = typeDescriptor.resolvableType;<z>
) {<z>
{<z>
= nested.getNested(2);<z>
{<z>
null;<z>
(typeDescriptor, nested);<z>
> body) {<z>
?<z>
::asByteBuffer) :<z>
map(DataBuffer::asByteBuffer));<z>
JdkFlowAdapter.publisherToFlowPublisher(byteBufferBody);<z>
).getContentLength() > 0 ?<z>
.getContentLength()) :<z>
(bodyFlow));<z>
> serviceLoader) {<z>
<>();<z>
(Object loaderObject : serviceLoader) {<z>
loaderObject);<z>
return result;<z>
Object obj, @Nullable OrderSourceProvider sourceProvider) {<z>
Integer order = null;<z>
&& sourceProvider != null) {<z>
orderSource = sourceProvider.getOrderSource(obj);<z>
null) {<z>
.getClass().isArray()) {<z>
ObjectUtils.toObjectArray(orderSource)) {<z>
;<z>
{<z>
= findOrder(orderSource);<z>
;<z>
boolean inheritable) {<z>
= getLocaleContext();<z>
= (localeContext instanceof TimeZoneAwareLocaleContext ?<z>
).getTimeZone() : null);<z>
(timeZone != null) {<z>
timeZone);<z>
if (locale != null) {<z>
localeContext = new SimpleLocaleContext(locale);<z>
= null;<z>
setLocaleContext(localeContext, inheritable);<z>
throws Exception {<z>
.get(urlPath);<z>
{<z>
instanceof String handlerName) {<z>
(handlerName);<z>
, request);<z>
handler, urlPath, urlPath, null);<z>
null;<z>
) {<z>
this.handlers.add(handler);<z>
if (result) {<z>
.isDebugEnabled()) {<z>
" added " + handler);<z>
return result;<z>
exception) {<z>
);<z>
method == null) {<z>
.getCause();<z>
!= null) {<z>
= resolveMethodByThrowable(cause);<z>
return method;<z>
requestEntity,<z>
Class<T> responseType) throws RestClientException {<z>
RequestCallback requestCallback = httpEntityCallback(requestEntity, responseType);<z>
responseType);<z>
responseExtractor));<z>
(EnumSet<DispatcherType> dispatcherTypes,<z>
) {<z>
servletNames) {<z>
, dispatcherTypes);<z>
{<z>
CacheInterceptor interceptor = new CacheInterceptor();<z>
;<z>
.setCacheOperationSource(cacheOperationSource);<z>
interceptor;<z>
registerAnnotationMethodMessageHandler(Element messageBrokerElement,<z>
RuntimeBeanReference outChannel,<z>
messagingTemplate,<z>
@Nullable Object source) {<z>
;<z>
cargs.addIndexedArgumentValue(0, inChannel);<z>
;<z>
);<z>
new MutablePropertyValues();<z>
= messageBrokerElement.getAttribute("application-destination-prefix");<z>
prefixAttribute, ",")));<z>
;<z>
(WebSocketAnnotationMethodMessageHandler.class, cargs, values);<z>
"path-matcher")) {<z>
"path-matcher");<z>
("pathMatcher", new RuntimeBeanReference(pathMatcherRef));<z>
= getValidator(messageBrokerElement, source, context);<z>
null) {<z>
, validatorRef);<z>
DomUtils.getChildElementByTagName(messageBrokerElement, "argument-resolvers");<z>
null) {<z>
);<z>
messageBrokerElement, "return-value-handlers");<z>
null) {<z>
));<z>
context, source);<z>
?> config,<z>
{<z>
(implClass);<z>
{<z>
(String.class, key, "Key must be a String-based header name");<z>
key;<z>
{<z>
Collections.singletonList(getFirst(headerName));<z>
servletResponse.getHeaders(headerName);<z>
) {<z>
<>(values1);<z>
values1);<z>
key);<z>
);<z>
isEmpty1 && isEmpty2) {<z>
null;<z>
ArrayList<>();<z>
) {<z>
(values1);<z>
(!isEmpty2) {<z>
values.addAll(values2);<z>
return values;<z>
) {<z>
aspectInstance = this.materialized;<z>
== null) {<z>
maaif.getAspectCreationMutex();<z>
) {<z>
this.maaif.getAspectInstance();<z>
.materialized = aspectInstance;<z>
{<z>
.materialized;<z>
if (aspectInstance == null) {<z>
);<z>
.materialized = aspectInstance;<z>
aspectInstance;<z>
MimeType... mimeTypes) {<z>
super(mapper, mimeTypes);<z>
);<z>
new MediaType("application", "stream+x-jackson-smile")));<z>
public Set<DataWithMediaType> build() {<z>
dataToSend.isEmpty()) {<z>
return Collections.emptySet();<z>
('\n');<z>
saveAppendedText();<z>
return this.dataToSend;<z>
() {<z>
null;<z>
reactorHandler = null;<z>
set(null);<z>
fields) {<z>
[0], 0, 60);<z>
], 0, 60);<z>
24);<z>
]);<z>
fields[4]);<z>
], "SUN,MON,TUE,WED,THU,FRI,SAT"), 8);<z>
(7)) {<z>
.daysOfWeek.set(0);<z>
(7);<z>
> configurers) {<z>
isEmpty(configurers)) {<z>
.delegates.addAll(configurers);<z>
() {<z>
;<z>
.REQUEST_SCOPE);<z>
.previousNestedPath != null) {<z>
, this.previousNestedPath, PageContext.REQUEST_SCOPE);<z>
;<z>
= null;<z>
.previousNestedPath = null;<z>
Nullable Annotation metaAnnotation) {<z>
&&<z>
&&<z>
, metaAnnotation));<z>
) {<z>
(props != null) {<z>
en.hasMoreElements();) {<z>
en.nextElement();<z>
;<z>
(value == null) {<z>
getProperty(key);<z>
) value);<z>
params) {<z>
"Parameter map must not be null");<z>
((key, value) -> {<z>
(value instanceof String) {<z>
setParameter(key, (String) value);<z>
]) {<z>
, (String[]) value);<z>
IllegalArgumentException(<z>
() + "]");<z>
);<z>
) {<z>
.destroyed) {<z>
throw new IllegalStateException("Already destroyed");<z>
this.destroyed = true;<z>
(List<ViewResolver> viewResolvers) {<z>
this.viewResolvers.clear();<z>
.isEmpty(viewResolvers)) {<z>
.addAll(viewResolvers);<z>
, String defaultKeyTypeName) {<z>
NodeList nl = keyEle.getChildNodes();<z>
;<z>
{<z>
= nl.item(i);<z>
node instanceof Element) {<z>
(subElement != null) {<z>
);<z>
;<z>
) {<z>
;<z>
subElement, bd, defaultKeyTypeName);<z>
{<z>
this.content);<z>
content.add(current);<z>
= false;<z>
(this.headers, content, byteCount);<z>
if (changeState(this, newState)) {<z>
createFile();<z>
::release);<z>
{<z>
{<z>
;<z>
translatedDex != null) {<z>
translatedDex;<z>
null;<z>
{<z>
variable = super.lookupVariable(name);<z>
if (variable != null) {<z>
return variable;<z>
!this.argumentsLoaded) {<z>
);<z>
;<z>
;<z>
variable;<z>
JMSException {<z>
this.consumersMonitor) {<z>
consumers == null) {<z>
concurrentConsumers);<z>
);<z>
con = getSharedConnection();<z>
i++) {<z>
= createSession(con);<z>
);<z>
add(session);<z>
add(consumer);<z>
public boolean equals(@Nullable Object other) {<z>
) {<z>
return true;<z>
)) {<z>
false;<z>
equals(otherElement.member);<z>
shortValue2) {<z>
currentLength = length;<z>
(currentLength + 5 > data.length) {<z>
(5);<z>
currentData = data;<z>
;<z>
);<z>
) shortValue1;<z>
;<z>
(byte) shortValue2;<z>
length = currentLength;<z>
this;<z>
String getContextPath(HttpServletRequest request) {<z>
WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE);<z>
) {<z>
();<z>
'/')) {<z>
contextPath = "";<z>
request, contextPath);<z>
MessageCreator messageCreator) throws JmsException {<z>
);<z>
defaultDestination != null) {<z>
);<z>
;<z>
{<z>
.notNull(this.jmsTemplate, "Property 'connectionFactory' or 'jmsTemplate' is required");<z>
) {<z>
)<z>
this.jmsTemplate.getMessageConverter());<z>
{<z>
this.responseLock) {<z>
ServerHttpAsyncRequestControl control = this.asyncRequestControl;<z>
.asyncRequestControl = null;<z>
readyToSend = false;<z>
.response = null;<z>
updateLastActiveTime();<z>
)) {<z>
complete();<z>
ex) {<z>
ex.getMessage());<z>
SQLException {<z>
shouldClose(con)) {<z>
();<z>
String getAsText() {<z>
.equals(getValue())) {<z>
);<z>
.equals(getValue())) {<z>
);<z>
;<z>
script,<z>
String commentPrefix, String blockCommentStartDelimiter,<z>
statements) throws ScriptException {<z>
);<z>
commentPrefix },<z>
;<z>
int getSingletonCount() {<z>
this.singletonObjects) {<z>
this.registeredSingletons.size();<z>
Object value) {<z>
(value == null) {<z>
"Ljava/lang/Object";<z>
));<z>
resource) {<z>
mediaType = null;<z>
getFilename();<z>
.isEmpty(this.mediaTypes)) {<z>
getFilenameExtension(filename);<z>
!= null) {<z>
(Locale.ENGLISH));<z>
(mediaType == null) {<z>
= MediaTypeFactory.getMediaTypes(filename);<z>
isEmpty(mediaTypes)) {<z>
.get(0);<z>
mediaType;<z>
void configure(<z>
AsyncUncaughtExceptionHandler> exceptionHandler) {<z>
this.executor = executor;<z>
;<z>
String toString() {<z>
;<z>
* 2);<z>
length; ++i) {<z>
switch (getStep(i)) {<z>
case ARRAY_ELEMENT:<z>
append('[');<z>
case INNER_TYPE:<z>
;<z>
case WILDCARD_BOUND:<z>
);<z>
TYPE_ARGUMENT:<z>
).append(';');<z>
;<z>
();<z>
writeStatusAndHeaders(HttpServletResponse response) {<z>
statusCode);<z>
response);<z>
(response);<z>
(<z>
T> targetType) {<z>
;<z>
TransactionException {<z>
this.lastDefinition = definition;<z>
begun;<z>
inflight;<z>
Mono.empty();<z>
, String proot) throws NamingException {<z>
!proot.endsWith("/")) {<z>
proot + "/";<z>
proot;<z>
;<z>
keySet()) {<z>
(root)) {<z>
startIndex = root.length();<z>
'/', startIndex);<z>
=<z>
);<z>
{<z>
lookup(proot + strippedName)));<z>
{<z>
.size() == 0) {<z>
+ context.root + proot + "]");<z>
iterator();<z>
, Type type, String value) {<z>
(fields, "Fields must not be empty");<z>
hasLength(value, "Value must not be empty");<z>
.length == 1) {<z>
return fields[0];<z>
value);<z>
) {<z>
.notNull(objectMapper, "ObjectMapper must not be null");<z>
();<z>
if (this.findModulesViaServiceLoader) {<z>
modulesToRegister));<z>
.findWellKnownModules) {<z>
;<z>
this.modules != null) {<z>
-> registerModule(module, modulesToRegister));<z>
null) {<z>
> moduleClass : this.moduleClasses) {<z>
instantiateClass(moduleClass), modulesToRegister);<z>
;<z>
) {<z>
;<z>
modules);<z>
(this.dateFormat != null) {<z>
;<z>
this.locale != null) {<z>
.setLocale(this.locale);<z>
if (this.timeZone != null) {<z>
timeZone);<z>
annotationIntrospector != null) {<z>
);<z>
{<z>
.setPropertyNamingStrategy(this.propertyNamingStrategy);<z>
.defaultTyping != null) {<z>
.setDefaultTyping(this.defaultTyping);<z>
(this.serializationInclusion != null) {<z>
.serializationInclusion);<z>
.filters != null) {<z>
objectMapper.setFilterProvider(this.filters);<z>
::addMixIn);<z>
.deserializers.isEmpty()) {<z>
();<z>
addSerializers(module);<z>
;<z>
objectMapper.registerModule(module);<z>
setVisibility);<z>
;<z>
(objectMapper, feature, enabled));<z>
.handlerInstantiator != null) {<z>
.setHandlerInstantiator(this.handlerInstantiator);<z>
else if (this.applicationContext != null) {<z>
.setHandlerInstantiator(<z>
this.applicationContext.getAutowireCapableBeanFactory()));<z>
!= null) {<z>
(objectMapper);<z>
) {<z>
) {<z>
= getAttributeName(i);<z>
().equals(localName) &&<z>
))) {<z>
return getAttributeValue(i);<z>
return null;<z>
{<z>
asyncManager.getConcurrentResult();<z>
();<z>
(logger, traceOn -> {<z>
);<z>
;<z>
});<z>
instanceof ServerResponse) {<z>
return (ServerResponse) result;<z>
else if (result instanceof Exception) {<z>
Exception) result;<z>
(result instanceof Throwable) {<z>
ServletException("Async processing failed", (Throwable) result);<z>
{<z>
return null;<z>
IllegalArgumentException("Unknown result from WebAsyncManager: [" + result + "]");<z>
(ReactiveTypeDescriptor descriptor,<z>
>, Object> fromAdapter) {<z>
) {<z>
fromAdapter));<z>
descriptor, toAdapter, fromAdapter));<z>
ServerHttpResponse response, HttpMethod... httpMethods)<z>
IOException {<z>
(request)) {<z>
;<z>
) == null) {<z>
{<z>
) + "' not allowed.");<z>
(HttpStatus.FORBIDDEN);<z>
;<z>
true;<z>
String className, String beanName) throws IOException {<z>
notNull(className, "No bean class name for configuration class bean definition");<z>
);<z>
(reader, beanName), DEFAULT_EXCLUSION_FILTER);<z>
void setAttribute(String name, Object value) {<z>
.setAttribute(name, value);<z>
) {<z>
if (value instanceof ResourceUrlProvider) {<z>
value);<z>
> findAnnotatedBeans(ApplicationContext context) {<z>
= context;<z>
{<z>
();<z>
;<z>
)) {<z>
{<z>
);<z>
controllerAdvice != null) {<z>
;<z>
adviceBeans);<z>
adviceBeans;<z>
targetType) {<z>
getObjectType();<z>
class == sourceClass) {<z>
false;<z>
) ||<z>
) ||<z>
sourceClass, String.class));<z>
<Void> upgrade(<z>
ServerWebExchange exchange, WebSocketHandler handler,<z>
handshakeInfoFactory) {<z>
ServerHttpRequest request = exchange.getRequest();<z>
.getResponse();<z>
= ServerHttpRequestDecorator.getNativeRequest(request);<z>
;<z>
servletContext = servletRequest.getServletContext();<z>
= handshakeInfoFactory.get();<z>
.bufferFactory();<z>
exchange.getResponse().setComplete()<z>
(Mono.deferContextual(contextView -> {<z>
adapter = new JettyWebSocketHandlerAdapter(<z>
.decorate(handler, contextView),<z>
;<z>
(upgradeRequest, upgradeResponse) -> {<z>
subProtocol != null) {<z>
subProtocol);<z>
adapter;<z>
container = JettyWebSocketServerContainer.getContainer(servletContext);<z>
.upgrade(webSocketCreator, servletRequest, servletResponse);<z>
) {<z>
Mono.error(ex);<z>
);<z>
);<z>
RequestDispatcher getRequestDispatcher(String path) {<z>
path.startsWith("/"),<z>
() -> "RequestDispatcher path [" + path + "] at ServletContext level must start with '/'");<z>
(path);<z>
<String, ?> parameters) throws InvalidDataAccessApiUsageException {<z>
);<z>
));<z>
declaredInParameters = 0;<z>
declaredParameters) {<z>
) {<z>
() &&<z>
.CLOB)) {<z>
new InvalidDataAccessApiUsageException(<z>
"BLOB or CLOB parameters are not allowed for this kind of operation");<z>
())) {<z>
"The parameter named '" + param.getName() +<z>
keySet());<z>
++;<z>
paramsToUse.size(), declaredInParameters);<z>
boolean equals(@Nullable Object other) {<z>
other) {<z>
return true;<z>
!(other instanceof ContentDisposition otherCd)) {<z>
return false;<z>
type, otherCd.type) &&<z>
.name, otherCd.name) &&<z>
, otherCd.filename) &&<z>
.charset) &&<z>
, otherCd.size) &&<z>
this.creationDate, otherCd.creationDate)&&<z>
(this.modificationDate, otherCd.modificationDate)&&<z>
.readDate));<z>
AnnotationVisitor visitTypeAnnotation(<z>
) {<z>
.ASM5) {<z>
UnsupportedOperationException(REQUIRES_ASM5);<z>
null) {<z>
, typePath, descriptor, visible);<z>
return null;<z>
(<z>
,<z>
annotationOffset,<z>
boolean named,<z>
) {<z>
;<z>
(currentOffset);<z>
currentOffset += 2;<z>
named) {<z>
> 0) {<z>
readUTF8(currentOffset, charBuffer);<z>
, elementName, charBuffer);<z>
} else {<z>
(numElementValuePairs-- > 0) {<z>
);<z>
{<z>
();<z>
currentOffset;<z>
Destination destination) throws JMSException {<z>
= doCreateProducer(session, destination);<z>
) {<z>
);<z>
if (!isMessageTimestampEnabled()) {<z>
.setDisableMessageTimestamp(true);<z>
;<z>
repositoryAnnotationType) {<z>
new PersistenceExceptionTranslationInterceptor(beanFactory);<z>
);<z>
void tryRead() {<z>
READING)) {<z>
read();<z>
int fromIndex) {<z>
;<z>
0) {<z>
result);<z>
;<z>
retrieveApplicationListeners(<z>
{<z>
= new ArrayList<>();<z>
null);<z>
);<z>
listeners;<z>
<String> listenerBeans;<z>
(this.defaultRetriever) {<z>
.defaultRetriever.applicationListeners);<z>
(this.defaultRetriever.applicationListenerBeans);<z>
: listeners) {<z>
listener, eventType, sourceType)) {<z>
{<z>
(listener);<z>
(listener);<z>
if (!listenerBeans.isEmpty()) {<z>
);<z>
: listenerBeans) {<z>
beanFactory, listenerBeanName, eventType)) {<z>
?> listener =<z>
(listenerBeanName, ApplicationListener.class);<z>
listener, eventType, sourceType)) {<z>
retriever != null) {<z>
beanFactory.isSingleton(listenerBeanName)) {<z>
filteredListeners.add(listener);<z>
(listenerBeanName);<z>
.add(listener);<z>
listenerBeanName);<z>
if (retriever != null) {<z>
filteredListeners.remove(listener);<z>
.remove(listener);<z>
catch (NoSuchBeanDefinitionException ex) {<z>
AnnotationAwareOrderComparator.sort(allListeners);<z>
(retriever != null) {<z>
()) {<z>
allListeners);<z>
= filteredListenerBeans;<z>
applicationListeners = filteredListeners;<z>
= filteredListenerBeans;<z>
return allListeners;<z>
(String pattern, RequestPredicate predicate,<z>
HandlerFunction<ServerResponse> handlerFunction) {<z>
(predicate), handlerFunction);<z>
(ListableBeanFactory beanFactory, AspectJAdvisorFactory advisorFactory) {<z>
beanFactory, "ListableBeanFactory must not be null");<z>
(advisorFactory, "AspectJAdvisorFactory must not be null");<z>
this.beanFactory = beanFactory;<z>
advisorFactory = advisorFactory;<z>
static HttpMethod method(ServerRequest request) {<z>
).getRequest())) {<z>
accessControlRequestMethod =<z>
);<z>
accessControlRequestMethod != null) {<z>
);<z>
);<z>
toUriString() {<z>
StringBuilder uriBuilder = new StringBuilder();<z>
if (getScheme() != null) {<z>
(getScheme());<z>
);<z>
ssp != null) {<z>
ssp);<z>
!= null) {<z>
;<z>
;<z>
toString();<z>
Class<?> resourceType) {<z>
this.isField) {<z>
);<z>
)) {<z>
throw new IllegalStateException("Specified field type [" + fieldType +<z>
() + "]");<z>
?> paramType =<z>
);<z>
paramType.isAssignableFrom(resourceType))) {<z>
("Specified parameter type [" + paramType +<z>
resourceType.getName() + "]");<z>
onApplicationEvent(ApplicationEvent event) {<z>
) {<z>
).onApplicationEvent(event);<z>
boolean supportsParameter(MethodParameter parameter) {<z>
(parameter,<z>
isAssignableFrom(type) ||<z>
class.isAssignableFrom(type) ||<z>
(type) ||<z>
type ||<z>
type ||<z>
TimeZone.class == type ||<z>
||<z>
UriComponentsBuilder.class == type);<z>
newHandle(<z>
tag,<z>
String owner,<z>
String name,<z>
descriptor,<z>
boolean isInterface) {<z>
.index;<z>
{<z>
) -> {<z>
.strategies.messageReaders());<z>
exchange, request);<z>
return this.routerFunction.route(request)<z>
))<z>
)))<z>
.writeTo(exchange,<z>
HandlerStrategiesResponseContext(this.strategies))));<z>
});<z>
buffers) {<z>
DataBuffer buffer : buffers) {<z>
(buffer instanceof NettyDataBuffer)) {<z>
;<z>
;<z>
(DatabaseMetaData databaseMetaData, TableMetaData tmd) {<z>
ResultSet tableColumns = null;<z>
());<z>
);<z>
.getTableName());<z>
(logger.isDebugEnabled()) {<z>
logger.debug("Retrieving meta-data for " + metaDataCatalogName + '/' +<z>
metaDataTableName);<z>
databaseMetaData.getColumns(<z>
, metaDataTableName, null);<z>
()) {<z>
getString("COLUMN_NAME");<z>
dataType = tableColumns.getInt("DATA_TYPE");<z>
(dataType == Types.DECIMAL) {<z>
);<z>
tableColumns.getInt("DECIMAL_DIGITS");<z>
(typeName) && decimalDigits == 0) {<z>
Types.NUMERIC;<z>
()) {<z>
+ " now NUMERIC instead of DECIMAL");<z>
"NULLABLE");<z>
TableParameterMetaData(columnName, dataType, nullable);<z>
);<z>
logger.isDebugEnabled()) {<z>
getParameterName() + "', sqlType=" +<z>
+ meta.isNullable());<z>
) {<z>
.isWarnEnabled()) {<z>
.warn("Error while retrieving meta-data for table columns. " +<z>
ex);<z>
);<z>
closeResultSet(tableColumns);<z>
> registrar) {<z>
.objectMapperRegistrations == null) {<z>
;<z>
registrations =<z>
>());<z>
accept(registrations);<z>
) {<z>
{<z>
(), lookupPath)) {<z>
();<z>
;<z>
complete() {<z>
.flush();<z>
this.deferredResult.setResult(null);<z>
(IOException ex) {<z>
(ex);<z>
{<z>
;<z>
= method;<z>
requestURI;<z>
);<z>
throws IOException {<z>
count = exceptionCounter.getAndIncrement();<z>
if (matchFilter) {<z>
("Expected exception (" + count + ")");<z>
);<z>
{<z>
);<z>
writeHandler = body -> {<z>
.empty();<z>
);<z>
);<z>
);<z>
) {<z>
left = getLeftOperand();<z>
getRightOperand();<z>
isCompilable()) {<z>
return false;<z>
= left.exitTypeDescriptor;<z>
.exitTypeDescriptor;<z>
.checkNumericCompatibility(<z>
);<z>
);<z>
CacheControl lookupCacheControl(PathContainer path) {<z>
entrySet()) {<z>
.matches(path)) {<z>
entry.getValue();<z>
null;<z>
ModelMBeanNotificationPublisher(<z>
) {<z>
(modelMBean, "'modelMBean' must not be null");<z>
);<z>
.notNull(managedResource, "'managedResource' must not be null");<z>
= modelMBean;<z>
.objectName = objectName;<z>
;<z>
toString() {<z>
("BindStatus: ");<z>
this.expression).append("]; ");<z>
(']');<z>
{<z>
));<z>
return sb.toString();<z>
) {<z>
) {<z>
protobuf.SecondMsg.getDefaultInstance();<z>
();<z>
else {<z>
blahBuilder_.clear();<z>
& ~0x00000002);<z>
return this;<z>
) {<z>
cookie, "ResponseCookie must not be null");<z>
;<z>
this;<z>
void setBeanClassLoader(ClassLoader classLoader) {<z>
) {<z>
this.proxyClassLoader = classLoader;<z>
public Theme getTheme(String themeName) {<z>
{<z>
getTheme(themeName);<z>
null;<z>
String type) {<z>
code.length;<z>
symbolTable.addConstantClass(type);<z>
.index);<z>
(currentBasicBlock != null) {<z>
compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {<z>
(opcode, lastBytecodeOffset, typeSymbol, symbolTable);<z>
.NEW) {<z>
+ 1;<z>
{<z>
;<z>
;<z>
{<z>
asType());<z>
();<z>
size() > 1) {<z>
) {<z>
);<z>
{<z>
.add(e);<z>
;<z>
{<z>
.pathPattern = pathPattern;<z>
= new CorsConfiguration().applyPermitDefaultValues();<z>
(MessageChannel channel) {<z>
for (ChannelInterceptor interceptor : interceptors) {<z>
)) {<z>
;<z>
false;<z>
receiveInterceptorIndex++;<z>
;<z>
DataBuffer buf) {<z>
.isEmpty() &&<z>
>= 2 &&<z>
getByte(1) == HYPHEN)<z>
size() == 1 &&<z>
&&<z>
.getByte(0) == HYPHEN &&<z>
buf.readableByteCount() >= 1 &&<z>
.getByte(0) == HYPHEN);<z>
public Object resolveBean() {<z>
== null) {<z>
.beanOrName);<z>
.isSingleton) {<z>
return resolvedBean;<z>
resolvedBean = resolvedBean;<z>
this.resolvedBean;<z>
(<z>
, FilterChain filterChain)<z>
IOException {<z>
parseIfNecessary(request);<z>
{<z>
;<z>
);<z>
method, Class<?> clazz) {<z>
;<z>
;<z>
());<z>
void setProcessExternalEntities(boolean processExternalEntities) {<z>
.processExternalEntities = processExternalEntities;<z>
if (processExternalEntities) {<z>
true;<z>
] readTypeAnnotations(<z>
MethodVisitor methodVisitor,<z>
Context context,<z>
,<z>
boolean visible) {<z>
[] charBuffer = context.charBuffer;<z>
currentOffset = runtimeTypeAnnotationsOffset;<z>
)];<z>
;<z>
i) {<z>
currentOffset;<z>
;<z>
targetType >>> 24) {<z>
.LOCAL_VARIABLE:<z>
TypeReference.RESOURCE_VARIABLE:<z>
int tableLength = readUnsignedShort(currentOffset + 1);<z>
+= 3;<z>
tableLength-- > 0) {<z>
int startPc = readUnsignedShort(currentOffset);<z>
2);<z>
currentOffset += 6;<z>
);<z>
, context.currentMethodLabels);<z>
:<z>
CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:<z>
TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:<z>
case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:<z>
METHOD_REFERENCE_TYPE_ARGUMENT:<z>
;<z>
case TypeReference.CLASS_EXTENDS:<z>
TypeReference.CLASS_TYPE_PARAMETER_BOUND:<z>
METHOD_TYPE_PARAMETER_BOUND:<z>
.THROWS:<z>
.EXCEPTION_PARAMETER:<z>
.INSTANCEOF:<z>
:<z>
TypeReference.CONSTRUCTOR_REFERENCE:<z>
TypeReference.METHOD_REFERENCE:<z>
currentOffset += 3;<z>
case TypeReference.CLASS_TYPE_PARAMETER:<z>
:<z>
TypeReference.METHOD_FORMAL_PARAMETER:<z>
FIELD:<z>
.METHOD_RETURN:<z>
case TypeReference.METHOD_RECEIVER:<z>
();<z>
(currentOffset);<z>
>> 24) == TypeReference.EXCEPTION_PARAMETER) {<z>
, currentOffset);<z>
* pathLength;<z>
, charBuffer);<z>
currentOffset += 2;<z>
methodVisitor.visitTryCatchAnnotation(<z>
0xFFFFFF00, path, annotationDescriptor, visible),<z>
charBuffer);<z>
else {<z>
* pathLength;<z>
charBuffer);<z>
return typeAnnotationsOffsets;<z>
publishRequestHandledEvent(HttpServletRequest request, HttpServletResponse response,<z>
startTime, @Nullable Throwable failureCause) {<z>
webApplicationContext != null) {<z>
System.currentTimeMillis() - startTime;<z>
(<z>
this,<z>
.getRemoteAddr(),<z>
getServletName(),<z>
,<z>
;<z>
beanName,<z>
Nullable TypeConverter typeConverter) {<z>
= descriptor.getDependencyType();<z>
) {<z>
findAutowireCandidates(beanName, type, descriptor);<z>
!= null) {<z>
addAll(matchingBeans.keySet());<z>
stream()<z>
, type, this))<z>
);<z>
StreamDependencyDescriptor) descriptor).isOrdered()) {<z>
sorted(adaptOrderComparator(matchingBeans));<z>
stream;<z>
else if (type.isArray()) {<z>
> componentType = type.getComponentType();<z>
;<z>
;<z>
resolvedArrayType != type) {<z>
();<z>
(componentType == null) {<z>
;<z>
findAutowireCandidates(beanName, componentType,<z>
descriptor));<z>
.isEmpty()) {<z>
null;<z>
if (autowiredBeanNames != null) {<z>
keySet());<z>
));<z>
(), resolvedArrayType);<z>
[]) {<z>
Object> comparator = adaptDependencyComparator(matchingBeans);<z>
if (comparator != null) {<z>
, comparator);<z>
return result;<z>
{<z>
).resolveGeneric();<z>
== null) {<z>
null;<z>
, elementType,<z>
;<z>
{<z>
return null;<z>
autowiredBeanNames != null) {<z>
addAll(matchingBeans.keySet());<z>
typeConverter : getTypeConverter());<z>
(matchingBeans.values(), type);<z>
if (result instanceof List) {<z>
() > 1) {<z>
;<z>
null) {<z>
).sort(comparator);<z>
;<z>
type) {<z>
).asMap();<z>
resolveGeneric(0);<z>
(String.class != keyType) {<z>
;<z>
1);<z>
== null) {<z>
null;<z>
valueType,<z>
(descriptor));<z>
(matchingBeans.isEmpty()) {<z>
;<z>
{<z>
));<z>
return matchingBeans;<z>
;<z>
static Object setCurrentProxy(@Nullable Object proxy) {<z>
Object old = currentProxy.get();<z>
(proxy != null) {<z>
.set(proxy);<z>
currentProxy.remove();<z>
old;<z>
) {<z>
null, "A SockJsMessageCodec is required but not available: " +<z>
"Add Jackson to the classpath, or configure a custom SockJsMessageCodec.");<z>
;<z>
, TypeDescriptor typeDescriptor) {<z>
target = target;<z>
;<z>
.typeDescriptor = typeDescriptor;<z>
Symbol addConstantInvokeDynamic(<z>
,<z>
,<z>
Handle bootstrapMethodHandle,<z>
bootstrapMethodArguments) {<z>
Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);<z>
(<z>
;<z>
T> source) {<z>
());<z>
for (T objectError : source) {<z>
escaped.add(escapeObjectError(objectError));<z>
escaped;<z>
Log... tertiaryLoggers) {<z>
(2 + tertiaryLoggers.length);<z>
primaryLogger);<z>
.add(secondaryLogger);<z>
, tertiaryLoggers);<z>
new CompositeLog(loggers);<z>
void send(Message<?> message) {<z>
(message, "Message is required");<z>
());<z>
destination != null) {<z>
message);<z>
(), message);<z>
(@Nullable String requestingBeanName)<z>
throws NoSuchBeanDefinitionException {<z>
beanFactory != null, "ListableBeanFactory required for EntityManagerFactory bean lookup");<z>
{<z>
= clbf.resolveNamedBean(EntityManagerFactory.class);<z>
!= null) {<z>
);<z>
emfHolder.getBeanInstance();<z>
);<z>
(@Nullable StompHeaders headers) {<z>
;<z>
DISCONNECT);<z>
!= null) {<z>
addNativeHeaders(headers);<z>
);<z>
);<z>
resetConnection();<z>
) {<z>
responseRef = getResponseReference(message);<z>
(responseRef != null) {<z>
;<z>
();<z>
{<z>
);<z>
httpMethod;<z>
requestURL = requestURL;<z>
headers = headers;<z>
getResponseHeaders(MockHttpServletResponse response) {<z>
headers = new HttpHeaders();<z>
String name : response.getHeaderNames()) {<z>
> values = response.getHeaders(name);<z>
(String value : values) {<z>
(name, value);<z>
headers;<z>
String getSchemaName(int column) throws InvalidResultSetAccessException {<z>
.getSchemaName(column);<z>
SQLException se) {<z>
se);<z>
annotationType) {<z>
(annotationType)) {<z>
;<z>
(scan(annotationType,<z>
.annotationFilter, false)));<z>
{<z>
);<z>
());<z>
file = null;<z>
filePath;<z>
] getResolvedObjectNames() throws MalformedObjectNameException {<z>
this.mappedObjectNames == null) {<z>
null;<z>
];<z>
;<z>
Object objectName : this.mappedObjectNames) {<z>
getInstance(objectName);<z>
i++;<z>
;<z>
) throws IOException {<z>
;<z>
)) {<z>
T data = read();<z>
(data != null) {<z>
!= Long.MAX_VALUE) {<z>
1L);<z>
? super T> subscriber = this.subscriber;<z>
subscriber != null, "No subscriber");<z>
(rsReadLogger.isTraceEnabled()) {<z>
;<z>
subscriber.onNext(data);<z>
rsReadLogger.isTraceEnabled()) {<z>
;<z>
true;<z>
false;<z>
visitMethod(<z>
,<z>
String name,<z>
final String descriptor,<z>
signature,<z>
{<z>
MethodWriter methodWriter =<z>
);<z>
== null) {<z>
firstMethod = methodWriter;<z>
else {<z>
= methodWriter;<z>
;<z>
Token t) {<z>
== null) {<z>
;<z>
).hasPayload()) {<z>
stringValue();<z>
).toLowerCase();<z>
exchange) {<z>
;<z>
getFirst(HttpHeaders.ACCEPT_ENCODING);<z>
.toLowerCase() : null);<z>
(Message<?> message) {<z>
messageToUse = message;<z>
executorInterceptors) {<z>
this, this.messageHandler);<z>
(messageToUse == null) {<z>
.getSimpleName();<z>
{<z>
.debug(name + " returned null from beforeHandle, i.e. precluding the send.");<z>
(message, null);<z>
;<z>
.interceptorIndex++;<z>
return messageToUse;<z>
> exceptionResolvers) {<z>
handlerExceptionResolvers == null) {<z>
{<z>
(resolver instanceof ApplicationContextAware) {<z>
getApplicationContext();<z>
applicationContext != null) {<z>
);<z>
resolver instanceof InitializingBean) {<z>
).afterPropertiesSet();<z>
ex) {<z>
new IllegalStateException("Failure from afterPropertiesSet", ex);<z>
.add(resolver);<z>
getScopeRootContextObject() {<z>
isEmpty(this.scopeRootObjects)) {<z>
this.rootObject;<z>
return this.scopeRootObjects.element();<z>
(ClientHttpRequest request) throws IOException {<z>
;<z>
this.body != null) {<z>
request instanceof StreamingHttpOutputMessage) {<z>
) request).setBody(outputStream -><z>
);<z>
);<z>
source) {<z>
().containsBeanDefinition(BEAN_NAME_URL_HANDLER_MAPPING_BEAN_NAME)) {<z>
);<z>
setSource(source);<z>
.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
).add("order", 2);<z>
registerCorsConfigurations(null, context, source);<z>
"corsConfigurations", corsRef);<z>
);<z>
;<z>
String propertyName,<z>
{<z>
)) {<z>
return original;<z>
(requiredType);<z>
!canCreateCopy(requiredType)) {<z>
) {<z>
getClass().getName() +<z>
);<z>
return original;<z>
isInstance(original);<z>
.getMapKeyTypeDescriptor() : null);<z>
null);<z>
&&<z>
, propertyName)) {<z>
original;<z>
?> it;<z>
.iterator();<z>
{<z>
()) {<z>
.getName() +<z>
+ ex);<z>
;<z>
Map<Object, Object> convertedCopy;<z>
approximable) {<z>
original, original.size());<z>
)<z>
(requiredType).newInstance();<z>
catch (Throwable ex) {<z>
.isDebugEnabled()) {<z>
().getName() +<z>
;<z>
;<z>
) {<z>
) it.next();<z>
= entry.getKey();<z>
);<z>
buildKeyedPropertyName(propertyName, key);<z>
null, key,<z>
keyType);<z>
(keyedPropertyName, null, value,<z>
, valueType);<z>
, convertedValue);<z>
{<z>
) {<z>
getClass().getName() +<z>
;<z>
;<z>
);<z>
original : convertedCopy);<z>
{<z>
range, "Range String must not be empty");<z>
indexOf('-');<z>
if (dashIdx > 0) {<z>
;<z>
- 1) {<z>
.substring(dashIdx + 1));<z>
(firstPos, lastPos);<z>
);<z>
else if (dashIdx == 0) {<z>
(1));<z>
return new SuffixByteRange(suffixLength);<z>
);<z>
converterRegistry) {<z>
(converterRegistry);<z>
(converterRegistry);<z>
((ConversionService) converterRegistry));<z>
.addConverter(new StringToTimeZoneConverter());<z>
));<z>
;<z>
);<z>
) converterRegistry));<z>
(new FallbackObjectToStringConverter());<z>
ObjectToOptionalConverter((ConversionService) converterRegistry));<z>
void initMessageSource() {<z>
getBeanFactory();<z>
(MESSAGE_SOURCE_BEAN_NAME)) {<z>
);<z>
{<z>
{<z>
hms.setParentMessageSource(getInternalParentMessageSource());<z>
)) {<z>
this.messageSource + "]");<z>
;<z>
dms.setParentMessageSource(getInternalParentMessageSource());<z>
.messageSource = dms;<z>
;<z>
.isTraceEnabled()) {<z>
);<z>
methodMatcher) {<z>
;<z>
.TRUE;<z>
.methodMatcher = methodMatcher;<z>
> clazz, @Nullable ClassLoader classLoader) {<z>
clazz, "Class must not be null");<z>
classLoader)) {<z>
(clazz);<z>
new LinkedHashSet<>();<z>
current = clazz;<z>
!= null) {<z>
ifcs = current.getInterfaces();<z>
{<z>
ifc, classLoader)) {<z>
ifc);<z>
);<z>
interfaces;<z>
[] args) {<z>
getDeclaringClass();<z>
= targetBean.getClass();<z>
!methodDeclaringClass.isAssignableFrom(targetBeanClass)) {<z>
= "The mapped handler method class '" + methodDeclaringClass.getName() +<z>
getName() + "'. If the controller requires proxying " +<z>
));<z>
deduceEnvironment(@Nullable BeanDefinitionRegistry source) {<z>
if (source instanceof EnvironmentCapable) {<z>
) source).getEnvironment();<z>
return new StandardEnvironment();<z>
{<z>
{<z>
(MockClientHttpRequest request) throws Exception {<z>
;<z>
) {<z>
synchronized (this.defaultProfiles) {<z>
) {<z>
String profiles = doGetDefaultProfilesProperty();<z>
StringUtils.hasText(profiles)) {<z>
.commaDelimitedListToStringArray(<z>
trimAllWhitespace(profiles)));<z>
defaultProfiles;<z>
isNamespaceDeclaration(QName qName) {<z>
qName.getPrefix();<z>
);<z>
||<z>
&& !localPart.isEmpty());<z>
getResource(PROPERTIES_RESOURCE_LOCATION) :<z>
;<z>
if (url != null) {<z>
openStream()) {<z>
(is);<z>
public UnsatisfiedDependencyException(<z>
Nullable InjectionPoint injectionPoint, String msg) {<z>
, beanName,<z>
"Unsatisfied dependency expressed through " + injectionPoint +<z>
? ": " + msg : ""));<z>
injectionPoint = injectionPoint;<z>
) {<z>
(value == null) {<z>
return this;<z>
.getClass(), getResolvableType());<z>
;<z>
rootObject)<z>
throws EvaluationException {<z>
;<z>
), this.configuration);<z>
(expressionState).getTypeDescriptor();<z>
Nullable Object obj, String message) {<z>
;<z>
type.isInstance(obj)) {<z>
obj, message);<z>
(<z>
{<z>
;<z>
) {<z>
if (allowedOriginPatterns == null) {<z>
allowedOriginPatterns = null;<z>
);<z>
{<z>
(patternValue);<z>
return this;<z>
) {<z>
annotationType, "Annotation type must not be null");<z>
.annotationType = annotationType;<z>
= checkInherited;<z>
(String value) {<z>
value);<z>
ex) {<z>
ex);<z>
prefix, String resourceDescription)<z>
BeansException {<z>
(prefix == null) {<z>
"";<z>
= 0;<z>
) {<z>
)) {<z>
+ key + "]: only Strings allowed");<z>
keyString.startsWith(prefix)) {<z>
length());<z>
;<z>
(PropertyAccessor.PROPERTY_KEY_PREFIX);<z>
!= -1) {<z>
, propKeyIdx);<z>
.lastIndexOf(SEPARATOR);<z>
-1) {<z>
, sepIdx);<z>
)) {<z>
trace("Found bean name '" + beanName + "'");<z>
beanName)) {<z>
map, prefix + beanName, resourceDescription);<z>
;<z>
()) {<z>
;<z>
return beanCount;<z>
, ByteBuffer byteBuffer) {<z>
(written);<z>
)) {<z>
byteBuffer, pos, byteBuffer, this);<z>
);<z>
.error.get();<z>
(throwable != null) {<z>
this.sink.error(throwable);<z>
.completed.get()) {<z>
complete();<z>
request(1);<z>
) {<z>
);<z>
value();<z>
this;<z>
void setExitTypeDescriptor(String descriptor) {<z>
&& CodeFlow.isPrimitive(descriptor)) {<z>
= descriptor;<z>
.exitTypeDescriptor = CodeFlow.toBoxedDescriptor(descriptor);<z>
descriptor;<z>
{<z>
();<z>
> values = matchInParameterValuesWithInsertColumns(args);<z>
);<z>
resumeReceiving() {<z>
.suspendToken;<z>
null;<z>
) {<z>
;<z>
byte[]> createDisconnectMessage(WebSocketSession session) {<z>
StompHeaderAccessor.create(StompCommand.DISCONNECT);<z>
!= null) {<z>
().initHeaders(headerAccessor);<z>
session.getId());<z>
());<z>
(session);<z>
) {<z>
;<z>
);<z>
() {<z>
AbstractBeanDefinition bd = new GenericBeanDefinition();<z>
bd.setBeanClass(this.clazz);<z>
.isEmpty(this.constructorArgs)) {<z>
();<z>
Object constructorArg : this.constructorArgs) {<z>
(constructorArg);<z>
;<z>
{<z>
(this.parentName);<z>
this.definitionWrapper = new BeanWrapperImpl(bd);<z>
return bd;<z>
{<z>
requestAttributes = RequestContextHolder.getRequestAttributes();<z>
instanceof ServletRequestAttributes, "No ServletRequestAttributes");<z>
(ServletRequestAttributes) requestAttributes;<z>
);<z>
{<z>
(this.outputProperties != null) {<z>
);<z>
.hasMoreElements()) {<z>
nextElement();<z>
getProperty(name));<z>
(RequestMethod... methods) {<z>
methodsCondition = (ObjectUtils.isEmpty(methods) ?<z>
methods));<z>
return this;<z>
private void maybeBindReturningVariable() {<z>
== 0) {<z>
throw new IllegalStateException(<z>
);<z>
) {<z>
.numberOfRemainingUnboundArguments > 1) {<z>
new AmbiguousBindingException("Binding of returning parameter '" + this.returningName +<z>
"' is ambiguous, there are " + this.numberOfRemainingUnboundArguments + " candidates.");<z>
.parameterNameBindings.length; i++) {<z>
[i] == null) {<z>
bindParameterName(i, this.returningName);<z>
void afterPropertiesSet() {<z>
if (this.validatorFactory == null) {<z>
Validation.buildDefaultValidatorFactory();<z>
= this.validatorFactory.usingContext();<z>
.messageInterpolator;<z>
null) {<z>
getMessageInterpolator();<z>
(new LocaleContextMessageInterpolator(targetInterpolator));<z>
traversableResolver != null) {<z>
this.traversableResolver);<z>
setTargetValidator(validatorContext.getValidator());<z>
) {<z>
();<z>
== null)<z>
"Factory didn't call setApplicationContext before afterPropertiesSet on lifecycle bean");<z>
,<z>
WebSocketHandler wsHandler, SockJsSession wsSession) throws SockJsException {<z>
= (AbstractHttpSockJsSession) wsSession;<z>
);<z>
response, sockJsSession);<z>
getValueInternal(ExpressionState state) throws EvaluationException {<z>
getValue();<z>
.state(typeName != null, "No type name");<z>
)) {<z>
;<z>
TypeCode.OBJECT) {<z>
);<z>
.exitTypeDescriptor = "Ljava/lang/Class";<z>
clazz;<z>
return new TypedValue(clazz);<z>
typeName);<z>
;<z>
exitTypeDescriptor = "Ljava/lang/Class";<z>
;<z>
);<z>
(Method rootMethod, Method candidateMethod) {<z>
)) {<z>
false;<z>
();<z>
] candidateParameterTypes = candidateMethod.getParameterTypes();<z>
.equals(candidateParameterTypes, rootParameterTypes)) {<z>
return true;<z>
candidateMethod,<z>
);<z>
getShortDescription() {<z>
null) {<z>
beanName + "'";<z>
+ ']';<z>
public void onWebSocketError(Throwable cause) {<z>
wsSession, cause);<z>
) {<z>
ex, logger);<z>
requiredType) {<z>
!= null) {<z>
);<z>
(requiredType.isInstance(response)) {<z>
;<z>
;<z>
cacheManager, String cacheName) {<z>
Cache cache = cacheManager.getCache(cacheName);<z>
== null) {<z>
"' not found");<z>
cache;<z>
() {<z>
new RequestMappingInfo(this.name,<z>
, this.patternsCondition,<z>
,<z>
.producesCondition,<z>
;<z>
void setAsText(String text) throws IllegalArgumentException {<z>
(StringUtils.hasText(text)) {<z>
trim()));<z>
;<z>
ml) {<z>
ml.size());<z>
{<z>
(i)));<z>
return resolved;<z>
(final String methodDescriptor) {<z>
;<z>
int currentOffset = 1;<z>
charAt(currentOffset);<z>
!= ')') {<z>
== 'D') {<z>
currentOffset++;<z>
2;<z>
} else {<z>
) {<z>
currentOffset++;<z>
++) == 'L') {<z>
.indexOf(';', currentOffset);<z>
1);<z>
argumentsSize += 1;<z>
(currentOffset);<z>
methodDescriptor.charAt(currentOffset + 1);<z>
currentChar == 'V') {<z>
argumentsSize << 2;<z>
else {<z>
? 2 : 1;<z>
returnSize;<z>
BeanFactory beanFactory) {<z>
.embeddedValueResolver == null && beanFactory instanceof ConfigurableBeanFactory) {<z>
ConfigurableBeanFactory) beanFactory);<z>
(String... allowedOriginPatterns) {<z>
;<z>
)) {<z>
allowedOriginPatterns));<z>
;<z>
) {<z>
exchangeResult.getRawStatusCode();<z>
("Status", status, actual));<z>
return this.responseSpec;<z>
<T> task) {<z>
task);<z>
future);<z>
future;<z>
visitEnd() {<z>
{<z>
[] data = annotation.data;<z>
numElementValuePairs >>> 8);<z>
;<z>
handleRequestInternal(HttpServletRequest request, HttpServletResponse response)<z>
Exception {<z>
servletContext = getServletContext();<z>
;<z>
.servletName);<z>
(rd == null) {<z>
;<z>
request, response)) {<z>
.include(request, response);<z>
if (logger.isTraceEnabled()) {<z>
this.servletName +<z>
);<z>
rd.forward(request, response);<z>
) {<z>
this.servletName +<z>
;<z>
;<z>
, R2dbcException ex) {<z>
R2dbcTransientException) {<z>
(ex instanceof R2dbcTransientResourceException) {<z>
, sql, ex), ex);<z>
(ex instanceof R2dbcRollbackException) {<z>
);<z>
ex instanceof R2dbcTimeoutException) {<z>
task, sql, ex), ex);<z>
(ex instanceof R2dbcNonTransientException) {<z>
{<z>
, ex), ex);<z>
(ex instanceof R2dbcDataIntegrityViolationException) {<z>
, sql, ex), ex);<z>
instanceof R2dbcPermissionDeniedException) {<z>
;<z>
ex instanceof R2dbcBadGrammarException) {<z>
, ex);<z>
, ex);<z>
{<z>
(type);<z>
adjuster;<z>
value = value;<z>
= rollForwardType;<z>
() {<z>
== null) {<z>
.returnValueHandlers = new ArrayList<>();<z>
addReturnValueHandlers(this.returnValueHandlers);<z>
.returnValueHandlers;<z>
<?> createCacheKeyInvocationContext(<z>
) {<z>
operation;<z>
>(keyCacheOperation, target, params);<z>
(String name) {<z>
= getCacheManager();<z>
null, "No CacheManager set");<z>
= cacheManager.getCache(name);<z>
if (jcache != null) {<z>
jcache, isAllowNullValues());<z>
return null;<z>
HttpMethod method, URI uri, HttpHeaders headers,<z>
DataBuffer> body) {<z>
id = id;<z>
this.method = method;<z>
uri;<z>
= RequestPath.parse(uri, null);<z>
headers);<z>
.cookies = unmodifiableCopy(cookies);<z>
parseQueryParams(uri);<z>
this.body = body;<z>
executeDestructionCallbacks() {<z>
-> {<z>
key.startsWith(DESTRUCTION_CALLBACK_NAME_PREFIX)) {<z>
);<z>
{<z>
error("Uncaught error in session attribute destruction callback", ex);<z>
});<z>
[] patterns, @Nullable UrlPathHelper urlPathHelper,<z>
PathMatcher pathMatcher, boolean useSuffixPatternMatch, boolean useTrailingSlashMatch) {<z>
, useSuffixPatternMatch, useTrailingSlashMatch, null);<z>
Object resolveArgument(MethodParameter parameter,<z>
,<z>
binderFactory) throws Exception {<z>
mavContainer != null,<z>
);<z>
();<z>
);<z>
) {<z>
.get(lastKey);<z>
throw new IllegalStateException(<z>
+ parameter.getMethod());<z>
String statusText,<z>
Charset charset) {<z>
, body, charset);<z>
NamedValueInfo getNamedValueInfo(MethodParameter parameter) {<z>
.get(parameter);<z>
) {<z>
namedValueInfo = createNamedValueInfo(parameter);<z>
namedValueInfo);<z>
, namedValueInfo);<z>
return namedValueInfo;<z>
.InternalDescriptorAssigner() {<z>
(<z>
) {<z>
;<z>
(0);<z>
internal_static_Msg_fieldAccessorTable = new<z>
google.protobuf.GeneratedMessage.FieldAccessorTable(<z>
});<z>
getMessageTypes().get(1);<z>
= new<z>
.google.protobuf.GeneratedMessage.FieldAccessorTable(<z>
{ "Blah", });<z>
;<z>
) {<z>
for (BeanDefinitionHolder holder : configCandidates) {<z>
= holder.getBeanDefinition();<z>
(bd instanceof AnnotatedBeanDefinition) {<z>
());<z>
).hasBeanClass()) {<z>
holder.getBeanName());<z>
(), holder.getBeanName());<z>
catch (BeanDefinitionStoreException ex) {<z>
ex;<z>
Throwable ex) {<z>
BeanDefinitionStoreException(<z>
ex);<z>
this.deferredImportSelectorHandler.process();<z>
cacheMappings) {<z>
);<z>
cacheMappings.propertyNames();<z>
(propNames.hasMoreElements()) {<z>
) propNames.nextElement();<z>
(path));<z>
(path), cacheSeconds);<z>
<String, CorsConfiguration> corsConfigurations) {<z>
;<z>
null) {<z>
.forEach(this::registerCorsConfiguration);<z>
Object templateSource, String encoding) throws IOException {<z>
(Resource) templateSource;<z>
.getInputStream(), encoding);<z>
) {<z>
if (logger.isDebugEnabled()) {<z>
;<z>
throw ex;<z>
{<z>
type, SET_THREAD_CALLBACKS_NAME);<z>
return true;<z>
) {<z>
;<z>
<DataBuffer> input, ResolvableType elementType,<z>
String, Object> hints) {<z>
selectObjectMapper(elementType, mimeType);<z>
) {<z>
("No ObjectMapper for " + elementType);<z>
;<z>
elementType.getType())) {<z>
forceUseOfBigDecimal = true;<z>
(input, elementType, mimeType, hints);<z>
mapper,<z>
, getMaxInMemorySize());<z>
= getObjectReader(mapper, elementType, hints);<z>
tokenBuffer, sink) -> {<z>
.asParser(mapper));<z>
logValue(value, hints);<z>
(value != null) {<z>
value);<z>
) {<z>
sink.error(processException(ex));<z>
});<z>
[] body) throws IOException {<z>
.iterator.hasNext()) {<z>
= this.iterator.next();<z>
(request, body, this);<z>
= request.getMethod();<z>
request.getURI(), method);<z>
;<z>
{<z>
streamingOutputMessage) {<z>
;<z>
delegate.getBody());<z>
delegate.execute();<z>
DefaultTransactionStatus prepareTransactionStatus(<z>
, @Nullable Object transaction, boolean newTransaction,<z>
@Nullable Object suspendedResources) {<z>
(<z>
, suspendedResources);<z>
;<z>
return status;<z>
() {<z>
;<z>
.pattern).append('\n');<z>
; i++) {<z>
;<z>
sb.append("^\n");<z>
;<z>
sb.toString();<z>
message, Object... inserts) {<z>
.formatMessage(inserts), cause);<z>
;<z>
= inserts;<z>
Nullable String beanName, BeanFactory owner,<z>
... args) {<z>
makeAccessible(factoryMethod);<z>
get();<z>
currentlyInvokedFactoryMethod.set(factoryMethod);<z>
invoke(factoryBean, args);<z>
) {<z>
NullBean();<z>
result;<z>
(priorInvokedFactoryMethod != null) {<z>
);<z>
;<z>
ex) {<z>
BeanInstantiationException(factoryMethod,<z>
factoryMethod.getName() + "'; " +<z>
, ex);<z>
catch (IllegalAccessException ex) {<z>
(factoryMethod,<z>
() + "'; is it public?", ex);<z>
{<z>
.getName() + "' threw exception";<z>
) != null && owner instanceof ConfigurableBeanFactory &&<z>
bd.getFactoryBeanName())) {<z>
) + "' - consider " +<z>
"declaring the factory method as static for independence from its containing instance. " + msg;<z>
, msg, ex.getTargetException());<z>
T> factory, Adapt... adaptations) {<z>
(this);<z>
.state(map != null, "Factory used to create MergedAnnotation Map must not return null");<z>
attributes = this.mapping.getAttributes();<z>
i++) {<z>
i);<z>
attribute.getName()) ? null :<z>
, adaptations)));<z>
null) {<z>
map.put(attribute.getName(),<z>
), factory, adaptations));<z>
map;<z>
(Marshaller marshaller, Object content) {<z>
InputSource());<z>
marshaller, "'marshaller' must not be null");<z>
(content, "'content' must not be null");<z>
.marshaller = marshaller;<z>
= content;<z>
<T> retrieveFlux(ResolvableType elementType) {<z>
= (this.payloadFlux != null ?<z>
payloadFlux) :<z>
;<z>
isVoid(elementType)) {<z>
());<z>
strategies.decoder(elementType, dataMimeType);<z>
dataBuffer -><z>
elementType, dataMimeType, EMPTY_HINTS));<z>
?> future) {<z>
DeferredResult<>();<z>
{<z>
@Nullable Object value) {<z>
result.setResult(value);<z>
ex) {<z>
result.setErrorResult(ex);<z>
);<z>
result;<z>
public MutableBindings(BindMarkers markers) {<z>
(new LinkedHashMap<>());<z>
notNull(markers, "BindMarkers must not be null");<z>
markers = markers;<z>
Predicate<String> valuePredicate) {<z>
);<z>
.notNull(valuePredicate, "Predicate must not be null");<z>
name;<z>
valuePredicate;<z>
null;<z>
Nullable ResourceLoader resourceLoader) {<z>
(resourceLoader);<z>
DefaultResourceLoader) {<z>
this.metadataReaderCache =<z>
.class);<z>
);<z>
resolveId() throws JspException {<z>
));<z>
!= null) {<z>
id.toString();<z>
: null);<z>
;<z>
Object handler)<z>
throws Exception {<z>
).handleRequest(request, response);<z>
null;<z>
void invokeValidator(<z>
Errors errors, @Nullable Object... validationHints) {<z>
;<z>
, "Target object must not be null");<z>
"Errors object must not be null");<z>
()) {<z>
;<z>
{<z>
new IllegalArgumentException(<z>
"]");<z>
instanceof SmartValidator) {<z>
.validate(target, errors, validationHints);<z>
validate(target, errors);<z>
isDebugEnabled()) {<z>
.hasErrors()) {<z>
);<z>
debug("Validator found no errors");<z>
public MockHttpServletMapping(<z>
match) {<z>
= matchValue;<z>
this.pattern = pattern;<z>
servletName = servletName;<z>
;<z>
?>> decoders, @Nullable Validator validator,<z>
{<z>
);<z>
));<z>
.validator = validator;<z>
();<z>
= useDefaultResolution;<z>
String name, boolean htmlEscape) {<z>
{<z>
<>();<z>
);<z>
put = false;<z>
null) {<z>
MODEL_KEY_PREFIX + name);<z>
if (errors instanceof BindException) {<z>
;<z>
(errors == null) {<z>
null;<z>
= true;<z>
) {<z>
= new EscapedErrors(errors);<z>
true;<z>
EscapedErrors) {<z>
errors).getSource();<z>
true;<z>
put) {<z>
(name, errors);<z>
errors;<z>
(ConfigurableListableBeanFactory beanFactory) {<z>
beanFactory, getBeanFactoryPostProcessors());<z>
{<z>
addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));<z>
()));<z>
setConnection(@Nullable Connection connection) {<z>
) {<z>
null) {<z>
.releaseConnection(this.currentConnection);<z>
currentConnection = null;<z>
connection != null) {<z>
new SimpleConnectionHandle(connection);<z>
this.connectionHandle = null;<z>
{<z>
makeAccessible(this.method);<z>
target);<z>
(InvocationTargetException ex) {<z>
rethrowRuntimeException(ex.getTargetException());<z>
(IllegalAccessException ex) {<z>
(ex);<z>
() {<z>
(this.messageConverters == null) {<z>
= new ArrayList<>();<z>
);<z>
isEmpty()) {<z>
.messageConverters);<z>
.messageConverters);<z>
this.messageConverters;<z>
public BeanDefinitionHolder decorate(<z>
, BeanDefinitionHolder definition, ParserContext parserContext) {<z>
= findDecoratorForNode(node, parserContext);<z>
definition, parserContext) : null);<z>
getExceptionsFromMethodSignature(Method method) {<z>
= new ArrayList<>();<z>
{<z>
isAssignableFrom(paramType)) {<z>
;<z>
if (result.isEmpty()) {<z>
"No exception types mapped to " + method);<z>
result;<z>
addCronTask(CronTask task) {<z>
) {<z>
>();<z>
(task);<z>
String filename) {<z>
null;<z>
getFilenameExtension(filename);<z>
(ext != null) {<z>
.ENGLISH));<z>
Collections.emptyList());<z>
HandshakeInterceptor... interceptors) {<z>
(!ObjectUtils.isEmpty(interceptors)) {<z>
;<z>
return this;<z>
Throwable {<z>
proceed();<z>
(Throwable ex) {<z>
ex);<z>
!= null) {<z>
handlerMethod);<z>
ex;<z>
Object value) {<z>
);<z>
!= null) {<z>
.values.add(value);<z>
, ZoneId zoneId) {<z>
Assert.hasLength(expression, "Expression must not be empty");<z>
Assert.notNull(zoneId, "ZoneId must not be null");<z>
expression = CronExpression.parse(expression);<z>
;<z>
object, @Nullable Type type, HttpOutputMessage outputMessage)<z>
IOException, HttpMessageNotWritableException {<z>
);<z>
(this.jsonPrefix != null) {<z>
jsonPrefix);<z>
, writer);<z>
catch (Exception ex) {<z>
;<z>
.flush();<z>
Locale getContentLanguage() {<z>
(CONTENT_LANGUAGE)<z>
.stream()<z>
.findFirst()<z>
map(Locale::forLanguageTag)<z>
null);<z>
> matcher) {<z>
= getHeaders().get(name);<z>
{<z>
getMessage(name);<z>
(message, values, matcher);<z>
});<z>
this.responseSpec;<z>
postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {<z>
;<z>
false);<z>
());<z>
);<z>
eventListenerFactories = factories;<z>
void preparePersistenceUnitInfos() {<z>
);<z>
clear();<z>
puis = readPersistenceUnitInfos();<z>
{<z>
() == null) {<z>
;<z>
!= null) {<z>
.setJtaDataSource(this.defaultJtaDataSource);<z>
) {<z>
(this.defaultDataSource);<z>
) {<z>
sharedCacheMode);<z>
this.validationMode != null) {<z>
validationMode);<z>
!= null) {<z>
loadTimeWeaver);<z>
resourcePatternResolver.getClassLoader());<z>
;<z>
;<z>
) {<z>
);<z>
;<z>
);<z>
());<z>
;<z>
name, pui);<z>
Object bean, Method method) {<z>
InvocableHandlerMethod(bean, method);<z>
handlerMethod.setMessageMethodArgumentResolvers(this.argumentResolvers);<z>
return handlerMethod;<z>
<?> message, Charset charset,<z>
.Builder builder)<z>
throws IOException, MessageConversionException {<z>
isCompatibleWith(APPLICATION_JSON)) {<z>
builder);<z>
MessageConversionException(<z>
;<z>
headers, Source source) throws Exception {<z>
source);<z>
clazz);<z>
XmlRootElement.class)) {<z>
source);<z>
unmarshaller.unmarshal(source, clazz);<z>
getValue();<z>
(NullPointerException ex) {<z>
{<z>
new IllegalStateException("NPE while unmarshalling. " +<z>
ex);<z>
ex;<z>
ex) {<z>
;<z>
(JAXBException ex) {<z>
ex);<z>
subProtocolWebSocketHandler(<z>
clientOutboundChannel) {<z>
SubProtocolWebSocketHandler(clientInboundChannel, clientOutboundChannel);<z>
, String uriTemplate, Object... uriVariables) {<z>
(uriTemplate, uriVariables);<z>
endpoint = endpoint;<z>
= null;<z>
> targetClass) {<z>
getPayload();<z>
payload.getClass(), targetClass)) {<z>
, targetClass);<z>
) {<z>
"Failed to convert message payload '" +<z>
);<z>
? payload : null);<z>
detectResourceHandlers(ApplicationContext appContext) {<z>
= appContext.getBeansOfType(SimpleUrlHandlerMapping.class);<z>
());<z>
sort(mappings);<z>
for (SimpleUrlHandlerMapping mapping : mappings) {<z>
()) {<z>
().get(pattern);<z>
instanceof ResourceHttpRequestHandler resourceHandler) {<z>
, resourceHandler);<z>
{<z>
.trace("No resource handling mappings found");<z>
Throwable exception) {<z>
) {<z>
null) {<z>
null, (String) message, exception);<z>
(String) message);<z>
;<z>
ClientRequest.Builder url(URI url) {<z>
, "URI must not be null");<z>
url = url;<z>
this;<z>
readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {<z>
();<z>
= LogFactory.getLog(getClass());<z>
();<z>
,<z>
,<z>
DestructionAwareBeanPostProcessor> postProcessors) {<z>
this.bean = bean;<z>
.beanName = beanName;<z>
= nonPublicAccessAllowed;<z>
.invokeDisposableBean = invokeDisposableBean;<z>
= invokeAutoCloseable;<z>
;<z>
= postProcessors;<z>
DataAccessException {<z>
)) {<z>
.debug("Executing SQL batch update [" + sql + "]");<z>
ps -> {<z>
= pss.getBatchSize();<z>
ipss =<z>
(pss instanceof InterruptibleBatchPreparedStatementSetter ?<z>
) pss : null);<z>
())) {<z>
; i < batchSize; i++) {<z>
pss.setValues(ps, i);<z>
) {<z>
.addBatch();<z>
executeBatch();<z>
> rowsAffected = new ArrayList<>();<z>
i < batchSize; i++) {<z>
i);<z>
.isBatchExhausted(i)) {<z>
add(ps.executeUpdate());<z>
;<z>
.length; i++) {<z>
get(i);<z>
return rowsAffectedArray;<z>
) {<z>
).cleanupParameters();<z>
);<z>
, "No result array");<z>
return result;<z>
expressions) {<z>
count = 0;<z>
ParamExpression e : expressions) {<z>
null && !e.isNegated()) {<z>
count++;<z>
;<z>
(ComponentDefinition component) {<z>
);<z>
) {<z>
addNestedComponent(component);<z>
this.readerContext.fireComponentRegistered(component);<z>
> R processMethodInheritedAnnotations(C context, Method source,<z>
R> processor) {<z>
= processor.doWithAggregate(context, 0);<z>
? result :<z>
0, source, processor));<z>
{<z>
handleIntrospectionFailure(source, ex);<z>
null;<z>
(ServletRequestEvent requestEvent) {<z>
{<z>
IllegalArgumentException(<z>
+ requestEvent.getServletRequest());<z>
) requestEvent.getServletRequest();<z>
ServletRequestAttributes attributes = new ServletRequestAttributes(request);<z>
(REQUEST_ATTRIBUTES_ATTRIBUTE, attributes);<z>
.getLocale());<z>
attributes);<z>
throws Exception {<z>
this.contextPath);<z>
!ObjectUtils.isEmpty(this.classesToBeBound);<z>
packagesToScan);<z>
&& (hasClassesToBeBound || hasPackagesToScan) ||<z>
(hasClassesToBeBound && hasPackagesToScan)) {<z>
throw new IllegalArgumentException("Specify either 'contextPath', 'classesToBeBound', " +<z>
"or 'packagesToScan'");<z>
{<z>
new IllegalArgumentException(<z>
);<z>
{<z>
;<z>
{<z>
(this.schemaResources, this.schemaLanguage);<z>
ex) {<z>
super(msg, ex);<z>
expectedSize;<z>
.actualSize = -1;<z>
() {<z>
this.handshakeHeaders;<z>
(headers != null, "No initial request yet");<z>
headers;<z>
supportsParameter(MethodParameter parameter) {<z>
) {<z>
contributor instanceof UriComponentsContributor ucc) {<z>
ucc.supportsParameter(parameter)) {<z>
;<z>
(contributor instanceof HandlerMethodArgumentResolver resolver) {<z>
{<z>
return false;<z>
false;<z>
getHandlerInternal(ServerWebExchange exchange) {<z>
).pathWithinApplication();<z>
handler;<z>
lookupPath, exchange);<z>
Exception ex) {<z>
Mono.error(ex);<z>
);<z>
header(String headerName, String... headerValues) {<z>
) {<z>
.add(headerName, headerValue);<z>
this;<z>
() {<z>
= new GenericObjectPoolConfig();<z>
;<z>
));<z>
;<z>
config.setMaxWaitMillis(getMaxWait());<z>
getTimeBetweenEvictionRunsMillis());<z>
getMinEvictableIdleTimeMillis());<z>
;<z>
GenericObjectPool(this, config);<z>
compiledByAjc(Class<?> clazz) {<z>
)) {<z>
(AJC_MAGIC)) {<z>
true;<z>
return false;<z>
requiredType) throws NamingException {<z>
Object jndiObject = lookup(name);<z>
(jndiObject)) {<z>
getClass());<z>
T) jndiObject;<z>
String annotationType) {<z>
this.annotationFilter.matches(annotationType)) {<z>
;<z>
Boolean.TRUE.equals(scan(annotationType,<z>
)));<z>
, Supplier<? extends CharSequence> messageSupplier) {<z>
isWarnEnabled()) {<z>
of(messageSupplier), cause);<z>
SavepointManager getSavepointManager() {<z>
{<z>
new NestedTransactionNotSupportedException(<z>
);<z>
).getSavepointManager();<z>
savepointManager == null) {<z>
(<z>
"JpaDialect does not support savepoints - check your JPA provider's capabilities");<z>
return savepointManager;<z>
@Nullable PathElement head) {<z>
;<z>
this.parser = parser;<z>
();<z>
matchOptionalTrailingSeparator = parser.isMatchOptionalTrailingSeparator();<z>
);<z>
this.head = head;<z>
;<z>
null) {<z>
.getCaptureCount();<z>
normalizedLength += elem.getNormalizedLength();<z>
;<z>
|| elem instanceof WildcardTheRestPathElement) {<z>
this.catchAll = true;<z>
.next == null) {<z>
true;<z>
.next;<z>
@Nullable File root) {<z>
{<z>
return false;<z>
());<z>
{<z>
return false;<z>
) {<z>
emptyList());<z>
isEqualTo(events.length);<z>
++) {<z>
;<z>
> next() {<z>
getNextIfNecessary();<z>
this.next == null) {<z>
);<z>
last = this.next;<z>
= null;<z>
return this.last;<z>
Mono<String> getResourceVersion(Resource resource) {<z>
Flux<DataBuffer> flux = DataBufferUtils.read(<z>
);<z>
return DataBufferUtils.join(flux)<z>
-> {<z>
[buffer.readableByteCount()];<z>
.read(result);<z>
buffer);<z>
return DigestUtils.md5DigestAsHex(result);<z>
});<z>
Entry entry) {<z>
typeTable == null) {<z>
new Entry[16];<z>
if (typeCount == typeTable.length) {<z>
* typeTable.length];<z>
;<z>
= newTypeTable;<z>
[typeCount++] = entry;<z>
.index;<z>
static PreparedOperation<String> substituteNamedParameters(ParsedSql parsedSql,<z>
BindMarkersFactory bindMarkersFactory, BindParameterSource paramSource) {<z>
bindMarkersFactory);<z>
String originalSql = parsedSql.getOriginalSql();<z>
parsedSql.getParameterNames();<z>
{<z>
originalSql, markerHolder, paramSource);<z>
length());<z>
int lastIndex = 0;<z>
size(); i++) {<z>
.get(i);<z>
i);<z>
];<z>
];<z>
, startIndex);<z>
);<z>
paramSource.hasValue(paramName)) {<z>
(paramName);<z>
value instanceof Collection) {<z>
).iterator();<z>
;<z>
= 0;<z>
while (entryIter.hasNext()) {<z>
> 0) {<z>
);<z>
k++;<z>
);<z>
entryItem instanceof Object[]) {<z>
Object[]) entryItem;<z>
actualSql.append('(');<z>
< expressionList.length; m++) {<z>
{<z>
", ");<z>
));<z>
counter++;<z>
;<z>
marker.getPlaceholder(counter));<z>
;<z>
getPlaceholder());<z>
());<z>
endIndex;<z>
originalSql.length());<z>
), markerHolder, paramSource);<z>
void complete() {<z>
(this.sendFailed) {<z>
();<z>
(null);<z>
{<z>
);<z>
hints2) {<z>
{<z>
Collections.emptyMap();<z>
hints2.isEmpty()) {<z>
hints1;<z>
(hints1.isEmpty()) {<z>
;<z>
;<z>
);<z>
hints2);<z>
result;<z>
build() {<z>
null;<z>
PatternsRequestCondition patterns = null;<z>
(this.options.patternParser != null) {<z>
?<z>
.paths));<z>
.paths) ?<z>
PatternsRequestCondition(<z>
, this.options.getPathMatcher(),<z>
useTrailingSlashMatch(),<z>
()));<z>
this.options.getContentNegotiationManager();<z>
return new RequestMappingInfo(<z>
, pathPatterns, patterns,<z>
methods) ?<z>
(this.methods),<z>
isEmpty(this.params) ?<z>
.params),<z>
this.headers) ?<z>
headers),<z>
&& !this.hasContentType ?<z>
this.headers),<z>
?<z>
.produces, this.headers, manager),<z>
!= null ?<z>
,<z>
.options);<z>
() {<z>
(!isPresent()) {<z>
("Unable to synthesize missing annotation");<z>
this.synthesizedAnnotation;<z>
) {<z>
synthesized = createSynthesized();<z>
this.synthesizedAnnotation = synthesized;<z>
synthesized;<z>
responseType,<z>
Object... uriVariables) throws RestClientException {<z>
responseType);<z>
responseExtractor =<z>
(responseType, getMessageConverters(), logger);<z>
;<z>
afterPropertiesSet() {<z>
;<z>
name == null) {<z>
.name = this.beanName;<z>
== null) {<z>
= Scheduler.DEFAULT_GROUP;<z>
applicationContextJobDataKey != null) {<z>
this.applicationContext == null) {<z>
IllegalStateException(<z>
"to be able to handle an 'applicationContextJobDataKey'");<z>
(this.applicationContextJobDataKey, this.applicationContext);<z>
);<z>
? this.name : toString());<z>
group);<z>
setJobClass(this.jobClass);<z>
);<z>
;<z>
this.requestsRecovery);<z>
this.description);<z>
jdi;<z>
(<z>
String beanName) {<z>
null && beanFactory.containsBeanDefinition(beanName)) {<z>
BeanDefinition bd = beanFactory.getBeanDefinition(beanName);<z>
getAttribute(PRESERVE_TARGET_CLASS_ATTRIBUTE));<z>
false;<z>
void addFirstPropertySource(PropertySource<?> propertySource) {<z>
propertySources);<z>
this.propertySources.clear();<z>
add(propertySource);<z>
propertySources.addAll(existing);<z>
getSupportedMediaTypes(ResolvableType elementType) {<z>
>();<z>
{<z>
);<z>
return mediaTypes;<z>
{<z>
response -> {<z>
.apply(response)<z>
response).thenReturn(value))<z>
(Mono.empty())))<z>
releaseIfNotConsumed(response, ex));<z>
ex) {<z>
(response, ex);<z>
;<z>
String getPathWithinServletMapping(HttpServletRequest request, String pathWithinApp) {<z>
getServletPath(request);<z>
String sanitizedPathWithinApp = getSanitizedPath(pathWithinApp);<z>
String path;<z>
) {<z>
getRemainingPath(sanitizedPathWithinApp, servletPath, false);<z>
pathWithinApp, servletPath, false);<z>
{<z>
;<z>
();<z>
(pathInfo != null) {<z>
return pathInfo;<z>
{<z>
false);<z>
null) {<z>
pathWithinApp;<z>
;<z>
{<z>
nextValueIndex >= getCacheSize()) {<z>
());<z>
Statement stmt = null;<z>
.createStatement();<z>
(stmt, getDataSource());<z>
)];<z>
.nextValueIndex = 0;<z>
{<z>
;<z>
getIdentityStatement());<z>
(!rs.next()) {<z>
throw new DataAccessResourceFailureException("Identity statement failed after inserting");<z>
i] = rs.getLong(1);<z>
.closeResultSet(rs);<z>
getDeleteStatement(this.valueCache));<z>
catch (SQLException ex) {<z>
DataAccessResourceFailureException("Could not increment identity", ex);<z>
JdbcUtils.closeStatement(stmt);<z>
.releaseConnection(con, getDataSource());<z>
++];<z>
{<z>
);<z>
!= null, "No DestinationVariable annotation");<z>
;<z>
Nullable T result) {<z>
.mutex) {<z>
.state = State.SUCCESS;<z>
this.result = result;<z>
? super T> callback;<z>
)) != null) {<z>
;<z>
obj) {<z>
null) {<z>
new IllegalArgumentException("Parent bean cannot be set to a null runtime bean reference!");<z>
if (obj instanceof String) {<z>
(String) obj;<z>
(obj instanceof RuntimeBeanReference) {<z>
).getBeanName();<z>
instanceof GroovyBeanDefinitionWrapper) {<z>
) obj).getBeanName();<z>
;<z>
);<z>
{<z>
(HEARTBEAT);<z>
.split(rawValue, ",");<z>
) {<z>
null;<z>
)};<z>
UriTemplate(String uriTemplate) {<z>
;<z>
uriTemplate;<z>
uriTemplate).build();<z>
TemplateInfo info = TemplateInfo.parse(uriTemplate);<z>
getVariableNames());<z>
);<z>
) {<z>
.jtaTransaction != null) {<z>
.setRollbackOnly();<z>
(UnsupportedOperationException ex) {<z>
+<z>
, ex);<z>
catch (Throwable ex) {<z>
;<z>
logger.debug("No JTA transaction handle available and/or running on WebLogic - " +<z>
"the exception thrown from beforeCompletion");<z>
(<z>
definition, @Nullable Object transaction, boolean newTransaction,<z>
, @Nullable Object suspendedResources) {<z>
actualNewSynchronization = newSynchronization &&<z>
isSynchronizationActive();<z>
DefaultTransactionStatus(<z>
, newTransaction, actualNewSynchronization,<z>
suspendedResources);<z>
Nullable ServletContext servletContext) {<z>
super(servletContext);<z>
setMethod("POST");<z>
"multipart/form-data");<z>
(String name) {<z>
)) {<z>
;<z>
return super.getHeader(name);<z>
{<z>
{<z>
false;<z>
)) {<z>
return true;<z>
{<z>
);<z>
== 0) {<z>
false;<z>
; i++) {<z>
value, i);<z>
{<z>
;<z>
true;<z>
Collection) {<z>
;<z>
{<z>
false;<z>
: coll) {<z>
)) {<z>
;<z>
;<z>
false;<z>
expectedMap, boolean containsExactly) {<z>
return request -> {<z>
mockRequest = (MockClientHttpRequest) request;<z>
));<z>
));<z>
.read(null, message);<z>
containsExactly) {<z>
, expectedMap, actualMap);<z>
size());<z>
) {<z>
();<z>
);<z>
(name) != null);<z>
get(name).size());<z>
i++) {<z>
i));<z>
(Message<?> requestMessage) {<z>
Destination defaultDestination = getDefaultDestination();<z>
if (defaultDestination != null) {<z>
(defaultDestination, requestMessage);<z>
requestMessage);<z>
,<z>
Nullable Object inValue) throws SQLException {<z>
sqlType, null, null, inValue);<z>
public FilteringClassFileTransformer(<z>
targetClassLoader) {<z>
= targetTransformer;<z>
targetClassLoader = targetClassLoader;<z>
Throwable ex) {<z>
(), ex)) {<z>
);<z>
exchange.getLogPrefix();<z>
) {<z>
));<z>
)) {<z>
ex, exchange.getRequest()));<z>
();<z>
doSetNestedPath(@Nullable String nestedPath) {<z>
) {<z>
"";<z>
);<z>
endsWith(Errors.NESTED_PATH_SEPARATOR)) {<z>
.NESTED_PATH_SEPARATOR;<z>
= nestedPath;<z>
{<z>
executeWithNativeSession(session -> {<z>
checkWriteOperationAllowed(session);<z>
entityName, entity);<z>
return null;<z>
);<z>
public StompBrokerRelayRegistration enableStompBrokerRelay(String... destinationPrefixes) {<z>
.brokerRelayRegistration = new StompBrokerRelayRegistration(<z>
clientOutboundChannel, destinationPrefixes);<z>
.brokerRelayRegistration;<z>
, char compatibleType) {<z>
areNumbers = areNumbers;<z>
areCompatible = areCompatible;<z>
;<z>
BeanDefinition bd) {<z>
;<z>
);<z>
elementType, nl.getLength());<z>
(extractSource(arrayEle));<z>
);<z>
);<z>
, elementType);<z>
target;<z>
protected void visitScope(BeanDefinition beanDefinition) {<z>
beanDefinition.getScope();<z>
null) {<z>
(scope);<z>
)) {<z>
setScope(resolvedScope);<z>
() {<z>
StringWriter();<z>
).handle(this);<z>
ex) {<z>
writer.append("Unable to format ")<z>
append(String.valueOf(this))<z>
": ")<z>
append(ex.getMessage());<z>
writer.toString();<z>
getAttributeCount() {<z>
!this.event.isStartElement()) {<z>
);<z>
;<z>
attributes);<z>
() throws IOException {<z>
);<z>
) {<z>
getMessage());<z>
route(<z>
T> handlerFunction) {<z>
predicate, handlerFunction);<z>
protected CacheResolverFactory determineCacheResolverFactory(<z>
? extends CacheResolverFactory> candidate) {<z>
!= CacheResolverFactory.class) {<z>
getBean(candidate);<z>
!= CacheResolverFactory.class) {<z>
getBean(defaults.cacheResolverFactory());<z>
return null;<z>
, HttpServletResponse response,<z>
IOException {<z>
(request);<z>
response);<z>
isValid || CorsUtils.isPreFlightRequest(request)) {<z>
doFilter(request, response);<z>
toHeaderName(String propertyName) {<z>
String headerName = propertyName;<z>
.startsWith(this.inboundPrefix)) {<z>
.inboundPrefix + propertyName;<z>
return headerName;<z>
throws EvalError {<z>
, "Script source must not be empty");<z>
interpreter = new Interpreter();<z>
{<z>
(classLoader);<z>
result = interpreter.eval(scriptSource);<z>
{<z>
(Class<?>) result;<z>
result != null) {<z>
();<z>
;<z>
registerCacheAdvisor(Element element, ParserContext parserContext) {<z>
{<z>
Object source = parserContext.extractSource(element);<z>
source);<z>
.registerWithGeneratedName(sourceDef);<z>
=<z>
new RootBeanDefinition("org.springframework.cache.jcache.interceptor.JCacheInterceptor");<z>
setSource(source);<z>
.ROLE_INFRASTRUCTURE);<z>
sourceName));<z>
, interceptorDef);<z>
).registerWithGeneratedName(interceptorDef);<z>
RootBeanDefinition(<z>
;<z>
);<z>
.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
(sourceName));<z>
("adviceBeanName", interceptorName);<z>
)) {<z>
;<z>
.registerBeanDefinition(CacheManagementConfigUtils.JCACHE_ADVISOR_BEAN_NAME, advisorDef);<z>
.getTagName(), source);<z>
sourceName));<z>
, interceptorName));<z>
JCACHE_ADVISOR_BEAN_NAME));<z>
registerComponent(compositeDef);<z>
MarshallingMessageConverter(Marshaller marshaller) {<z>
Assert.notNull(marshaller, "Marshaller must not be null");<z>
) {<z>
(<z>
+<z>
);<z>
this.marshaller = marshaller;<z>
;<z>
) {<z>
{<z>
= SimpMessageHeaderAccessor.create(SimpMessageType.MESSAGE);<z>
(headerAccessor);<z>
(true);<z>
);<z>
headers.containsKey(NativeMessageHeaderAccessor.NATIVE_HEADERS)) {<z>
headers;<z>
MessageHeaders) {<z>
accessor =<z>
SimpMessageHeaderAccessor.class);<z>
null) {<z>
headers;<z>
);<z>
(headerAccessor);<z>
);<z>
return headerAccessor.getMessageHeaders();<z>
() {<z>
this.compiledAst;<z>
compiledAst != null) {<z>
true;<z>
) {<z>
;<z>
(this) {<z>
(this.compiledAst != null) {<z>
true;<z>
);<z>
this.ast);<z>
(compiledAst != null) {<z>
compiledAst = compiledAst;<z>
return true;<z>
.incrementAndGet();<z>
;<z>
<?>>> processContextInitializerClasses(<z>
<?>>> contextInitializerClasses) {<z>
return (contextInitializerClasses != null ?<z>
(contextInitializerClasses) : EMPTY_INITIALIZER_CLASSES);<z>
(String beanName) {<z>
.add(beanName)) {<z>
beanName);<z>
Object convertForProperty(<z>
String propertyName, BeanWrapper bw, TypeConverter converter) {<z>
(converter instanceof BeanWrapperImpl) {<z>
;<z>
;<z>
.getWriteMethodParameter(pd);<z>
methodParam);<z>
HeaderMethodArgumentResolver(<z>
@Nullable ConfigurableBeanFactory beanFactory) {<z>
(conversionService, beanFactory);<z>
getServerId() {<z>
== null) {<z>
)) % 1000);<z>
.serverId;<z>
) {<z>
if (browser != null) {<z>
;<z>
(JMSException ex) {<z>
logger.trace("Could not close JMS QueueBrowser", ex);<z>
ex) {<z>
, ex);<z>
public String getVersion() {<z>
.isStartDocument()) {<z>
;<z>
;<z>
ResponseBodyResultHandler responseBodyResultHandler(<z>
ReactiveAdapterRegistry reactiveAdapterRegistry,<z>
ServerCodecConfigurer serverCodecConfigurer,<z>
@Qualifier("webFluxContentTypeResolver") RequestedContentTypeResolver contentTypeResolver) {<z>
serverCodecConfigurer.getWriters(),<z>
reactiveAdapterRegistry);<z>
throws Throwable {<z>
switch (method.getName()) {<z>
:<z>
];<z>
"hashCode":<z>
);<z>
case "unwrap":<z>
this.target;<z>
"close":<z>
empty();<z>
);<z>
(InvocationTargetException ex) {<z>
throw ex.getTargetException();<z>
void copyFrom(final Frame frame) {<z>
;<z>
= frame.inputStack;<z>
;<z>
;<z>
;<z>
frame.outputStackTop;<z>
initializationCount;<z>
initializations = frame.initializations;<z>
request, ServerHttpResponse response,<z>
SockJsException {<z>
) {<z>
if (logger.isWarnEnabled()) {<z>
logger.warn(LogFormatUtils.formatValue(<z>
), -1, true));<z>
HttpStatus.NOT_FOUND);<z>
request.getHeaders();<z>
ex) {<z>
);<z>
("/")) {<z>
(requestInfo != null) {<z>
;<z>
().getUpgrade())) {<z>
(HttpStatus.BAD_REQUEST);<z>
"text", "plain", StandardCharsets.UTF_8));<z>
.getBytes(StandardCharsets.UTF_8));<z>
) {<z>
) {<z>
);<z>
, response);<z>
"/iframe[0-9-.a-z_]*.html")) {<z>
) ||<z>
getAllowedOriginPatterns().isEmpty()) {<z>
null) {<z>
+<z>
;<z>
response.setStatusCode(HttpStatus.NOT_FOUND);<z>
{<z>
);<z>
) {<z>
requestInfo);<z>
.iframeHandler.handle(request, response);<z>
) {<z>
{<z>
) {<z>
);<z>
, response, wsHandler);<z>
(requestInfo != null) {<z>
logger.debug("WebSocket disabled. Ignoring transport request: " + requestInfo);<z>
1), "/");<z>
{<z>
(logger.isWarnEnabled()) {<z>
"Invalid SockJS path '" + sockJsPath + "' - " +<z>
, -1, true));<z>
(requestInfo != null) {<z>
.debug("Ignoring transport request: " + requestInfo);<z>
response.setStatusCode(HttpStatus.NOT_FOUND);<z>
pathSegments[0];<z>
];<z>
= pathSegments[2];<z>
("websocket")) {<z>
(requestInfo != null) {<z>
);<z>
;<z>
) {<z>
requestInfo != null) {<z>
requestInfo);<z>
HttpStatus.NOT_FOUND);<z>
requestInfo != null) {<z>
requestInfo);<z>
, transport);<z>
();<z>
catch (IOException ex) {<z>
SockJsException("Failed to write to the response", null, ex);<z>
request) {<z>
.hasCachedPath(request)) {<z>
this.lookupPathAttributeName != null ?<z>
lookupPathAttributeName) :<z>
.getLookupPathForRequest(request));<z>
lookupPath = ServletRequestPathUtils.getCachedPath(request);<z>
this.pathMatcher != defaultPathMatcher) {<z>
);<z>
return lookupPath;<z>
void putParameterAnnotations(<z>
final int attributeNameIndex,<z>
[] annotationWriters,<z>
final int annotableParameterCount,<z>
) {<z>
1 + 2 * annotableParameterCount;<z>
++i) {<z>
= annotationWriters[i];<z>
8;<z>
);<z>
;<z>
putByte(annotableParameterCount);<z>
0; i < annotableParameterCount; ++i) {<z>
;<z>
= null;<z>
0;<z>
null) {<z>
;<z>
++;<z>
= annotationWriter;<z>
= annotationWriter.previousAnnotation;<z>
putShort(numAnnotations);<z>
firstAnnotation;<z>
{<z>
(<z>
;<z>
annotationWriter.nextAnnotation;<z>
XpathAssertions(WebTestClient.BodyContentSpec spec,<z>
String> namespaces, Object... args) {<z>
bodySpec = spec;<z>
initXpathHelper(expression, namespaces, args);<z>
) {<z>
) {<z>
) &&<z>
(pathContainer)) ?<z>
.EMPTY);<z>
if (!hasLength(pathContainer)) {<z>
.head instanceof CaptureTheRestPathElement) {<z>
EMPTY_PATH;<z>
return null;<z>
;<z>
) : null;<z>
{<z>
if (this.clientInboundChannelRegistration == null) {<z>
);<z>
configureClientInboundChannel(registration);<z>
interceptors(new ImmutableMessageChannelInterceptor());<z>
= registration;<z>
this.clientInboundChannelRegistration;<z>
) {<z>
(element instanceof QualifiedNameable) {<z>
toString();<z>
toString();<z>
, String id) {<z>
(id, "'id' is required");<z>
);<z>
);<z>
purgeUnreferencedEntries() {<z>
) {<z>
.restructureIfNecessary(false);<z>
brokerChannelExecutor(<z>
clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel) {<z>
clientOutboundChannel);<z>
.getBrokerChannelRegistration();<z>
ThreadPoolTaskExecutor executor;<z>
{<z>
registration.taskExecutor().getTaskExecutor();<z>
ThreadPoolTaskExecutor();<z>
(0);<z>
executor.setMaxPoolSize(1);<z>
);<z>
setThreadNamePrefix("brokerChannel-");<z>
;<z>
{<z>
data.requestPaths) {<z>
PathPattern pattern : data.patterns) {<z>
(pattern.matches(path));<z>
boolean peekToken(TokenKind desiredTokenKind, boolean consumeIfMatched) {<z>
peekToken();<z>
) {<z>
false;<z>
) {<z>
) {<z>
++;<z>
return true;<z>
if (desiredTokenKind == TokenKind.IDENTIFIER) {<z>
<= TokenKind.NOT.ordinal() &&<z>
null) {<z>
return true;<z>
return false;<z>
public HttpHeaders getHeaders() {<z>
null) {<z>
.headers = new HttpHeaders();<z>
(0);<z>
(name)) {<z>
(0));<z>
;<z>
(true) {<z>
= this.connection.getHeaderFieldKey(i);<z>
hasLength(name)) {<z>
;<z>
++;<z>
;<z>
{<z>
externalContext = getExternalContext();<z>
= new StringBuilder();<z>
getRequestContextPath());<z>
) {<z>
externalContext.getSession(false);<z>
!= null) {<z>
getSessionId());<z>
getRemoteUser();<z>
(user)) {<z>
user);<z>
;<z>
(PreparedStatement ps) throws SQLException {<z>
parameterPosition = 1;<z>
null) {<z>
++) {<z>
arg = this.args[i];<z>
.ARRAY) {<z>
Collection<?>) arg;<z>
(Object entry : entries) {<z>
{<z>
(Object argValue : valueArray) {<z>
argValue);<z>
parameterPosition++;<z>
i], entry);<z>
parameterPosition++;<z>
i], arg);<z>
parameterPosition++;<z>
{<z>
configuration = getConfiguration();<z>
!= null, "No Configuration set");<z>
configuration;<z>
) {<z>
bindingResult == null,<z>
);<z>
;<z>
?> collection, String message) {<z>
) {<z>
IllegalArgumentException(message);<z>
MediaType> getConsumableMediaTypes() {<z>
;<z>
match : this.partialMatches) {<z>
{<z>
());<z>
;<z>
protected void cancelRemainingTask(Runnable task) {<z>
super.cancelRemainingTask(task);<z>
task);<z>
) {<z>
.cancel(true);<z>
protected void initTransactionSynchronizationRegistry() {<z>
transactionSynchronizationRegistry == null) {<z>
.transactionSynchronizationRegistryName)) {<z>
transactionSynchronizationRegistry =<z>
lookupTransactionSynchronizationRegistry(this.transactionSynchronizationRegistryName);<z>
transactionSynchronizationRegistry = retrieveTransactionSynchronizationRegistry();<z>
null && this.autodetectTransactionSynchronizationRegistry) {<z>
transactionSynchronizationRegistry =<z>
(this.userTransaction, this.transactionManager);<z>
!= null) {<z>
) {<z>
"Using JTA TransactionSynchronizationRegistry: " + this.transactionSynchronizationRegistry);<z>
ReactiveAdapterRegistry registry) {<z>
(encoders, "At least one Encoder is required");<z>
);<z>
= Collections.unmodifiableList(encoders);<z>
;<z>
ConfigurationClassParser(MetadataReaderFactory metadataReaderFactory,<z>
problemReporter, Environment environment, ResourceLoader resourceLoader,<z>
registry) {<z>
metadataReaderFactory = metadataReaderFactory;<z>
problemReporter;<z>
this.environment = environment;<z>
resourceLoader;<z>
;<z>
(<z>
, resourceLoader, componentScanBeanNameGenerator, registry);<z>
, resourceLoader);<z>
Element ele, String... childEleNames) {<z>
.notNull(ele, "Element must not be null");<z>
(childEleNames, "Element names collection must not be null");<z>
> childEleNameList = Arrays.asList(childEleNames);<z>
ele.getChildNodes();<z>
<>();<z>
; i++) {<z>
.item(i);<z>
)) {<z>
node);<z>
childEles;<z>
JspException {<z>
(tagWriter);<z>
, getOnfocus());<z>
);<z>
, ONCHANGE_ATTRIBUTE, getOnchange());<z>
tagWriter, ACCESSKEY_ATTRIBUTE, getAccesskey());<z>
{<z>
"disabled");<z>
(isReadonly()) {<z>
, "readonly");<z>
void setText(String text) throws MailParseException {<z>
this.helper.setText(text);<z>
catch (MessagingException ex) {<z>
;<z>
<?> requiredType) {<z>
;<z>
shortcut = shortcut;<z>
.requiredType = requiredType;<z>
message) {<z>
);<z>
SETUP || frameType == FrameType.METADATA_PUSH) {<z>
if (frameType == FrameType.REQUEST_FNF) {<z>
("No handler for fireAndForget to '" + destination + "'");<z>
).stream()<z>
(CompositeMessageCondition::getMessageConditions)<z>
)<z>
(RSocketFrameTypeMessageCondition) conditions.get(0))<z>
)<z>
.collect(Collectors.toSet());<z>
throw new MessageDeliveryException(frameTypes.isEmpty() ?<z>
+ "'" :<z>
+ frameType + ". " +<z>
"Supported interaction(s): " + frameTypes);<z>
String name)<z>
{<z>
null;<z>
(Notification notification) {<z>
)) {<z>
);<z>
beanName, Class<A> annotationType)<z>
throws NoSuchBeanDefinitionException {<z>
);<z>
annotationType);<z>
String placeholderName) {<z>
placeholderName);<z>
(propVal == null) {<z>
getProperty(placeholderName);<z>
) {<z>
= System.getenv(placeholderName);<z>
;<z>
(Throwable ex) {<z>
"' in [" +<z>
text + "] as ServletContext init-parameter or system property: " + ex);<z>
null;<z>
Function<AbstractClassGenerator, Object>() {<z>
apply(AbstractClassGenerator gen) {<z>
gen.key;<z>
{<z>
.beanFactory = new DefaultListableBeanFactory();<z>
);<z>
; i++) {<z>
class));<z>
();<z>
Class<?> clazz) {<z>
.get(clazz);<z>
(typeVariableMap == null) {<z>
HashMap<>();<z>
ResolvableType.forClass(clazz), typeVariableMap);<z>
(typeVariableMap));<z>
typeVariableMap;<z>
) throws IOException {<z>
)) {<z>
.error(LogFormatUtils.formatValue(<z>
, true));<z>
setStatusCode(HttpStatus.BAD_REQUEST);<z>
.UTF_8));<z>
createMessageListener(MessageListenerContainer container) {<z>
= getMessageListener();<z>
state(listener != null, "No MessageListener set");<z>
;<z>
Object> model, HttpServletRequest request,<z>
HttpServletResponse response) {<z>
SimpleHash(getObjectWrapper());<z>
);<z>
return fmModel;<z>
{<z>
return result -> {<z>
;<z>
.getMethod().getName());<z>
() {<z>
.type == this.resolved) {<z>
return this.resolved;<z>
= this.type;<z>
instanceof ParameterizedType) {<z>
.getRawType();<z>
Class<?>) rawType : null);<z>
public static SecondMsg parseFrom(<z>
.CodedInputStream input)<z>
java.io.IOException {<z>
input);<z>
isCompilable() {<z>
SpelNodeImpl left = getLeftOperand();<z>
= getRightOperand();<z>
) || !right.isCompilable()) {<z>
return false;<z>
String leftDesc = left.exitTypeDescriptor;<z>
= right.exitTypeDescriptor;<z>
= DescriptorComparison.checkNumericCompatibility(leftDesc,<z>
rightActualDescriptor);<z>
.areNumbers || dc.areCompatible);<z>
Nullable String descriptor) {<z>
(descriptor == null) {<z>
return false;<z>
length() == 1) {<z>
descriptor);<z>
descriptor.startsWith("Ljava/lang/")) {<z>
.substring("Ljava/lang/".length());<z>
("Long")) {<z>
return true;<z>
false;<z>
(Instant lastModified) {<z>
(Instant.EPOCH)) {<z>
return false;<z>
getRequestHeaders().getIfModifiedSince();<z>
-1) {<z>
return false;<z>
;<z>
;<z>
)<z>
{<z>
, bd, null);<z>
final int shortValue) {<z>
;<z>
{<z>
enlarge(4);<z>
= data;<z>
) byteValue1;<z>
byte) byteValue2;<z>
);<z>
++] = (byte) shortValue;<z>
length = currentLength;<z>
;<z>
packaze) {<z>
if (mv != null) {<z>
;<z>
{<z>
typeLocator == null) {<z>
StandardTypeLocator();<z>
.typeLocator;<z>
M getMappings() {<z>
;<z>
!= null) {<z>
sockJsService = this.sockJsServiceRegistration.getSockJsService();<z>
{<z>
path : paths) {<z>
"**" : path + "/**");<z>
, pathPattern);<z>
);<z>
getOrCreateHandshakeHandler();<z>
[] interceptors = getInterceptors();<z>
-> {<z>
) {<z>
;<z>
);<z>
mappings;<z>
private DateFormat newDateFormat() {<z>
SimpleDateFormat(DATE_FORMAT, Locale.US);<z>
;<z>
;<z>
onApplicationEvent(ContextRefreshedEvent event) {<z>
&& isAutodetect()) {<z>
clear();<z>
this.applicationContext);<z>
this.handlerMap.isEmpty()) {<z>
.autodetect = false;<z>
void applyCookies() {<z>
).isEmpty()) {<z>
this.context.getCookieStore();<z>
).values()<z>
stream()<z>
Collection::stream)<z>
.forEach(cookie -> {<z>
(), cookie.getValue());<z>
).getHost());<z>
(getURI().getPath());<z>
cookieStore.addCookie(clientCookie);<z>
;<z>
T> void registerBean(<z>
> supplier, BeanDefinitionCustomizer... customizers) {<z>
, supplier, customizers);<z>
{<z>
= this.beanClass;<z>
if (beanClassObject instanceof Class) {<z>
>) beanClassObject).getName();<z>
) beanClassObject;<z>
() {<z>
;<z>
false;<z>
= null;<z>
= 0;<z>
static String getFilename(@Nullable String path) {<z>
path == null) {<z>
;<z>
FOLDER_SEPARATOR);<z>
substring(separatorIndex + 1) : path);<z>
, Object> urlMap) throws BeansException {<z>
if (urlMap.isEmpty()) {<z>
.trace("No patterns in " + formatMappingName());<z>
.forEach((url, handler) -> {<z>
{<z>
;<z>
{<z>
String) handler).trim();<z>
handler);<z>
);<z>
logMappings();<z>
fromMethodCall(UriComponentsBuilder builder, Object info) {<z>
, info, "MethodInvocationInfo required");<z>
invocationInfo = (MethodInvocationInfo) info;<z>
invocationInfo.getControllerType();<z>
invocationInfo.getControllerMethod();<z>
= invocationInfo.getArgumentValues();<z>
, arguments);<z>
List<ParameterHolder> parameterList,<z>
int i, int j, String parameter) {<z>
j - escapes));<z>
totalParameterCount++;<z>
;<z>
) {<z>
> converters = new ArrayList<>();<z>
= configureMessageConverters(converters);<z>
(registerDefaults) {<z>
StringMessageConverter());<z>
ByteArrayMessageConverter());<z>
) {<z>
.add(createJacksonConverter());<z>
gsonPresent) {<z>
GsonMessageConverter());<z>
else if (jsonbPresent) {<z>
new JsonbMessageConverter());<z>
(kotlinSerializationJsonPresent) {<z>
);<z>
CompositeMessageConverter(converters);<z>
{<z>
this.includePatterns == null) {<z>
true;<z>
: this.includePatterns) {<z>
beanName).matches()) {<z>
return true;<z>
;<z>
labels) {<z>
) {<z>
(compute == COMPUTE_ALL_FRAMES) {<z>
, null);<z>
(Edge.JUMP, dflt);<z>
.FLAG_JUMP_TARGET;<z>
{<z>
);<z>
.FLAG_JUMP_TARGET;<z>
(compute == COMPUTE_MAX_STACK_AND_LOCAL) {<z>
--relativeStackSize;<z>
addSuccessorToCurrentBasicBlock(relativeStackSize, dflt);<z>
labels) {<z>
);<z>
;<z>
() throws BeansException {<z>
) {<z>
();<z>
);<z>
();<z>
;<z>
beanFactory);<z>
beanFactory);<z>
this.beanFactory = beanFactory;<z>
catch (IOException ex) {<z>
getDisplayName(), ex);<z>
addUrlPattern(String urlPattern) {<z>
;<z>
) {<z>
;<z>
if (urlPattern.equals(PATH_MAPPING_PATTERN)) {<z>
.startsWithMatches.add("");<z>
{<z>
- 1));<z>
) - 2));<z>
) {<z>
urlPattern = "/";<z>
add(urlPattern);<z>
(<z>
, final String descriptor, final boolean visible) {<z>
{<z>
new UnsupportedOperationException(REQUIRES_ASM5);<z>
if (mv != null) {<z>
);<z>
;<z>
ProducesRequestCondition other, ServerWebExchange exchange) {<z>
getAcceptedMediaTypes(exchange);<z>
acceptedMediaTypes) {<z>
= this.indexOfEqualMediaType(acceptedMediaType);<z>
int otherIndex = other.indexOfEqualMediaType(acceptedMediaType);<z>
other, otherIndex);<z>
!= 0) {<z>
return result;<z>
;<z>
(acceptedMediaType);<z>
);<z>
) {<z>
result;<z>
0;<z>
) {<z>
ex);<z>
removeSemicolonContent) {<z>
(removeSemicolonContent);<z>
.corsConfigurationSource instanceof UrlBasedCorsConfigurationSource urlConfigSource) {<z>
urlConfigSource.setRemoveSemicolonContent(removeSemicolonContent);<z>
@Nullable ParserContext context)<z>
ParseException {<z>
expressionString;<z>
new Tokenizer(expressionString);<z>
tokenizer.process();<z>
size();<z>
tokenStreamPointer = 0;<z>
;<z>
();<z>
!= null, "No node");<z>
t = peekToken();<z>
{<z>
MORE_INPUT, toString(nextToken()));<z>
isEmpty(), "At least one node expected");<z>
, this.configuration);<z>
{<z>
.getCause();<z>
Locale locale) throws Exception {<z>
attrs = RequestContextHolder.getRequestAttributes();<z>
);<z>
ServletRequestAttributes) attrs).getRequest());<z>
requestedMediaTypes != null) {<z>
requestedMediaTypes);<z>
= getBestView(candidateViews, requestedMediaTypes, attrs);<z>
(bestView != null) {<z>
bestView;<z>
) && requestedMediaTypes != null ?<z>
() : "";<z>
this.useNotAcceptableStatusCode) {<z>
)) {<z>
.debug("Using 406 NOT_ACCEPTABLE" + mediaTypeInfo);<z>
;<z>
+ mediaTypeInfo);<z>
null;<z>
JoinPointMatch getJoinPointMatch() {<z>
MethodInvocation mi = ExposeInvocationInterceptor.currentInvocation();<z>
instanceof ProxyMethodInvocation)) {<z>
throw new IllegalStateException("MethodInvocation is not a Spring ProxyMethodInvocation: " + mi);<z>
mi);<z>
Object lookup(String name) throws NamingException {<z>
name);<z>
) {<z>
+ this.jndiObjects.keySet());<z>
;<z>
{<z>
product = 1;<z>
Integer arg : args) {<z>
arg;<z>
return product;<z>
Object value) {<z>
value == null && this.nullAsEmptyMap) {<z>
;<z>
)) {<z>
;<z>
> source) {<z>
.size());<z>
), convertValue(val)));<z>
;<z>
("Value cannot be converted to Map: " + value);<z>
nextPowerOf2(int val) {<z>
val--;<z>
val;<z>
val >> 2) | val;<z>
;<z>
) | val;<z>
= (val >> 16) | val;<z>
;<z>
;<z>
transformer) {<z>
);<z>
=<z>
;<z>
synchronized (this.transformers) {<z>
instrumentation != null,<z>
);<z>
);<z>
(actualTransformer);<z>
encoder) {<z>
this.jackson2SmileEncoder = encoder;<z>
);<z>
;<z>
RequestPredicate predicate,<z>
ServerResponse> handlerFunction) {<z>
;<z>
TransactionDefinition definition) {<z>
definition;<z>
begun;<z>
;<z>
ServletResponse response) throws IOException {<z>
(paramType)) {<z>
;<z>
isAssignableFrom(paramType)) {<z>
response.getWriter();<z>
+ paramType);<z>
injectNotificationPublisherIfNecessary(<z>
Nullable ModelMBean modelMBean, @Nullable ObjectName objectName) {<z>
null && objectName != null) {<z>
).setNotificationPublisher(<z>
ModelMBeanNotificationPublisher(modelMBean, objectName, managedResource));<z>
sourceType, TypeDescriptor targetType) {<z>
);<z>
!= null &&<z>
);<z>
valueInstantiatorInstance(MapperConfig<?> config,<z>
> implClass) {<z>
createBean(implClass);<z>
) {<z>
String infix = getToStringInfix();<z>
(infix, "[", "]");<z>
) {<z>
(expression.toString());<z>
();<z>
String message, String statusText,<z>
@Nullable Charset charset) {<z>
headers, body, charset);<z>
public void popActiveContextObject() {<z>
.contextObjects == null) {<z>
.contextObjects = new ArrayDeque<>();<z>
;<z>
(NoSuchElementException ex) {<z>
);<z>
, String incrementerName) {<z>
.notNull(dataSource, "DataSource must not be null");<z>
incrementerName, "Incrementer name must not be null");<z>
= dataSource;<z>
incrementerName;<z>
() {<z>
);<z>
name == null) {<z>
getClass().getName();<z>
return name + ALREADY_FILTERED_SUFFIX;<z>
) {<z>
(task != null) {<z>
.scheduledTasks.add(task);<z>
,<z>
Object handler, Exception ex) throws Exception {<z>
().value();<z>
.reason();<z>
(statusCode, reason, response);<z>
desiredResultType)<z>
throws EvaluationException {<z>
context, rootObject);<z>
(value), desiredResultType);<z>
() {<z>
{<z>
(MockClientHttpRequest request) throws IOException, ParseException {<z>
request.getBodyAsString());<z>
() {<z>
());<z>
if (this.keepTaskList) {<z>
: getTaskInfo()) {<z>
);<z>
() / getTotalTimeNanos());<z>
.append('%');<z>
;<z>
;<z>
<String, ?> uriVars) {<z>
DefaultUriBuilderFactory) {<z>
;<z>
throw new IllegalArgumentException(<z>
;<z>
BindMarker marker, Object value) {<z>
);<z>
notNull(value, "Value must not be null");<z>
value));<z>
this;<z>
int off, int count) {<z>
) {<z>
&&<z>
size() > contentCacheLimit) {<z>
;<z>
- cachedContent.size());<z>
contentCacheLimit);<z>
;<z>
) {<z>
PooledDataBuffer pooledDataBuffer) {<z>
{<z>
;<z>
catch (IllegalStateException ex) {<z>
.isDebugEnabled()) {<z>
;<z>
false;<z>
return false;<z>
(BenchmarkState state, Blackhole bh) {<z>
) state.context.getBean("test");<z>
(tb.getName());<z>
(tb.getCountry());<z>
> toSingleValueMap() {<z>
(this.headers.size());<z>
.entries()<z>
.forEach(entry -> {<z>
getKey())) {<z>
));<z>
;<z>
singleValueMap;<z>
ScheduledFuture<?> schedule() {<z>
triggerContextMonitor) {<z>
this.triggerContext);<z>
this.scheduledExecutionTime == null) {<z>
;<z>
getClock().millis();<z>
;<z>
;<z>
request) {<z>
String enc = request.getCharacterEncoding();<z>
enc == null) {<z>
enc = getDefaultEncoding();<z>
;<z>
Object handler) {<z>
;<z>
{<z>
= getApplicationContext();<z>
null, "ApplicationContext is required for resolving handler bean names");<z>
);<z>
handler.getClass();<z>
!= null) {<z>
;<z>
> methods = MethodIntrospector.selectMethods(userType,<z>
getMappingForMethod(method, userType));<z>
)) {<z>
;<z>
));<z>
public SqlXmlValue newSqlXmlValue(final XmlCharacterStreamProvider provider) {<z>
{<z>
provideXml(SQLXML xmlObject) throws SQLException, IOException {<z>
;<z>
) {<z>
PropertyHandler ph = getPropertyHandler(propertyName);<z>
{<z>
;<z>
;<z>
;<z>
) {<z>
return false;<z>
ce) {<z>
ACC_PUBLIC, SINGLE_NEW_INSTANCE, null);<z>
length) {<z>
case 0:<z>
case 1:<z>
.push(1);<z>
CALLBACK);<z>
;<z>
);<z>
;<z>
();<z>
e), SET_THREAD_CALLBACKS, false);<z>
);<z>
;<z>
{<z>
AbstractPollingMessageListenerContainer.this.sharedConnectionEnabled()) {<z>
this.getSharedConnection();<z>
;<z>
();<z>
{<z>
resolvedType = getResolvedType(targetClass, conversionHint);<z>
Object payload = message.getPayload();<z>
targetClass, payload)) {<z>
return payload;<z>
byte[]) {<z>
()), resolvedType);<z>
toString(), resolvedType);<z>
ex) {<z>
+ ex.getMessage(), ex);<z>
{<z>
if (this.sendFailed) {<z>
= true;<z>
ex;<z>
.handler != null) {<z>
this.handler.completeWithError(ex);<z>
void generateCode(MethodVisitor mv, CodeFlow cf) {<z>
{<z>
visitTypeInsn(NEW, "java/lang/StringBuilder");<z>
visitInsn(DUP);<z>
"()V", false);<z>
);<z>
getRightOperand());<z>
, "()Ljava/lang/String;", false);<z>
(mv, cf);<z>
= this.children[0].exitTypeDescriptor;<z>
String exitDesc = this.exitTypeDescriptor;<z>
(exitDesc != null, "No exit type descriptor");<z>
exitDesc.charAt(0);<z>
, targetDesc);<z>
> 1) {<z>
;<z>
(mv, cf);<z>
;<z>
cf.exitCompilationScope();<z>
;<z>
) {<z>
:<z>
mv.visitInsn(IADD);<z>
case 'J':<z>
visitInsn(LADD);<z>
'F':<z>
);<z>
case 'D':<z>
.visitInsn(DADD);<z>
new IllegalStateException(<z>
exitTypeDescriptor + "'");<z>
exitTypeDescriptor);<z>
(ServletRequest request, String name)<z>
{<z>
, request.getParameter(name));<z>
(Path src, Path dest) throws IOException {<z>
"Source Path must not be null");<z>
);<z>
.class);<z>
isDirectory()) {<z>
<Path>() {<z>
BasicFileAttributes attrs) throws IOException {<z>
.relativize(dir)));<z>
return FileVisitResult.CONTINUE;<z>
throws IOException {<z>
.REPLACE_EXISTING);<z>
;<z>
});<z>
) {<z>
Files.copy(src, dest);<z>
("Source File must denote a directory or file");<z>
(IntPredicate predicate,<z>
> exceptionFunction) {<z>
predicate = predicate;<z>
;<z>
, String beanName)<z>
throws BeansException {<z>
beanClass != null && hasInstantiationAwareBeanPostProcessors()) {<z>
) {<z>
beanName);<z>
if (ctors != null) {<z>
;<z>
null;<z>
String parameter, String value) {<z>
);<z>
{<z>
);<z>
= Double.parseDouble(value);<z>
,<z>
+ value + "\": should be between 0.0 and 1.0");<z>
(<z>
)<z>
throws MessagingException {<z>
notNull(inputStreamSource, "InputStreamSource must not be null");<z>
resource && resource.isOpen()) {<z>
throw new IllegalArgumentException(<z>
"JavaMail requires an InputStreamSource that creates a fresh stream for every call.");<z>
attachmentFilename);<z>
;<z>
message) {<z>
(message));<z>
catch (JmsException ex) {<z>
ex);<z>
request) {<z>
if (request instanceof Request jettyRequest) {<z>
;<z>
) {<z>
.getRequest();<z>
);<z>
request.getClass() +<z>
);<z>
) {<z>
(this.lifecycleMonitor) {<z>
;<z>
;<z>
?> paramMap, ResultSetExtractor<T> rse)<z>
throws DataAccessException {<z>
;<z>
exchange(String url, HttpMethod method,<z>
T> responseType, Object... uriVariables)<z>
RestClientException {<z>
, responseType);<z>
= responseEntityExtractor(responseType);<z>
method, requestCallback, responseExtractor, uriVariables));<z>
@Nullable Throwable cause) {<z>
msg, cause);<z>
;<z>
.beanName = null;<z>
messages) {<z>
messages, "messages must not be null");<z>
);<z>
"a[");<z>
++) {<z>
append('"');<z>
messages[i]);<z>
(escapeSockJsSpecialChars(quotedChars));<z>
.append('"');<z>
length - 1) {<z>
(',');<z>
(']');<z>
sb.toString();<z>
throws IOException {<z>
ByteArrayOutputStream(1024);<z>
object, out);<z>
();<z>
public void initApplicationException(Throwable ex) {<z>
notNull(ex, "Application exception must not be null");<z>
{<z>
+ this.applicationException);<z>
ex;<z>
public TypeDescriptor getValueTypeDescriptor(EvaluationContext context) throws EvaluationException {<z>
"EvaluationContext is required");<z>
;<z>
.getTypeDescriptor();<z>
{<z>
;<z>
.getPropertySourceLocations());<z>
(context, mergedConfig.getPropertySourceProperties());<z>
invokeApplicationContextInitializers(context, mergedConfig);<z>
) {<z>
String extension = null;<z>
originalPath != null) {<z>
.extractFileExtension(this.originalPath);<z>
)) {<z>
extension.length() + 1);<z>
, end));<z>
= null;<z>
extension;<z>
HttpServletRequest request,<z>
IOException {<z>
String targetUrl = createTargetUrl(model, request);<z>
(targetUrl, model, request, response);<z>
, response);<z>
);<z>
ServerRequest request) {<z>
();<z>
) {<z>
();<z>
equals(method)) {<z>
(this.resource);<z>
).build();<z>
(method)) {<z>
()<z>
.build();<z>
status(HttpStatus.METHOD_NOT_ALLOWED)<z>
;<z>
HttpServletRequest request) {<z>
{<z>
multipartRequest =<z>
(request, MultipartHttpServletRequest.class);<z>
(multipartRequest != null) {<z>
cleanupMultipart(multipartRequest);<z>
protected Context createInitialContext() throws NamingException {<z>
<?, ?> icEnv = null;<z>
;<z>
(env != null) {<z>
(env.size());<z>
CollectionUtils.mergePropertiesIntoMap(env, icEnv);<z>
);<z>
) {<z>
cookies, "'cookies' must not be null");<z>
cookies;<z>
return this;<z>
String> requiredProperties)<z>
{<z>
requiredProperties) ?<z>
HashSet<>(requiredProperties) : null);<z>
paramNames = config.getInitParameterNames();<z>
)) {<z>
= paramNames.nextElement();<z>
config.getInitParameter(property);<z>
PropertyValue(property, value));<z>
{<z>
remove(property);<z>
)) {<z>
new ServletException(<z>
+ config.getServletName() +<z>
", "));<z>
, @Nullable Object value) {<z>
.MODEL_KEY_PREFIX) && value != null &&<z>
value instanceof Map) &&<z>
== null &&<z>
;<z>
Encoder<?> encoder) {<z>
.jackson2JsonEncoder = encoder;<z>
);<z>
;<z>
) {<z>
.delegates) {<z>
addResourceHandlers(registry);<z>
private void initHeaders(SimpMessageHeaderAccessor headerAccessor) {<z>
getHeaderInitializer() != null) {<z>
;<z>
CacheOperationContext context, @Nullable Object result) {<z>
boolean passing = context.isConditionPassing(result);<z>
) {<z>
+ context.metadata.method +<z>
.metadata.operation);<z>
return passing;<z>
int bytecodeOffset) {<z>
|= FLAG_RESOLVED;<z>
= bytecodeOffset;<z>
) {<z>
false;<z>
;<z>
-= 2) {<z>
1];<z>
int reference = forwardReferences[i];<z>
;<z>
handle = reference & FORWARD_REFERENCE_HANDLE_MASK;<z>
FORWARD_REFERENCE_TYPE_SHORT) {<z>
.MIN_VALUE || relativeOffset > Short.MAX_VALUE) {<z>
[sourceInsnBytecodeOffset] & 0xFF;<z>
< Opcodes.IFNULL) {<z>
ASM_OPCODE_DELTA);<z>
else {<z>
ASM_IFNULL_OPCODE_DELTA);<z>
true;<z>
> 8);<z>
handle] = (byte) relativeOffset;<z>
{<z>
byte) (relativeOffset >>> 24);<z>
);<z>
> 8);<z>
relativeOffset;<z>
;<z>
private <T> DataBuffer encodeValue(<z>
Nullable Encoder<T> encoder,<z>
MimeType mimeType,<z>
) {<z>
encoder == null) {<z>
;<z>
if (encoder == null) {<z>
new MessagingException(<z>
());<z>
, bufferFactory, elementType, mimeType, hints);<z>
contentType) {<z>
isWildcardSubtype()) {<z>
;<z>
(contentType, "Could not select Content-Type. " +<z>
;<z>
return contentType;<z>
final @Nullable String body,<z>
responses, final CountDownLatch latch) {<z>
return new ClientCallback<>() {<z>
result) {<z>
{<z>
result) {<z>
;<z>
getConnection().getBufferPool()) {<z>
string) {<z>
(RESPONSE_BODY, string);<z>
;<z>
void error(IOException ex) {<z>
onFailure(latch, ex);<z>
));<z>
failed(IOException ex) {<z>
(latch, ex);<z>
});<z>
!= null) {<z>
()));<z>
().shutdownWrites();<z>
().flush()) {<z>
().getWriteSetter()<z>
));<z>
();<z>
{<z>
onFailure(latch, ex);<z>
{<z>
onFailure(latch, ex);<z>
IOException ex) {<z>
countDown();<z>
, ex);<z>
A> annotationType) {<z>
if (annotationType == null) {<z>
;<z>
annotationType) ||<z>
{<z>
);<z>
())<z>
annotationType).withNonMergedAttributes()<z>
(null);<z>
boolean hasBody(ServerHttpRequest request) {<z>
);<z>
.getFirst(HttpHeaders.TRANSFER_ENCODING);<z>
) ||<z>
trim().equals("0"));<z>
PreparedStatementCreatorFactory getPreparedStatementCreatorFactory(<z>
ParsedSql parsedSql, SqlParameterSource paramSource) {<z>
paramSource);<z>
(parsedSql, paramSource);<z>
, declaredParameters);<z>
original, Set<String> keysToIgnore) {<z>
headers.size());<z>
{<z>
contains(key)) {<z>
;<z>
});<z>
RequestMappingInfo createRequestMappingInfo(<z>
@Nullable RequestCondition<?> customCondition) {<z>
RequestMappingInfo.Builder builder = RequestMappingInfo<z>
()))<z>
requestMapping.method())<z>
(requestMapping.params())<z>
requestMapping.headers())<z>
))<z>
produces())<z>
(requestMapping.name());<z>
) {<z>
customCondition(customCondition);<z>
this.config).build();<z>
(HttpServletRequest request, boolean lazyParsing)<z>
MultipartException {<z>
);<z>
if (!lazyParsing) {<z>
parseRequest(request);<z>
, @Nullable Object source, ParserContext context) {<z>
);<z>
messageConverters = new ManagedList<>();<z>
if (convertersElement != null) {<z>
(source);<z>
, "bean", "ref")) {<z>
).parsePropertySubElement(beanElement, null);<z>
object);<z>
)) {<z>
messageConverters.setSource(source);<z>
class, source));<z>
StringHttpMessageConverter.class, source);<z>
);<z>
.add(stringConverterDef);<z>
createConverterDefinition(ResourceHttpMessageConverter.class, source));<z>
createConverterDefinition(ResourceRegionHttpMessageConverter.class, source));<z>
));<z>
);<z>
romePresent) {<z>
);<z>
));<z>
) {<z>
.class;<z>
type, source);<z>
createObjectMapperFactoryDefinition(source);<z>
);<z>
, jacksonFactoryDef);<z>
(jacksonConverterDef);<z>
{<z>
createConverterDefinition(Jaxb2RootElementHttpMessageConverter.class, source));<z>
jackson2Present) {<z>
?> type = MappingJackson2HttpMessageConverter.class;<z>
source);<z>
createObjectMapperFactoryDefinition(source);<z>
(0, jacksonFactoryDef);<z>
add(jacksonConverterDef);<z>
else if (gsonPresent) {<z>
(GsonHttpMessageConverter.class, source));<z>
jackson2SmilePresent) {<z>
.class;<z>
);<z>
(source);<z>
));<z>
(0, jacksonFactoryDef);<z>
(jacksonConverterDef);<z>
jackson2CborPresent) {<z>
type = MappingJackson2CborHttpMessageConverter.class;<z>
, source);<z>
source);<z>
"factory", new CBORFactory());<z>
;<z>
add(jacksonConverterDef);<z>
return messageConverters;<z>
bean, String beanName) {<z>
EnhancedConfiguration enhancedConfiguration) {<z>
enhancedConfiguration.setBeanFactory(this.beanFactory);<z>
return pvs;<z>
(ProducerCallback<T> action) throws JmsException {<z>
);<z>
(defaultDestinationName != null) {<z>
(defaultDestinationName, action);<z>
execute(getDefaultDestination(), action);<z>
{<z>
getScheduledExecutor();<z>
;<z>
catch (RejectedExecutionException ex) {<z>
"] did not accept task: " + task, ex);<z>
> writeAction) {<z>
;<z>
State.COMMITTING)) {<z>
()) {<z>
))<z>
doOnError(ex -> {<z>
{<z>
();<z>
);<z>
State.COMMIT_ACTION_FAILED, State.COMMITTING)) {<z>
();<z>
(() -> {<z>
);<z>
);<z>
applyCookies();<z>
.COMMITTED);<z>
}));<z>
(writeAction != null) {<z>
;<z>
then();<z>
) default "";<z>
) default "";<z>
DEFAULT;<z>
TransactionMode {<z>
MappingRegistration(<z>
boolean corsConfig) {<z>
;<z>
handlerMethod, "HandlerMethod must not be null");<z>
mapping;<z>
.handlerMethod = handlerMethod;<z>
? directPaths : Collections.emptySet());<z>
= corsConfig;<z>
private static boolean merge(<z>
SymbolTable symbolTable,<z>
int sourceType,<z>
] dstTypes,<z>
{<z>
= dstTypes[dstIndex];<z>
sourceType) {<z>
return false;<z>
sourceType;<z>
) {<z>
) {<z>
false;<z>
;<z>
) {<z>
srcType;<z>
;<z>
mergedType;<z>
|| (dstType & KIND_MASK) == REFERENCE_KIND) {<z>
(srcType == NULL) {<z>
return false;<z>
dstType & (DIM_MASK | KIND_MASK))) {<z>
== REFERENCE_KIND) {<z>
srcType & DIM_MASK)<z>
VALUE_MASK, dstType & VALUE_MASK);<z>
{<z>
mergedDim = ELEMENT_OF + (srcType & DIM_MASK);<z>
addType("java/lang/Object");<z>
REFERENCE_KIND) {<z>
= srcType & DIM_MASK;<z>
(srcType & KIND_MASK) != REFERENCE_KIND) {<z>
srcDim = ELEMENT_OF + srcDim;<z>
& DIM_MASK;<z>
KIND_MASK) != REFERENCE_KIND) {<z>
+ dstDim;<z>
| REFERENCE_KIND | symbolTable.addType("java/lang/Object");<z>
} else {<z>
;<z>
{<z>
srcType : TOP;<z>
} else {<z>
= TOP;<z>
{<z>
;<z>
return true;<z>
;<z>
?> converter) {<z>
if (logger.isDebugEnabled()) {<z>
null) {<z>
+ body + "] as \"" + mediaType + "\"");<z>
);<z>
username, String password) {<z>
username, "'username' must not be null");<z>
);<z>
.username = username;<z>
password;<z>
, String actualDest, String subscribeDest,<z>
{<z>
= sourceDest;<z>
actualDestination = actualDest;<z>
.subscribeDestination = subscribeDest;<z>
this.sessionIds = sessionIds;<z>
;<z>
(long lastModifiedTimestamp) {<z>
< 0) {<z>
false;<z>
= parseDateHeader(HttpHeaders.IF_UNMODIFIED_SINCE);<z>
(ifUnmodifiedSince == -1) {<z>
return false;<z>
);<z>
true;<z>
boolean isWritable(@Nullable MediaType mediaType) {<z>
mediaType)) {<z>
return true;<z>
;<z>
.hasNext();<z>
?> targetClass) {<z>
();<z>
.nameMap.get(methodName);<z>
null) {<z>
bestNameMatch = null;<z>
nameMap.keySet()) {<z>
methodName, mappedName)<z>
)) {<z>
;<z>
bestNameMatch = mappedName;<z>
;<z>
other, int age, String name) {<z>
super(spouse1, spouse2, other);<z>
);<z>
;<z>
increment) {<z>
length;<z>
(increment < -128)) {<z>
putShort(increment);<z>
} else {<z>
.put11(var, increment);<z>
null<z>
COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES)) {<z>
;<z>
(compute != COMPUTE_NOTHING) {<z>
;<z>
(currentMaxLocals > maxLocals) {<z>
;<z>
(RequestMatcher requestMatcher) {<z>
requestMatcher, "RequestMatcher is required");<z>
.add(requestMatcher);<z>
this;<z>
protected void initPropertySources() {<z>
getEnvironment();<z>
) {<z>
this.servletConfig);<z>
{<z>
Assert.notNull(registry, "BeanDefinitionRegistry must not be null");<z>
if (registry instanceof EnvironmentCapable) {<z>
).getEnvironment();<z>
);<z>
(boolean strictContentTypeMatch) {<z>
strictContentTypeMatch) {<z>
;<z>
, "Strict match requires ContentTypeResolver");<z>
.strictContentTypeMatch = strictContentTypeMatch;<z>
Type type, HttpOutputMessage outputMessage)<z>
HttpMessageNotWritableException {<z>
instanceof ResourceRegion resourceRegion) {<z>
resourceRegion, outputMessage);<z>
;<z>
) == 1) {<z>
next(), outputMessage);<z>
;<z>
Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {<z>
(source == null) {<z>
;<z>
Array.getLength(source);<z>
TypeDescriptor elementDesc = targetType.getElementTypeDescriptor();<z>
,<z>
) : null), length);<z>
if (elementDesc == null) {<z>
; i++) {<z>
Array.get(source, i);<z>
);<z>
; i < length; i++) {<z>
;<z>
targetElement = this.conversionService.convert(sourceElement,<z>
, elementDesc);<z>
targetElement);<z>
return target;<z>
void addFormatters(FormatterRegistry registry) {<z>
{<z>
.addFormatters(registry);<z>
@Nullable Object value) {<z>
"Method must not be null");<z>
== resolvedType) {<z>
== null) {<z>
(<z>
);<z>
(value);<z>
?> valueClass;<z>
boolean pluralize = false;<z>
String reactiveSuffix = "";<z>
{<z>
resolvedType.getComponentType();<z>
true;<z>
) {<z>
resolveGeneric();<z>
if (valueClass == null) {<z>
(value instanceof Collection)) {<z>
IllegalArgumentException("Cannot generate variable name " +<z>
;<z>
= (Collection<?>) value;<z>
(collection.isEmpty()) {<z>
IllegalArgumentException("Cannot generate variable name " +<z>
"for non-typed Collection return type and an empty Collection value");<z>
collection);<z>
);<z>
true;<z>
resolvedType;<z>
;<z>
)) {<z>
);<z>
toClass();<z>
;<z>
(name) : name + reactiveSuffix);<z>
DataSource dataSource, String databaseName) {<z>
connect(<z>
new Properties());<z>
ex) {<z>
ex.getSQLState())) {<z>
).warn("Could not shut down embedded Derby database", ex);<z>
TyrusWebSocketEngine engine, Object endpoint) {<z>
.invoke(engine, endpoint);<z>
ex) {<z>
HandshakeFailureException("Failed to register " + endpoint, ex);<z>
String[] getBeanDefinitionNames() {<z>
frozenBeanDefinitionNames;<z>
) {<z>
;<z>
beanDefinitionNames);<z>
(Object[] array) {<z>
0) {<z>
()) + '>' + EMPTY;<z>
);<z>
{<z>
add(style(o));<z>
result;<z>
createMessage(Session session) throws JMSException {<z>
(this.message, session);<z>
catch (Exception ex) {<z>
ex);<z>
T> processor) {<z>
.sourceCompleted = true;<z>
REQUESTED) {<z>
);<z>
SQLException {<z>
ResultSetMetaData rsmd = rs.getMetaData();<z>
= rsmd.getColumnCount();<z>
) {<z>
IncorrectResultSetColumnCountException(1, nrOfColumns);<z>
requiredType);<z>
(result)) {<z>
) convertValueToRequiredType(result, this.requiredType);<z>
{<z>
new TypeMismatchDataAccessException(<z>
"Type mismatch affecting row number " + rowNum + " and column type '" +<z>
);<z>
T) result;<z>
DataSourceLookupFailureException {<z>
);<z>
catch (NamingException ex) {<z>
(<z>
dataSourceName + "'", ex);<z>
computeAttributesSize(<z>
final int accessFlags, final int signatureIndex) {<z>
size = 0;<z>
) != 0<z>
< Opcodes.V1_5) {<z>
.SYNTHETIC);<z>
+= 6;<z>
signatureIndex != 0) {<z>
symbolTable.addConstantUtf8(Constants.SIGNATURE);<z>
size += 8;<z>
) {<z>
addConstantUtf8(Constants.DEPRECATED);<z>
size += 6;<z>
size;<z>
(<z>
?> targetClass, @Nullable Object conversionHint) {<z>
null;<z>
(int pathIndex, MatchingContext matchingContext) {<z>
>= matchingContext.pathLength) {<z>
false;<z>
= matchingContext.pathElements.get(pathIndex);<z>
(!(element instanceof PathSegment)) {<z>
return false;<z>
)element).valueToMatch();<z>
) {<z>
false;<z>
if (this.caseSensitive) {<z>
{<z>
ch = this.text[i];<z>
charAt((i)))) {<z>
return false;<z>
++) {<z>
];<z>
value.charAt(i)))) {<z>
false;<z>
pathIndex++;<z>
)) {<z>
{<z>
pathIndex;<z>
true;<z>
pathIndex == matchingContext.pathLength) {<z>
return true;<z>
isMatchOptionalTrailingSeparator() &&<z>
) == matchingContext.pathLength &&<z>
.isSeparator(pathIndex));<z>
next.matches(pathIndex, matchingContext));<z>
name) {<z>
.isInfoEnabled()) {<z>
root + name + "]");<z>
this.root + name);<z>
createDataBinderFactory(List<InvocableHandlerMethod> binderMethods)<z>
{<z>
);<z>
?> reactiveType, boolean multiValue, boolean noValue,<z>
?> emptySupplier, boolean deferred) {<z>
);<z>
.reactiveType = reactiveType;<z>
= multiValue;<z>
this.noValue = noValue;<z>
;<z>
deferred = deferred;<z>
(Map<String, String> pathVariables) {<z>
;<z>
this.pathVariables = pathVariables;<z>
this;<z>
<?> classBeingRedefined,<z>
protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {<z>
(this.targetClassLoader != loader) {<z>
;<z>
this.targetTransformer.transform(<z>
);<z>
) {<z>
TemporalAdjuster adjuster = TemporalAdjusters.lastInMonth(dayOfWeek);<z>
-> {<z>
(temporal);<z>
, result);<z>
,<z>
,<z>
String descriptor,<z>
{<z>
super( Opcodes.ASM9);<z>
= symbolTable;<z>
;<z>
= symbolTable.addConstantUtf8(descriptor);<z>
if (signature != null) {<z>
signatureIndex = symbolTable.addConstantUtf8(signature);<z>
) {<z>
(4);<z>
isCandidateClass(getIntrospectedClass(), annotationName)) {<z>
.doWithLocalMethods(getIntrospectedClass(), method -> {<z>
{<z>
));<z>
;<z>
;<z>
new ClassEmitter(v);<z>
.findNewInstance(keyInterface);<z>
.class)) {<z>
("newInstance method must return Object");<z>
ce.begin_class(Constants.V1_8,<z>
ACC_PUBLIC,<z>
{Type.getType(keyInterface)},<z>
seed = 0;<z>
= ce.begin_method(Constants.ACC_PUBLIC,<z>
(parameterTypes),<z>
load_this();<z>
e.super_invoke_constructor();<z>
> fieldTypeCustomizers = getCustomizers(FieldTypeCustomizer.class);<z>
i < parameterTypes.length; i++) {<z>
[i];<z>
= parameterType;<z>
.getOutType(i, fieldType);<z>
.hashCode();<z>
.ACC_PRIVATE | Constants.ACC_FINAL,<z>
e.dup();<z>
.customize(e, i, parameterType);<z>
e.putfield(getFieldName(i));<z>
, HASH_CODE, null);<z>
.length)];<z>
push(hc);<z>
length; i++) {<z>
e.load_this();<z>
e.getfield(getFieldName(i));<z>
hm, customizers);<z>
e.end_method();<z>
(Constants.ACC_PUBLIC, EQUALS, null);<z>
.make_label();<z>
e.load_arg(0);<z>
if_jump(CodeEmitter.EQ, fail);<z>
; i++) {<z>
(getFieldName(i));<z>
, customizers);<z>
.push(1);<z>
(fail);<z>
e.end_method();<z>
Constants.ACC_PUBLIC, TO_STRING, null);<z>
invoke_constructor(Constants.TYPE_STRING_BUFFER);<z>
.push(", ");<z>
(Constants.TYPE_STRING_BUFFER, APPEND_STRING);<z>
.load_this();<z>
customizers);<z>
.invoke_virtual(Constants.TYPE_STRING_BUFFER, TO_STRING);<z>
e.end_method();<z>
.end_class();<z>
) {<z>
getUrl();<z>
, "'url' not set");<z>
exchange.getRequest();<z>
);<z>
url.startsWith("/")) {<z>
.contextPath().value());<z>
targetUrl.append(url);<z>
.hasText(targetUrl)) {<z>
(exchange);<z>
), model, uriVars);<z>
if (isPropagateQuery()) {<z>
request);<z>
String result = targetUrl.toString();<z>
getRequestDataValueProcessor();<z>
, result) : result);<z>
getSendProcessor() {<z>
;<z>
"No WebSocketSendProcessor available");<z>
;<z>
throws SQLException {<z>
) &&<z>
(password, getPassword())) {<z>
();<z>
);<z>
reader, Type resolvedType) {<z>
;<z>
(IOException ex) {<z>
ex);<z>
boolean hasPlainJavaAnnotationsOnly(@Nullable Object annotatedElement) {<z>
Class) {<z>
) annotatedElement);<z>
annotatedElement instanceof Member) {<z>
getDeclaringClass());<z>
false;<z>
OracleTableMetaDataProvider(DatabaseMetaData databaseMetaData, boolean includeSynonyms)<z>
throws SQLException {<z>
);<z>
includeSynonyms = includeSynonyms;<z>
.defaultSchema = lookupDefaultSchema(databaseMetaData);<z>
{<z>
();<z>
;<z>
unmarshaller;<z>
(JAXBException ex) {<z>
throw convertJaxbException(ex);<z>
) {<z>
(member instanceof Method) {<z>
) member));<z>
{<z>
) member).getParameterTypes());<z>
.CONSTRUCTOR_NAME,<z>
.VOID_TYPE, types));<z>
;<z>
(StartElement event) {<z>
();<z>
hasNext();) {<z>
Attribute) i.next();<z>
;<z>
getNamespaceURI();<z>
) {<z>
"";<z>
getDTDType();<z>
type == null) {<z>
"CDATA";<z>
, type, attribute.getValue());<z>
) {<z>
;) {<z>
);<z>
String prefix = namespace.getPrefix();<z>
namespace.getNamespaceURI();<z>
qName;<z>
) {<z>
;<z>
"xmlns";<z>
;<z>
attributes;<z>
) {<z>
if (this.beanFactory instanceof ConfigurableBeanFactory) {<z>
;<z>
.adviceMonitor = new Object();<z>
{<z>
isEmpty(),<z>
);<z>
patternParser);<z>
void flush() throws DataAccessException {<z>
-> {<z>
();<z>
;<z>
});<z>
SchedulerFactory schedulerFactory) throws SchedulerException {<z>
if (this.resourceLoader != null) {<z>
this.resourceLoader);<z>
taskExecutor != null) {<z>
set(this.taskExecutor);<z>
) {<z>
.dataSource);<z>
this.nonTransactionalDataSource != null) {<z>
(this.nonTransactionalDataSource);<z>
schedulerFactory, this.schedulerName);<z>
scheduler);<z>
(scheduler instanceof RemoteScheduler)) {<z>
);<z>
jobFactory != null) {<z>
this.jobFactory instanceof ApplicationContextAware) {<z>
).setApplicationContext(this.applicationContext);<z>
jobFactory instanceof SchedulerContextAware) {<z>
scheduler.getContext());<z>
.jobFactory);<z>
;<z>
if (this.resourceLoader != null) {<z>
);<z>
!= null) {<z>
.remove();<z>
.dataSource != null) {<z>
configTimeDataSourceHolder.remove();<z>
null) {<z>
remove();<z>
, boolean mustBeStatic) {<z>
(getPropertyMethodSuffixes(propertyName),<z>
, mustBeStatic, 0, ANY_TYPES);<z>
== null) {<z>
,<z>
;<z>
(method == null) {<z>
new String[] {propertyName},<z>
, 0, ANY_TYPES);<z>
;<z>
{<z>
)];<z>
idx = 0;<z>
buffer : this.content) {<z>
buffer.readableByteCount();<z>
(bytes, idx, len);<z>
;<z>
(buffer);<z>
.clear();<z>
));<z>
);<z>
transaction) throws TransactionException {<z>
{<z>
(new IllegalTransactionStateException(<z>
;<z>
).flatMap(synchronizationManager -> {<z>
= (GenericReactiveTransaction) transaction;<z>
reactiveTx.isRollbackOnly()) {<z>
)) {<z>
debug("Transactional code has requested rollback");<z>
;<z>
reactiveTx);<z>
});<z>
) throws MessagingException {<z>
MimeMultipart mimeMultipart = getMimeMultipart();<z>
null;<z>
getCount(); i++) {<z>
.getBodyPart(i);<z>
bp.getFileName() == null) {<z>
) bp;<z>
{<z>
();<z>
.addBodyPart(mimeBodyPart);<z>
= mimeBodyPart;<z>
;<z>
throws BeansException {<z>
(logger.isDebugEnabled()) {<z>
);<z>
(getTargetBeanName());<z>
protected void afterSingletonCreation(String beanName) {<z>
) {<z>
;<z>
public ReadableByteChannel readableChannel() throws IOException {<z>
StandardOpenOption.READ);<z>
catch (FileNotFoundException | NoSuchFileException ex) {<z>
();<z>
A> findMergedAnnotation(<z>
A> annotationType) {<z>
annotationType));<z>
{<z>
) {<z>
= byteBuffer.get();<z>
b == '\n') {<z>
;<z>
(b == '\r') {<z>
byteBuffer.get() == '\n') {<z>
return true;<z>
);<z>
() - 1);<z>
return false;<z>
void request(long n) {<z>
s = this.subscription;<z>
) {<z>
READY_TO_WRITE) {<z>
.request(n);<z>
this) {<z>
writeSubscriber != null) {<z>
(this.state == State.EMITTING_CACHED_SIGNALS) {<z>
this.demandBeforeReadyToWrite = n;<z>
;<z>
(emitCachedSignals()) {<z>
;<z>
n == 0) {<z>
state = State.READY_TO_WRITE;<z>
);<z>
InvalidResultSetAccessException {<z>
resultSetMetaData.getColumnName(column);<z>
) {<z>
InvalidResultSetAccessException(se);<z>
addPathPatterns(List<String> patterns) {<z>
includePatterns != null ?<z>
;<z>
patterns);<z>
return this;<z>
?> clazz, Object target) {<z>
clazz, target instanceof Class);<z>
instanceof Class) {<z>
false);<z>
;<z>
result) throws IOException {<z>
)) {<z>
.parser);<z>
this.arrayDepth == 1) &&<z>
))) {<z>
(this.tokenBuffer);<z>
;<z>
) {<z>
{<z>
MediaType contentType =<z>
).orElse(MediaType.APPLICATION_OCTET_STREAM);<z>
mediaTypes.stream()<z>
contentType));<z>
;<z>
;<z>
);<z>
.mediaTypes = mediaTypes;<z>
{<z>
(request);<z>
)) {<z>
.getServletPath());<z>
return builder;<z>
, ServerHttpResponse response,<z>
) throws IOException {<z>
byte[] prelude = getPrelude(request);<z>
.write(prelude);<z>
;<z>
if (initialRequest) {<z>
(SockJsFrame.openFrame());<z>
;<z>
byte[] getContentRangeHeader(ResourceRegion region) {<z>
long start = region.getPosition();<z>
getCount() - 1;<z>
.getResource());<z>
{<z>
long length = contentLength.getAsLong();<z>
length + "\r\n\r\n");<z>
+ end + "\r\n\r\n");<z>
String message) {<z>
array != null) {<z>
{<z>
if (element == null) {<z>
new IllegalArgumentException(message);<z>
) throws TransactionTimedOutException {<z>
deadlineReached) {<z>
;<z>
TransactionTimedOutException("Transaction timed out: deadline was " + this.deadline);<z>
) {<z>
Assert.notEmpty(transports, "No transports provided");<z>
);<z>
this.infoReceiver = initInfoReceiver(transports);<z>
(jackson2Present) {<z>
();<z>
addReturnValueHandlers(List<HandlerMethodReturnValueHandler> returnValueHandlers) {<z>
(WebMvcConfigurer delegate : this.delegates) {<z>
addReturnValueHandlers(returnValueHandlers);<z>
Nullable String requestingBeanName) {<z>
if (this.type != null) {<z>
.EXTENDED ?<z>
target, requestingBeanName) :<z>
));<z>
requestingBeanName);<z>
String delim) {<z>
.isEmpty(arr)) {<z>
return "";<z>
arr.length == 1) {<z>
(arr[0]);<z>
new StringJoiner(delim);<z>
(Object elem : arr) {<z>
(String.valueOf(elem));<z>
sj.toString();<z>
(BeanWrapper bw) {<z>
);<z>
{<z>
setConversionService(cs);<z>
(Method beanMethod) {<z>
;<z>
scopedProxy == null) {<z>
AnnotationAttributes scope =<z>
;<z>
!= ScopedProxyMode.NO);<z>
;<z>
return scopedProxy;<z>
) {<z>
this == other) {<z>
true;<z>
)) {<z>
false;<z>
.advised;<z>
)) {<z>
;<z>
)) {<z>
return false;<z>
()) {<z>
return false;<z>
, otherAdvised)) {<z>
return false;<z>
!= otherAdvised.getAdvisorCount()) {<z>
;<z>
= this.advised.getAdvisors();<z>
;<z>
{<z>
thisAdvisors[i];<z>
thatAdvisor = thatAdvisors[i];<z>
!equalsAdviceClasses(thisAdvisor, thatAdvisor)) {<z>
false;<z>
equalsPointcuts(thisAdvisor, thatAdvisor)) {<z>
;<z>
true;<z>
Integer typeIndex) {<z>
);<z>
copy.nestingLevel = nestingLevel;<z>
if (this.typeIndexesPerLevel != null) {<z>
.typeIndexesPerLevel);<z>
typeIndex != null) {<z>
;<z>
;<z>
null;<z>
;<z>
, ResolvableType elementType,<z>
> hints) {<z>
(mimeType);<z>
.decode(dataBuffer.asByteBuffer());<z>
dataBuffer);<z>
.toString();<z>
traceDebug(logger, traceOn -> {<z>
traceOn);<z>
.getLogPrefix(hints) + "Decoded " + formatted;<z>
);<z>
;<z>
protected void printFlashMap(FlashMap flashMap) throws Exception {<z>
if (ObjectUtils.isEmpty(flashMap)) {<z>
.printer.printValue("Attributes", null);<z>
name, value) -> {<z>
);<z>
value);<z>
);<z>
<InvocableHandlerMethod> getModelAttributeMethods(HandlerMethod handlerMethod) {<z>
;<z>
?> handlerType = handlerMethod.getBeanType();<z>
, methods) -> {<z>
if (adviceBean.isApplicableToBeanType(handlerType)) {<z>
bean = adviceBean.resolveBean();<z>
, method)));<z>
});<z>
this.modelAttributeMethodCache<z>
(handlerType,<z>
MODEL_ATTRIBUTE_METHODS))<z>
(method -> {<z>
;<z>
);<z>
;<z>
return result;<z>
name) {<z>
= this.cacheMap.get(name);<z>
{<z>
;<z>
);<z>
(missingCache != null) {<z>
this.cacheMap) {<z>
);<z>
(cache == null) {<z>
decorateCache(missingCache);<z>
name, cache);<z>
name);<z>
cache;<z>
(ExpectedCount count, RequestMatcher matcher) {<z>
isEmpty(), "Cannot add more expectations after actual requests are made");<z>
, matcher);<z>
expectations.add(expectation);<z>
return expectation;<z>
String signature, Class<?> clazz) {<z>
);<z>
.notNull(clazz, "Class must not be null");<z>
('(');<z>
= signature.indexOf(')');<z>
endParen == -1) {<z>
throw new IllegalArgumentException("Invalid method signature '" + signature +<z>
;<z>
-1) {<z>
+<z>
"': expected opening '(' for args list");<z>
else if (startParen == -1) {<z>
return findMethodWithMinimalParameters(clazz, signature);<z>
;<z>
[] parameterTypeNames =<z>
startParen + 1, endParen));<z>
?>[parameterTypeNames.length];<z>
i++) {<z>
.trim();<z>
parameterTypeName, clazz.getClassLoader());<z>
ex) {<z>
"Invalid method signature: unable to resolve type [" +<z>
i + ". Root cause: " + ex);<z>
methodName, parameterTypes);<z>
String name) {<z>
();<z>
;<z>
);<z>
public Object getAttribute(String name) {<z>
&&<z>
name)) &&<z>
containsBean(name)) {<z>
return this.webApplicationContext.getBean(name);<z>
.getAttribute(name);<z>
public void process() {<z>
DeferredImportSelectorHolder> deferredImports = this.deferredImportSelectors;<z>
deferredImportSelectors = null;<z>
deferredImports != null) {<z>
);<z>
.sort(DEFERRED_IMPORT_COMPARATOR);<z>
register);<z>
);<z>
ArrayList<>();<z>
public InputStream getInputStream() throws IOException {<z>
()) {<z>
(getPath() + " (no such file or directory)");<z>
.path)) {<z>
getPath() + " (is a directory)");<z>
);<z>
configureClient() {<z>
initHttpHandlerBuilder();<z>
(this.filters)) {<z>
, this.filters));<z>
{<z>
(this.sessionManager);<z>
.isEmpty(this.configurers)) {<z>
configurer.beforeServerCreated(builder));<z>
(builder);<z>
value, Consumer<E> consumer) {<z>
;<z>
.classLoader);<z>
.valueOf(type, value));<z>
) {<z>
preparationMonitor) {<z>
;<z>
onComplete(AsyncEvent event) {<z>
bodyFlushProcessor;<z>
= bodyProcessor;<z>
(flushProcessor != null) {<z>
.cancel();<z>
processor != null) {<z>
();<z>
processor.onComplete();<z>
.onComplete();<z>
MediaType contentType,<z>
, ServerHttpResponse response) {<z>
JsonView.class);<z>
;<z>
();<z>
length != 1) {<z>
IllegalArgumentException(<z>
;<z>
setSerializationView(classes[0]);<z>
IOException {<z>
== null) {<z>
createTemplateClassLoader();<z>
;<z>
templateEngine;<z>
protected void startSharedConnection() throws JMSException {<z>
(this.sharedConnectionMonitor) {<z>
true;<z>
{<z>
;<z>
jakarta.jms.IllegalStateException ex) {<z>
);<z>
(String innerBeanName) {<z>
= innerBeanName;<z>
0;<z>
prefix = innerBeanName + BeanFactoryUtils.GENERATED_BEAN_NAME_SEPARATOR;<z>
)) {<z>
counter++;<z>
+ counter;<z>
return actualInnerBeanName;<z>
Object value) {<z>
{<z>
Integer) value).intValue());<z>
} else if (value instanceof Byte) {<z>
.intValue());<z>
instanceof Character) {<z>
;<z>
else if (value instanceof Short) {<z>
));<z>
} else if (value instanceof Boolean) {<z>
1 : 0);<z>
else if (value instanceof Float) {<z>
);<z>
) {<z>
);<z>
) {<z>
Double) value).doubleValue());<z>
(value instanceof String) {<z>
) value);<z>
{<z>
;<z>
= type.getSort();<z>
== Type.OBJECT) {<z>
getInternalName());<z>
typeSort == Type.METHOD) {<z>
getDescriptor());<z>
else {<z>
type.getDescriptor());<z>
instanceof Handle) {<z>
handle = (Handle) value;<z>
(<z>
(),<z>
handle.getOwner(),<z>
.getName(),<z>
getDesc(),<z>
isInterface());<z>
} else if (value instanceof ConstantDynamic) {<z>
ConstantDynamic constantDynamic = (ConstantDynamic) value;<z>
addConstantDynamic(<z>
(),<z>
),<z>
.getBootstrapMethod(),<z>
constantDynamic.getBootstrapMethodArgumentsUnsafe());<z>
else {<z>
"value " + value);<z>
,<z>
Nullable ServletContext sc) {<z>
.SCOPE_REQUEST, new RequestScope());<z>
.SCOPE_SESSION, new SessionScope());<z>
null) {<z>
sc);<z>
registerScope(WebApplicationContext.SCOPE_APPLICATION, appScope);<z>
, appScope);<z>
, new RequestObjectFactory());<z>
ResponseObjectFactory());<z>
HttpSession.class, new SessionObjectFactory());<z>
());<z>
(jsfPresent) {<z>
beanFactory);<z>
Converter<?, ?> converter) {<z>
, Converter.class);<z>
&& converter instanceof DecoratingProxy) {<z>
);<z>
typeInfo == null) {<z>
("Unable to determine source type <S> and target type <T> for your " +<z>
() + "]; does the class parameterize those types?");<z>
;<z>
rbd, DependencyDescriptor descriptor) {<z>
.factoryMethodReturnType;<z>
== null) {<z>
Method factoryMethod = rbd.getResolvedFactoryMethod();<z>
if (factoryMethod != null) {<z>
);<z>
(returnType != null) {<z>
> resolvedClass = returnType.resolve();<z>
.isAssignableFrom(resolvedClass)) {<z>
return returnType;<z>
null;<z>
getPersistenceUnit(@Nullable String unitName) {<z>
.persistenceUnits != null) {<z>
null ? unitName : "");<z>
unitNameForLookup.isEmpty()) {<z>
this.defaultPersistenceUnitName;<z>
;<z>
{<z>
).next();<z>
!= null) {<z>
jndiName, EntityManagerFactory.class);<z>
{<z>
jndiName + "] from JNDI", ex);<z>
;<z>
request) {<z>
()<z>
, chunkPublisher) -> {<z>
chunkPublisher).map(this::toDataBuffer);<z>
(reactiveResponse, content));<z>
));<z>
(char ch) {<z>
this.sb == null) {<z>
this.sb = new StringBuilder();<z>
(ch);<z>
this;<z>
{<z>
);<z>
hasClasses()),<z>
.format("Cannot process locations AND classes for context configuration %s: " +<z>
);<z>
(configAttributes.hasLocations()) {<z>
delegateProcessing(getXmlLoader(), configAttributes);<z>
configAttributes.hasClasses()) {<z>
);<z>
delegateProcessing(getXmlLoader(), configAttributes);<z>
configAttributes.hasLocations();<z>
(xmlLoaderDetectedDefaults) {<z>
{<z>
logger.info(String.format("%s detected default locations for context configuration %s.",<z>
), configAttributes));<z>
(), () -> String.format(<z>
;<z>
, configAttributes);<z>
(configAttributes.hasClasses()) {<z>
.isInfoEnabled()) {<z>
("%s detected default configuration classes for context configuration %s.",<z>
;<z>
-> String.format(<z>
), configAttributes));<z>
() && configAttributes.hasClasses()) {<z>
msg = String.format(<z>
configAttributes);<z>
msg);<z>
(msg);<z>
Object> resolveArgument(<z>
MethodParameter parameter, BindingContext bindingContext, ServerWebExchange exchange) {<z>
parameter, bindingContext, exchange));<z>
throws IllegalStateException {<z>
.userTransaction != null) {<z>
)) {<z>
userTransaction);<z>
"No JTA UserTransaction available - specify either " +<z>
);<z>
this.transactionManager != null) {<z>
.isDebugEnabled()) {<z>
.debug("Using JTA TransactionManager: " + this.transactionManager);<z>
"No JTA TransactionManager found: transaction suspension not available");<z>
method, Class<?> targetClass) {<z>
getName().startsWith("set") &&<z>
== 1 &&<z>
) == Void.TYPE);<z>
int maxStack, final int maxLocals) {<z>
) {<z>
visitMaxs(maxStack, maxLocals);<z>
extends Annotation>> annotationTypes) {<z>
element).stream()<z>
))<z>
))<z>
));<z>
) throws Exception {<z>
{<z>
debug(String.format("Loading ApplicationContext for locations [%s].",<z>
;<z>
();<z>
prepareContext(context);<z>
(context.getDefaultListableBeanFactory());<z>
;<z>
.registerAnnotationConfigProcessors(context);<z>
context);<z>
.refresh();<z>
context.registerShutdownHook();<z>
context;<z>
() {<z>
StringBuilder result = new StringBuilder();<z>
).getSimpleName());<z>
.append('[');<z>
.append(this.methodDetails);<z>
;<z>
{<z>
new TestBean();<z>
tb.setName(this.factoryBeanProperty);<z>
FactoryMethods.newInstance(tb);<z>
(Type type, T message) {<z>
WebSocketSession session = this.delegateSession;<z>
;<z>
type)) {<z>
).getBytes(StandardCharsets.UTF_8);<z>
).wrap(bytes);<z>
, buffer);<z>
BINARY.equals(type)) {<z>
((ByteBuffer) message);<z>
(Type.BINARY, buffer);<z>
Type.PONG.equals(type)) {<z>
) message);<z>
PONG, buffer);<z>
("Unexpected message type: " + message);<z>
protected SimpMessageHeaderAccessor(SimpMessageType messageType,<z>
externalSourceHeaders) {<z>
;<z>
);<z>
setHeader(MESSAGE_TYPE_HEADER, messageType);<z>
this);<z>
] paramTypes) {<z>
getTypeDifferenceWeight(paramTypes, this.arguments);<z>
;<z>
);<z>
componentType) {<z>
(componentType);<z>
null) {<z>
= Array.newInstance(componentType, 0);<z>
return result;<z>
in) throws IOException {<z>
new CandidateComponentsMetadata();<z>
props = new Properties();<z>
props.load(in);<z>
value) -> {<z>
);<z>
candidates));<z>
);<z>
return result;<z>
) {<z>
{<z>
;<z>
(this.beanFactory instanceof ListableBeanFactory) {<z>
<String, SchedulingConfigurer> beans =<z>
;<z>
));<z>
);<z>
(SchedulingConfigurer configurer : configurers) {<z>
registrar);<z>
null) {<z>
null, "BeanFactory must be set to find scheduler by type");<z>
false));<z>
{<z>
{<z>
("Could not find unique TaskScheduler bean - attempting to resolve by name: " +<z>
getMessage());<z>
class, true));<z>
NoSuchBeanDefinitionException ex2) {<z>
if (logger.isInfoEnabled()) {<z>
.info("More than one TaskScheduler bean exists within the context, and " +<z>
.getBeanNamesFound());<z>
(NoSuchBeanDefinitionException ex) {<z>
)) {<z>
.trace("Could not find default TaskScheduler bean - attempting to find ScheduledExecutorService: " +<z>
.getMessage());<z>
ScheduledExecutorService.class, false));<z>
) {<z>
) {<z>
"Could not find unique ScheduledExecutorService bean - attempting to resolve by name: " +<z>
getMessage());<z>
, ScheduledExecutorService.class, true));<z>
{<z>
(logger.isInfoEnabled()) {<z>
.info("More than one ScheduledExecutorService bean exists within the context, and " +<z>
);<z>
NoSuchBeanDefinitionException ex2) {<z>
.isTraceEnabled()) {<z>
.trace("Could not find default ScheduledExecutorService bean - falling back to default: " +<z>
ex2.getMessage());<z>
logger.info("No TaskScheduler/ScheduledExecutorService bean found for scheduled processing");<z>
.afterPropertiesSet();<z>
{<z>
result -> {<z>
, name);<z>
getSecure());<z>
(ClientHttpRequest request, ClientHttpResponse response,<z>
timeout, @Nullable String uriTemplate,<z>
serverResult) {<z>
);<z>
, "ClientHttpResponse is required");<z>
.notNull(requestBody, "'requestBody' is required");<z>
"'responseBody' is required");<z>
= request;<z>
this.response = response;<z>
requestBody;<z>
responseBody = responseBody;<z>
= timeout;<z>
uriTemplate;<z>
;<z>
RuntimeBeanReference registerUrlPathHelper(<z>
, @Nullable Object source) {<z>
urlPathHelperRef != null) {<z>
).isAlias(URL_PATH_HELPER_BEAN_NAME)) {<z>
.getRegistry().removeAlias(URL_PATH_HELPER_BEAN_NAME);<z>
, URL_PATH_HELPER_BEAN_NAME);<z>
.isAlias(URL_PATH_HELPER_BEAN_NAME) &&<z>
{<z>
= new RootBeanDefinition(UrlPathHelper.class);<z>
setSource(source);<z>
;<z>
);<z>
;<z>
return new RuntimeBeanReference(URL_PATH_HELPER_BEAN_NAME);<z>
source) throws PatternSyntaxException {<z>
new Pattern[source.length];<z>
source.length; i++) {<z>
source[i]);<z>
;<z>
<?> message) {<z>
if (this.isRemoteClientSession) {<z>
.send(message);<z>
@Nullable Object value)<z>
{<z>
);<z>
, value);<z>
DefaultRenderingResponseBuilder(RenderingResponse other) {<z>
Assert.notNull(other, "RenderingResponse must not be null");<z>
.name();<z>
DefaultRenderingResponse ?<z>
().value());<z>
.headers());<z>
;<z>
multipartMode, @Nullable String encoding)<z>
throws MessagingException {<z>
this.mimeMessage = mimeMessage;<z>
createMimeMultiparts(mimeMessage, multipartMode);<z>
getDefaultEncoding(mimeMessage));<z>
;<z>
RequestPredicate predicate,<z>
>> routerFunctionSupplier) {<z>
Assert.notNull(routerFunctionSupplier, "RouterFunction Supplier must not be null");<z>
ServerResponse> nestedRoute = routerFunctionSupplier.get();<z>
predicate, nestedRoute));<z>
this;<z>
) {<z>
();<z>
.HttpServer.create()<z>
(getPort());<z>
() {<z>
public boolean matches(Annotation annotation) {<z>
true;<z>
<?> type) {<z>
true;<z>
public boolean matches(String typeName) {<z>
true;<z>
String toString() {<z>
return "All annotations filtered";<z>
Nullable PatternsRequestCondition patterns,<z>
methods, @Nullable ParamsRequestCondition params,<z>
consumes,<z>
RequestCondition<?> custom) {<z>
headers, consumes, produces, custom);<z>
(final int opcode, final int var) {<z>
;<z>
< 4 && opcode != Opcodes.RET) {<z>
optimizedOpcode;<z>
ISTORE) {<z>
) + var;<z>
{<z>
) + var;<z>
code.putByte(optimizedOpcode);<z>
(var >= 256) {<z>
, var);<z>
} else {<z>
code.put11(opcode, var);<z>
{<z>
COMPUTE_INSERTED_FRAMES) {<z>
, null);<z>
else {<z>
RET) {<z>
.flags |= Label.FLAG_SUBROUTINE_END;<z>
;<z>
);<z>
else {<z>
;<z>
if (size > maxRelativeStackSize) {<z>
size;<z>
relativeStackSize = size;<z>
if (compute != COMPUTE_NOTHING) {<z>
int currentMaxLocals;<z>
.LLOAD<z>
DLOAD<z>
== Opcodes.LSTORE<z>
.DSTORE) {<z>
var + 2;<z>
else {<z>
1;<z>
> maxLocals) {<z>
;<z>
&& firstHandler != null) {<z>
Label());<z>
JMException {<z>
= getObjectName(bean, beanKey);<z>
Object mbeanToExpose = null;<z>
)) {<z>
;<z>
;<z>
adaptedBean != null) {<z>
adaptedBean;<z>
) {<z>
)) {<z>
+ beanKey + "': registering with JMX server as MBean [" +<z>
"]");<z>
);<z>
.isDebugEnabled()) {<z>
+<z>
);<z>
createAndConfigureMBean(bean, beanKey);<z>
, objectName);<z>
(bean, mbean, objectName);<z>
;<z>
request, Class<T> targetClass,<z>
) {<z>
postProcessor);<z>
Connection con) {<z>
con.getMetaData();<z>
!= null) {<z>
{<z>
("JDBC driver supports batch updates");<z>
;<z>
.debug("JDBC driver does not support batch updates");<z>
{<z>
, ex);<z>
return false;<z>
throws ParseException {<z>
this.cronExpression, "Property 'cronExpression' is required");<z>
{<z>
;<z>
.group == null) {<z>
group = Scheduler.DEFAULT_GROUP;<z>
!= null) {<z>
.jobDetail);<z>
) {<z>
.currentTimeMillis() + this.startDelay);<z>
{<z>
);<z>
CronTriggerImpl cti = new CronTriggerImpl();<z>
toString());<z>
this.group);<z>
if (this.jobDetail != null) {<z>
);<z>
this.jobDataMap);<z>
.startTime);<z>
.cronExpression);<z>
);<z>
(this.calendarName);<z>
.setPriority(this.priority);<z>
);<z>
setDescription(this.description);<z>
cti;<z>
void initStrategies(ApplicationContext context) {<z>
(context);<z>
initLocaleResolver(context);<z>
context);<z>
context);<z>
initHandlerAdapters(context);<z>
context);<z>
context);<z>
initViewResolvers(context);<z>
initFlashMapManager(context);<z>
) {<z>
matchingContext.pathElementValue(pathIndex);<z>
(textToMatch);<z>
);<z>
(matches) {<z>
if (isNoMorePattern()) {<z>
&&<z>
0)) {<z>
+ 1;<z>
true;<z>
pathLength) &&<z>
|| textToMatch.length() > 0);<z>
)) {<z>
length() > 0) &&<z>
2 >= matchingContext.pathLength) &&<z>
);<z>
(pathIndex + 1, matchingContext));<z>
&& matchingContext.extractingVariables) {<z>
{<z>
new IllegalArgumentException("The number of capturing groups in the pattern segment " +<z>
+<z>
"Use non-capturing groups instead.");<z>
(); i++) {<z>
);<z>
group(i);<z>
,<z>
.size())?<z>
.parameters():<z>
);<z>
;<z>
name, Object value) throws SAXNotRecognizedException {<z>
)) {<z>
;<z>
throw new SAXNotRecognizedException(name);<z>
, Charset charset) {<z>
(charSequence, "CharSequence must not be null");<z>
(charset, "Charset must not be null");<z>
) {<z>
.writeUtf8(this.byteBuf, charSequence);<z>
) {<z>
(this.byteBuf, charSequence);<z>
charset);<z>
this;<z>
> matcher) {<z>
{<z>
getAttribute(name);<z>
"'", value, matcher);<z>
) {<z>
);<z>
attributes = attributes;<z>
;<z>
, DataBufferFactory bufferFactory) {<z>
Assert.notNull(delegate, "Native session is required.");<z>
, "Session id is required.");<z>
(info, "HandshakeInfo is required.");<z>
);<z>
= delegate;<z>
;<z>
;<z>
;<z>
;<z>
logPrefix = initLogPrefix(info, id);<z>
logger.isDebugEnabled()) {<z>
);<z>
path) {<z>
= getResourceLocation(path);<z>
;<z>
.getResource(resourceLocation);<z>
)) {<z>
return null;<z>
;<z>
) {<z>
if (logger.isDebugEnabled()) {<z>
debug("Could not open InputStream for resource " +<z>
), ex);<z>
;<z>
computeFieldInfoSize() {<z>
= 8;<z>
(constantValueIndex != 0) {<z>
);<z>
size += 8;<z>
accessFlags, signatureIndex);<z>
AnnotationWriter.computeAnnotationsSize(<z>
lastRuntimeInvisibleTypeAnnotation);<z>
if (firstAttribute != null) {<z>
size += firstAttribute.computeAttributesSize(symbolTable);<z>
return size;<z>
public ModelMap getModelMap() {<z>
model == null) {<z>
model = new ModelMap();<z>
this.model;<z>
> initFormData(ServerHttpRequest request,<z>
{<z>
;<z>
.isCompatibleWith(contentType)) {<z>
, String>>) readers.stream()<z>
.APPLICATION_FORM_URLENCODED))<z>
findFirst()<z>
new IllegalStateException("No form data HttpMessageReader.")))<z>
))<z>
EMPTY_FORM_DATA)<z>
;<z>
ex) {<z>
;<z>
{<z>
this == other) {<z>
return true;<z>
HierarchicalUriComponents otherComp)) {<z>
return false;<z>
) &&<z>
) &&<z>
) &&<z>
getPort() == otherComp.getPort() &&<z>
.equals(otherComp.path) &&<z>
(otherComp.queryParams) &&<z>
)));<z>
) {<z>
if (this.shutdownHook == null) {<z>
this.shutdownHook = new Thread(SHUTDOWN_HOOK_THREAD_NAME) {<z>
{<z>
synchronized (startupShutdownMonitor) {<z>
;<z>
().addShutdownHook(this.shutdownHook);<z>
UndertowWebSocketSession(WebSocketChannel channel, HandshakeInfo info,<z>
Sinks.Empty<Void> completionSink) {<z>
), info, factory, completionSink);<z>
suspendReceiving();<z>
> message) {<z>
destination, createMessageCreator(message));<z>
) {<z>
;<z>
boolean httpOnly) {<z>
{<z>
Cookie cookie = getCookie(result, name);<z>
httpOnly, cookie.isHttpOnly());<z>
public Object merge(@Nullable Object parent) {<z>
null) {<z>
return this;<z>
(parent instanceof MockHttpServletRequestBuilder) {<z>
merge(parent);<z>
parentBuilder) {<z>
parentBuilder.files);<z>
keySet().forEach(name -><z>
.parts.get(name)));<z>
;<z>
;<z>
boolean allowNullValues) {<z>
) {<z>
allowNullValues = allowNullValues;<z>
);<z>
String aspectName, @Nullable BeanDefinition[] beanDefinitions,<z>
beanReferences, @Nullable Object source) {<z>
source);<z>
;<z>
]);<z>
] getRequiredLongParameters(ServletRequest request, String name)<z>
throws ServletRequestBindingException {<z>
));<z>
Nullable String name) {<z>
null) {<z>
return null;<z>
.toUpperCase());<z>
ex) {<z>
LogFactory.getLog(AutowireMode.class);<z>
.isDebugEnabled()) {<z>
()));<z>
null;<z>
{<z>
!= null) {<z>
(null);<z>
HttpHeaders getResponseHeaders() {<z>
CollectionUtils.isEmpty(this.supportedMediaTypes)) {<z>
.EMPTY;<z>
= new HttpHeaders();<z>
.setAccept(this.supportedMediaTypes);<z>
;<z>
public final ConfigurablePropertyAccessor getPropertyAccessor() {<z>
null) {<z>
= createBeanWrapper();<z>
true);<z>
.beanWrapper.setAutoGrowNestedPaths(this.autoGrowNestedPaths);<z>
.setAutoGrowCollectionLimit(this.autoGrowCollectionLimit);<z>
beanWrapper;<z>
static ResolvableType forMethodParameter(<z>
nestingLevel) {<z>
getDeclaringClass());<z>
owner.asVariableResolver()).<z>
typeIndexesPerLevel);<z>
) {<z>
.APPLICATION_FORM_URLENCODED);<z>
;<z>
.add(MediaType.MULTIPART_MIXED);<z>
());<z>
partConverters.add(new StringHttpMessageConverter());<z>
());<z>
();<z>
message) {<z>
;<z>
message);<z>
.value()) : null);<z>
(mappingsByUrl != null) {<z>
, matches);<z>
(matches.isEmpty()) {<z>
.keySet();<z>
, message, matches);<z>
matches.isEmpty()) {<z>
destination, message);<z>
null;<z>
(message));<z>
(comparator);<z>
if (logger.isTraceEnabled()) {<z>
);<z>
> bestMatch = matches.get(0);<z>
.size() > 1) {<z>
);<z>
(bestMatch, secondBestMatch) == 0) {<z>
bestMatch.handlerMethod;<z>
m2 = secondBestMatch.handlerMethod;<z>
IllegalStateException("Ambiguous handler methods mapped for destination '" +<z>
+ "': {" +<z>
+ "}");<z>
return bestMatch;<z>
,<z>
sessionHandler) {<z>
notNull(url, "'url' must not be null");<z>
;<z>
WebSocketTcpConnectionHandlerAdapter(session);<z>
()<z>
new LoggingWebSocketHandlerDecorator(adapter), handshakeHeaders, url)<z>
);<z>
session.getSessionFuture();<z>
initViewResolvers(ApplicationContext context) {<z>
= null;<z>
if (this.detectAllViewResolvers) {<z>
Map<String, ViewResolver> matchingBeans =<z>
false);<z>
)) {<z>
values());<z>
viewResolvers);<z>
getBean(VIEW_RESOLVER_BEAN_NAME, ViewResolver.class);<z>
viewResolvers = Collections.singletonList(vr);<z>
) {<z>
this.viewResolvers == null) {<z>
getDefaultStrategies(context, ViewResolver.class);<z>
(logger.isTraceEnabled()) {<z>
("No ViewResolvers declared for servlet '" + getServletName() +<z>
"': using default strategies from DispatcherServlet.properties");<z>
Object> model, HttpServletRequest request,<z>
HttpServletResponse response) throws Exception {<z>
Object toBeMarshalled = locateToBeMarshalled(model);<z>
toBeMarshalled == null) {<z>
model);<z>
);<z>
ByteArrayOutputStream baos = new ByteArrayOutputStream(1024);<z>
(baos));<z>
(request, response);<z>
.size());<z>
);<z>
, @Nullable String requestingBeanName) {<z>
true);<z>
if (em == null) {<z>
= getPersistenceUnit(this.unitName);<z>
if (emf == null) {<z>
);<z>
.createContainerManagedEntityManager(<z>
properties, this.synchronizedWithTransaction);<z>
beanFactory != null && requestingBeanName != null &&<z>
&& !beanFactory.isPrototype(requestingBeanName)) {<z>
));<z>
;<z>
connection, Session session) {<z>
= connectionFactory;<z>
(connection);<z>
(session, connection);<z>
this.frozen = true;<z>
encodeContent(<z>
, MethodParameter returnType, DataBufferFactory bufferFactory,<z>
{<z>
= ResolvableType.forMethodParameter(returnType);<z>
, content);<z>
publisher;<z>
ResolvableType elementType;<z>
) {<z>
content);<z>
();<z>
(method) &&<z>
;<z>
);<z>
genericType);<z>
(content);<z>
class && content != null ?<z>
;<z>
.resolve() == Void.class) {<z>
cast(DataBuffer.class);<z>
elementType, mimeType);<z>
.from(publisher).map(value -><z>
hints));<z>
getRequiredStringParameters(ServletRequest request, String name)<z>
ServletRequestBindingException {<z>
(name));<z>
Method method, String beanKey) {<z>
).getManagedOperation(method);<z>
{<z>
;<z>
NamingException {<z>
;<z>
state(jndiName != null, "No JNDI name specified");<z>
jndiName, getExpectedType());<z>
<T> elementClass) {<z>
elementClass, "Class must not be null");<z>
this.responseMono.flatMapMany(response -><z>
)));<z>
Message message) throws JMSException, MessageConversionException {<z>
= extractHeaders(message);<z>
);<z>
?<z>
) convertedObject) :<z>
;<z>
build();<z>
getLocalHost() {<z>
();<z>
catch (UnknownHostException ex) {<z>
;<z>
setApplicationEventClass(Class<?> applicationEventClass) {<z>
== applicationEventClass ||<z>
)) {<z>
("'applicationEventClass' needs to extend ApplicationEvent");<z>
(Object.class);<z>
) {<z>
IllegalArgumentException("ApplicationEvent class [" +<z>
+ "] does not have the required Object constructor: " + ex);<z>
) {<z>
.getDeclaredMethod(MethodInterceptorGenerator.FIND_PROXY_NAME,<z>
.FIND_PROXY_TYPES);<z>
[]{sig});<z>
) {<z>
type + " does not use a MethodInterceptor");<z>
(IllegalAccessException | InvocationTargetException ex) {<z>
new CodeGenerationException(ex);<z>
) {<z>
super(attributes);<z>
idGenerator.generateId().toString();<z>
this.user = user;<z>
() {<z>
conversionService = new DefaultFormattingConversionService();<z>
(conversionService);<z>
;<z>
)<z>
{<z>
().getComponentType());<z>
array));<z>
(Object element : array) {<z>
null, element));<z>
;<z>
) {<z>
== other) {<z>
return true;<z>
) {<z>
return false;<z>
(InjectionPoint) other;<z>
.field, otherPoint.field) &&<z>
, otherPoint.methodParameter));<z>
void store(DataBuffer dataBuffer) {<z>
)];<z>
bytes);<z>
;<z>
{<z>
);<z>
);<z>
bundle, String key) {<z>
bundle.containsKey(key)) {<z>
return bundle.getString(key);<z>
(MissingResourceException ex) {<z>
null;<z>
{<z>
.cache instanceof LoadingCache) {<z>
(key);<z>
key);<z>
SimpleNamingContext(<z>
Nullable Hashtable<String, Object> env) {<z>
= root;<z>
= boundObjects;<z>
env != null) {<z>
(env);<z>
{<z>
] result = new int[2];<z>
)) {<z>
0] = min;<z>
;<z>
return result;<z>
"-")) {<z>
field);<z>
"-");<z>
length > 2) {<z>
"Range has more than two fields: '" +<z>
+ this.expression + "\"");<z>
0]);<z>
Integer.parseInt(split[1]);<z>
result[1] >= max) {<z>
+<z>
;<z>
result[1] < min) {<z>
throw new IllegalArgumentException("Range less than minimum (" + min + "): '" +<z>
"\"");<z>
> result[1]) {<z>
new IllegalArgumentException("Invalid inverted range: '" + field +<z>
+ this.expression + "\"");<z>
result;<z>
beanName, DependencyDescriptor descriptor)<z>
NoSuchBeanDefinitionException {<z>
, descriptor, getAutowireCandidateResolver());<z>
{<z>
.resultSet.getBigDecimal(columnIndex);<z>
catch (SQLException se) {<z>
;<z>
clazz, Class<?> genericIfc) {<z>
as(genericIfc);<z>
() || type.isEntirelyUnresolvable()) {<z>
null;<z>
.resolveGenerics(Object.class);<z>
response) throws IOException {<z>
();<z>
HttpStatus statusCode = HttpStatus.resolve(rawStatusCode);<z>
rawStatusCode));<z>
(ObjectMapper objectMapper) {<z>
MapperFeature.DEFAULT_VIEW_INCLUSION)) {<z>
(objectMapper, MapperFeature.DEFAULT_VIEW_INCLUSION, false);<z>
features.containsKey(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {<z>
false);<z>
{<z>
notNull(httpMethod, "'httpMethod' is required");<z>
);<z>
= httpMethod;<z>
;<z>
ServerWebExchange exchange) throws Exception {<z>
new ArrayList<>();<z>
this.mappingRegistry.getMappingsByDirectPath(exchange);<z>
null) {<z>
);<z>
.isEmpty()) {<z>
, matches, exchange);<z>
) {<z>
exchange));<z>
sort(comparator);<z>
get(0);<z>
1) {<z>
if (logger.isTraceEnabled()) {<z>
" matching mappings: " + matches);<z>
exchange.getRequest())) {<z>
for (Match match : matches) {<z>
.hasCorsConfig()) {<z>
PREFLIGHT_AMBIGUOUS_MATCH;<z>
);<z>
secondBestMatch) == 0) {<z>
getMethod();<z>
getHandlerMethod().getMethod();<z>
getPath();<z>
(<z>
+ ", " + m2 + "}");<z>
(), exchange);<z>
bestMatch.getHandlerMethod();<z>
;<z>
() throws SQLException {<z>
= this.threadBoundCredentials.get();<z>
?<z>
.username, threadCredentials.password) :<z>
password));<z>
null) {<z>
);<z>
(this.schema != null) {<z>
);<z>
con;<z>
(Publisher<?> inputStream, DataBufferFactory bufferFactory,<z>
hints) {<z>
instanceof Mono) {<z>
from(inputStream)<z>
)<z>
();<z>
List.class, elementType);<z>
)<z>
collectList()<z>
, hints))<z>
flux();<z>
(MissingPathVariableException ex,<z>
Nullable Object handler) throws IOException {<z>
getMessage());<z>
ModelAndView();<z>
getSingletonInstance() {<z>
this.singletonInstance == null) {<z>
= freshTargetSource();<z>
()) {<z>
;<z>
null) {<z>
("Cannot determine target class for proxy");<z>
getAllInterfacesForClass(targetClass, this.proxyClassLoader));<z>
;<z>
));<z>
.singletonInstance;<z>
<?>> converters,<z>
{<z>
super(converters, requestResponseBodyAdvice);<z>
));<z>
.contentNegotiationManager.getAllFileExtensions());<z>
SAFE_EXTENSIONS);<z>
, String name)<z>
ServletRequestBindingException {<z>
name, request.getParameterValues(name));<z>
ScriptException {<z>
Assert.notNull(connection, "Connection must not be null");<z>
: this.populators) {<z>
(connection);<z>
handlerMethod) {<z>
, "HandlerMethod is required");<z>
= handlerMethod.bean;<z>
.beanFactory;<z>
beanType = handlerMethod.beanType;<z>
;<z>
handlerMethod.bridgedMethod;<z>
handlerMethod.parameters;<z>
resolvedFromHandlerMethod = handlerMethod.resolvedFromHandlerMethod;<z>
T> type)<z>
BeansException {<z>
> beansOfType = beansOfTypeIncludingAncestors(lbf, type);<z>
, beansOfType);<z>
ConfigurableListableBeanFactory beanFactory) throws BeansException {<z>
if (this.customQualifierTypes != null) {<z>
) {<z>
IllegalStateException(<z>
;<z>
getAutowireCandidateResolver() instanceof QualifierAnnotationAutowireCandidateResolver)) {<z>
dlbf.setAutowireCandidateResolver(new QualifierAnnotationAutowireCandidateResolver());<z>
=<z>
dlbf.getAutowireCandidateResolver();<z>
.customQualifierTypes) {<z>
;<z>
instanceof Class) {<z>
<? extends Annotation>) value;<z>
instanceof String className) {<z>
className, this.beanClassLoader);<z>
(<z>
"Invalid value [" + value + "] for custom qualifier type: needs to be Class or String.");<z>
.class.isAssignableFrom(customType)) {<z>
IllegalArgumentException(<z>
;<z>
(customType);<z>
void afterPropertiesSet() {<z>
== null) {<z>
("Property 'targetDestinationResolver' is required");<z>
constantName) throws IllegalArgumentException {<z>
"CACHE_")) {<z>
);<z>
());<z>
{<z>
getResolvableType().hasGenerics()) {<z>
new GenericTypeDescriptor(targetType));<z>
return true;<z>
Integer findOrder(MergedAnnotations annotations) {<z>
;<z>
{<z>
MergedAnnotation.VALUE);<z>
> priorityAnnotation = annotations.get(JAVAX_PRIORITY_ANNOTATION);<z>
.isPresent()) {<z>
.getInt(MergedAnnotation.VALUE);<z>
return null;<z>
{<z>
() - 1;<z>
get(last);<z>
();<z>
;<z>
while (oldNamespaces.hasNext()) {<z>
next();<z>
;<z>
namespace);<z>
, newNamespaces.iterator());<z>
.eventWriter.add(namespace);<z>
last, newEndElement);<z>
HttpServletRequest request) {<z>
this.entityManagerFactory;<z>
if (emf == null) {<z>
;<z>
;<z>
emf;<z>
) {<z>
requestedPath)) {<z>
get(requestedPath);<z>
) : null);<z>
);<z>
) throws JspException {<z>
ArrayList<>();<z>
();<z>
;<z>
public boolean hasMessageBody() throws IOException {<z>
(getRawStatusCode());<z>
status == HttpStatus.NO_CONTENT ||<z>
NOT_MODIFIED)) {<z>
;<z>
() == 0) {<z>
return false;<z>
;<z>
) throws NoSuchMessageException {<z>
this.errorMessages == null) {<z>
null) {<z>
objectErrors.size()];<z>
objectErrors.size(); i++) {<z>
.get(i);<z>
getMessage(error, this.htmlEscape);<z>
[0];<z>
return this.errorMessages;<z>
MBeanServerNotFoundException {<z>
server = null;<z>
)) {<z>
servers = MBeanServerFactory.findMBeanServer(agentId);<z>
.isEmpty(servers)) {<z>
&& logger.isInfoEnabled()) {<z>
("Found more than one MBeanServer instance" +<z>
agentId + "]" : "") +<z>
);<z>
.get(0);<z>
) {<z>
ManagementFactory.getPlatformMBeanServer();<z>
(SecurityException ex) {<z>
MBeanServerNotFoundException("No specific MBeanServer found, " +<z>
ex);<z>
if (server == null) {<z>
new MBeanServerNotFoundException(<z>
" with agent id [" + agentId + "]" : ""));<z>
{<z>
("Found MBeanServer: " + server);<z>
return server;<z>
(DefaultServletHandlerConfigurer configurer) {<z>
delegate : this.delegates) {<z>
.configureDefaultServletHandling(configurer);<z>
private WebSocketService initWebSocketService() {<z>
;<z>
(service == null) {<z>
service = new HandshakeWebSocketService();<z>
ex) {<z>
NoUpgradeStrategyWebSocketService();<z>
return service;<z>
{<z>
);<z>
= session;<z>
this;<z>
public DelegatingErrorHandlingRunnable(Runnable delegate, ErrorHandler errorHandler) {<z>
notNull(delegate, "Delegate must not be null");<z>
"ErrorHandler must not be null");<z>
delegate = delegate;<z>
this.errorHandler = errorHandler;<z>
) {<z>
;<z>
setHeader(SimpMessageHeaderAccessor.IGNORE_ERROR, true);<z>
.setLeaveMutable(true);<z>
();<z>
());<z>
();<z>
<HttpMessageReader<?>> getCatchAllReaders() {<z>
{<z>
);<z>
new ArrayList<>();<z>
));<z>
return readers;<z>
(StompHeaders connectedHeaders) {<z>
getHeartbeat();<z>
);<z>
connected == null) {<z>
= this.connection;<z>
"No TcpConnection available");<z>
&& connected[1] > 0) {<z>
[0], connected[1]);<z>
onWriteInactivity(new WriteInactivityTask(), interval);<z>
&& connected[0] > 0) {<z>
[0]) * HEARTBEAT_MULTIPLIER;<z>
onReadInactivity(new ReadInactivityTask(), interval);<z>
@Nullable Class<?> viewClass) {<z>
) {<z>
name = viewClass.getName();<z>
+<z>
"]");<z>
viewClass = viewClass;<z>
(Element element) {<z>
instanceof TypeElement) {<z>
(element));<z>
, Object optionSource,<z>
String valueProperty, @Nullable String labelProperty) {<z>
);<z>
selectName;<z>
) throws IOException {<z>
String resourcePath = ResourceLoader.CLASSPATH_URL_PREFIX +<z>
convertClassNameToResourcePath(className) + ClassUtils.CLASS_FILE_SUFFIX;<z>
.resourceLoader.getResource(resourcePath);<z>
getMetadataReader(resource);<z>
{<z>
className.lastIndexOf('.');<z>
-1) {<z>
=<z>
;<z>
String innerClassResourcePath = ResourceLoader.CLASSPATH_URL_PREFIX +<z>
convertClassNameToResourcePath(innerClassName) + ClassUtils.CLASS_FILE_SUFFIX;<z>
innerClassResourcePath);<z>
(innerClassResource.exists()) {<z>
return getMetadataReader(innerClassResource);<z>
throw ex;<z>
size, String arraytype) {<z>
);<z>
) {<z>
.arrayCodeFor(arraytype));<z>
(0) == '[') {<z>
if (CodeFlow.isReferenceTypeArray(arraytype)) {<z>
visitTypeInsn(ANEWARRAY, arraytype + ";");<z>
mv.visitTypeInsn(ANEWARRAY, arraytype);<z>
ANEWARRAY, arraytype.substring(1));<z>
public int compareTo(CacheOperationCacheKey other) {<z>
cacheOperation.getName());<z>
) {<z>
other.methodCacheKey);<z>
return result;<z>
) {<z>
Assert.hasText(login, "systemLogin must not be empty");<z>
this.systemLogin = login;<z>
this;<z>
exchange) {<z>
TimeZoneAwareLocaleContext() {<z>
) {<z>
return locale;<z>
) {<z>
return timeZone;<z>
) {<z>
!= null) {<z>
);<z>
.getTargetClass();<z>
(Object target, @Nullable String requestingBeanName) {<z>
beanName)) {<z>
(this.beanName)) {<z>
.lookupType);<z>
configurableBeanFactory) {<z>
);<z>
;<z>
.mappedName)) {<z>
new NoSuchBeanDefinitionException(this.beanName,<z>
"Cannot resolve 'beanName' in local BeanFactory. Consider specifying a general 'name' value instead.");<z>
getResource(this, requestingBeanName);<z>
static MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy,<z>
) {<z>
AnnotationsScanner.isKnownEmpty(element, searchStrategy)) {<z>
;<z>
, repeatableContainers, annotationFilter);<z>
methodParamValue) {<z>
(Locale.ENGLISH));<z>
(ALLOWED_METHODS.contains(httpMethod)) {<z>
.build();<z>
exchange;<z>
chain) {<z>
null && chain != null),<z>
"Both resolver and resolver chain must be null, or neither is");<z>
resolver;<z>
chain;<z>
) {<z>
);<z>
()) {<z>
case OPEN:<z>
;<z>
:<z>
.isTraceEnabled()) {<z>
this);<z>
MESSAGE:<z>
);<z>
:<z>
);<z>
protected void refreshApplicationContext(ApplicationContext context) {<z>
!cac.isActive()) {<z>
.refresh();<z>
throws Throwable {<z>
if (this.timeout == 0) {<z>
evaluate();<z>
.currentTimeMillis();<z>
evaluate();<z>
currentTimeMillis() - startTime;<z>
timeout) {<z>
throw new TimeoutException(<z>
));<z>
boolean visible) {<z>
(visible) {<z>
visibleAnnotableParameterCount = parameterCount;<z>
else {<z>
parameterCount;<z>
publishEvent(@Nullable Object event) {<z>
!= null) {<z>
.applicationContext, "ApplicationContext must not be null");<z>
);<z>
final int maxStringLength) {<z>
[] charBuffer = new char[maxStringLength];<z>
getFirstAttributeOffset();<z>
; --i) {<z>
);<z>
attributeLength = readInt(currentAttributeOffset + 2);<z>
;<z>
.equals(attributeName)) {<z>
)];<z>
;<z>
; ++j) {<z>
] = currentBootstrapMethodOffset;<z>
* 2;<z>
;<z>
attributeLength;<z>
);<z>
setIdleTaskExecutionLimit(int idleTaskExecutionLimit) {<z>
> 0, "'idleTaskExecutionLimit' must be 1 or higher");<z>
) {<z>
= idleTaskExecutionLimit;<z>
(<z>
final int tag,<z>
,<z>
name,<z>
,<z>
final boolean isInterface) {<z>
tag = tag;<z>
= owner;<z>
= name;<z>
.descriptor = descriptor;<z>
this.isInterface = isInterface;<z>
args) throws Throwable {<z>
ReflectionUtils.isEqualsMethod(method)) {<z>
proxy == args[0]);<z>
isHashCodeMethod(method)) {<z>
return System.identityHashCode(proxy);<z>
method)) {<z>
+<z>
());<z>
invoke(getSingletonInstance(), args);<z>
InvocationTargetException ex) {<z>
;<z>
<? extends Annotation> annotationType) {<z>
) {<z>
return (MergedAnnotation<?>) value;<z>
get(0);<z>
>(<z>
.aggregateIndex);<z>
mapper) {<z>
;<z>
(provider, "No ConnectionProvider: is ReactorResourceFactory not initialized yet?");<z>
andThen(applyLoopResources(factory))<z>
create(provider));<z>
JettyServerHttpResponse(HttpServletResponse response, AsyncContext asyncContext,<z>
bufferFactory, int bufferSize, ServletServerHttpRequest request)<z>
IOException {<z>
asyncContext, bufferFactory, bufferSize, request);<z>
invocation)<z>
, IOException {<z>
null, "No MBeanServerConnection available");<z>
);<z>
(attributeName);<z>
{<z>
throw new InvalidInvocationException(<z>
;<z>
{<z>
.isReadable()) {<z>
.objectName, attributeName);<z>
"' is not readable");<z>
)) {<z>
.isWritable()) {<z>
[0]));<z>
null;<z>
("Attribute '" + attributeName + "' is not writable");<z>
(<z>
() + "] is neither a bean property getter nor a setter");<z>
SymbolTable symbolTable,<z>
,<z>
final String name,<z>
,<z>
final String signature,<z>
final Object constantValue) {<z>
.ASM9);<z>
this.symbolTable = symbolTable;<z>
this.accessFlags = access;<z>
symbolTable.addConstantUtf8(name);<z>
addConstantUtf8(descriptor);<z>
if (signature != null) {<z>
symbolTable.addConstantUtf8(signature);<z>
constantValue != null) {<z>
index;<z>
Throwable {<z>
.preparationMonitor) {<z>
isPrepared()) {<z>
);<z>
return doInvoke(invocation);<z>
IOException ex) {<z>
return handleConnectFailure(invocation, ex);<z>
String... headers) {<z>
Set<HeaderExpression> result = null;<z>
!ObjectUtils.isEmpty(headers)) {<z>
for (String header : headers) {<z>
HeaderExpression expr = new HeaderExpression(header);<z>
(expr.name)) {<z>
.length));<z>
;<z>
));<z>
{<z>
DefaultFormattingConversionService();<z>
(service);<z>
return service;<z>
) {<z>
);<z>
);<z>
autowiredAnnotationTypes.addAll(autowiredAnnotationTypes);<z>
static EntityManager createSharedEntityManager(<z>
<?>... entityManagerInterfaces) {<z>
;<z>
handler) {<z>
connectHeaders, handler);<z>
session);<z>
.getSessionFuture();<z>
basename, Locale locale) {<z>
new ArrayList<>(3);<z>
();<z>
country = locale.getCountry();<z>
= locale.getVariant();<z>
StringBuilder temp = new StringBuilder(basename);<z>
('_');<z>
0) {<z>
language);<z>
(0, temp.toString());<z>
('_');<z>
() > 0) {<z>
temp.append(country);<z>
temp.toString());<z>
country.length() > 0)) {<z>
variant);<z>
temp.toString());<z>
result;<z>
) {<z>
).isCompilable()) {<z>
return false;<z>
(this.children.length > 1) {<z>
)) {<z>
false;<z>
return (this.exitTypeDescriptor != null);<z>
Resource resource) {<z>
resource.getURI().toString();<z>
{<z>
;<z>
() {<z>
;<z>
.defaultCharacterEncoding;<z>
false;<z>
;<z>
this.contentType = null;<z>
.locale = Locale.getDefault();<z>
.cookies.clear();<z>
clear();<z>
this.status = HttpServletResponse.SC_OK;<z>
this.errorMessage = null;<z>
?> valueType) {<z>
getPropertyEditorRegistry();<z>
{<z>
= valueType;<z>
) {<z>
valueTypeToUse = getFieldType(field);<z>
(valueTypeToUse, fixedField(field));<z>
;<z>
boolean exposeModelAttributes) {<z>
super(url);<z>
;<z>
.http10Compatible = http10Compatible;<z>
.exposeModelAttributes = exposeModelAttributes;<z>
false);<z>
AbstractBeanFactoryBasedTargetSource createBeanFactoryBasedTargetSource(<z>
beanClass, String beanName) {<z>
.startsWith(PREFIX_COMMONS_POOL)) {<z>
new CommonsPool2TargetSource();<z>
(25);<z>
return cpts;<z>
.startsWith(PREFIX_THREAD_LOCAL)) {<z>
new ThreadLocalTargetSource();<z>
if (beanName.startsWith(PREFIX_PROTOTYPE)) {<z>
;<z>
return null;<z>
autowiredValue) {<z>
notNull(dependencyType, "Dependency type must not be null");<z>
) {<z>
autowiredValue))) {<z>
("Value [" + autowiredValue +<z>
);<z>
.put(dependencyType, autowiredValue);<z>
public Object resolveArgumentValue(<z>
, BindingContext context, ServerWebExchange exchange) {<z>
);<z>
.class.isAssignableFrom(type)) {<z>
return context.getModel();<z>
) {<z>
context.getModel().asMap();<z>
new IllegalStateException("Unexpected method parameter type: " + type);<z>
{<z>
(this);<z>
(4));<z>
);<z>
;<z>
{<z>
notNull(task, "Runnable must not be null");<z>
.decorate(task) : task);<z>
) {<z>
);<z>
(taskToUse));<z>
;<z>
() {<z>
interceptorNames)) {<z>
1];<z>
&& this.targetSource == EMPTY_TARGET_SOURCE) {<z>
)) {<z>
.targetName = finalName;<z>
{<z>
("Bean with name '" + finalName + "' concluding interceptor chain " +<z>
);<z>
.interceptorNames.length - 1);<z>
{<z>
.encoder = new ResourceEncoder(bufferSize);<z>
(bufferSize);<z>
());<z>
) throws ClassNotFoundException, NoSuchFieldException {<z>
!= null && this.targetObject != null) {<z>
new IllegalArgumentException("Specify either targetClass or targetObject, not both");<z>
null) {<z>
this.targetField != null) {<z>
new IllegalArgumentException(<z>
);<z>
(this.staticField == null) {<z>
;<z>
.staticField != null, "No target field specified");<z>
);<z>
== this.staticField.length()) {<z>
(<z>
"e.g. 'example.MyExampleClass.MY_EXAMPLE_FIELD'");<z>
staticField.substring(0, lastDotIndex);<z>
substring(lastDotIndex + 1);<z>
(className, this.beanClassLoader);<z>
fieldName;<z>
(this.targetField == null) {<z>
"targetField is required");<z>
getClass() : this.targetClass);<z>
= targetClass.getField(this.targetField);<z>
?> model) {<z>
.view = view;<z>
(model != null) {<z>
);<z>
extends ByteBuf> inputStream,<z>
ResolvableType elementType, @Nullable MimeType mimeType,<z>
Object> hints) {<z>
inputStream).map(byteBuffer -><z>
, mimeType, hints));<z>
,<z>
, @Nullable String body) {<z>
method);<z>
httpRequest, headers);<z>
(body != null) {<z>
(new StringRequestContent(body));<z>
ContentResponse response;<z>
.send();<z>
{<z>
("Failed to execute request to " + url, ex);<z>
(response.getStatus());<z>
getHeaders());<z>
(response.getContent() != null ?<z>
responseHeaders, status) :<z>
<>(responseHeaders, status));<z>
() throws SAXException {<z>
getLexicalHandler() != null) {<z>
(this.reader.getLocalName());<z>
getLexicalHandler() != null) {<z>
getLocalName());<z>
loadTemplates() throws ApplicationContextException {<z>
();<z>
;<z>
templates;<z>
(TransformerConfigurationException ex) {<z>
() + "'", ex);<z>
(stylesheetSource);<z>
public T convert(String source) {<z>
.isEmpty()) {<z>
return null;<z>
source, this.targetType);<z>
state) throws EvaluationException {<z>
) {<z>
);<z>
.children[0];<z>
);<z>
getChildCount();<z>
++) {<z>
);<z>
nextNode = this.children[i];<z>
);<z>
popActiveContextObject();<z>
);<z>
this.children[cc - 1];<z>
state);<z>
);<z>
(SpelEvaluationException ex) {<z>
(nextNode.getStartPosition());<z>
throw ex;<z>
Builder mergeFrom(<z>
.protobuf.CodedInputStream input,<z>
.google.protobuf.ExtensionRegistryLite extensionRegistry)<z>
java.io.IOException {<z>
null;<z>
= PARSER.parsePartialFrom(input, extensionRegistry);<z>
.google.protobuf.InvalidProtocolBufferException e) {<z>
);<z>
e;<z>
finally {<z>
(parsedMessage != null) {<z>
parsedMessage);<z>
;<z>
getDefaultFileTypeMap(MimeMessage mimeMessage) {<z>
mimeMessage instanceof SmartMimeMessage smartMimeMessage) {<z>
;<z>
!= null) {<z>
return fileTypeMap;<z>
;<z>
.afterPropertiesSet();<z>
fileTypeMap;<z>
(<z>
> fixedInterceptorMap, int fixedInterceptorOffset) {<z>
advised;<z>
.fixedInterceptorMap = fixedInterceptorMap;<z>
.fixedInterceptorOffset = fixedInterceptorOffset;<z>
) {<z>
();<z>
sessionHolder.getPreviousFlushMode() != null) {<z>
getPreviousFlushMode());<z>
.disconnect();<z>
newSession) {<z>
TransactionSynchronizationManager.unbindResource(this.sessionFactory);<z>
;<z>
{<z>
inserts));<z>
= message;<z>
inserts;<z>
(AnnotatedElement element,<z>
Annotation> containerType) {<z>
(element, containerType, annotationType)<z>
stream(annotationType)<z>
(highAggregateIndexesFirst())<z>
.toAnnotationSet());<z>
, @Nullable Class<?> requiredType,<z>
Nullable Throwable cause) {<z>
,<z>
+ "'" +<z>
!= null ?<z>
"'" : "") +<z>
!= null ?<z>
),<z>
);<z>
.propertyName = propertyChangeEvent.getPropertyName();<z>
value = propertyChangeEvent.getNewValue();<z>
this.requiredType = requiredType;<z>
Map<String, String> toSingleValueMap() {<z>
this.headers.size());<z>
);<z>
{<z>
.getName())) {<z>
);<z>
;<z>
return singleValueMap;<z>
resultType) {<z>
(1);<z>
);<z>
;<z>
types);<z>
resultType);<z>
getCorsHandlerExecutionChain(HttpServletRequest request,<z>
HandlerExecutionChain chain, @Nullable CorsConfiguration config) {<z>
) {<z>
);<z>
config), interceptors);<z>
));<z>
chain;<z>
) {<z>
this == other) {<z>
return true;<z>
))) {<z>
return false;<z>
ObjectUtils.nullSafeEquals(<z>
((OriginPattern) other).declaredPattern);<z>
Object handler,<z>
Nullable ModelAndView modelAndView) throws Exception {<z>
new DispatcherServletWebRequest(request, response),<z>
() : null));<z>
{<z>
null) {<z>
throw new IllegalStateException("Must set property 'expression' before attempting to match");<z>
== null) {<z>
();<z>
.pointcutExpression = buildPointcutExpression(this.pointcutClassLoader);<z>
this.pointcutExpression;<z>
) throws SQLException {<z>
.getConnection().createSQLXML();<z>
.xmlObject);<z>
catch (IOException ex) {<z>
("Failure encountered while providing XML", ex);<z>
this.xmlObject);<z>
NoSuchBeanDefinitionException {<z>
remove(beanName) == null) {<z>
throw new NoSuchBeanDefinitionException(beanName);<z>
) {<z>
== obj) {<z>
;<z>
Set<?> other) {<z>
== this.delegate.size() &&<z>
;<z>
false;<z>
void onTimeout(AsyncEvent event) {<z>
Throwable ex = event.getThrowable();<z>
);<z>
(ex);<z>
expression) {<z>
;<z>
i = i + 2) {<z>
(expression)) {<z>
1];<z>
;<z>
] values) throws ServletRequestBindingException {<z>
, values);<z>
new boolean[values.length];<z>
) {<z>
]);<z>
;<z>
?> handlerType) {<z>
class);<z>
if (ann != null) {<z>
.attributeNames, ann.names());<z>
types());<z>
.knownAttributeNames.addAll(this.attributeNames);<z>
private void changeStateToComplete(State oldState) {<z>
(oldState, State.COMPLETED)) {<z>
();<z>
;<z>
;<z>
.get().onComplete(this);<z>
) {<z>
.pathMatchConfigurer == null) {<z>
;<z>
;<z>
this.pathMatchConfigurer;<z>
{<z>
super(initialCapacity);<z>
this.annotationType = null;<z>
.displayName = UNKNOWN;<z>
> targetClass, Method method) {<z>
method);<z>
TransactionalEventListener ann =<z>
method, TransactionalEventListener.class);<z>
{<z>
throw new IllegalStateException("No TransactionalEventListener annotation found on method: " + method);<z>
ann;<z>
phase();<z>
(InputStream in, OutputStream out) throws IOException {<z>
(in, "No InputStream specified");<z>
out, "No OutputStream specified");<z>
;<z>
] buffer = new byte[BUFFER_SIZE];<z>
;<z>
{<z>
write(buffer, 0, bytesRead);<z>
;<z>
out.flush();<z>
return byteCount;<z>
void startDeferredResultProcessing(<z>
processingContext) throws Exception {<z>
;<z>
"AsyncWebRequest must not be null");<z>
Long timeout = deferredResult.getTimeoutValue();<z>
{<z>
);<z>
);<z>
add(deferredResult.getInterceptor());<z>
this.deferredResultInterceptors.values());<z>
(timeoutDeferredResultInterceptor);<z>
;<z>
this.asyncWebRequest.addTimeoutHandler(() -> {<z>
this.asyncWebRequest, deferredResult);<z>
{<z>
(ex);<z>
);<z>
.asyncWebRequest.addErrorHandler(ex -> {<z>
if (!this.errorHandlingInProgress) {<z>
, ex)) {<z>
.setErrorResult(ex);<z>
catch (Throwable interceptorEx) {<z>
interceptorEx);<z>
;<z>
.asyncWebRequest.addCompletionHandler(()<z>
.asyncWebRequest, deferredResult));<z>
;<z>
processingContext);<z>
, deferredResult);<z>
.setResultHandler(result -> {<z>
result);<z>
(result);<z>
);<z>
{<z>
ex);<z>
) throws SQLException {<z>
) {<z>
= con.getAutoCommit();<z>
this.defaultTransactionIsolation == null) {<z>
this.defaultTransactionIsolation = con.getTransactionIsolation();<z>
private boolean refreshCheckDelayElapsed() {<z>
.refreshCheckDelay < 0) {<z>
;<z>
System.currentTimeMillis();<z>
.lastRefreshCheck > this.refreshCheckDelay) {<z>
;<z>
;<z>
return true;<z>
return false;<z>
void onNext(AbstractListenerWriteFlushProcessor<T> processor,<z>
extends T> currentPublisher) {<z>
, RECEIVED)) {<z>
);<z>
= (AbstractListenerWriteProcessor<?>) writeProcessor;<z>
);<z>
subscribe(new WriteResultSubscriber(processor));<z>
void setupDomain(AnnotationMBeanExporter exporter, AnnotationAttributes enableMBeanExport) {<z>
"defaultDomain");<z>
.environment != null) {<z>
defaultDomain);<z>
.hasText(defaultDomain)) {<z>
);<z>
private void updateAcceptLanguageHeader() {<z>
new HttpHeaders();<z>
(this.locales);<z>
true);<z>
) {<z>
{<z>
, values) -> {<z>
String value : values) {<z>
.add(key, value);<z>
});<z>
;<z>
ResourceLoader resourceLoader,<z>
) {<z>
if (resourceLoader != null) {<z>
getClassLoader();<z>
if (classLoader != null) {<z>
return classLoader;<z>
if (beanFactory != null) {<z>
getBeanClassLoader();<z>
return ClassUtils.getDefaultClassLoader();<z>
dataBufferFactory, ByteBuffer byteBuffer) {<z>
DefaultDataBuffer(dataBufferFactory, byteBuffer);<z>
);<z>
return dataBuffer;<z>
Object transaction)<z>
{<z>
defer(() -> {<z>
= (ConnectionFactoryTransactionObject) transaction;<z>
txObject.setConnectionHolder(null);<z>
(obtainConnectionFactory()));<z>
});<z>
, Type> typeVariableMap) {<z>
) {<z>
.resolve();<z>
{<z>
();<z>
{<z>
.getGeneric(i);<z>
<?>) {<z>
);<z>
!= ResolvableType.NONE) {<z>
getType());<z>
);<z>
.getInterfaces()) {<z>
typeVariableMap);<z>
()) {<z>
typeVariableMap);<z>
(Resource rootDirResource, String subPattern)<z>
{<z>
;<z>
getFile().getAbsoluteFile();<z>
(FileNotFoundException ex) {<z>
(logger.isDebugEnabled()) {<z>
("Cannot search for matching files underneath " + rootDirResource +<z>
" in the file system: " + ex.getMessage());<z>
;<z>
{<z>
) {<z>
ex);<z>
return Collections.emptySet();<z>
;<z>
(@Nullable List<T> list) {<z>
isEmpty(list)) {<z>
;<z>
) - 1);<z>
message, String defaultPrefix) {<z>
(annotation != null) {<z>
(annotation);<z>
!ObjectUtils.isEmpty(value)) {<z>
;<z>
name = DestinationPatternsMessageCondition.LOOKUP_DESTINATION_HEADER;<z>
;<z>
) {<z>
throw new IllegalStateException("No lookup destination header in " + message);<z>
return (destination.startsWith("/") ?<z>
});<z>
<DataBuffer> encodedData) {<z>
.metadataEncoder.encode())<z>
, tuple.getT2()))<z>
)<z>
Payload::release);<z>
, Object> attributes) {<z>
if (attributes != null) {<z>
attributes);<z>
> valuePredicate) {<z>
);<z>
notNull(valuePredicate, "Predicate must not be null");<z>
;<z>
this.valuePredicate = valuePredicate;<z>
= null;<z>
HandlerMethod handlerMethod) {<z>
handlerMethod);<z>
);<z>
;<z>
handlerMethod,<z>
) {<z>
exchange);<z>
).getPath().pathWithinApplication();<z>
bestPattern;<z>
String> uriVariables;<z>
<String, String>> matrixVariables;<z>
;<z>
if (patterns.isEmpty()) {<z>
.value());<z>
uriVariables = Collections.emptyMap();<z>
);<z>
iterator().next();<z>
PathMatchInfo result = bestPattern.matchAndExtract(lookupPath);<z>
.notNull(result, () -><z>
);<z>
();<z>
result.getMatrixVariables();<z>
handlerMethod);<z>
(BEST_MATCHING_PATTERN_ATTRIBUTE, bestPattern);<z>
, uriVariables);<z>
);<z>
getProducibleMediaTypes().isEmpty()) {<z>
.getProducibleMediaTypes();<z>
PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, mediaTypes);<z>
) {<z>
message.getBody())<z>
s -> {<z>
false, true)) {<z>
;<z>
dataBufferFactory::wrap);<z>
createContextCustomizer(Class<?> testClass,<z>
configAttributes) {<z>
= new LinkedHashSet<>();<z>
, methods);<z>
) {<z>
null;<z>
new DynamicPropertiesContextCustomizer(methods);<z>
> result) {<z>
, ExceptionHandler.class);<z>
);<z>
;<z>
) {<z>
) {<z>
1; i >= 0; i--) {<z>
i) instanceof PathResourceResolver pathResolver) {<z>
pathResolver.getAllowedLocations())) {<z>
[0]));<z>
.urlPathHelper != null) {<z>
locationCharsets);<z>
);<z>
name, String value) {<z>
;<z>
, "'value' must not be null");<z>
name, value);<z>
Mono<Void> delete() {<z>
{<z>
Files.delete(this.file);<z>
;<z>
});<z>
{<z>
(DEFAULT_LAZY_INIT_ATTRIBUTE);<z>
(lazyInit)) {<z>
parentDefaults.getLazyInit() : FALSE_VALUE);<z>
);<z>
String merge = root.getAttribute(DEFAULT_MERGE_ATTRIBUTE);<z>
(merge)) {<z>
? parentDefaults.getMerge() : FALSE_VALUE);<z>
merge);<z>
(DEFAULT_AUTOWIRE_ATTRIBUTE);<z>
{<z>
() : AUTOWIRE_NO_VALUE);<z>
defaults.setAutowire(autowire);<z>
.hasAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE)) {<z>
setAutowireCandidates(root.getAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE));<z>
null) {<z>
));<z>
hasAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE)) {<z>
getAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE));<z>
null) {<z>
.getInitMethod());<z>
(root.hasAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE)) {<z>
getAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE));<z>
if (parentDefaults != null) {<z>
.getDestroyMethod());<z>
));<z>
path, int pos, String separator) {<z>
0;<z>
separator, pos + skipped)) {<z>
length();<z>
;<z>
offset) {<z>
);<z>
();<z>
return temporal -> {<z>
, ChronoUnit.DAYS);<z>
return rollbackToMidnight(temporal, result);<z>
) {<z>
(this == other) {<z>
;<z>
!(other instanceof ContextConfigurationAttributes otherAttr)) {<z>
false;<z>
declaringClass, otherAttr.declaringClass) &&<z>
.classes, otherAttr.classes)) &&<z>
.locations) &&<z>
otherAttr.inheritLocations &&<z>
initializers, otherAttr.initializers) &&<z>
&&<z>
otherAttr.name) &&<z>
.contextLoaderClass, otherAttr.contextLoaderClass);<z>
public final void onError(Throwable ex) {<z>
.state == State.READY_TO_WRITE) {<z>
onError(ex);<z>
(this) {<z>
{<z>
().onError(ex);<z>
== State.NEW) {<z>
;<z>
(ex);<z>
this.error = ex;<z>
protected void populateAttributeDescriptor(<z>
{<z>
(desc);<z>
> targetType) {<z>
{<z>
method;<z>
.getName();<z>
parameterTypes = method.getParameterTypes();<z>
getInterfaces()) {<z>
parameterTypes);<z>
catch (NoSuchMethodException ex) {<z>
targetType.getMethod(methodName, parameterTypes);<z>
) {<z>
.format(<z>
).getSimpleName()));<z>
<ConvertiblePair> createConvertibleTypes() {<z>
convertiblePairs = new HashSet<>();<z>
.class, Collection.class));<z>
.class));<z>
);<z>
class));<z>
convertiblePairs;<z>
{<z>
events.stream()<z>
.map(this::unwrapPayloadEvent)<z>
)<z>
type::cast);<z>
Nullable ModelAndViewContainer mavContainer,<z>
throws Exception {<z>
resolver = getArgumentResolver(parameter);<z>
if (resolver == null) {<z>
+<z>
);<z>
, webRequest, binderFactory);<z>
@Nullable List<RequestBodyAdvice> requestBodyAdvice) {<z>
) {<z>
requestResponseBodyAdvice.addAll(requestBodyAdvice);<z>
Temporal result) {<z>
get(ChronoField.DAY_OF_MONTH)) {<z>
;<z>
(result);<z>
, Message request, @Nullable Session session) {<z>
null) {<z>
)) {<z>
result +<z>
"] - generating response message for it");<z>
, result);<z>
(request, response);<z>
result);<z>
;<z>
Exception ex) {<z>
("Failed to send reply with payload [" + result + "]", ex);<z>
logger.isWarnEnabled()) {<z>
.warn("Listener method returned result [" + result +<z>
;<z>
{<z>
SESSION_TRANSACTED && bw.isWritableProperty("useRAManagedTransaction")) {<z>
("useRAManagedTransaction", "true");<z>
, ackMode);<z>
static SimpAttributes currentAttributes() throws IllegalStateException {<z>
getAttributes();<z>
attributes == null) {<z>
"No thread-bound SimpAttributes found. " +<z>
);<z>
;<z>
) throws IOException {<z>
;<z>
)) {<z>
super.readFromInputStream();<z>
;<z>
= this.bufferSize;<z>
;<z>
(0, capacity);<z>
int read = coyoteInputStream.read(byteBuffer);<z>
;<z>
(read > 0) {<z>
;<z>
release = false;<z>
;<z>
{<z>
;<z>
null;<z>
{<z>
(dataBuffer);<z>
public OkHttp3ClientHttpRequestFactory(OkHttpClient client) {<z>
client, "OkHttpClient must not be null");<z>
client = client;<z>
= false;<z>
{<z>
(this.registrations.isEmpty()) {<z>
;<z>
urlMap = new LinkedHashMap<>();<z>
: this.registrations) {<z>
ResourceWebHandler handler = getRequestHandler(registration);<z>
registration.getPathPatterns()) {<z>
, handler);<z>
order);<z>
viewName, Locale locale) throws Exception {<z>
(viewName, locale)) {<z>
return null;<z>
{<z>
));<z>
view = new RedirectView(redirectUrl,<z>
(), isRedirectHttp10Compatible());<z>
;<z>
(hosts != null) {<z>
setHosts(hosts);<z>
view);<z>
{<z>
());<z>
(forwardUrl);<z>
applyLifecycleMethods(FORWARD_URL_PREFIX, view);<z>
, locale);<z>
getValue() {<z>
);<z>
collection instanceof List list) {<z>
.get(this.index);<z>
.class);<z>
);<z>
pos = 0;<z>
this.collection) {<z>
{<z>
));<z>
++;<z>
collection);<z>
> inputStream, ResolvableType elementType,<z>
String, Object> hints) {<z>
.error(new UnsupportedOperationException());<z>
,<z>
Object source, Annotation[] annotations) {<z>
: annotations) {<z>
(annotation != null) {<z>
> type = annotation.annotationType();<z>
.matches(type)) {<z>
)) {<z>
;<z>
=<z>
;<z>
if (repeatedAnnotations != null) {<z>
= doWithAnnotations(<z>
;<z>
{<z>
;<z>
{<z>
AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(type);<z>
size(); i++) {<z>
(i);<z>
{<z>
TRUE;<z>
;<z>
(MockHttpServletRequest request, String requestUri) {<z>
(this.contextPath)) {<z>
throw new IllegalArgumentException(<z>
this.contextPath + "]");<z>
.contextPath);<z>
servletPath);<z>
this.pathInfo)) {<z>
)) {<z>
new IllegalArgumentException(<z>
"]");<z>
servletPath.length());<z>
hasText(extraPath) ?<z>
(request, extraPath) : null);<z>
setPathInfo(this.pathInfo);<z>
{<z>
LinkedHashSet<>();<z>
PartialMatch match : this.partialMatches) {<z>
getMethods()) {<z>
method.name());<z>
result;<z>
parsePropsElement(Element propsEle) {<z>
ManagedProperties();<z>
);<z>
);<z>
.getChildElementsByTagName(propsEle, PROP_ELEMENT);<z>
propEle : propEles) {<z>
KEY_ATTRIBUTE);<z>
.trim();<z>
TypedStringValue(key);<z>
.setSource(extractSource(propEle));<z>
TypedStringValue valueHolder = new TypedStringValue(value);<z>
(extractSource(propEle));<z>
put(keyHolder, valueHolder);<z>
return props;<z>
<A> withNonMergedAttributes() {<z>
,<z>
.aggregateIndex, false, this.attributeFilter,<z>
.resolvedMirrors);<z>
propagationBehavior) {<z>
contains(propagationBehavior)) {<z>
("Only values of propagation constants allowed");<z>
.propagationBehavior = propagationBehavior;<z>
{<z>
) {<z>
.strategies : ExchangeStrategies.withDefaults());<z>
ExchangeStrategies.Builder builder =<z>
: ExchangeStrategies.builder());<z>
-> configurer.accept(builder));<z>
);<z>
] excludePatterns,<z>
interceptor, @Nullable PathPatternParser parser) {<z>
;<z>
);<z>
= interceptor;<z>
() {<z>
;<z>
asList(<z>
);<z>
"custom/type" + i));<z>
, this.requestedTypeCount);<z>
parseMediaType);<z>
instantiate(<z>
?> constructorToUse, Object[] argsToUse) {<z>
beanFactory.getInstantiationStrategy();<z>
, argsToUse);<z>
{<z>
getResourceDescription(), beanName,<z>
, ex);<z>
String beanName) {<z>
pvs);<z>
, beanName, pvs);<z>
catch (Throwable ex) {<z>
BeanCreationException(beanName, "Injection of resource dependencies failed", ex);<z>
return pvs;<z>
void close(Closeable closeable) {<z>
close();<z>
ex) {<z>
getNextKey() throws DataAccessException {<z>
.maxId == this.nextId) {<z>
= null;<z>
stmt = null;<z>
= false;<z>
this.useNewConnection) {<z>
();<z>
.getAutoCommit()) {<z>
;<z>
.setAutoCommit(false);<z>
);<z>
;<z>
.useNewConnection) {<z>
, getDataSource());<z>
= getColumnName();<z>
) + " set " + columnName +<z>
+ " + " + getCacheSize() + ") limit 1");<z>
SQLException ex) {<z>
+ columnName + " for " +<z>
" sequence table", ex);<z>
stmt.executeQuery(VALUE_SQL);<z>
if (!rs.next()) {<z>
throw new DataAccessResourceFailureException("last_insert_id() failed after executing an update");<z>
(1);<z>
;<z>
this.maxId - getCacheSize() + 1;<z>
) {<z>
;<z>
);<z>
null) {<z>
{<z>
();<z>
mustRestoreAutoCommit) {<z>
.setAutoCommit(true);<z>
(SQLException ignore) {<z>
(<z>
));<z>
(con);<z>
, getDataSource());<z>
this.nextId++;<z>
.nextId;<z>
public Object resolveArgumentValue(<z>
context, ServerWebExchange exchange) {<z>
getParameterType());<z>
.getQueryParams();<z>
;<z>
getCorsConfiguration(Object handler, HttpServletRequest request) {<z>
Object resolvedHandler = handler;<z>
{<z>
= handlerExecutionChain.getHandler();<z>
instanceof CorsConfigurationSource configSource) {<z>
getCorsConfiguration(request);<z>
;<z>
session) throws JMSException {<z>
> message = toMessagingMessage(jmsMessage);<z>
logger.isDebugEnabled()) {<z>
+ "]");<z>
);<z>
(result != null) {<z>
handleResult(result, jmsMessage, session);<z>
logger.trace("No result object given - no result to handle");<z>
(boolean subscriptionDurable) {<z>
.subscriptionDurable = subscriptionDurable;<z>
) {<z>
(true);<z>
void setAttributes(HttpServletRequest servletRequest, ServerRequest request,<z>
<?> handlerFunction) {<z>
matchingPattern =<z>
servletRequest.getAttribute(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE);<z>
if (matchingPattern != null) {<z>
.MATCHING_PATTERN_ATTRIBUTE);<z>
, matchingPattern.getPatternString());<z>
;<z>
(RouterFunctions.REQUEST_ATTRIBUTE, request);<z>
MimeType mimeType) {<z>
()) {<z>
(elementType, mimeType)) {<z>
>) decoder;<z>
elementType);<z>
@Nullable Object parent) {<z>
(parent == null) {<z>
return this;<z>
MockHttpServletRequestBuilder parentBuilder)) {<z>
) + "]");<z>
contextPath)) {<z>
;<z>
{<z>
this.servletPath = parentBuilder.servletPath;<z>
)) {<z>
;<z>
null) {<z>
.secure = parentBuilder.secure;<z>
) {<z>
.principal;<z>
null) {<z>
.session;<z>
characterEncoding == null) {<z>
characterEncoding = parentBuilder.characterEncoding;<z>
(this.content == null) {<z>
= parentBuilder.content;<z>
{<z>
this.contentType = parentBuilder.contentType;<z>
()) {<z>
);<z>
this.headers.containsKey(headerName)) {<z>
(headerName, entry.getValue());<z>
: parentBuilder.parameters.entrySet()) {<z>
entry.getKey();<z>
.parameters.containsKey(paramName)) {<z>
entry.getValue());<z>
.queryParams.entrySet()) {<z>
.getKey();<z>
(paramName)) {<z>
, entry.getValue());<z>
: parentBuilder.cookies) {<z>
{<z>
cookie);<z>
.locales) {<z>
) {<z>
;<z>
: parentBuilder.requestAttributes.entrySet()) {<z>
String attributeName = entry.getKey();<z>
(attributeName)) {<z>
attributeName, entry.getValue());<z>
) {<z>
;<z>
.containsKey(attributeName)) {<z>
(attributeName, entry.getValue());<z>
: parentBuilder.flashAttributes.entrySet()) {<z>
= entry.getKey();<z>
attributeName)) {<z>
getValue());<z>
parentBuilder.postProcessors);<z>
return this;<z>
> sqlSupplier) {<z>
Collections.emptyMap();<z>
this.byName = Collections.emptyMap();<z>
;<z>
.filterFunction = StatementFilterFunction.EMPTY_FILTER;<z>
{<z>
);<z>
.getResource(dataSource);<z>
isSynchronizedWithTransaction())) {<z>
.requested();<z>
{<z>
debug("Fetching resumed JDBC Connection from DataSource");<z>
);<z>
);<z>
;<z>
con = fetchConnection(dataSource);<z>
.isSynchronizationActive()) {<z>
conHolder;<z>
if (holderToUse == null) {<z>
;<z>
setConnection(con);<z>
();<z>
TransactionSynchronizationManager.registerSynchronization(<z>
ConnectionSynchronization(holderToUse, dataSource));<z>
.setSynchronizedWithTransaction(true);<z>
conHolder) {<z>
, holderToUse);<z>
(RuntimeException ex) {<z>
con, dataSource);<z>
;<z>
con;<z>
SQLException ex) {<z>
"]" : "") +<z>
+ ex.getErrorCode() + "]; " +<z>
.getMessage(), ex);<z>
= sql;<z>
() throws Exception {<z>
jettyServer = new Server();<z>
;<z>
);<z>
setAsyncSupported(true);<z>
, "", false, false);<z>
, "/");<z>
contextHandler.addServletContainerInitializer(new JettyWebSocketServletContainerInitializer());<z>
this.contextHandler.start();<z>
= new ServerConnector(this.jettyServer);<z>
(getHost());<z>
setPort(getPort());<z>
;<z>
long period) {<z>
ScheduledExecutorService executor = getScheduledExecutor();<z>
;<z>
MILLISECONDS);<z>
catch (RejectedExecutionException ex) {<z>
, ex);<z>
toDataBuffer(ContentChunk chunk) {<z>
.capacity());<z>
;<z>
.callback.succeeded();<z>
buffer;<z>
(SubProtocolHandler handler) {<z>
;<z>
) {<z>
.isErrorEnabled()) {<z>
+ handler);<z>
{<z>
);<z>
) {<z>
"Cannot map " + handler +<z>
+ "': already mapped to " + replaced + ".");<z>
.protocolHandlers.add(handler);<z>
() {<z>
);<z>
(themeSource == null) {<z>
new ResourceBundleThemeSource();<z>
Theme theme = themeSource.getTheme(DEFAULT_THEME_NAME);<z>
theme == null) {<z>
"No theme defined and no fallback theme found");<z>
return theme;<z>
(RSocketStrategies other) {<z>
;<z>
());<z>
;<z>
adapterRegistry = other.reactiveAdapterRegistry();<z>
.dataBufferFactory();<z>
metadataExtractor = other.metadataExtractor();<z>
CorsConfiguration applyPermitDefaultValues() {<z>
this.allowedOriginPatterns == null) {<z>
allowedOrigins = DEFAULT_PERMIT_ALL;<z>
.allowedMethods == null) {<z>
DEFAULT_PERMIT_METHODS;<z>
this.resolvedMethods = DEFAULT_PERMIT_METHODS<z>
());<z>
) {<z>
= DEFAULT_PERMIT_ALL;<z>
null) {<z>
= 1800L;<z>
this;<z>
public ServletServerHttpAsyncRequestControl(ServletServerHttpRequest request, ServletServerHttpResponse response) {<z>
;<z>
"response is required");<z>
),<z>
"filter declarations in web.xml.");<z>
request;<z>
= response;<z>
{<z>
this.nestingLevel++;<z>
null;<z>
null) {<z>
.methodParameter.nested();<z>
TransactionException {<z>
execute(status -> {<z>
action.accept(status);<z>
;<z>
});<z>
(<z>
AbstractSubscribableChannel clientInboundChannel,<z>
{<z>
);<z>
MessageBrokerRegistry registry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);<z>
;<z>
!= null) {<z>
);<z>
return resolver;<z>
) {<z>
null && this.excludePatterns == null) {<z>
;<z>
MappedInterceptor mappedInterceptor = new MappedInterceptor(<z>
includePatterns),<z>
(this.excludePatterns),<z>
.interceptor);<z>
{<z>
pathMatcher);<z>
return mappedInterceptor;<z>
) {<z>
MULTIARG_NEW_INSTANCE, null);<z>
Type thisType = getThisType(e);<z>
.load_arg(2);<z>
invoke_static(thisType, SET_THREAD_CALLBACKS, false);<z>
;<z>
);<z>
(0);<z>
ObjectSwitchCallback() {<z>
key, Label end) {<z>
constructor = (MethodInfo) key;<z>
constructor.getSignature().getArgumentTypes();<z>
i++) {<z>
;<z>
i);<z>
.aaload();<z>
;<z>
thisType, constructor.getSignature());<z>
);<z>
void processDefault() {<z>
throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, "Constructor not found");<z>
;<z>
.aconst_null();<z>
SET_THREAD_CALLBACKS, false);<z>
.return_value();<z>
e.end_method();<z>
{<z>
if (getEncoding() != null) {<z>
);<z>
CONTENT_TYPE_HTML);<z>
HttpHeaders headers, String value) {<z>
notNull(headers, "Headers must not be null");<z>
);<z>
, value);<z>
String... names) {<z>
-> {<z>
String name : names) {<z>
.get(name));<z>
) {<z>
(<z>
).onErrorResume(Exception.class,<z>
.close()));<z>
{<z>
);<z>
= overrideDelegate;<z>
{<z>
packageName);<z>
void changeParser(PathPatternParser parser) {<z>
instanceof ChangePathPatternParserVisitor.Target target) {<z>
target.changeParser(parser);<z>
int doEndTag() throws JspException {<z>
();<z>
getRequestContext().getRequestDataValueProcessor();<z>
();<z>
{<z>
((HttpServletRequest) request, url);<z>
) {<z>
.print(url);<z>
) {<z>
new JspException(ex);<z>
, url, this.scope);<z>
;<z>
) {<z>
.isOpen()) {<z>
);<z>
.holderActive = false;<z>
()) {<z>
.getConnection(), this.dataSource);<z>
AbstractListenerWriteFlushProcessor(String logPrefix) {<z>
= logPrefix;<z>
logPrefix + "[WFP] ",<z>
) -> {<z>
);<z>
State.COMPLETED);<z>
{<z>
state);<z>
> writeProcessor = this.currentWriteProcessor;<z>
{<z>
.cancelAndSetCompleted();<z>
.currentWriteProcessor = null;<z>
});<z>
boolean isWritePossible() {<z>
this.responseChannel;<z>
null) {<z>
.resumeWrites();<z>
;<z>
false;<z>
ConfigurationClass configClass, SourceClass sourceClass) throws IOException {<z>
) {<z>
;<z>
{<z>
!methodMetadata.isAbstract()) {<z>
methodMetadata, configClass));<z>
ifc);<z>
Message<?> message) {<z>
;<z>
MessageHeaders headers = message.getHeaders();<z>
sessionId = SimpMessageHeaderAccessor.getSessionId(headers);<z>
headers);<z>
) {<z>
throw new IllegalStateException("No session id in " + message);<z>
sessionAttributes == null) {<z>
message);<z>
sessionId, sessionAttributes);<z>
String[] generatedKeyNames) {<z>
{<z>
true;<z>
if (!declaredColumns.isEmpty()) {<z>
declaredColumns);<z>
<>(generatedKeyNames.length);<z>
key : generatedKeyNames) {<z>
());<z>
new ArrayList<>();<z>
.getTableParameterMetaData()) {<z>
getParameterName().toUpperCase())) {<z>
getParameterName());<z>
return columns;<z>
{<z>
) {<z>
;<z>
handler) {<z>
constructor.newInstance(handler);<z>
Exception ex) {<z>
, ex);<z>
? extends Annotation> factory) {<z>
Class<? extends Annotation>)<z>
);<z>
{<z>
IllegalArgumentException("Unable to extract parameterized Annotation type argument from " +<z>
getName() +<z>
;<z>
annotationType;<z>
void scheduleNewInvoker() {<z>
invoker = new AsyncMessageListenerInvoker();<z>
) {<z>
.scheduledInvokers.add(invoker);<z>
public void setBeanFactory(BeanFactory beanFactory) {<z>
{<z>
;<z>
CorsConfiguration getCorsConfiguration(HttpServletRequest request) {<z>
(HttpHeaders.ORIGIN) != null)) {<z>
.corsConfiguration;<z>
null;<z>
public RequestMappingHandlerMapping requestMappingHandlerMapping(<z>
"mvcContentNegotiationManager") ContentNegotiationManager contentNegotiationManager,<z>
("mvcConversionService") FormattingConversionService conversionService,<z>
("mvcResourceUrlProvider") ResourceUrlProvider resourceUrlProvider) {<z>
mapping = createRequestMappingHandlerMapping();<z>
;<z>
));<z>
;<z>
));<z>
;<z>
.getPatternParser() != null) {<z>
);<z>
(pathConfig.getUrlPathHelperOrDefault());<z>
));<z>
;<z>
useSuffixPatternMatch != null) {<z>
useSuffixPatternMatch);<z>
useRegisteredSuffixPatternMatch = pathConfig.isUseRegisteredSuffixPatternMatch();<z>
useRegisteredSuffixPatternMatch != null) {<z>
);<z>
;<z>
null) {<z>
(useTrailingSlashMatch);<z>
getPathPrefixes() != null) {<z>
getPathPrefixes());<z>
mapping;<z>
Class c2) {<z>
.c1 = c1;<z>
c2 = c2;<z>
fromEnhancer = AbstractClassGenerator.getCurrent();<z>
(fromEnhancer != null) {<z>
);<z>
.getStrategy();<z>
();<z>
{<z>
this.previousNestedPath =<z>
);<z>
nestedPath =<z>
getPath());<z>
PageContext.REQUEST_SCOPE);<z>
return EVAL_BODY_INCLUDE;<z>
void checkOnDataAvailable() {<z>
();<z>
onDataAvailable();<z>
<Void> beforeCompletion() {<z>
)) {<z>
.synchronizationManager.unbindResource(this.resourceKey);<z>
= false;<z>
(shouldReleaseBeforeCompletion()) {<z>
);<z>
);<z>
,<z>
@Nullable MediaType contentType, ServerWebExchange exchange) {<z>
.getResponse().writeWith(Mono<z>
fromCallable(() -> {<z>
renderAttributes, exchange);<z>
logger.isDebugEnabled()) {<z>
"]");<z>
getLocale(exchange.getLocaleContext());<z>
.allocateBuffer();<z>
= getCharset(contentType);<z>
;<z>
(freeMarkerModel, writer);<z>
;<z>
) {<z>
.release(dataBuffer);<z>
"]";<z>
ex);<z>
(Throwable ex) {<z>
dataBuffer);<z>
ex;<z>
));<z>
handleMissingServletRequestPartException(MissingServletRequestPartException ex,<z>
IOException {<z>
());<z>
new ModelAndView();<z>
(String urlPath, String redirectUrl) {<z>
RedirectViewControllerRegistration(urlPath, redirectUrl);<z>
setApplicationContext(this.applicationContext);<z>
(registration);<z>
;<z>
Nullable String parameterName) {<z>
{<z>
return null;<z>
startsWith(REMOVABLE_COLUMN_PREFIX)) {<z>
.substring(1));<z>
parameterNameToUse(parameterName);<z>
boolean enforceClosingTag) throws JspException {<z>
if (!inTag()) {<z>
IllegalStateException("Cannot write end of tag. No open tag available.");<z>
boolean renderClosingTag = true;<z>
)) {<z>
{<z>
(">");<z>
.append("/>");<z>
;<z>
(renderClosingTag) {<z>
).append(">");<z>
pop();<z>
afterPropertiesSet() {<z>
getEntityManagerFactory();<z>
null) {<z>
);<z>
if (emf instanceof EntityManagerFactoryInfo emfInfo) {<z>
null) {<z>
);<z>
.entityManagerInterface == null) {<z>
= EntityManager.class;<z>
this.entityManagerInterface == null) {<z>
.class;<z>
= SharedEntityManagerCreator.createSharedEntityManager(<z>
entityManagerInterface);<z>
Advisor a, Advisor b) {<z>
!(a instanceof PointcutAdvisor) ||<z>
instanceof PointcutAdvisor &&<z>
)));<z>
ignoreInvalid)<z>
{<z>
PropertyAccessException> propertyAccessExceptions = null;<z>
= (pvs instanceof MutablePropertyValues ?<z>
)));<z>
if (ignoreUnknown) {<z>
.suppressNotWritablePropertyException = true;<z>
{<z>
);<z>
{<z>
ignoreUnknown) {<z>
;<z>
) {<z>
ignoreInvalid) {<z>
ex;<z>
{<z>
) {<z>
ArrayList<>();<z>
ex);<z>
) {<z>
this.suppressNotWritablePropertyException = false;<z>
if (propertyAccessExceptions != null) {<z>
new PropertyAccessException[0]);<z>
(paeArray);<z>
enhancer, Callback[] callbacks) {<z>
false);<z>
;<z>
constructorArgs != null && this.constructorArgTypes != null ?<z>
.constructorArgs) :<z>
enhancer.create());<z>
E next() {<z>
inUse = true;<z>
.iterators) {<z>
(iterator.hasNext()) {<z>
();<z>
"All iterators exhausted");<z>
@Nullable Object body, MethodParameter bodyParameter,<z>
Nullable MethodParameter actualParam, ServerWebExchange exchange) {<z>
.forMethodParameter(bodyParameter);<z>
;<z>
(bodyType.resolve(), body);<z>
;<z>
ResolvableType elementType;<z>
actualElementType;<z>
adapter != null) {<z>
);<z>
.isSuspendingFunction(bodyParameter.getMethod()) &&<z>
));<z>
? bodyType : bodyType.getGeneric();<z>
);<z>
elementType;<z>
= Mono.justOrEmpty(body);<z>
ResolvableType.forInstance(body) : bodyType;<z>
body != null ? actualElementType : bodyType);<z>
== Void.class) {<z>
;<z>
bestMediaType;<z>
-> getMediaTypesFor(elementType));<z>
) {<z>
.getResponse().getStatusCode();<z>
) {<z>
.isDebugEnabled()) {<z>
"Ignoring error response content (if any). " + ex.getReason());<z>
.empty();<z>
throw ex;<z>
(bestMediaType != null) {<z>
exchange.getLogPrefix();<z>
()) {<z>
.debug(logPrefix +<z>
);<z>
writer : getMessageWriters()) {<z>
{<z>
, actualType, elementType,<z>
getRequest(), exchange.getResponse(),<z>
(Hints.LOG_PREFIX_HINT, logPrefix));<z>
).getContentType();<z>
(bestMediaType));<z>
(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);<z>
CollectionUtils.isEmpty(producibleTypes)) {<z>
error(new HttpMessageNotWritableException(<z>
+ contentType + "'"));<z>
> mediaTypes = getMediaTypesFor(elementType);<z>
== null && mediaTypes.isEmpty()) {<z>
);<z>
error(new NotAcceptableStatusException(mediaTypes));<z>
> clazz)<z>
throws InvalidMetadataException {<z>
? extends Annotation>> anns = getRepeatableAnnotations(<z>
;<z>
metadata.ManagedNotification.class);<z>
{<z>
Charset charset = null;<z>
.getContentType();<z>
!= null) {<z>
);<z>
? charset : StandardCharsets.UTF_8);<z>
beanFactory) throws BeansException {<z>
(this.persistenceExceptionTranslator == null) {<z>
)) {<z>
IllegalArgumentException(<z>
"Cannot use PersistenceExceptionTranslator autodetection without ListableBeanFactory");<z>
) beanFactory;<z>
public Annotation[] getParameterAnnotations() {<z>
combinedAnnotations;<z>
null) {<z>
= super.getParameterAnnotations();<z>
index = getParameterIndex();<z>
index >= 0) {<z>
) {<z>
if (index < ifcAnns.length) {<z>
[] paramAnns = ifcAnns[index];<z>
> 0) {<z>
length + paramAnns.length);<z>
.asList(anns));<z>
) {<z>
= false;<z>
{<z>
{<z>
= true;<z>
{<z>
));<z>
[0]);<z>
combinedAnnotations = anns;<z>
anns;<z>
, AssertionError {<z>
MockClientHttpRequest mockRequest = (MockClientHttpRequest) request;<z>
matchInternal(mockRequest);<z>
) {<z>
new AssertionError("Failed to parse expected or actual XML request content", ex);<z>
protected Object getValue() throws BeansException {<z>
) {<z>
this.beanName);<z>
null);<z>
@Nullable JsonFactory factory) {<z>
!= null) {<z>
XmlFactory) factory);<z>
new XmlMapper(StaxUtils.createDefensiveInputFactory());<z>
throws JMSException {<z>
();<z>
if (correlation == null) {<z>
();<z>
setJMSCorrelationID(correlation);<z>
(Object... uriVariables) {<z>
(uriVariables)<z>
(value -> {<z>
() : "");<z>
UTF_8);<z>
;<z>
) {<z>
);<z>
new Properties();<z>
.query(sql, rs -> {<z>
rs.getString(1);<z>
2);<z>
= rs.getString(3);<z>
value);<z>
);<z>
.registerBeanDefinitions(props);<z>
, @Nullable MimeType mimeType) {<z>
null) {<z>
;<z>
MimeType candidate : this.encodableMimeTypes) {<z>
) {<z>
return true;<z>
return false;<z>
factoryBean) {<z>
getObjectType();<z>
(Throwable ex) {<z>
("FactoryBean threw exception from getObjectType, despite the contract saying " +<z>
, ex);<z>
null;<z>
ListableBeanFactory lbf, ResolvableType type) {<z>
notNull(lbf, "ListableBeanFactory must not be null");<z>
lbf.getBeanNamesForType(type);<z>
if (lbf instanceof HierarchicalBeanFactory hbf) {<z>
() instanceof ListableBeanFactory) {<z>
String[] parentResult = beanNamesForTypeIncludingAncestors(<z>
type);<z>
;<z>
result;<z>
public Long getTimestamp() {<z>
TIMESTAMP);<z>
{<z>
;<z>
);<z>
context, @Nullable Object rootObject) throws EvaluationException {<z>
new StringBuilder();<z>
: this.expressions) {<z>
class);<z>
if (value != null) {<z>
;<z>
sb.toString();<z>
{<z>
();<z>
;<z>
(pe != null) {<z>
append(pe.getChars());<z>
pe.next;<z>
sb.toString();<z>
String serverId, String sessionId, String transport) {<z>
transport)) {<z>
false;<z>
"*") ||<z>
{<z>
TransportType.fromValue(transport);<z>
!transportType.supportsOrigin()) {<z>
.isWarnEnabled()) {<z>
warn("Origin check enabled but transport '" + transport + "' does not support it.");<z>
;<z>
;<z>
) {<z>
cacheManagers) {<z>
getCache(name);<z>
) {<z>
;<z>
null;<z>
public final void setServletContext(ServletContext servletContext) {<z>
(servletContext != this.servletContext) {<z>
;<z>
servletContext);<z>
Nullable Object request, Class<T> responseType)<z>
RestClientException {<z>
);<z>
> responseExtractor = responseEntityExtractor(responseType);<z>
);<z>
TransactionSynchronizationManager TransactionSynchronizationManager,<z>
status) throws TransactionException {<z>
);<z>
);<z>
isDebug()) {<z>
;<z>
.commitTransaction())<z>
);<z>
, ResolvableType elementType,<z>
Map<String, Object> hints) {<z>
xmlEventDecoder.decode(<z>
class), mimeType, hints);<z>
toClass();<z>
typeName = toQName(outputClass);<z>
;<z>
.map(events -> {<z>
unmarshal(events, outputClass);<z>
(logger, traceOn -> {<z>
LogFormatUtils.formatValue(value, !traceOn);<z>
+ formatted + "]";<z>
;<z>
value;<z>
);<z>
getProducibleMediaTypes() {<z>
();<z>
this.partialMatches) {<z>
match.hasConsumesMatch()) {<z>
);<z>
return result;<z>
Object other) {<z>
(other == this) {<z>
;<z>
) {<z>
false;<z>
);<z>
) throws Exception {<z>
++) {<z>
(i);<z>
request, response, this.handler)) {<z>
null);<z>
;<z>
;<z>
true;<z>
) {<z>
classLoaderToUse = classLoader;<z>
== null) {<z>
CandidateComponentsIndexLoader.class.getClassLoader();<z>
, CandidateComponentsIndexLoader::doLoadIndex);<z>
throws IOException {<z>
, len);<z>
writeToCache(b, off, count);<z>
return count;<z>
{<z>
();<z>
add(COUNTRY_AT);<z>
;<z>
;<z>
(COUNTRY_US);<z>
;<z>
() {<z>
getResource().lastModified();<z>
ex) {<z>
()) {<z>
(getResource() + " could not be resolved in the file system - " +<z>
;<z>
;<z>
protected ObjectWrapper getObjectWrapper() {<z>
();<z>
(ow != null ? ow :<z>
.build());<z>
ClientHttpConnector initConnector() {<z>
{<z>
ReactorClientHttpConnector();<z>
else if (jettyClientPresent) {<z>
return new JettyClientHttpConnector();<z>
httpComponentsClientPresent) {<z>
);<z>
);<z>
@Nullable Object other) {<z>
this == other) {<z>
return true;<z>
) {<z>
;<z>
(otherCookie.getName()));<z>
) {<z>
{<z>
:<z>
();<z>
case ASPECTJ:<z>
return getAspectJImports();<z>
;<z>
getOperationContext(<z>
target, Class<?> targetClass) {<z>
targetClass);<z>
, target);<z>
{<z>
resourceLocation != null &&<z>
ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX) ||<z>
(resourceLocation)));<z>
boolean isNamedBeanAnAdvisorOrAdvice(String beanName) {<z>
beanFactory != null, "No BeanFactory set");<z>
this.beanFactory.getType(beanName);<z>
{<z>
));<z>
if (logger.isDebugEnabled()) {<z>
"Could not determine type of bean with name '" + beanName +<z>
);<z>
return false;<z>
) {<z>
) {<z>
getMessage().startsWith("Cannot find"));<z>
()) {<z>
: "") +<z>
"serialization for type [" + type + "]";<z>
debugLevel) {<z>
(msg, cause);<z>
()) {<z>
(msg, cause);<z>
warn(msg + ": " + cause);<z>
String baseUrl) {<z>
delegate = delegateRequest;<z>
;<z>
().getRequestURI();<z>
.get());<z>
);<z>
;<z>
String desc, ClassLoader loader) {<z>
indexOf('(');<z>
;<z>
(desc, loader));<z>
| NoSuchMethodException ex) {<z>
(ex);<z>
MimeType(MimeType other) {<z>
.type;<z>
= other.subtype;<z>
= other.parameters;<z>
this.resolvedCharset = other.resolvedCharset;<z>
toStringValue = other.toStringValue;<z>
filter, FilterChain nextFilterChain) {<z>
Assert.notNull(filter, "Filter must not be null");<z>
nextFilterChain, "'FilterChain must not be null");<z>
;<z>
.nextFilterChain = nextFilterChain;<z>
generateCode(MethodVisitor mv, CodeFlow cf) {<z>
generateCode(mv, cf);<z>
().exitTypeDescriptor;<z>
this.exitTypeDescriptor;<z>
.state(exitDesc != null, "No exit type descriptor");<z>
= exitDesc.charAt(0);<z>
);<z>
.children.length > 1) {<z>
);<z>
cf);<z>
.exitTypeDescriptor;<z>
);<z>
mv, rightDesc, targetDesc);<z>
) {<z>
'I':<z>
visitInsn(IREM);<z>
:<z>
.visitInsn(LREM);<z>
:<z>
.visitInsn(FREM);<z>
case 'D':<z>
(DREM);<z>
IllegalStateException(<z>
.exitTypeDescriptor + "'");<z>
(this.exitTypeDescriptor);<z>
getName(HandlerMethod handlerMethod, RequestMappingInfo mapping) {<z>
(mapping.getName() != null) {<z>
();<z>
sb = new StringBuilder();<z>
.getBeanType().getSimpleName();<z>
) {<z>
(i))) {<z>
simpleTypeName.charAt(i));<z>
);<z>
();<z>
MediaType type) throws IOException {<z>
{<z>
&&<z>
(type.isCompatibleWith(MediaType.APPLICATION_JSON) ||<z>
))) {<z>
headers.setContentType(type);<z>
headers, s, type);<z>
publishError(Throwable t) {<z>
this.state.get();<z>
(rsWriteResultLogger.isTraceEnabled()) {<z>
+ t + " [" + state + "]");<z>
, t);<z>
, RowMapper<T> rowMapper)<z>
throws DataAccessException {<z>
paramMap), rowMapper);<z>
parameterIndex, Class<?> implementationClass) {<z>
;<z>
implementationClass);<z>
return forMethodParameter(methodParameter);<z>
Annotation[] findRepeatedAnnotations(Annotation annotation) {<z>
) {<z>
return null;<z>
this.parent.findRepeatedAnnotations(annotation);<z>
queryObject, String paramName, Object value)<z>
HibernateException {<z>
value instanceof Collection) {<z>
(Collection<?>) value);<z>
else if (value instanceof Object[]) {<z>
value);<z>
;<z>
{<z>
;<z>
.extractSource(advisorElement));<z>
String adviceRef = advisorElement.getAttribute(ADVICE_REF);<z>
adviceRef)) {<z>
(<z>
());<z>
.getPropertyValues().add(<z>
adviceRef));<z>
advisorElement.hasAttribute(ORDER_PROPERTY)) {<z>
(<z>
advisorElement.getAttribute(ORDER_PROPERTY));<z>
advisorDefinition;<z>
Nullable UrlPathHelper urlPathHelper,<z>
boolean useSuffixPatternMatch,<z>
{<z>
patterns);<z>
AntPathMatcher();<z>
useSuffixPatternMatch;<z>
= useTrailingSlashMatch;<z>
!= null) {<z>
for (String fileExtension : fileExtensions) {<z>
) {<z>
fileExtension = "." + fileExtension;<z>
(fileExtension);<z>
bufferFactory,<z>
, Object> hints) {<z>
();<z>
returnType) {<z>
(ModelAttribute.class))<z>
)<z>
.map(ModelAttribute::value)<z>
));<z>
, Class interfaces[], Callback callback) {<z>
e = new Enhancer();<z>
setSuperclass(superclass);<z>
(interfaces);<z>
callback);<z>
();<z>
CorsConfiguration getCorsConfiguration(Object handler, HttpServletRequest request) {<z>
= super.getCorsConfiguration(handler, request);<z>
handler instanceof HandlerMethod handlerMethod) {<z>
PREFLIGHT_AMBIGUOUS_MATCH)) {<z>
.ALLOW_CORS_CONFIG;<z>
getCorsConfiguration(handlerMethod);<z>
: corsConfigFromMethod);<z>
corsConfig;<z>
,<z>
Class<? extends Annotation> annotationType) {<z>
annotationType));<z>
@Nullable PropertyValues original) {<z>
original != null) {<z>
;<z>
<>(pvs.length);<z>
(PropertyValue pv : pvs) {<z>
pv));<z>
0);<z>
Collection<?> c) {<z>
boolean success = super.removeAll(c);<z>
(success) {<z>
;<z>
return success;<z>
ServerWebExchange exchange) {<z>
));<z>
();<z>
;<z>
.setStatusCode(getStatusCode());<z>
Mono.empty();<z>
endPos, SpelNodeImpl expression) {<z>
, expression);<z>
nullSafe = nullSafe;<z>
;<z>
> webAsyncTask, Object... processingContext)<z>
throws Exception {<z>
;<z>
null, "AsyncWebRequest must not be null");<z>
();<z>
null) {<z>
;<z>
.getExecutor();<z>
null) {<z>
= executor;<z>
logExecutorWarning();<z>
();<z>
));<z>
;<z>
);<z>
getCallable();<z>
interceptors);<z>
) -> {<z>
) {<z>
+ formatRequestUri());<z>
this.asyncWebRequest, callable);<z>
) {<z>
;<z>
;<z>
(ex -> {<z>
errorHandlingInProgress) {<z>
{<z>
;<z>
, ex);<z>
ex);<z>
setConcurrentResultAndDispatch(result);<z>
});<z>
(() -><z>
, callable));<z>
applyBeforeConcurrentHandling(this.asyncWebRequest, callable);<z>
(processingContext);<z>
-> {<z>
null;<z>
;<z>
();<z>
) {<z>
= ex;<z>
.asyncWebRequest, callable, result);<z>
result);<z>
});<z>
interceptorChain.setTaskFuture(future);<z>
RejectedExecutionException ex) {<z>
);<z>
setConcurrentResultAndDispatch(result);<z>
throw ex;<z>
) {<z>
Assert.notNull(other, "ServerResponse must not be null");<z>
(other instanceof AbstractServerResponse ?<z>
));<z>
(other.headers());<z>
other.cookies());<z>
) throws UnavailableException {<z>
);<z>
);<z>
return endpoint;<z>
event) {<z>
;<z>
Exception ex) {<z>
(<z>
, ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler) {<z>
ScheduledThreadPoolExecutor(poolSize, threadFactory, rejectedExecutionHandler);<z>
() {<z>
();<z>
[] arguments = getArguments();<z>
= arguments.length;<z>
= getTargetClass();<z>
.state(targetClass != null, "No target class set");<z>
getAllDeclaredMethods(targetClass);<z>
Integer.MAX_VALUE;<z>
Method matchingMethod = null;<z>
{<z>
) {<z>
{<z>
getParameterTypes();<z>
= getTypeDifferenceWeight(paramTypes, arguments);<z>
) {<z>
= typeDiffWeight;<z>
candidate;<z>
;<z>
() {<z>
Collection::stream)<z>
))<z>
.forEach(this.jettyRequest::cookie);<z>
) {<z>
);<z>
);<z>
));<z>
afterPropertiesSet();<z>
> value) {<z>
)) {<z>
"Immutable headers");<z>
= headers.getValuesList(this.key);<z>
key, value);<z>
return previousValues;<z>
, Locale locale) throws ParseException {<z>
CurrencyStyleFormatter formatter = new CurrencyStyleFormatter();<z>
;<z>
(currency.getCurrencyCode());<z>
formatter.setCurrency(currency);<z>
pattern);<z>
, locale);<z>
();<z>
> arguments) {<z>
();<z>
.classLoader);<z>
(arguments != null) {<z>
> entry : arguments.entrySet()) {<z>
));<z>
StringReader(script.getScriptAsString()));<z>
ex) {<z>
;<z>
) {<z>
script, ex);<z>
Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {<z>
) {<z>
return null;<z>
targetType.getType());<z>
state(finder != null, "No finder method");<z>
Object id = this.conversionService.convert(<z>
;<z>
, source, id);<z>
private void cleanupAfterCompletion(DefaultTransactionStatus status) {<z>
setCompleted();<z>
()) {<z>
);<z>
()) {<z>
.getTransaction());<z>
null) {<z>
{<z>
debug("Resuming suspended transaction after completion of inner transaction");<z>
;<z>
getSuspendedResources());<z>
void logResponse(ServerWebExchange exchange) {<z>
, traceOn -> {<z>
).getStatusCode();<z>
? status : "200 OK") +<z>
;<z>
);<z>
body(DataBuffer dataBuffer) {<z>
.byteCount.get();<z>
);<z>
||<z>
) {<z>
;<z>
prevCount <= PartGenerator.this.maxInMemorySize) {<z>
count);<z>
DataBufferUtils.release(dataBuffer);<z>
IllegalStateException("Body token not expected"));<z>
HttpClientErrorException create(<z>
) {<z>
statusText, headers, body, charset);<z>
@Nullable Class<?> javaType) {<z>
javaType == null) {<z>
SqlTypeValue.TYPE_UNKNOWN;<z>
= javaTypeToSqlTypeMap.get(javaType);<z>
{<z>
;<z>
{<z>
;<z>
isStringValue(javaType)) {<z>
VARCHAR;<z>
)) {<z>
.TIMESTAMP;<z>
;<z>
static int computeParameterAnnotationsSize(<z>
attributeName,<z>
annotationWriters,<z>
annotableParameterCount) {<z>
+ 2 * annotableParameterCount;<z>
< annotableParameterCount; ++i) {<z>
AnnotationWriter annotationWriter = annotationWriters[i];<z>
(attributeName) - 8;<z>
;<z>
getFooBytes() {<z>
Object ref = foo_;<z>
(ref instanceof java.lang.String) {<z>
com.google.protobuf.ByteString b =<z>
.copyFromUtf8(<z>
ref);<z>
= b;<z>
b;<z>
else {<z>
google.protobuf.ByteString) ref;<z>
(Object entity) throws DataAccessException {<z>
session -> {<z>
checkWriteOperationAllowed(session);<z>
(entity);<z>
null;<z>
});<z>
(<z>
customResolvers, ReactiveAdapterRegistry adapterRegistry,<z>
ConfigurableApplicationContext context) {<z>
Collections.emptyList());<z>
(LineNumberReader lineNumberReader, @Nullable String commentPrefix,<z>
Nullable String blockCommentEndDelimiter) throws IOException {<z>
;<z>
separator, blockCommentEndDelimiter);<z>
private void schedule() {<z>
.taskExecutor.execute(this);<z>
{<z>
);<z>
.decrementAndGet();<z>
;<z>
, String... matchingPaths) {<z>
.pattern = pattern;<z>
{<z>
);<z>
matchingPaths = Collections.singletonList(pattern);<z>
final void setIsolationLevelName(String constantName) throws IllegalArgumentException {<z>
)) {<z>
"Only isolation constants allowed");<z>
).intValue());<z>
{<z>
> propertyNames = props.propertyNames();<z>
{<z>
);<z>
String propertyValue = props.getProperty(propertyName);<z>
(propertyName, propertyValue);<z>
convertedValue)) {<z>
propertyName, convertedValue);<z>
() {<z>
(this.filters == null) {<z>
);<z>
return this.filters;<z>
Nullable HttpHeaders headers, @Nullable Object body) {<z>
.name = name;<z>
this.headers = headers;<z>
body;<z>
void closeConnection() {<z>
null) {<z>
this.target.close();<z>
(Throwable ex) {<z>
"Could not close shared JDBC Connection", ex);<z>
method, Object... params) {<z>
);<z>
(operation instanceof AbstractJCacheKeyOperation)) {<z>
);<z>
createCacheKeyInvocationContext(target, operation, params);<z>
if (this.cacheKeyGenerator != null) {<z>
cacheKeyGenerator.generateCacheKey(invocationContext);<z>
null, "No key generator");<z>
invocationContext);<z>
beanName) {<z>
(this.customTargetSourceCreators != null &&<z>
(beanName)) {<z>
for (TargetSourceCreator tsc : this.customTargetSourceCreators) {<z>
(beanClass, beanName);<z>
) {<z>
isTraceEnabled()) {<z>
.trace("TargetSourceCreator [" + tsc +<z>
);<z>
ts;<z>
null;<z>
(@Nullable String uri) {<z>
{<z>
;<z>
.matchPattern.matcher(uri);<z>
);<z>
) {<z>
) {<z>
isRunning()) {<z>
)) {<z>
);<z>
();<z>
Throwable ex) {<z>
logger.error("Failed to stop WebSocket connection", ex);<z>
= false;<z>
) {<z>
ClassLoader cl = null;<z>
).getContextClassLoader();<z>
) {<z>
{<z>
;<z>
if (cl == null) {<z>
);<z>
catch (Throwable ex) {<z>
;<z>
(<z>
MediaType> mediaTypes) {<z>
(mediaTypes);<z>
;<z>
servletContext;<z>
() {<z>
getNativeCache();<z>
!nativeCache.isEmpty()) {<z>
);<z>
) {<z>
new ConnectionProperties() {<z>
Driver> driverClass) {<z>
);<z>
setUrl(String url) {<z>
;<z>
void setUsername(String username) {<z>
username);<z>
void setPassword(String password) {<z>
(password);<z>
) {<z>
;<z>
return new TimeZoneAwareLocaleContext() {<z>
{<z>
getAttribute(LOCALE_REQUEST_ATTRIBUTE_NAME);<z>
TimeZone getTimeZone() {<z>
);<z>
, boolean useStrictCasing) {<z>
) {<z>
));<z>
property.getName();<z>
public ModelAndView resolveException(<z>
, Exception ex) {<z>
) {<z>
);<z>
request, response, handler, ex);<z>
!= null) {<z>
{<z>
"" : " to " + result));<z>
ex, request);<z>
result;<z>
return null;<z>
IOException {<z>
;<z>
);<z>
.getSystemResources(path));<z>
) {<z>
URL url = resourceUrls.nextElement();<z>
url));<z>
.hasLength(path)) {<z>
(cl, result);<z>
result;<z>
> map, MatchCallback callback) {<z>
();<z>
putAll(getFlattenedMap(map));<z>
()) {<z>
isDebugEnabled()) {<z>
map);<z>
(properties, map);<z>
;<z>
= MatchStatus.ABSTAIN;<z>
{<z>
(properties);<z>
;<z>
.FOUND) {<z>
(logger.isDebugEnabled()) {<z>
);<z>
properties, map);<z>
true;<z>
matchDefault) {<z>
()) {<z>
;<z>
properties, map);<z>
;<z>
.isDebugEnabled()) {<z>
debug("Unmatched document: " + map);<z>
return false;<z>
(Class<?> returnType, ResolvableType generic,<z>
generics) {<z>
).returnType();<z>
rowMapper) {<z>
provider = obtainMetaDataProvider();<z>
provider.isReturnResultSetSupported()) {<z>
rowMapper);<z>
provider.isRefCursorSupported()) {<z>
rowMapper);<z>
throw new InvalidDataAccessApiUsageException(<z>
;<z>
) {<z>
.instant();<z>
this.expiredSessionChecker.checkIfNecessary(now);<z>
= this.sessions.get(id);<z>
session == null) {<z>
Mono.empty();<z>
(now)) {<z>
);<z>
.empty();<z>
.updateLastAccessTime(now);<z>
.just(session);<z>
IOException {<z>
this.serverToUse != null, "No MBeanServerConnection available");<z>
method.getParameterTypes());<z>
key);<z>
null) {<z>
() +<z>
;<z>
String[] signature;<z>
synchronized (this.signatureCache) {<z>
.get(method);<z>
if (signature == null) {<z>
(method);<z>
put(method, signature);<z>
, args, signature);<z>
(@Nullable int... indexes) {<z>
);<z>
|| indexes.length == 0) {<z>
[0]);<z>
generic = this;<z>
) {<z>
);<z>
generics.length) {<z>
;<z>
;<z>
generic;<z>
BeansException {<z>
(beanClass, autowireMode, dependencyCheck);<z>
.setScope(SCOPE_PROTOTYPE);<z>
) {<z>
.getWrappedInstance();<z>
(bd, null, this);<z>
));<z>
bean;<z>
targetClass) {<z>
isPrivate(method.getModifiers())) {<z>
;<z>
(method.getModifiers())) {<z>
return true;<z>
||<z>
(targetClass)));<z>
{<z>
SimpAttributes simpAttributes = SimpAttributesContextHolder.currentAttributes();<z>
);<z>
(scopedObject != null) {<z>
;<z>
()) {<z>
getAttribute(name);<z>
if (scopedObject == null) {<z>
objectFactory.getObject();<z>
name, scopedObject);<z>
scopedObject;<z>
matcher) {<z>
;<z>
exchangeResult.assertWithDiagnostics(() -> {<z>
name) + " maxAge";<z>
matcher);<z>
);<z>
;<z>
setValue(@Nullable Object value) throws Exception {<z>
;<z>
, value);<z>
ex) {<z>
this.field.getName(),<z>
;<z>
<?> receive(long timeout) {<z>
< 0) {<z>
await();<z>
true;<z>
)) {<z>
= true;<z>
;<z>
ex) {<z>
.currentThread().interrupt();<z>
;<z>
, Runnable task) {<z>
(false, true)) {<z>
run();<z>
) {<z>
{<z>
) {<z>
{<z>
return true;<z>
;<z>
void handleRequest(HttpServletRequest servletRequest, HttpServletResponse servletResponse)<z>
IOException {<z>
;<z>
= new ServletServerHttpResponse(servletResponse);<z>
);<z>
failure = null;<z>
logger.isDebugEnabled()) {<z>
());<z>
();<z>
{<z>
, response, this.wsHandler, attributes);<z>
, null);<z>
HandshakeFailureException ex) {<z>
ex;<z>
ex) {<z>
, ex);<z>
) {<z>
response, failure);<z>
();<z>
throw failure;<z>
close();<z>
(TransactionSynchronizationManager TransactionSynchronizationManager,<z>
) throws TransactionException {<z>
;<z>
.getConnectionHolder().getConnection();<z>
isDebug()) {<z>
("Rolling back R2DBC transaction on Connection [" + connection + "]");<z>
connection.rollbackTransaction())<z>
));<z>
{<z>
mediaType != null) {<z>
), "Content-Type cannot contain wildcard type '*'");<z>
;<z>
());<z>
CONTENT_TYPE);<z>
Nullable Duration retry,<z>
, @Nullable T data) {<z>
id = id;<z>
= event;<z>
retry;<z>
this.comment = comment;<z>
data;<z>
> connect(<z>
>> requestCallback) {<z>
method, uri, requestCallback);<z>
;<z>
isAsyncStarted()) {<z>
();<z>
);<z>
mvcResult));<z>
Exception ex) {<z>
(ex);<z>
{<z>
(this.status);<z>
this.reason + "\"" : "");<z>
.buildMessage(msg, getCause());<z>
, Marshaller marshaller) throws PropertyException {<z>
getCharset() != null) {<z>
name());<z>
static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(<z>
BeanDefinitionRegistry registry, @Nullable Object source) {<z>
);<z>
getExceptionHandlerMethod(<z>
) {<z>
= null;<z>
handlerMethod != null) {<z>
handlerMethod.getBeanType();<z>
computeIfAbsent(<z>
);<z>
;<z>
{<z>
, this.applicationContext);<z>
Proxy.isProxyClass(handlerType)) {<z>
getBean());<z>
) {<z>
ControllerAdviceBean advice = entry.getKey();<z>
.isApplicableToBeanType(handlerType)) {<z>
.getValue();<z>
resolver.resolveMethod(exception);<z>
{<z>
;<z>
;<z>
handleClose(CloseStatus closeStatus) {<z>
.closeStatusSink.tryEmitValue(closeStatus);<z>
.receivePublisher.onAllDataRead();<z>
WebSocketSendProcessor sendProcessor = this.sendProcessor;<z>
{<z>
.cancel();<z>
);<z>
entityClass) throws DataAccessException {<z>
List<T>>) session -> {<z>
createCriteria(entityClass);<z>
.DISTINCT_ROOT_ENTITY);<z>
);<z>
);<z>
}));<z>
String toString() {<z>
();<z>
this.value != null) {<z>
name);<z>
isNegated) {<z>
);<z>
.append('=');<z>
.append(this.value);<z>
this.isNegated) {<z>
;<z>
(this.name);<z>
;<z>
(byte[]... byteArrays) {<z>
len = 0;<z>
byteArray : byteArrays) {<z>
;<z>
];<z>
= 0;<z>
{<z>
length);<z>
;<z>
return result;<z>
@Nullable float[] array) {<z>
== null) {<z>
;<z>
length;<z>
{<z>
;<z>
ARRAY_END);<z>
float f : array) {<z>
String.valueOf(f));<z>
.toString();<z>
MailException {<z>
), contentStream);<z>
) {<z>
("Could not parse raw MIME content", ex);<z>
() {<z>
parent == null) {<z>
null;<z>
null,<z>
"Cannot retrieve a parent application context without access to the CacheAwareContextLoaderDelegate");<z>
);<z>
) {<z>
'?');<z>
int fragmentIndex = path.indexOf('#');<z>
)) {<z>
fragmentIndex;<z>
end == -1) {<z>
end = path.length();<z>
, end) + 1;<z>
(';', begin);<z>
end);<z>
.lastIndexOf('.', end);<z>
{<z>
(extIndex + 1, end);<z>
;<z>
{<z>
.completedBeforeSubscribed = true;<z>
state.get()) {<z>
);<z>
void setServletContext(ServletContext servletContext) {<z>
= getRequestUpgradeStrategy();<z>
{<z>
(servletContext);<z>
String getSourceClassName() {<z>
!this.resolved) {<z>
();<z>
;<z>
public final Connection createConnection() throws JMSException {<z>
;<z>
) {<z>
threadCredentials.username, threadCredentials.password);<z>
.password);<z>
, @Nullable Object returnValue) {<z>
null) {<z>
return ClassUtils.isAssignableValue(type, returnValue);<z>
) {<z>
return true;<z>
.getReturnType());<z>
private boolean isQuotedString(String s) {<z>
s.length() < 2) {<z>
false;<z>
"'")));<z>
private static AssertionError createLeakError(DataBuffer delegate) {<z>
("DataBuffer leak detected: {%s} has not been released.%n" +<z>
delegate);<z>
;<z>
result.getStackTrace();<z>
new StackTraceElement[oldTrace.length - 4];<z>
, 0, oldTrace.length - 4);<z>
newTrace);<z>
return result;<z>
... args) {<z>
;<z>
getTargetShadowMatch(method, targetClass);<z>
null;<z>
null;<z>
Object thisObject = null;<z>
();<z>
.getThis();<z>
instanceof ProxyMethodInvocation)) {<z>
+ mi);<z>
pmi = (ProxyMethodInvocation) mi;<z>
getProxy();<z>
catch (IllegalStateException ex) {<z>
.isDebugEnabled()) {<z>
;<z>
args);<z>
null && thisObject != null) {<z>
method));<z>
{<z>
false;<z>
{<z>
joinPointMatch);<z>
joinPointMatch.matches();<z>
catch (Throwable ex) {<z>
()) {<z>
args) +<z>
ex);<z>
return false;<z>
() {<z>
>(4);<z>
ByteArrayHttpMessageConverter());<z>
messageConverters.add(new StringHttpMessageConverter());<z>
(!shouldIgnoreXml) {<z>
<>());<z>
Error err) {<z>
(new AllEncompassingFormHttpMessageConverter());<z>
;<z>
public boolean isRequired(DependencyDescriptor descriptor) {<z>
)) {<z>
return false;<z>
.class);<z>
);<z>
value, Type type) {<z>
if (value.equals("*")) {<z>
;<z>
= value.indexOf('-');<z>
(hyphenPos == -1) {<z>
(value));<z>
of(result, result);<z>
(value, 0, hyphenPos, 10);<z>
(), 10);<z>
= type.checkValidValue(min);<z>
type.checkValidValue(max);<z>
Type.DAY_OF_WEEK && min == 7) {<z>
;<z>
return ValueRange.of(min, max);<z>
pos, Advice advice) throws AopConfigException {<z>
);<z>
advice instanceof IntroductionInfo) {<z>
);<z>
DynamicIntroductionAdvice) {<z>
);<z>
advice));<z>
methodName) {<z>
= getCallbacksSetter(type, methodName);<z>
, new Object[]{callbacks});<z>
(NoSuchMethodException e) {<z>
new IllegalArgumentException(type + " is not an enhanced class");<z>
catch (IllegalAccessException e) {<z>
);<z>
InvocationTargetException e) {<z>
e);<z>
() {<z>
).getSession(true);<z>
"getId");<z>
(getIdMethod, session));<z>
ex) {<z>
;<z>
URI uri, HttpMethod httpMethod) {<z>
.notNull(uri, "'uri' must not be null");<z>
);<z>
) {<z>
IOException {<z>
validateRequest(this);<z>
);<z>
response;<z>
boolean isAnnotatedWithIndexed(Element type) {<z>
getAnnotationMirrors()) {<z>
) {<z>
;<z>
false;<z>
targetType) {<z>
isAssignableTo(STREAM_TYPE)) {<z>
, targetType);<z>
(targetType.isAssignableTo(STREAM_TYPE)) {<z>
(targetType.getElementTypeDescriptor(), sourceType);<z>
return false;<z>
) {<z>
(bufferFactory, createHeaders(exchange));<z>
;<z>
exchange;<z>
= request;<z>
public UriComponents normalize() {<z>
);<z>
= new FullPathComponent(normalizedPath);<z>
, this.host, this.port,<z>
;<z>
, HttpHeaders headers, WebSocketHandler handler) {<z>
Sinks.empty();<z>
-> {<z>
)) {<z>
);<z>
jettyHandler = createHandler(<z>
;<z>
);<z>
request.setHeaders(headers);<z>
));<z>
request);<z>
.asMono();<z>
) {<z>
ex);<z>
;<z>
public WebSocketStompClient(WebSocketClient webSocketClient) {<z>
.notNull(webSocketClient, "WebSocketClient is required");<z>
;<z>
0});<z>
void doPut(HttpServletRequest request, HttpServletResponse response)<z>
{<z>
);<z>
Nullable Object other) {<z>
== other) {<z>
return true;<z>
) {<z>
return false;<z>
() ||<z>
()) {<z>
;<z>
it1 = this.genericArgumentValues.iterator();<z>
);<z>
&& it2.hasNext()) {<z>
.next();<z>
vh2 = it2.next();<z>
(vh2)) {<z>
return false;<z>
) {<z>
entry.getValue();<z>
.getKey());<z>
vh1.contentEquals(vh2)) {<z>
false;<z>
return true;<z>
@Nullable MimeType other) {<z>
null) {<z>
false;<z>
()) {<z>
return true;<z>
(other.getType())) {<z>
{<z>
true;<z>
.isWildcardSubtype()) {<z>
thisSuffix = getSubtypeSuffix();<z>
String otherSuffix = other.getSubtypeSuffix();<z>
.equals(WILDCARD_TYPE)) {<z>
return true;<z>
null) {<z>
) || thisSuffix.equals(otherSuffix));<z>
otherSuffix != null) {<z>
|| otherSuffix.equals(thisSuffix));<z>
return false;<z>
private String getContentCodingKey(ServerWebExchange exchange) {<z>
);<z>
hasText(header)) {<z>
null;<z>
tokenizeToStringArray(header, ","))<z>
(token -> {<z>
indexOf(';');<z>
toLowerCase();<z>
)<z>
()<z>
(Collectors.joining(","));<z>
) {<z>
) {<z>
{<z>
BeanCreationException(<z>
;<z>
) && hasInstantiationAwareBeanPostProcessors()) {<z>
().instantiationAware) {<z>
, beanName)) {<z>
() : null);<z>
int resolvedAutowireMode = mbd.getResolvedAutowireMode();<z>
resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {<z>
);<z>
if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {<z>
, newPvs);<z>
== AUTOWIRE_BY_TYPE) {<z>
(beanName, mbd, bw, newPvs);<z>
;<z>
hasInstantiationAwareBeanPostProcessors();<z>
) != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);<z>
{<z>
null) {<z>
mbd.getPropertyValues();<z>
InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {<z>
;<z>
{<z>
;<z>
if (needsDepCheck) {<z>
, mbd.allowCaching);<z>
, filteredPds, pvs);<z>
!= null) {<z>
, pvs);<z>
initRequestUpgradeStrategy() {<z>
className;<z>
(tomcatWsPresent) {<z>
;<z>
{<z>
= "org.springframework.web.socket.server.jetty.JettyRequestUpgradeStrategy";<z>
if (undertowWsPresent) {<z>
"org.springframework.web.socket.server.standard.UndertowRequestUpgradeStrategy";<z>
else if (glassfishWsPresent) {<z>
= "org.springframework.web.socket.server.standard.GlassFishRequestUpgradeStrategy";<z>
if (weblogicWsPresent) {<z>
;<z>
) {<z>
className = "org.springframework.web.socket.server.standard.WebSphereRequestUpgradeStrategy";<z>
throw new IllegalStateException("No suitable default RequestUpgradeStrategy found");<z>
());<z>
.newInstance();<z>
ex) {<z>
new IllegalStateException(<z>
);<z>
object) {<z>
Resource resource = null;<z>
object instanceof ResourceRegion resourceRegion) {<z>
);<z>
<ResourceRegion>) object;<z>
()) {<z>
);<z>
;<z>
RequestMatcher isMap() {<z>
return new AbstractJsonPathRequestMatcher() {<z>
MockClientHttpRequest request) throws IOException, ParseException {<z>
());<z>
public static char toPrimitiveTargetDesc(String descriptor) {<z>
1) {<z>
.charAt(0);<z>
equals("Ljava/lang/Boolean")) {<z>
'Z';<z>
(descriptor.equals("Ljava/lang/Byte")) {<z>
;<z>
{<z>
;<z>
)) {<z>
'D';<z>
{<z>
;<z>
("Ljava/lang/Integer")) {<z>
'I';<z>
) {<z>
'J';<z>
if (descriptor.equals("Ljava/lang/Short")) {<z>
;<z>
;<z>
computeRecordComponentInfoSize() {<z>
= 6;<z>
symbolTable, 0, signatureIndex);<z>
AnnotationWriter.computeAnnotationsSize(<z>
;<z>
(firstAttribute != null) {<z>
+= firstAttribute.computeAttributesSize(symbolTable);<z>
;<z>
ConnectionProperties properties, String databaseName) {<z>
);<z>
.setDriverClass(this.driverClass);<z>
.setUrl(url);<z>
("sa");<z>
.setPassword("");<z>
) {<z>
.afterPropertiesSet();<z>
rowMapperClass != null,<z>
"'rowMapper' or 'rowMapperClass' is required");<z>
Object, Exception> failedMessages) {<z>
);<z>
new LinkedHashMap<>(failedMessages);<z>
);<z>
> parser, ConversionService conversionService) {<z>
fieldType;<z>
parser;<z>
= conversionService;<z>
Nullable Class<?> targetType) {<z>
) {<z>
;<z>
selectInvocableMethod(method, targetType);<z>
(methodToUse.getModifiers()) &&<z>
.class.isAssignableFrom(targetType)) {<z>
IllegalStateException(String.format(<z>
));<z>
return methodToUse;<z>
() {<z>
return super.getEndpointDescription()<z>
'\'')<z>
);<z>
WebSocketMessage textMessage(String payload) {<z>
UTF_8);<z>
bytes);<z>
.Type.TEXT, buffer);<z>
public void visitInvokeDynamicInsn(<z>
,<z>
final String descriptor,<z>
Handle bootstrapMethodHandle,<z>
) {<z>
(api < Opcodes.ASM5) {<z>
UnsupportedOperationException(REQUIRES_ASM5);<z>
mv != null) {<z>
);<z>
<String> cacheNames) {<z>
!= null) {<z>
name : cacheNames) {<z>
);<z>
false;<z>
.dynamic = true;<z>
BeanDefinitionBuilder addDependsOn(String beanName) {<z>
) {<z>
.setDependsOn(beanName);<z>
beanName);<z>
added);<z>
this;<z>
pattern2) {<z>
pattern1);<z>
pattern2);<z>
() && info2.isLeastSpecific()) {<z>
0;<z>
{<z>
1;<z>
else if (info2.isLeastSpecific()) {<z>
return -1;<z>
pattern1.equals(this.path);<z>
path);<z>
) {<z>
0;<z>
if (pattern1EqualsPath) {<z>
1;<z>
{<z>
1;<z>
{<z>
);<z>
) {<z>
;<z>
) {<z>
-1;<z>
info2.getTotalCount()) {<z>
) - info2.getTotalCount();<z>
()) {<z>
getLength();<z>
) < info2.getSingleWildcards()) {<z>
1;<z>
)) {<z>
return 1;<z>
getUriVars()) {<z>
;<z>
)) {<z>
return 1;<z>
return 0;<z>
(<z>
Object identifier, @Nullable Throwable cause) {<z>
persistentClass, identifier,<z>
+ identifier +<z>
);<z>
Throwable ex) {<z>
);<z>
{<z>
class);<z>
(ann != null) {<z>
;<z>
status;<z>
RuntimeBeanReference registerUserDestResolver(Element brokerElem,<z>
, ParserContext context, @Nullable Object source) {<z>
new RootBeanDefinition(DefaultUserDestinationResolver.class);<z>
().addIndexedArgumentValue(0, userRegistry);<z>
) {<z>
"user-destination-prefix"));<z>
);<z>
protected final void renderMergedOutputModel(<z>
request, HttpServletResponse response) throws Exception {<z>
this.exposeRequestAttributes) {<z>
null;<z>
; en.hasMoreElements();) {<z>
String attribute = en.nextElement();<z>
.allowRequestOverride) {<z>
ServletException("Cannot expose request attribute '" + attribute +<z>
);<z>
attributeValue = request.getAttribute(attribute);<z>
) {<z>
exposed : new LinkedHashMap<>();<z>
;<z>
model.put(attribute, attributeValue);<z>
&& exposed != null) {<z>
logger.trace("Exposed request attributes to model: " + exposed);<z>
(this.exposeSessionAttributes) {<z>
request.getSession(false);<z>
{<z>
, Object> exposed = null;<z>
; en.hasMoreElements();) {<z>
nextElement();<z>
this.allowSessionOverride) {<z>
+ attribute +<z>
);<z>
.getAttribute(attribute);<z>
.isDebugEnabled()) {<z>
? exposed : new LinkedHashMap<>();<z>
attributeValue);<z>
;<z>
!= null) {<z>
);<z>
this.exposeSpringMacroHelpers) {<z>
(model.containsKey(SPRING_MACRO_REQUEST_CONTEXT_ATTRIBUTE)) {<z>
(<z>
"Cannot expose bind macro helper '" + SPRING_MACRO_REQUEST_CONTEXT_ATTRIBUTE +<z>
"' because of an existing model object of the same name");<z>
,<z>
), model));<z>
(response);<z>
(logger.isDebugEnabled()) {<z>
) + "]");<z>
(model, request, response);<z>
public void setClobAsCharacterStream(<z>
characterStream, int contentLength)<z>
SQLException {<z>
!= null) {<z>
.createClob();<z>
, clob.setCharacterStream(1));<z>
ex) {<z>
);<z>
;<z>
.setClob(paramIndex, clob);<z>
setClob(paramIndex, (Clob) null);<z>
)) {<z>
debug(characterStream != null ?<z>
"Copied character stream into temporary CLOB with length " + contentLength :<z>
"Set CLOB to null");<z>
, String htmlText) throws MessagingException {<z>
(plainText, "Plain text must not be null");<z>
.notNull(htmlText, "HTML text must not be null");<z>
MimeMultipart(MULTIPART_SUBTYPE_ALTERNATIVE);<z>
.setContent(messageBody, CONTENT_TYPE_ALTERNATIVE);<z>
();<z>
);<z>
;<z>
new MimeBodyPart();<z>
;<z>
(htmlTextPart);<z>
(<z>
, FilterChain filterChain)<z>
throws ServletException, IOException {<z>
(request);<z>
false;<z>
.getAsyncManager(request);<z>
= getAlreadyFilteredAttributeName();<z>
TransactionSynchronizationManager.hasResource(emf)) {<z>
;<z>
;<z>
|| !applyEntityManagerBindingInterceptor(asyncManager, key)) {<z>
logger.debug("Opening JPA EntityManager in OpenEntityManagerInViewFilter");<z>
(emf);<z>
;<z>
;<z>
(emf, emHolder);<z>
interceptor);<z>
);<z>
{<z>
("Could not create JPA EntityManager", ex);<z>
doFilter(request, response);<z>
{<z>
)<z>
unbindResource(emf);<z>
!isAsyncStarted(request)) {<z>
logger.debug("Closing JPA EntityManager in OpenEntityManagerInViewFilter");<z>
;<z>
Exception {<z>
) {<z>
;<z>
protected boolean isAllowed(String field) {<z>
allowed = getAllowedFields();<z>
disallowed = getDisallowedFields();<z>
simpleMatch(allowed, field)) &&<z>
);<z>
List<HttpMessageConverter<?>> converters,<z>
) {<z>
);<z>
builder) {<z>
;<z>
!StringUtils.hasText(path)) {<z>
);<z>
indexOf('.');<z>
1) {<z>
).error(<z>
"Attribute 'path' must follow pattern 'beanName.propertyName'", element);<z>
;<z>
path.substring(dotIndex + 1);<z>
("targetBeanName", beanName);<z>
.addPropertyValue("propertyPath", propertyPath);<z>
{<z>
for (String prefix : this.prefixes) {<z>
)) {<z>
;<z>
false;<z>
{<z>
.getRequestAttributes();<z>
state(attrs instanceof ServletRequestAttributes, "No current ServletRequestAttributes");<z>
getRequest();<z>
Nullable Map<String, ?> attributes) {<z>
(attributes != null) {<z>
-> {<z>
(key)) {<z>
);<z>
});<z>
return this;<z>
HandlerMethod createWithResolvedBean() {<z>
handler = this.bean;<z>
{<z>
this.beanFactory != null, "Cannot resolve bean name without BeanFactory");<z>
String beanName = (String) this.bean;<z>
= this.beanFactory.getBean(beanName);<z>
new HandlerMethod(this, handler);<z>
setup() {<z>
this.factory = new DefaultListableBeanFactory();<z>
XmlBeanDefinitionReader(this.factory).loadBeanDefinitions(<z>
(ConcurrentBeanFactoryBenchmark.class, "context.xml"));<z>
factory.addPropertyEditorRegistrar(<z>
,<z>
false)));<z>
HttpServletRequest servletRequest,<z>
servletResponse, Context context) throws ServletException, IOException {<z>
servletRequest);<z>
serverResponse != null) {<z>
, servletResponse, context);<z>
else if (t instanceof ServletException) {<z>
throw (ServletException) t;<z>
{<z>
throw (IOException) t;<z>
(t);<z>
String schemaMappingsLocation) {<z>
);<z>
this.classLoader = classLoader;<z>
;<z>
next,<z>
queue) {<z>
queue);<z>
.hash = hash;<z>
next;<z>
() {<z>
this.subscriptions) {<z>
);<z>
Connection con) throws SQLException {<z>
getAutoCommitValue();<z>
!= autoCommit) {<z>
con.setAutoCommit(autoCommit);<z>
<Object> doSuspend(TransactionSynchronizationManager synchronizationManager,<z>
TransactionException {<z>
new TransactionSuspensionNotSupportedException(<z>
getName() + "] does not support transaction suspension");<z>
remove(Object key) {<z>
if (key instanceof String) {<z>
);<z>
(caseInsensitiveKey != null) {<z>
caseInsensitiveKey);<z>
return null;<z>
private Msg(<z>
.protobuf.CodedInputStream input,<z>
)<z>
{<z>
initFields();<z>
"unused")<z>
= 0;<z>
=<z>
);<z>
;<z>
{<z>
readTag();<z>
(tag) {<z>
0:<z>
;<z>
{<z>
(input, unknownFields,<z>
{<z>
true;<z>
: {<z>
;<z>
();<z>
: {<z>
.Builder subBuilder = null;<z>
) {<z>
;<z>
SecondMsg.PARSER, extensionRegistry);<z>
!= null) {<z>
;<z>
);<z>
bitField0_ |= 0x00000002;<z>
protobuf.InvalidProtocolBufferException e) {<z>
);<z>
e) {<z>
google.protobuf.InvalidProtocolBufferException(<z>
);<z>
finally {<z>
);<z>
makeExtensionsImmutable();<z>
int idleTaskExecutionCount) {<z>
=<z>
() > 1);<z>
(this.scheduledInvokers.size() <=<z>
;<z>
, A[] array) {<z>
>();<z>
(enumeration.hasMoreElements()) {<z>
.nextElement());<z>
toArray(array);<z>
) {<z>
(propertyName.charAt(1))) {<z>
propertyName;<z>
;<z>
getValidator(<z>
@Nullable Object source, ParserContext context) {<z>
hasAttribute("validator")) {<z>
messageBrokerElement.getAttribute("validator"));<z>
if (javaxValidationPresent) {<z>
RootBeanDefinition validatorDef = new RootBeanDefinition(<z>
;<z>
source);<z>
;<z>
(validatorDef);<z>
;<z>
(validatorName);<z>
null;<z>
private MetadataAwareAspectInstanceFactory createAspectInstanceFactory(<z>
String aspectName) {<z>
instanceFactory;<z>
.SINGLETON) {<z>
Object instance = getSingletonAspectInstance(aspectClass);<z>
, aspectName);<z>
);<z>
;<z>
throws IOException {<z>
);<z>
= false;<z>
) {<z>
fileCheck = true;<z>
File fileToCheck = getFileForLastModifiedCheck();<z>
();<z>
0L || fileToCheck.exists()) {<z>
;<z>
ex) {<z>
();<z>
);<z>
.getLastModified();<z>
{<z>
new FileNotFoundException(getDescription() +<z>
);<z>
return lastModified;<z>
String destinationName) {<z>
().receive(destinationName);<z>
convertJmsMessage(jmsMessage);<z>
catch (JmsException ex) {<z>
throw convertJmsException(ex);<z>
) {<z>
.getClass(), genericInterface);<z>
{<z>
resolveTypeArgument(<z>
, genericInterface);<z>
.notNull(fieldType, () -> "Unable to extract the parameterized field type from " +<z>
instance.getClass().getName() +<z>
"]; does the class parameterize the <T> generic type?");<z>
return fieldType;<z>
{<z>
(expectedCount, "ExpectedCount is required");<z>
Assert.notNull(requestMatcher, "RequestMatcher is required");<z>
;<z>
requestMatchers.add(requestMatcher);<z>
value, ValueExtractor valueExtractor) {<z>
get(attributeIndex);<z>
, value, valueExtractor);<z>
public ContentCachingRequestWrapper(HttpServletRequest request) {<z>
super(request);<z>
contentLength = request.getContentLength();<z>
contentLength : 1024);<z>
this.contentCacheLimit = null;<z>
DefaultResourceTransformerChain(<z>
@Nullable List<ResourceTransformer> transformers) {<z>
notNull(resolverChain, "ResourceResolverChain is required");<z>
resolverChain = resolverChain;<z>
());<z>
new ArrayList<>(transformers));<z>
this.transformer = chain.transformer;<z>
this.nextChain = chain.nextChain;<z>
boolean equals(@Nullable Object other) {<z>
{<z>
return true;<z>
()) {<z>
false;<z>
other;<z>
headers) &&<z>
body));<z>
, final Label[] labels) {<z>
;<z>
flags &= ~Label.FLAG_DEBUG_ONLY;<z>
;<z>
{<z>
);<z>
.errors) {<z>
instanceof FieldError) {<z>
FieldError) objectError);<z>
.unmodifiableList(result);<z>
TransactionAttributeSourcePointcut() {<z>
TransactionAttributeSource getTransactionAttributeSource() {<z>
return transactionAttributeSource;<z>
headers) {<z>
()) {<z>
logger.trace("Emitting headers: " + headers);<z>
(headers));<z>
Nullable HttpServletRequest request, String requestPath,<z>
extends Resource> locations, ResourceResolverChain chain) {<z>
, requestPath, locations);<z>
null) {<z>
return resolved;<z>
(requestPath);<z>
== null) {<z>
;<z>
String candidateVersion = versionStrategy.extractVersion(requestPath);<z>
) {<z>
;<z>
= versionStrategy.removeVersion(requestPath, candidateVersion);<z>
, simplePath, locations);<z>
{<z>
;<z>
= versionStrategy.getResourceVersion(baseResource);<z>
(actualVersion)) {<z>
;<z>
(logger.isTraceEnabled()) {<z>
("Found resource for \"" + requestPath + "\", but version [" +<z>
"] does not match");<z>
null;<z>
SpelNodeImpl argument, String paramDesc) {<z>
);<z>
argument.generateCode(mv, cf);<z>
= cf.lastDescriptor();<z>
.state(lastDesc != null, "No last descriptor");<z>
CodeFlow.isPrimitive(lastDesc);<z>
) == 'L') {<z>
charAt(0));<z>
== 1 && !primitiveOnStack) {<z>
lastDesc);<z>
{<z>
);<z>
.exitCompilationScope();<z>
) throws EvaluationException {<z>
);<z>
state).getValue();<z>
toDescriptorFromObject(leftValue);<z>
(rightValue);<z>
leftValue, rightValue));<z>
HttpServerExchange exchange) {<z>
next) -> {<z>
);<z>
.proceed();<z>
);<z>
.set(c -> onDataAvailable());<z>
set(c -> onAllDataRead());<z>
.channel.resumeReads();<z>
,<z>
{<z>
]) newArray;<z>
i < newIntArray.length; i++) {<z>
getTypedValue(state);<z>
toInt(typeConverter, typedValue);<z>
void initSynchronization() throws IllegalStateException {<z>
)) {<z>
;<z>
new LinkedHashSet<>());<z>
TypeDescriptor sourceType, TypeDescriptor targetType) {<z>
source == null) {<z>
null;<z>
= (String) source;<z>
StringUtils.commaDelimitedListToStringArray(string);<z>
);<z>
createCollection(targetType.getType(),<z>
length);<z>
== null) {<z>
for (String field : fields) {<z>
(field.trim());<z>
fields) {<z>
, sourceType, elementDesc);<z>
targetElement);<z>
;<z>
) {<z>
)) {<z>
false;<z>
.getDeclaringClass();<z>
ClassLoader.class.isAssignableFrom(targetClass));<z>
{<z>
getType(), getMessageType());<z>
ex) {<z>
"Unable to encode websocket message using ConversionService", ex);<z>
SockJsServiceRegistration withSockJS() {<z>
();<z>
);<z>
) {<z>
.sockJsServiceRegistration.setInterceptors(interceptors);<z>
if (this.handshakeHandler != null) {<z>
);<z>
(transportHandler);<z>
()) {<z>
toStringArray(this.allowedOrigins));<z>
allowedOriginPatterns.isEmpty()) {<z>
setAllowedOriginPatterns(<z>
allowedOriginPatterns));<z>
;<z>
public WebTestClient.ResponseSpec reasonEquals(String reason) {<z>
();<z>
this.exchangeResult.assertWithDiagnostics(() -><z>
, reason, actual));<z>
responseSpec;<z>
sqlEx, boolean custom) {<z>
)) {<z>
custom ? "Custom translation of" : "Translating";<z>
" SQLException with SQL state '" + sqlEx.getSQLState() +<z>
+ sqlEx.getMessage() + "]" +<z>
"]");<z>
BeanDefinition parse(Element element, ParserContext context) {<z>
context.pushContainingComponent(<z>
;<z>
RuntimeBeanReference pathMatcherRef = null;<z>
element.hasAttribute("path-matcher")) {<z>
"path-matcher"));<z>
"ref", "interceptor");<z>
interceptor : interceptors) {<z>
(MappedInterceptor.class);<z>
(context.extractSource(interceptor));<z>
(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
> includePatterns = null;<z>
null;<z>
;<z>
equals(interceptor.getLocalName())) {<z>
includePatterns = getIncludePatterns(interceptor, "mapping");<z>
= getIncludePatterns(interceptor, "exclude-mapping");<z>
(0);<z>
beanElem, null);<z>
);<z>
);<z>
);<z>
, interceptorBean);<z>
null) {<z>
("pathMatcher", pathMatcherRef);<z>
).registerWithGeneratedName(mappedInterceptorDef);<z>
);<z>
.popAndRegisterContainingComponent();<z>
return null;<z>
(Object bean, String name) throws BeansException {<z>
{<z>
LifecycleBean) bean).postProcessAfterInit();<z>
bean;<z>
TransactionException {<z>
= getConnectionHolderForSavepoint();<z>
;<z>
) {<z>
);<z>
, ResponseCookie> getCookies() {<z>
;<z>
.getCookies().forEach(cookie -><z>
.getName(),<z>
getName(), cookie.getValue())<z>
getDomain())<z>
))<z>
cookie))<z>
.secure(cookie.isSecure())<z>
))<z>
("samesite"))<z>
.build()));<z>
result;<z>
Class<?> clazz) {<z>
from(clazz, SearchStrategy.INHERITED_ANNOTATIONS)<z>
(annotationType)<z>
::isDirectlyPresent)<z>
(MergedAnnotation::missing)<z>
.getAggregateIndex() > 0;<z>
<? extends RestClientException>> statusMapping) {<z>
(!CollectionUtils.isEmpty(statusMapping)) {<z>
.putAll(statusMapping);<z>
(ResolvableType actualType,<z>
ServerHttpResponse response) {<z>
this.decoder instanceof HttpMessageDecoder) {<z>
(HttpMessageDecoder<?>) this.decoder;<z>
;<z>
Hints.none();<z>
byIndex, Map<String, Parameter> byName,<z>
, StatementFilterFunction filterFunction) {<z>
.byIndex = byIndex;<z>
.byName = byName;<z>
this.sqlSupplier = sqlSupplier;<z>
filterFunction = filterFunction;<z>
CacheParameterDetail(Method method, int parameterPosition) {<z>
= method.getParameterTypes()[parameterPosition];<z>
>();<z>
false;<z>
foundValueAnnotation = false;<z>
()[parameterPosition]) {<z>
annotation);<z>
))) {<z>
foundKeyAnnotation = true;<z>
.annotationType())) {<z>
;<z>
= parameterPosition;<z>
;<z>
.isValue = foundValueAnnotation;<z>
value) {<z>
endPos);<z>
TypedValue(value);<z>
;<z>
<?> clazz) {<z>
) {<z>
getKey().isAssignableFrom(clazz)) {<z>
;<z>
return Collections.emptyMap();<z>
payload, Type resolvedType, Writer writer) {<z>
instanceof ParameterizedType) {<z>
, resolvedType, writer);<z>
);<z>
) {<z>
ArrayList<>();<z>
{<z>
)) {<z>
String name = getNameForParameter(parameter);<z>
.getParameterType();<z>
(name, paramType)) {<z>
;<z>
return result;<z>
{<z>
{<z>
start, end));<z>
);<z>
(String sessionId) {<z>
{<z>
)).get(sessionId);<z>
(TransferSimpSession session : this.sessions) {<z>
{<z>
session;<z>
null;<z>
) {<z>
ResponseBodyFlushProcessor flushProcessor = bodyFlushProcessor;<z>
;<z>
) {<z>
);<z>
if (processor != null) {<z>
;<z>
);<z>
(ex);<z>
{<z>
if (peekIdentifierToken("new")) {<z>
);<z>
(peekToken(TokenKind.RSQUARE)) {<z>
.startPos, newToken.endPos));<z>
;<z>
;<z>
new ArrayList<>();<z>
(possiblyQualifiedConstructorName);<z>
{<z>
>();<z>
(TokenKind.LSQUARE, true)) {<z>
TokenKind.RSQUARE)) {<z>
.add(eatExpression());<z>
.add(null);<z>
eatToken(TokenKind.RSQUARE);<z>
(maybeEatInlineListOrMap()) {<z>
nodes.add(pop());<z>
endPos,<z>
);<z>
;<z>
)));<z>
return true;<z>
return false;<z>
.AFTER_METHOD;<z>
() default ClassMode.AFTER_CLASS;<z>
hierarchyMode() default HierarchyMode.EXHAUSTIVE;<z>
enum MethodMode {<z>
) {<z>
;<z>
.values.put(paramName, value);<z>
(value instanceof SqlParameterValue) {<z>
());<z>
return this;<z>
void silentClose(CloseStatus status) {<z>
(status);<z>
Throwable ex) {<z>
(logger.isWarnEnabled()) {<z>
"Failed to close " + this, ex);<z>
(boolean restrictDefaultSupportedMethods) {<z>
restrictDefaultSupportedMethods) {<z>
(4);<z>
.add(METHOD_GET);<z>
this.supportedMethods.add(METHOD_HEAD);<z>
);<z>
();<z>
String>> extractor) {<z>
null;<z>
for (MediaTypeFileExtensionResolver resolver : this.resolvers) {<z>
apply(resolver);<z>
)) {<z>
;<z>
: extensions) {<z>
(!result.contains(extension)) {<z>
;<z>
;<z>
() {<z>
null) {<z>
close();<z>
{<z>
.debug("Could not close JMX connector", ex);<z>
(WritingFileState newState) {<z>
;<z>
newState)) {<z>
;<z>
(this.completed) {<z>
);<z>
MultipartUtils.closeChannel(newState.channel);<z>
.forEach(DataBufferUtils::release);<z>
Type type) {<z>
equals("?")) {<z>
value = "*";<z>
;<z>
void addCc(InternetAddress cc) throws MessagingException {<z>
.notNull(cc, "Cc address must not be null");<z>
;<z>
cc);<z>
{<z>
assertPositions(firstPos, lastPos);<z>
this.firstPos = firstPos;<z>
;<z>
throws SQLException {<z>
doGetConnection(username, password);<z>
();<z>
!= null) {<z>
;<z>
);<z>
if (isolationLevelToUse != null) {<z>
.setTransactionIsolation(isolationLevelToUse);<z>
con;<z>
String name,<z>
Class<? extends Annotation>... qualifiers) {<z>
, null, null);<z>
throws ObjectStreamException {<z>
null) {<z>
new SerializedBeanFactoryReference(this.serializationId);<z>
;<z>
boolean shouldWrap,<z>
> hints) {<z>
? ServerSentEvent.builder() : null;<z>
null;<z>
= null;<z>
for (String line : lines) {<z>
if (line.startsWith("data:")) {<z>
: new StringBuilder());<z>
5) != ' ') {<z>
5, line.length());<z>
));<z>
;<z>
(shouldWrap) {<z>
if (line.startsWith("id:")) {<z>
.trim());<z>
) {<z>
trim());<z>
{<z>
trim())));<z>
(":")) {<z>
));<z>
trim()).append('\n');<z>
null);<z>
{<z>
{<z>
);<z>
(decodedData != null) {<z>
(decodedData);<z>
build();<z>
decodedData;<z>
@Nullable Object payload) {<z>
.updateSimpMessageHeadersFromStompHeaders();<z>
message;<z>
.isEmpty(payload)) {<z>
.getMessageHeaders());<z>
));<z>
updateStompHeadersFromSimpMessageHeaders();<z>
if (message == null) {<z>
throw new MessageConversionException("Unable to convert payload with type='" +<z>
) + "', contentType='" + accessor.getContentType() +<z>
;<z>
message;<z>
(Element element, ParserContext parserContext) {<z>
CompositeComponentDefinition compositeDef =<z>
, parserContext.extractSource(element));<z>
);<z>
, element);<z>
DomUtils.getChildElements(element);<z>
Element elt: childElts) {<z>
.getLocalName(elt);<z>
(localName)) {<z>
elt, parserContext);<z>
)) {<z>
;<z>
ASPECT.equals(localName)) {<z>
(elt, parserContext);<z>
;<z>
;<z>
handler, Method method) {<z>
{<z>
HandlerMethod(beanName,<z>
.getAutowireCapableBeanFactory(),<z>
obtainApplicationContext(),<z>
;<z>
;<z>
> successCallback, final FailureCallback failureCallback) {<z>
;<z>
(new ListenableFutureCallback<S>() {<z>
result) {<z>
;<z>
{<z>
result);<z>
) {<z>
.getCause();<z>
cause : ex);<z>
ex) {<z>
);<z>
;<z>
public void onFailure(Throwable ex) {<z>
;<z>
);<z>
cacheOperationSource, KeyGenerator target) {<z>
;<z>
target, "KeyGenerator must not be null");<z>
this.cacheOperationSource = cacheOperationSource;<z>
target;<z>
getDefaultValue(<z>
Nullable String attributeName) {<z>
!StringUtils.hasText(attributeName)) {<z>
;<z>
null);<z>
parameter, NativeWebRequest request) throws Exception {<z>
.getHeaderValues(name);<z>
if (headerValues != null) {<z>
1 ? headerValues[0] : headerValues);<z>
;<z>
, String beanName) {<z>
(beanName, "Bean name must not be null");<z>
metadata;<z>
.getClassName());<z>
beanName = beanName;<z>
public WebTestClient.ResponseSpec doesNotExist(String name) {<z>
.getFirst(name);<z>
) {<z>
;<z>
AssertionErrors.fail(message));<z>
responseSpec;<z>
> source, SortDefinition sortDefinition) throws BeansException {<z>
(sortDefinition.getProperty())) {<z>
new PropertyComparator<>(sortDefinition));<z>
{<z>
findMergedAnnotation(element, MessageMapping.class);<z>
length > 0) {<z>
return new CompositeMessageCondition(<z>
EMPTY_CONDITION,<z>
);<z>
(element, ConnectMapping.class);<z>
if (ann2 != null) {<z>
= processDestinations(ann2.value());<z>
new CompositeMessageCondition(<z>
CONNECT_CONDITION,<z>
DestinationPatternsMessageCondition(patterns, obtainRouteMatcher()));<z>
null;<z>
) {<z>
);<z>
;<z>
.append(this.unless);<z>
;<z>
sb;<z>
) {<z>
ScheduledThreadPoolExecutor) {<z>
);<z>
= flag;<z>
{<z>
== 42) {<z>
return new Person("Dilbert");<z>
("Wally");<z>
boolean isWeak) throws IOException {<z>
37);<z>
if (isWeak) {<z>
"W/");<z>
.append("\"0");<z>
);<z>
('"');<z>
.toString();<z>
forExecutable(Executable executable, int parameterIndex) {<z>
instanceof Method) {<z>
executable, parameterIndex);<z>
else if (executable instanceof Constructor) {<z>
executable, parameterIndex);<z>
IllegalArgumentException("Not a Method/Constructor: " + executable);<z>
) {<z>
expandUriComponent(getScheme(), uriVariables);<z>
getSchemeSpecificPart(), uriVariables);<z>
uriVariables);<z>
expandedFragment);<z>
static String initSessionId(SSLSession session) {<z>
session.getId();<z>
) {<z>
null;<z>
;<z>
for (byte b : bytes) {<z>
String digit = Integer.toHexString(b);<z>
length() < 2) {<z>
'0');<z>
) {<z>
2);<z>
(digit);<z>
return sb.toString();<z>
) {<z>
boolean success = super.remove(o);<z>
{<z>
;<z>
;<z>
, long timeout) {<z>
;<z>
messageToUse = message;<z>
chain = new ChannelInterceptorChain();<z>
boolean sent = false;<z>
);<z>
== null) {<z>
return false;<z>
timeout);<z>
);<z>
sent, null);<z>
return sent;<z>
(Exception ex) {<z>
, sent, ex);<z>
MessagingException) {<z>
) ex;<z>
);<z>
err) {<z>
MessageDeliveryException ex2 =<z>
, "Failed to send message to " + this, err);<z>
;<z>
ex2;<z>
{<z>
);<z>
value == null) {<z>
methodParam = descriptor.getMethodParameter();<z>
null) {<z>
getMethodAnnotations());<z>
;<z>
void start() {<z>
lifecycleMonitor) {<z>
.clientInboundChannel.subscribe(this);<z>
.brokerChannel.subscribe(this);<z>
;<z>
) throws IOException {<z>
;<z>
)) {<z>
null;<z>
getContentType(responseWrapper);<z>
messageConverters) {<z>
instanceof GenericHttpMessageConverter) {<z>
?> genericMessageConverter =<z>
GenericHttpMessageConverter<?>) messageConverter;<z>
) {<z>
{<z>
);<z>
"]");<z>
, null, responseWrapper);<z>
null) {<z>
, contentType)) {<z>
if (logger.isDebugEnabled()) {<z>
className = this.responseClass.getName();<z>
);<z>
;<z>
{<z>
throw new RestClientException("Error while extracting response for type [" +<z>
, ex);<z>
this.responseType, contentType,<z>
(), responseWrapper.getStatusText(),<z>
, getResponseBody(responseWrapper));<z>
dayOfWeek,<z>
{<z>
count = 0;<z>
int max = 366;<z>
&& count++ < max) {<z>
add(Calendar.DAY_OF_MONTH, 1);<z>
.DAY_OF_MONTH);<z>
(Calendar.DAY_OF_WEEK);<z>
(calendar, resets);<z>
>= max) {<z>
this.expression + "\"");<z>
dayOfMonth;<z>
parseScope(Element element, ClassPathBeanDefinitionScanner scanner) {<z>
SCOPE_RESOLVER_ATTRIBUTE)) {<z>
hasAttribute(SCOPED_PROXY_ATTRIBUTE)) {<z>
new IllegalArgumentException(<z>
);<z>
scopeMetadataResolver = (ScopeMetadataResolver) instantiateUserDefinedStrategy(<z>
(SCOPE_RESOLVER_ATTRIBUTE), ScopeMetadataResolver.class,<z>
getResourceLoader().getClassLoader());<z>
(scopeMetadataResolver);<z>
.hasAttribute(SCOPED_PROXY_ATTRIBUTE)) {<z>
String mode = element.getAttribute(SCOPED_PROXY_ATTRIBUTE);<z>
) {<z>
);<z>
mode)) {<z>
;<z>
"no".equals(mode)) {<z>
.setScopedProxyMode(ScopedProxyMode.NO);<z>
);<z>
, RequestMappingInfo mappingInfo) {<z>
(handler, method);<z>
?> beanType = handlerMethod.getBeanType();<z>
.class);<z>
, CrossOrigin.class);<z>
{<z>
null;<z>
config = new CorsConfiguration();<z>
typeAnnotation);<z>
(config, methodAnnotation);<z>
())) {<z>
getMethodsCondition().getMethods()) {<z>
allowedMethod.name());<z>
config.applyPermitDefaultValues();<z>
() throws SAXException {<z>
) != null) {<z>
.endDocument();<z>
{<z>
uriVariables);<z>
this.endpoint = null;<z>
<>(endpointClass);<z>
(ServerRequest serverRequest) {<z>
nest(serverRequest)<z>
.map(nestedRequest -> {<z>
)) {<z>
;<z>
predicate));<z>
.route(nestedRequest)<z>
(match -> {<z>
!= serverRequest) {<z>
serverRequest.attributes().clear();<z>
.attributes()<z>
));<z>
});<z>
);<z>
> ctor) {<z>
getParameterTypes();<z>
StringBuilder sb = new StringBuilder();<z>
('(');<z>
(Class<?> param : params) {<z>
);<z>
);<z>
();<z>
path) throws IOException {<z>
(path)) {<z>
);<z>
;<z>
Marshaller marshaller) throws JAXBException {<z>
null) {<z>
.marshallerProperties.entrySet()) {<z>
);<z>
marshallerListener != null) {<z>
.marshallerListener);<z>
!= null) {<z>
.setEventHandler(this.validationEventHandler);<z>
if (this.adapters != null) {<z>
: this.adapters) {<z>
.setAdapter(adapter);<z>
this.schema != null) {<z>
schema);<z>
<?> valueType) {<z>
;<z>
valueType, "Value type must not be null");<z>
NullBinding(marker, valueType));<z>
;<z>
isActive() {<z>
lifecycleMonitor) {<z>
active;<z>
targetType) {<z>
) {<z>
;<z>
source;<z>
sourceCollection.isEmpty()) {<z>
"";<z>
DELIMITER);<z>
: sourceCollection) {<z>
(<z>
);<z>
));<z>
);<z>
extends RestClientException> exceptionClass,<z>
IOException {<z>
exceptionClass == null) {<z>
<? extends RestClientException> extractor =<z>
;<z>
;<z>
null) {<z>
;<z>
public void changeLocale(Locale locale) {<z>
;<z>
) {<z>
"Cannot change locale if no LocaleResolver configured");<z>
.response, locale);<z>
;<z>
) {<z>
!this.active.get()) {<z>
.closed.get()) {<z>
) + " has been closed already");<z>
;<z>
beforeMockMvcCreated(<z>
ConfigurableMockMvcBuilder<?> builder, WebApplicationContext context) {<z>
;<z>
, String httpMethod) throws IOException {<z>
>= 0) {<z>
.setConnectTimeout(this.connectTimeout);<z>
{<z>
(this.readTimeout);<z>
mayWrite =<z>
equals(httpMethod) ||<z>
httpMethod));<z>
(true);<z>
"GET".equals(httpMethod));<z>
(mayWrite);<z>
(httpMethod);<z>
>> int compare(<z>
{<z>
T) second, message);<z>
nullSafeToString(@Nullable long[] array) {<z>
{<z>
;<z>
int length = array.length;<z>
0) {<z>
EMPTY_ARRAY;<z>
StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);<z>
long l : array) {<z>
(l));<z>
stringJoiner.toString();<z>
unmarshalFromBytesMessage(BytesMessage message, Unmarshaller unmarshaller)<z>
XmlMappingException {<z>
()];<z>
.readBytes(bytes);<z>
ByteArrayInputStream(bytes);<z>
;<z>
(source);<z>
, SimpSession> map) {<z>
for (SimpSession session : this.sessions) {<z>
(), session);<z>
@Nullable String... locations) {<z>
new UnsupportedOperationException(<z>
;<z>
() {<z>
{<z>
(index != -1) {<z>
true;<z>
.isEmpty()) {<z>
return true;<z>
.conventionMappings) {<z>
1) {<z>
return true;<z>
)) {<z>
();<z>
; i++) {<z>
attributeMethods.get(i);<z>
();<z>
)) {<z>
> annotationType =<z>
type : type.getComponentType());<z>
(0);<z>
mapping.isSynthesizable()) {<z>
true;<z>
false;<z>
(Database database) {<z>
database) {<z>
;<z>
Derby;<z>
: return TargetDatabase.HANA;<z>
return TargetDatabase.HSQL;<z>
case INFORMIX: return TargetDatabase.Informix;<z>
: return TargetDatabase.MySQL;<z>
case ORACLE: return TargetDatabase.Oracle;<z>
case POSTGRESQL: return TargetDatabase.PostgreSQL;<z>
TargetDatabase.SQLServer;<z>
return TargetDatabase.Sybase;<z>
;<z>
String schemaLanguage) throws IOException, SAXException, ParserConfigurationException {<z>
logger.isDebugEnabled()) {<z>
debug("Setting validation schema to " +<z>
;<z>
(resources, "No resources given");<z>
, "No schema language provided");<z>
Source[resources.length];<z>
);<z>
(true);<z>
);<z>
);<z>
xmlReader = saxParser.getXMLReader();<z>
) {<z>
[i];<z>
) -> "Resource does not exist: " + resource);<z>
(resource);<z>
= new SAXSource(xmlReader, inputSource);<z>
);<z>
) {<z>
(this.schemaResourceResolver);<z>
newSchema(schemaSources);<z>
protected String resolveUrlPathInternal(String resourceUrlPath,<z>
locations, ResourceResolverChain chain) {<z>
);<z>
{<z>
.session = session;<z>
(session instanceof MockHttpSession) {<z>
= ((MockHttpSession) session);<z>
();<z>
IllegalStateException {<z>
());<z>
&& !dest.exists()) {<z>
newOutputStream(dest.toPath()));<z>
public RequestMappingInfo combine(RequestMappingInfo other) {<z>
(other);<z>
(other.patternsCondition);<z>
other.methodsCondition);<z>
.paramsCondition.combine(other.paramsCondition);<z>
.headersCondition);<z>
consumesCondition.combine(other.consumesCondition);<z>
.producesCondition);<z>
);<z>
new RequestMappingInfo(name, patterns,<z>
);<z>
) {<z>
16];<z>
.nextBytes(randomBytes);<z>
mostSigBits = 0;<z>
i++) {<z>
i] & 0xff);<z>
= 0;<z>
8; i < 16; i++) {<z>
& 0xff);<z>
UUID(mostSigBits, leastSigBits);<z>
protected int detectValidationMode(Resource resource) {<z>
if (resource.isOpen()) {<z>
new BeanDefinitionStoreException(<z>
"] contains an open stream: " +<z>
;<z>
InputStream inputStream;<z>
= resource.getInputStream();<z>
) {<z>
throw new BeanDefinitionStoreException(<z>
"]: cannot open InputStream. " +<z>
;<z>
(inputStream);<z>
ex) {<z>
new BeanDefinitionStoreException("Unable to determine validation mode for [" +<z>
+ "]: an error occurred whilst reading from the InputStream.", ex);<z>
WebClientResponseException(int statusCode, String statusText,<z>
Nullable Charset charset) {<z>
, body, charset, null);<z>
parameter, @Nullable ModelAndViewContainer mavContainer,<z>
WebDataBinderFactory binderFactory)<z>
{<z>
webRequest);<z>
= getHttpEntityType(parameter);<z>
== null) {<z>
) +<z>
getMethod() + " is not parameterized");<z>
, parameter, paramType);<z>
== parameter.getParameterType()) {<z>
,<z>
inputMessage.getURI());<z>
inputMessage.getHeaders());<z>
{<z>
annotationFilter == AnnotationFilter.ALL) {<z>
.empty();<z>
.stream(spliterator(), false);<z>
(Class<?> declaringClass) {<z>
notNull(declaringClass, "Declaring class must not be null");<z>
;<z>
) {<z>
if (isDefaultConfigurationClassCandidate(candidate)) {<z>
candidate);<z>
(logger.isDebugEnabled()) {<z>
.debug(String.format(<z>
);<z>
configClasses.isEmpty()) {<z>
logger.isInfoEnabled()) {<z>
.info(String.format("Could not detect default configuration classes for test class [%s]: " +<z>
getSimpleName()));<z>
;<z>
registerSubscriptions(String sessionId, String destination) {<z>
.equals(this.specialization)) {<z>
destination = "/**/" + destination;<z>
incrementAndGet();<z>
);<z>
public RequestPartServletServerHttpRequest(HttpServletRequest request, String requestPartName)<z>
{<z>
super(request);<z>
);<z>
;<z>
this.multipartRequest.getMultipartHeaders(requestPartName);<z>
null) {<z>
new MissingServletRequestPartException(requestPartName);<z>
multipartHeaders;<z>
) {<z>
off) {<z>
;<z>
else if (len == 0) {<z>
0;<z>
) {<z>
;<z>
) {<z>
.nextIndexInCurrentBuffer);<z>
;<z>
+= bytesToCopy;<z>
this.nextIndexInCurrentBuffer += bytesToCopy;<z>
;<z>
Math.max(remaining, 0);<z>
()) {<z>
next();<z>
updateCurrentBufferLength();<z>
.nextIndexInCurrentBuffer = 0;<z>
.currentBuffer = null;<z>
off, len);<z>
fc, @Nullable FieldFilter ff) {<z>
Class<?> targetClass = clazz;<z>
fields = getDeclaredFields(targetClass);<z>
(Field field : fields) {<z>
{<z>
;<z>
{<z>
() + "': " + ex);<z>
.getSuperclass();<z>
;<z>
supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {<z>
();<z>
;<z>
extensionContext.getRequiredTestClass();<z>
propertyName -><z>
null);<z>
||<z>
isAssignableFrom(parameter.getType()) ||<z>
parameterContext) ||<z>
()));<z>
keepAliveSeconds) {<z>
this.poolSizeMonitor) {<z>
!= null) {<z>
SECONDS);<z>
keepAliveSeconds = keepAliveSeconds;<z>
String beanName, Object beanInstance) throws BeansException {<z>
(!(beanInstance instanceof FactoryBean)) {<z>
,<z>
"] is not a FactoryBean");<z>
FactoryBean<?>) beanInstance;<z>
) throws DataAccessException {<z>
executeWithNativeSession(session -> {<z>
;<z>
null;<z>
);<z>
() throws ClassNotFoundException {<z>
(this.source instanceof Class) {<z>
>) this.source;<z>
().getClassName();<z>
);<z>
(@Nullable Object obj) {<z>
) {<z>
true;<z>
Optional) {<z>
>) obj).isPresent();<z>
obj instanceof CharSequence) {<z>
obj).length() == 0;<z>
getClass().isArray()) {<z>
;<z>
Collection) {<z>
();<z>
(obj instanceof Map) {<z>
.isEmpty();<z>
false;<z>
headersConsumer) {<z>
(headersConsumer, "'headersConsumer' must not be null");<z>
;<z>
this;<z>
(String url, Object[] vars) {<z>
url, "'url' must not be null");<z>
+<z>
+ url);<z>
).toUri();<z>
(ConfigurableWebApplicationContext wac, ServletContext sc) {<z>
(wac.getId())) {<z>
getInitParameter(CONTEXT_ID_PARAM);<z>
idParam != null) {<z>
(idParam);<z>
.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +<z>
);<z>
;<z>
;<z>
) {<z>
setConfigLocation(configLocationParam);<z>
();<z>
) {<z>
;<z>
;<z>
wac.refresh();<z>
array) {<z>
(array)) {<z>
return array;<z>
array);<z>
return array;<z>
protected void addResponseBodyAdvice(RootBeanDefinition beanDef) {<z>
if (jackson2Present) {<z>
,<z>
));<z>
<ConsumeMediaTypeExpression> getMatchingExpressions(MediaType contentType) {<z>
;<z>
.expressions) {<z>
match(contentType)) {<z>
>();<z>
);<z>
;<z>
(<z>
keyColumnNames)<z>
throws DataAccessException {<z>
(sql, paramSource, pscf -> {<z>
null) {<z>
setGeneratedKeysColumnNames(keyColumnNames);<z>
(true);<z>
});<z>
generatedKeyHolder);<z>
public WebMvcStompWebSocketEndpointRegistration(<z>
sockJsTaskScheduler) {<z>
"No paths specified");<z>
webSocketHandler, "WebSocketHandler must not be null");<z>
paths = paths;<z>
= webSocketHandler;<z>
= sockJsTaskScheduler;<z>
) {<z>
null) {<z>
value);<z>
static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry) {<z>
(registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {<z>
registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);<z>
add("proxyTargetClass", Boolean.TRUE);<z>
RequestConditionHolder getMatchingCondition(HttpServletRequest request) {<z>
null) {<z>
this;<z>
;<z>
(match) : null);<z>
, MethodParameter parameter,<z>
{<z>
class);<z>
servletRequest != null, "No HttpServletRequest");<z>
);<z>
(parameter.getNestedParameterType())) {<z>
;<z>
null) {<z>
(servletRequest, cookieValue.getValue());<z>
;<z>
boolean equals(@Nullable Object other) {<z>
{<z>
;<z>
)) {<z>
;<z>
) other;<z>
fullPath.equals(otherPath.fullPath) &&<z>
otherPath.contextPath) &&<z>
pathWithinApplication));<z>
className, ClassNotFoundException ex)<z>
throws IOException, ClassNotFoundException{<z>
throw ex;<z>
) throws ELException {<z>
{<z>
);<z>
;<z>
;<z>
cookie(String name, String... values) {<z>
String value : values) {<z>
));<z>
this;<z>
?> aspectClass, String aspectName) {<z>
, aspectName);<z>
.getAjType().isAspect()) {<z>
;<z>
;<z>
{<z>
Mono.fromCallable(() -> {<z>
buffer = bufferFactory.allocateBuffer();<z>
> entry : headers.entrySet()) {<z>
));<z>
headerValueString : entry.getValue()) {<z>
= headerValueString.getBytes(getCharset());<z>
.write(headerName);<z>
write((byte)':');<z>
);<z>
(headerValue);<z>
buffer.write((byte)'\r');<z>
buffer.write((byte)'\n');<z>
'\r');<z>
;<z>
buffer;<z>
);<z>
Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {<z>
this.annotationType);<z>
{<z>
(<z>
targetType);<z>
getObjectType());<z>
get(converterKey);<z>
) {<z>
annotationFormatterFactory.getParser(<z>
(), converterKey.getFieldType());<z>
.this);<z>
put(converterKey, converter);<z>
targetType);<z>
{<z>
(abstractType == UNINITIALIZED_THIS<z>
)) == UNINITIALIZED_KIND) {<z>
i) {<z>
initializations[i];<z>
DIM_MASK;<z>
KIND_MASK;<z>
initializedType & VALUE_MASK;<z>
kind == LOCAL_KIND) {<z>
[value];<z>
) {<z>
value];<z>
(abstractType == initializedType) {<z>
== UNINITIALIZED_THIS) {<z>
(symbolTable.getClassName());<z>
else {<z>
);<z>
;<z>
, CodeFlow cf) {<z>
this.name.equals(ROOT)) {<z>
);<z>
(ALOAD, 2);<z>
this.name);<z>
"lookupVariable", "(Ljava/lang/String;)Ljava/lang/Object;",true);<z>
(mv, this.exitTypeDescriptor);<z>
);<z>
, @Nullable Object key) {<z>
) {<z>
+ "]" : "entire cache") +<z>
" on method " + context.metadata.method);<z>
MethodParameter parameter) {<z>
).getSimpleName();<z>
new ServerWebInputException("Missing request header '" + name + "' " +<z>
type, parameter);<z>
private void bindArgumentsByName(int numArgumentsExpectingToBind) {<z>
{<z>
).getParameterNames(this.aspectJAdviceMethod);<z>
this.argumentNames != null) {<z>
);<z>
this.aspectJAdviceMethod.getName() + "] " +<z>
numArgumentsExpectingToBind + " arguments to be bound by name, but " +<z>
"the argument names were not specified and could not be discovered.");<z>
getPathMatchResult() {<z>
) {<z>
.EMPTY;<z>
);<z>
public MockMultipartFile(<z>
{<z>
Assert.hasLength(name, "Name must not be empty");<z>
name;<z>
);<z>
contentType;<z>
[0]);<z>
protected Builder newBuilderForType(<z>
BuilderParent parent) {<z>
Builder(parent);<z>
builder;<z>
public CompositeUriComponentsContributor mvcUriComponentsContributor(<z>
("mvcConversionService") FormattingConversionService conversionService,<z>
{<z>
new CompositeUriComponentsContributor(<z>
, conversionService);<z>
, DateTimeFormatter formatter,<z>
fallbackPatterns, @Nullable Object source) {<z>
temporalAccessorType = temporalAccessorType;<z>
this.formatter = formatter;<z>
.fallbackPatterns = fallbackPatterns;<z>
source;<z>
getDetailedPayloadLogMessage(@Nullable Object payload) {<z>
instanceof String) {<z>
+ payload;<z>
[] bytes) {<z>
{<z>
getCharset());<z>
;<z>
+ payload;<z>
, @Nullable Object right) {<z>
) {<z>
(leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {<z>
, BigDecimal.class);<z>
;<z>
0);<z>
leftNumber instanceof Double || rightNumber instanceof Double) {<z>
());<z>
(leftNumber instanceof Float || rightNumber instanceof Float) {<z>
== rightNumber.floatValue());<z>
(leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {<z>
leftNumber, BigInteger.class);<z>
class);<z>
compareTo(rightBigInteger) == 0);<z>
) {<z>
== rightNumber.longValue());<z>
leftNumber instanceof Integer || rightNumber instanceof Integer) {<z>
() == rightNumber.intValue());<z>
leftNumber instanceof Short || rightNumber instanceof Short) {<z>
== rightNumber.shortValue());<z>
(leftNumber instanceof Byte || rightNumber instanceof Byte) {<z>
() == rightNumber.byteValue());<z>
());<z>
right instanceof CharSequence) {<z>
());<z>
instanceof Boolean) {<z>
);<z>
(left, right)) {<z>
true;<z>
{<z>
0;<z>
;<z>
handshakeHeaders,<z>
handler, Object... uriVariables) {<z>
, null, handler, uriVariables);<z>
void prepareCriteria(Criteria criteria) {<z>
{<z>
setCacheable(true);<z>
() != null) {<z>
criteria.setCacheRegion(getQueryCacheRegion());<z>
if (getFetchSize() > 0) {<z>
setFetchSize(getFetchSize());<z>
0) {<z>
criteria.setMaxResults(getMaxResults());<z>
ResourceHolderSupport sessionHolder =<z>
) TransactionSynchronizationManager.getResource(obtainSessionFactory());<z>
)) {<z>
(sessionHolder.getTimeToLiveInSeconds());<z>
Object target) {<z>
) {<z>
ann : parameter.getParameterAnnotations()) {<z>
getAnnotation(ann, Validated.class);<z>
startsWith("Valid")) {<z>
));<z>
);<z>
BeanPropertyBindingResult bindingResult =<z>
(target, getParameterName(parameter));<z>
validationHints) && this.validator instanceof SmartValidator) {<z>
(target, bindingResult, validationHints);<z>
validator.validate(target, bindingResult);<z>
(bindingResult.hasErrors()) {<z>
, bindingResult);<z>
ProtobufFormatSupport formatSupport,<z>
Nullable ExtensionRegistry extensionRegistry) {<z>
TEXT_PLAIN);<z>
(formatSupport != null) {<z>
protobufFormatSupport = formatSupport;<z>
).getClassLoader())) {<z>
null);<z>
null;<z>
) {<z>
.protobufFormatSupport.supportedMediaTypes());<z>
newInstance() : extensionRegistry);<z>
throws MalformedURLException {<z>
);<z>
null;<z>
this.resourceLoader.getResource(resourceLocation);<z>
.exists()) {<z>
return null;<z>
();<z>
MalformedURLException ex) {<z>
ex;<z>
IOException ex) {<z>
isDebugEnabled()) {<z>
debug("Could not get URL for resource " +<z>
: resourceLocation), ex);<z>
;<z>
{<z>
{<z>
.source, this.annotations);<z>
;<z>
!= null && this.searchStrategy != null) {<z>
element, this.searchStrategy, processor);<z>
;<z>
Object source) {<z>
(element, "stomp-broker-relay");<z>
("user-registry-broadcast"));<z>
(multiServer) {<z>
= new RootBeanDefinition(DefaultSimpUserRegistry.class);<z>
new RootBeanDefinition(MultiServerUserRegistry.class);<z>
.addIndexedArgumentValue(0, localRegistryBeanDef);<z>
, source);<z>
return new RuntimeBeanReference(beanName);<z>
beanDef = new RootBeanDefinition(DefaultSimpUserRegistry.class);<z>
source);<z>
new RuntimeBeanReference(beanName);<z>
scriptSource) {<z>
(this.scriptClassMonitor) {<z>
.wasModifiedForTypeCheck);<z>
boolean isCompilable() {<z>
{<z>
(this.exitTypeDescriptor != null);<z>
(this.indexedType == IndexedType.LIST) {<z>
].isCompilable();<z>
MAP) {<z>
children[0].isCompilable());<z>
this.indexedType == IndexedType.OBJECT) {<z>
.cachedReadAccessor != null &&<z>
ReflectivePropertyAccessor.OptimalPropertyAccessor &&<z>
);<z>
return false;<z>
String> stereotypes, Element element,<z>
{<z>
(annotation)) {<z>
(element));<z>
);<z>
{<z>
(FactoryBean.OBJECT_TYPE_ATTRIBUTE);<z>
) {<z>
;<z>
Class) {<z>
attribute);<z>
ResolvableType.NONE;<z>
{<z>
);<z>
Unpooled.EMPTY_BUFFER) {<z>
dataBuffer);<z>
;<z>
<?> config,<z>
Annotated annotated, Class<?> implClass) {<z>
.beanFactory.createBean(implClass);<z>
ModelAndView getModelAndView(MvcResult mvcResult) {<z>
;<z>
, mav);<z>
mav;<z>
parserContext) {<z>
;<z>
String txAdvisorBeanName = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME;<z>
).containsBeanDefinition(txAdvisorBeanName)) {<z>
parserContext.extractSource(element);<z>
new RootBeanDefinition(<z>
);<z>
setSource(eleSource);<z>
;<z>
).registerWithGeneratedName(sourceDef);<z>
class);<z>
.setSource(eleSource);<z>
setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
registerTransactionManager(element, interceptorDef);<z>
sourceName));<z>
).registerWithGeneratedName(interceptorDef);<z>
.class);<z>
setSource(eleSource);<z>
.ROLE_INFRASTRUCTURE);<z>
new RuntimeBeanReference(sourceName));<z>
add("adviceBeanName", interceptorName);<z>
.hasAttribute("order")) {<z>
"order", element.getAttribute("order"));<z>
);<z>
element.getTagName(), eleSource);<z>
));<z>
new BeanComponentDefinition(interceptorDef, interceptorName));<z>
BeanComponentDefinition(advisorDef, txAdvisorBeanName));<z>
.registerComponent(compositeDef);<z>
(XMLStreamWriter streamWriter) {<z>
StaxStreamHandler(streamWriter);<z>
);<z>
(handler);<z>
streamWriter = streamWriter;<z>
isLast) {<z>
.notNull(payload, "payload must not be null");<z>
this.payload = payload;<z>
;<z>
int hashCode() {<z>
nullSafeHashCode(this.methodName);<z>
;<z>
;<z>
{<z>
).get("interceptorNames");<z>
, "Missing 'interceptorNames' property");<z>
(interceptorName);<z>
content, Class<?> targetType) {<z>
, targetType);<z>
) {<z>
= "No value at JSON path \"" + this.expression + "\"";<z>
AssertionError(message, ex);<z>
public String toString() {<z>
;<z>
length; i++) {<z>
[i].getName());<z>
' ');<z>
[i]);<z>
this.pointcutParameterTypes.length) {<z>
;<z>
;<z>
(getExpression() != null) {<z>
);<z>
.append("<pointcut expression not set>");<z>
);<z>
namespaceMappings) {<z>
>(namespaceMappings.size());<z>
.forEach((prefix, namespaceUri) -><z>
)));<z>
result;<z>
contentId, File file) throws MessagingException {<z>
(file, "File must not be null");<z>
file);<z>
.setFileTypeMap(getFileTypeMap());<z>
;<z>
parseResourceResolversTransformers(boolean isAutoRegistration,<z>
resourceResolvers, ManagedList<Object> resourceTransformers,<z>
@Nullable Object source) {<z>
"resolvers");<z>
) {<z>
.getChildElements(resolversElement)) {<z>
beanElement.getLocalName())) {<z>
= parseVersionResolver(context, beanElement, source);<z>
versionResolverDef.setSource(source);<z>
add(versionResolverDef);<z>
{<z>
CssLinkResourceTransformer.class);<z>
cssLinkTransformerDef.setSource(source);<z>
.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
cssLinkTransformerDef);<z>
parsePropertySubElement(beanElement, null);<z>
.add(object);<z>
if (isAutoRegistration) {<z>
) {<z>
new RootBeanDefinition(WebJarsResourceResolver.class);<z>
;<z>
webJarsResolverDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
webJarsResolverDef);<z>
;<z>
;<z>
BeanDefinition.ROLE_INFRASTRUCTURE);<z>
pathResolverDef);<z>
, "transformers");<z>
(transformersElement != null) {<z>
"bean", "ref")) {<z>
().parsePropertySubElement(beanElement, null);<z>
add(object);<z>
(Method method, TransactionAttribute attr) {<z>
Assert.notNull(method, "Method must not be null");<z>
, "TransactionAttribute must not be null");<z>
(logger.isDebugEnabled()) {<z>
+ method + "] with attribute [" + attr + "]");<z>
!= null && attr instanceof DefaultTransactionAttribute dta) {<z>
this.embeddedValueResolver);<z>
;<z>
protected AbstractServerResponse(<z>
<String, ResponseCookie> cookies,<z>
{<z>
this.statusCode = statusCode;<z>
headers);<z>
new LinkedMultiValueMap<>(cookies));<z>
;<z>
element) {<z>
= new HashSet<>();<z>
() == ElementKind.PACKAGE) {<z>
;<z>
stereotypes;<z>
> getCookies() {<z>
();<z>
).values().stream()<z>
.flatMap(Collection::stream)<z>
name(),<z>
name(), cookie.value())<z>
domain())<z>
())<z>
cookie.maxAge())<z>
.isSecure())<z>
cookie.isHttpOnly())<z>
(cookie))<z>
);<z>
return CollectionUtils.unmodifiableMultiValueMap(result);<z>
model, ServerWebExchange exchange) {<z>
(BINDING_CONTEXT_ATTRIBUTE);<z>
() || value instanceof Collection ||<z>
.getClass())) {<z>
.getBindingResult();<z>
name, result);<z>
read() throws IOException {<z>
();<z>
-1) {<z>
.finished = true;<z>
data;<z>
) {<z>
.getPort() == -1) {<z>
.toLowerCase(Locale.ENGLISH);<z>
);<z>
;<z>
) {<z>
method.getParameterCount();<z>
new Object[argumentCount];<z>
= new DependencyDescriptor[argumentCount];<z>
(argumentCount);<z>
null, "No BeanFactory available");<z>
getTypeConverter();<z>
++) {<z>
, i);<z>
required);<z>
getClass());<z>
= currDesc;<z>
typeConverter);<z>
) {<z>
= null;<z>
] = arg;<z>
) {<z>
methodParam), ex);<z>
this) {<z>
) {<z>
null) {<z>
, arguments.length);<z>
);<z>
) == argumentCount) {<z>
();<z>
] paramTypes = method.getParameterTypes();<z>
paramTypes.length; i++) {<z>
= it.next();<z>
(beanFactory.containsBean(autowiredBeanName) &&<z>
paramTypes[i])) {<z>
i] = new ShortcutDependencyDescriptor(<z>
);<z>
= cachedMethodArguments;<z>
= null;<z>
this.cached = true;<z>
return arguments;<z>
{<z>
reader.getEventType()) {<z>
this.reader.getVersion();<z>
{<z>
xmlVersion = xmlVersion;<z>
reader.getCharacterEncodingScheme();<z>
contentHandler = getContentHandler();<z>
{<z>
= this.reader.getLocation();<z>
{<z>
() {<z>
() : -1);<z>
() {<z>
) : -1);<z>
String getPublicId() {<z>
.getPublicId() : null);<z>
{<z>
? location.getSystemId() : null);<z>
() {<z>
return xmlVersion;<z>
) {<z>
return encoding;<z>
;<z>
;<z>
{<z>
.isStandalone());<z>
(<z>
<TransactionSynchronization> synchronizations) throws TransactionException {<z>
.debug("Cannot register Spring after-completion synchronization with existing transaction - " +<z>
);<z>
STATUS_UNKNOWN);<z>
getSubscriptionName() {<z>
();<z>
(delegate != this && delegate instanceof SubscriptionNameProvider) {<z>
getSubscriptionName();<z>
);<z>
throws JMSException {<z>
;<z>
> entry : map.entrySet()) {<z>
);<z>
)) {<z>
MessageConversionException("Cannot convert non-String key of type [" +<z>
);<z>
.getValue());<z>
message;<z>
status) {<z>
, "Property 'redirectStatus' is required");<z>
), "Not a redirect status code");<z>
redirectStatus = status;<z>
String, ResponseCookie> getCookies() {<z>
result = new LinkedMultiValueMap<>();<z>
get(HttpHeaders.SET_COOKIE);<z>
if (cookieHeader != null) {<z>
.forEach(header -><z>
(),<z>
), cookie.getValue())<z>
))<z>
getPath())<z>
getMaxAge())<z>
))<z>
)<z>
(header))<z>
()))<z>
(result);<z>
) {<z>
wsSession.initializeNativeSession(session);<z>
this.wsSession);<z>
) {<z>
.wsSession, ex, logger);<z>
{<z>
).get(name);<z>
null;<z>
null) {<z>
paramValues.get(0) : paramValues);<z>
;<z>
void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,<z>
initialRequest) throws IOException {<z>
(initialRequest) {<z>
.openFrame());<z>
).isEmpty()) {<z>
flushCache();<z>
();<z>
protected Object doJtaSuspend(JtaTransactionObject txObject) throws SystemException {<z>
null) {<z>
(<z>
);<z>
return getTransactionManager().suspend();<z>
objectName) {<z>
;<z>
(target, "Target Map must not be null");<z>
target;<z>
) {<z>
name);<z>
!name.equals(actualName)) {<z>
"PropertySource '" + getName() + "' does not contain property '" + name +<z>
"'");<z>
return super.getProperty(actualName);<z>
unmarshalDomNode(Node node) throws XmlMappingException {<z>
streamReader;<z>
(node instanceof Document document) {<z>
this.nameCoder);<z>
(node instanceof Element element) {<z>
DomReader(element, this.nameCoder);<z>
("DOMSource contains neither Document nor Element");<z>
null);<z>
Element element, BeanDefinition def, boolean setBoth) {<z>
= element.getAttribute("cache-resolver");<z>
= StringUtils.hasText(name);<z>
{<z>
()));<z>
!hasText || setBoth) {<z>
getPropertyValues().add("cacheManager",<z>
));<z>
) {<z>
] globalAdvisorNames =<z>
Advisor.class);<z>
globalInterceptorNames =<z>
class);<z>
) {<z>
globalAdvisorNames.length + globalInterceptorNames.length);<z>
(String name : globalAdvisorNames) {<z>
(name.startsWith(prefix)) {<z>
(name));<z>
String name : globalInterceptorNames) {<z>
prefix)) {<z>
add(beanFactory.getBean(name));<z>
);<z>
beans) {<z>
addAdvisorOnChainCreation(bean);<z>
, Resource resource, ResourceTransformerChain transformerChain)<z>
{<z>
(request, resource);<z>
filename = resource.getFilename();<z>
equals(StringUtils.getFilenameExtension(filename)) ||<z>
EncodedResource) {<z>
;<z>
.getInputStream());<z>
bytes, DEFAULT_CHARSET);<z>
;<z>
: this.linkParsers) {<z>
.parse(content, links);<z>
{<z>
;<z>
= 0;<z>
writer = new StringWriter();<z>
linkContentChunkInfo : links) {<z>
, linkContentChunkInfo.getStart()));<z>
());<z>
null;<z>
{<z>
request);<z>
);<z>
null ? newLink : link);<z>
);<z>
index));<z>
DEFAULT_CHARSET));<z>
JAXBException {<z>
null) {<z>
)) {<z>
, entry.getValue());<z>
!= null) {<z>
unmarshaller.setListener(this.unmarshallerListener);<z>
!= null) {<z>
);<z>
!= null) {<z>
?> adapter : this.adapters) {<z>
.setAdapter(adapter);<z>
this.schema != null) {<z>
unmarshaller.setSchema(this.schema);<z>
(HttpServletRequest request, HttpServletResponse response,<z>
{<z>
.wrapIfNecessary(response, this.redirectStatus);<z>
);<z>
public ExtendedEntityManagerSynchronization(<z>
@Nullable PersistenceExceptionTranslator exceptionTranslator) {<z>
em);<z>
this.entityManager = em;<z>
.exceptionTranslator = exceptionTranslator;<z>
) {<z>
TransactionSynchronizationManager.getResource(this);<z>
scopedObjects != null) {<z>
destructionCallbacks.put(name, callback);<z>
) {<z>
(uriVariables.size());<z>
) -> {<z>
"");<z>
;<z>
);<z>
result;<z>
> ranges) {<z>
ranges, "Ranges Collection must not be empty");<z>
, BYTE_RANGE_PREFIX, "");<z>
HttpRange range : ranges) {<z>
;<z>
);<z>
void processRequest(HttpServletRequest request, HttpServletResponse response)<z>
, IOException {<z>
currentTimeMillis();<z>
Throwable failureCause = null;<z>
);<z>
localeContext = buildLocaleContext(request);<z>
RequestContextHolder.getRequestAttributes();<z>
response, previousAttributes);<z>
= WebAsyncUtils.getAsyncManager(request);<z>
());<z>
);<z>
;<z>
ex) {<z>
= ex;<z>
ex;<z>
Throwable ex) {<z>
;<z>
throw new NestedServletException("Request processing failed", ex);<z>
;<z>
requestAttributes != null) {<z>
requestCompleted();<z>
asyncManager);<z>
, failureCause);<z>
) {<z>
.isLoggingSuppressed(hints)) {<z>
LogFormatUtils.traceDebug(logger, traceOn -> {<z>
.formatValue(value, !traceOn);<z>
+ formatted + "]";<z>
);<z>
String name) {<z>
StringUtils.hasText(name)) {<z>
"'");<z>
= name;<z>
{<z>
= resolve();<z>
resolved == null) {<z>
EMPTY_TYPES_ARRAY;<z>
.interfaces;<z>
(interfaces == null) {<z>
] genericIfcs = resolved.getGenericInterfaces();<z>
[genericIfcs.length];<z>
i < genericIfcs.length; i++) {<z>
], this);<z>
;<z>
;<z>
>, ?, R[]> toAnnotationArray(<z>
]> generator) {<z>
synthesize()),<z>
);<z>
writeToInternal(<z>
, Context context) {<z>
.apply(request, response);<z>
) {<z>
{<z>
type : types) {<z>
{<z>
false;<z>
;<z>
) {<z>
notNull(superType, "Super type to check against must not be null");<z>
{<z>
, message);<z>
column) throws InvalidResultSetAccessException {<z>
resultSetMetaData.getColumnTypeName(column);<z>
{<z>
se);<z>
) {<z>
element, builder.getRawBeanDefinition());<z>
builder.addPropertyValue("sourceSet", parsedSet);<z>
= element.getAttribute("set-class");<z>
if (StringUtils.hasText(setClass)) {<z>
setClass);<z>
scope = element.getAttribute(SCOPE_ATTRIBUTE);<z>
(StringUtils.hasLength(scope)) {<z>
.setScope(scope);<z>
(<z>
, Throwable beginEx) {<z>
, suspendedResources);<z>
{<z>
;<z>
;<z>
;<z>
{<z>
this.cookies) {<z>
{<z>
;<z>
false;<z>
endpoint, String uriTemplate, Object... uriVariables) {<z>
(uriTemplate, uriVariables);<z>
"endpoint must not be null");<z>
endpoint;<z>
= null;<z>
ServletContext servletContext) {<z>
this.handshakeHandler instanceof ServletContextAware) {<z>
this.handshakeHandler).setServletContext(servletContext);<z>
(<z>
{<z>
instanceof ServletWebRequest servletWebRequest) {<z>
servletWebRequest.getResponse();<z>
&& response.isCommitted()) {<z>
logger.isWarnEnabled()) {<z>
"Async request timed out");<z>
;<z>
);<z>
void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {<z>
int registryId = System.identityHashCode(registry);<z>
.registriesPostProcessed.contains(registryId)) {<z>
throw new IllegalStateException(<z>
+ registry);<z>
) {<z>
(<z>
;<z>
registryId);<z>
);<z>
> readInputStream(<z>
inputStreamSupplier, DataBufferFactory bufferFactory, int bufferSize) {<z>
(inputStreamSupplier, "'inputStreamSupplier' must not be null");<z>
call()), bufferFactory, bufferSize);<z>
{<z>
this.propertyResolver == null) {<z>
propertyResolver = new StandardEnvironment();<z>
.propertyResolver.resolvePlaceholders(path) :<z>
;<z>
Mono<Void> afterCompletion(int status) {<z>
.holderActive) {<z>
{<z>
connectionFactory);<z>
holderActive = false;<z>
hasConnection()) {<z>
getConnection(), this.connectionFactory)<z>
;<z>
);<z>
});<z>
connectionHolder.reset();<z>
;<z>
getAttributeName(MethodParameter param) {<z>
class))<z>
)<z>
ModelAttribute::value)<z>
);<z>
, Matcher<? super T> matcher) {<z>
result -> {<z>
ModelAndView mav = getModelAndView(result);<z>
, matcher);<z>
theme) {<z>
.request);<z>
{<z>
);<z>
theme.getName() : null));<z>
theme = theme;<z>
close() {<z>
null) {<z>
close();<z>
applyStatusCode() {<z>
();<z>
status != null) {<z>
.setStatusCode(status);<z>
private void init() {<z>
) {<z>
IllegalStateException("Init already called");<z>
this.initCalled = true;<z>
public void removeAllListeners() {<z>
(this.defaultRetriever) {<z>
();<z>
;<z>
.retrieverCache.clear();<z>
String, Object> getAttributeMap(int scope) {<z>
SCOPE_REQUEST) {<z>
);<z>
);<z>
message) throws SockJsTransportFailureException {<z>
.openFrameSent) {<z>
.initSessionLock) {<z>
!this.openFrameSent) {<z>
.add(message);<z>
cancelHeartbeat();<z>
message));<z>
;<z>
{<z>
().getName();<z>
== null) {<z>
className + ": no wrapped object set";<z>
identityToString(this.wrappedObject) + ']';<z>
() {<z>
bpCache = this.beanPostProcessorCache;<z>
== null) {<z>
bpCache = new BeanPostProcessorCache();<z>
: this.beanPostProcessors) {<z>
(bp instanceof InstantiationAwareBeanPostProcessor) {<z>
);<z>
SmartInstantiationAwareBeanPostProcessor) {<z>
SmartInstantiationAwareBeanPostProcessor) bp);<z>
{<z>
destructionAware.add((DestructionAwareBeanPostProcessor) bp);<z>
MergedBeanDefinitionPostProcessor) {<z>
.add((MergedBeanDefinitionPostProcessor) bp);<z>
beanPostProcessorCache = bpCache;<z>
return bpCache;<z>
{<z>
)) {<z>
(logger.isDebugEnabled()) {<z>
this.phase);<z>
(this.members);<z>
{<z>
.autoStartupOnly);<z>
Object getValue() throws EvaluationException {<z>
compiledAst;<z>
null) {<z>
context = getEvaluationContext();<z>
).getValue(), context);<z>
ex) {<z>
) == SpelCompilerMode.MIXED) {<z>
compiledAst = null;<z>
);<z>
ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);<z>
, this.configuration);<z>
.ast.getValue(expressionState);<z>
;<z>
return result;<z>
ApplicationContextInitializer<?>... initializers) {<z>
if (initializers != null) {<z>
: initializers) {<z>
<ConfigurableApplicationContext>) initializer);<z>
, boolean registerWithFactory) {<z>
if (registerWithFactory) {<z>
return MBeanServerFactory.createMBeanServer(defaultDomain);<z>
;<z>
(HttpStatus statusCode, String statusText,<z>
responseBody, @Nullable Charset responseCharset) {<z>
this(getMessage(statusCode, statusText),<z>
, responseBody, responseCharset);<z>
private CachedIntrospectionResults getCachedIntrospectionResults() {<z>
== null) {<z>
);<z>
cachedIntrospectionResults;<z>
String name) {<z>
.value = value;<z>
.type = type;<z>
;<z>
, TypeDescriptor streamType) {<z>
);<z>
(source, sourceType, targetCollection);<z>
target == null) {<z>
;<z>
);<z>
(HttpServletRequest request) {<z>
;<z>
) {<z>
{<z>
true;<z>
error.getCause();<z>
;<z>
Method method) {<z>
;<z>
for (MethodOverride candidate : this.overrides) {<z>
method)) {<z>
;<z>
;<z>
(<z>
mbd) {<z>
;<z>
null) {<z>
(beanName, currentlyCreatedBean);<z>
);<z>
(Class[] callbackTypes) {<z>
0) {<z>
throw new IllegalArgumentException("Array cannot be empty");<z>
callbackTypes = CallbackInfo.determineTypes(callbackTypes);<z>
public List<Advisor> findAdvisorBeans() {<z>
= this.cachedAdvisorBeanNames;<z>
{<z>
.beanNamesForTypeIncludingAncestors(<z>
);<z>
.cachedAdvisorBeanNames = advisorNames;<z>
== 0) {<z>
();<z>
new ArrayList<>();<z>
: advisorNames) {<z>
if (isEligibleBean(name)) {<z>
(name)) {<z>
) {<z>
+ name + "'");<z>
Advisor.class));<z>
BeanCreationException ex) {<z>
;<z>
BeanCurrentlyInCreationException) {<z>
;<z>
);<z>
.isCurrentlyInCreation(bceBeanName)) {<z>
) {<z>
("Skipping advisor '" + name +<z>
ex.getMessage());<z>
throw ex;<z>
advisors;<z>
() {<z>
= this.session;<z>
if (session != null) {<z>
session.close();<z>
(IOException ex) {<z>
(logger.isDebugEnabled()) {<z>
+ session.getId(), ex);<z>
ClientHttpRequest> requestConsumer) {<z>
null ?<z>
andThen(requestConsumer) : requestConsumer);<z>
return this;<z>
{<z>
getActiveContextObject();<z>
= op.getValue();<z>
(operand);<z>
(operand instanceof Map) {<z>
?>) operand;<z>
ArrayList<>();<z>
.entrySet()) {<z>
TypedValue(entry));<z>
;<z>
getValue());<z>
state.popActiveContextObject();<z>
();<z>
(new TypedValue(result), this);<z>
operandIsArray) {<z>
data = (operand instanceof Iterable ?<z>
ObjectUtils.toObjectArray(operand)));<z>
<>();<z>
Class<?> arrayElementType = null;<z>
{<z>
new TypedValue(element));<z>
"index", result.size());<z>
;<z>
if (value != null && operandIsArray) {<z>
getClass());<z>
result.add(value);<z>
exitScope();<z>
;<z>
{<z>
if (arrayElementType == null) {<z>
Object.class;<z>
size());<z>
());<z>
this);<z>
);<z>
) {<z>
) {<z>
.INSTANCE;<z>
);<z>
.PROJECTION_NOT_SUPPORTED_ON_TYPE,<z>
;<z>
.google.protobuf.CodedOutputStream output)<z>
IOException {<z>
;<z>
) == 0x00000001)) {<z>
.writeInt32(1, blah_);<z>
output);<z>
void afterConnectionClosed() {<z>
null) {<z>
if (logger.isDebugEnabled()) {<z>
.sessionId);<z>
"Connection to broker closed.");<z>
;<z>
clearConnection();<z>
(Throwable ex) {<z>
int getOrder() {<z>
order != null) {<z>
order;<z>
);<z>
Ordered) {<z>
getOrder();<z>
;<z>
, @Nullable String beanKey) throws MalformedObjectNameException {<z>
(this.attributeSource != null, "No JmxAttributeSource set");<z>
AopUtils.getTargetClass(managedBean);<z>
= this.attributeSource.getManagedResource(managedClass);<z>
{<z>
));<z>
"No ManagedResource attribute and no bean key specified");<z>
);<z>
) {<z>
= this.defaultDomain;<z>
null) {<z>
domain = ClassUtils.getPackageName(managedClass);<z>
>();<z>
);<z>
.put("name", beanKey);<z>
ObjectNameManager.getInstance(domain, properties);<z>
public boolean equals(@Nullable Object other) {<z>
== other) {<z>
;<z>
other.getClass()) {<z>
return false;<z>
AbstractNameValueExpression<?>) other;<z>
that.name)) &&<z>
this.isNegated == that.isNegated);<z>
paramType) {<z>
request.newPushBuilder();<z>
) {<z>
throw new IllegalStateException(<z>
pushBuilder);<z>
pushBuilder;<z>
() {<z>
), Type.SCHEME);<z>
(this.userInfo, Type.USER_INFO);<z>
this.host, getHostType());<z>
this.path.verify();<z>
((key, values) -> {<z>
);<z>
String value : values) {<z>
(value, Type.QUERY_PARAM);<z>
});<z>
Type.FRAGMENT);<z>
<?> candidateParameterType) {<z>
StaticPart.class == candidateParameterType) {<z>
0;<z>
true;<z>
;<z>
nested) {<z>
(NEW, "java/util/ArrayList");<z>
(DUP);<z>
"java/util/ArrayList", "<init>", "()V", false);<z>
{<z>
PUTSTATIC, clazzname, constantFieldName, "Ljava/util/List;");<z>
childCount = getChildCount();<z>
{<z>
nested) {<z>
;<z>
.visitInsn(DUP);<z>
InlineList inlineList) {<z>
, codeflow, true);<z>
generateCode(mv, codeflow);<z>
codeflow.lastDescriptor();<z>
(CodeFlow.isPrimitive(lastDesc)) {<z>
(0));<z>
, true);<z>
(POP);<z>
Object> beans, AutodetectCallback callback) {<z>
!= null, "No BeanFactory set");<z>
beanFactory.getBeanDefinitionCount());<z>
.beanFactory.getBeanDefinitionNames());<z>
{<z>
.beanFactory).getSingletonNames());<z>
for (String beanName : beanNames) {<z>
this.beanFactory, beanName)) {<z>
);<z>
)) {<z>
beanName);<z>
null;<z>
{<z>
);<z>
) {<z>
beans.containsValue(beanName) &&<z>
== null ||<z>
), beanInstance))) {<z>
? beanInstance : beanName));<z>
if (logger.isDebugEnabled()) {<z>
;<z>
{<z>
trace("Bean with name '" + beanName + "' is already registered for JMX exposure");<z>
CannotLoadBeanClassException ex) {<z>
.allowEagerInit) {<z>
ex;<z>
) {<z>
;<z>
this.sortUsed)) {<z>
copySortDefinition(sort);<z>
, sort);<z>
(0);<z>
() {<z>
.interceptors.size() + 1);<z>
.addAll(this.interceptors);<z>
;<z>
ObjectUtils.isEmpty(this.allowedOriginPatterns)) {<z>
setAllowedOriginPatterns(this.allowedOriginPatterns);<z>
interceptors.add(interceptor);<z>
);<z>
Nullable Map<String, Object> map) {<z>
null) {<z>
return null;<z>
map instanceof AnnotationAttributes) {<z>
return (AnnotationAttributes) map;<z>
map);<z>
static <T> DataClassRowMapper<T> newInstance(<z>
T> mappedClass, @Nullable ConversionService conversionService) {<z>
newInstance(mappedClass);<z>
;<z>
rowMapper;<z>
,<z>
) {<z>
;<z>
bean = bean;<z>
beanName = beanName;<z>
);<z>
.invokeDisposableBean = (bean instanceof DisposableBean &&<z>
);<z>
, beanDefinition);<z>
&&<z>
)) &&<z>
(destroyMethodName)) {<z>
));<z>
.invokeAutoCloseable) {<z>
destroyMethodName = destroyMethodName;<z>
;<z>
null) {<z>
(beanDefinition.isEnforceDestroyMethod()) {<z>
new BeanDefinitionValidationException("Could not find a destroy method named '" +<z>
+ "' on bean with name '" + beanName + "'");<z>
destroyMethod.getParameterCount() > 0) {<z>
);<z>
.length > 1) {<z>
"Method '" + destroyMethodName + "' of bean '" +<z>
;<z>
]) {<z>
"' of bean '" +<z>
beanName + "' has a non-boolean parameter - not supported as destroy method");<z>
destroyMethod);<z>
= destroyMethod;<z>
= filterPostProcessors(postProcessors, bean);<z>
Class<?> type) {<z>
notNull(lbf, "ListableBeanFactory must not be null");<z>
lbf.getBeanNamesForType(type);<z>
instanceof HierarchicalBeanFactory hbf) {<z>
hbf.getParentBeanFactory() instanceof ListableBeanFactory) {<z>
beanNamesForTypeIncludingAncestors(<z>
;<z>
mergeNamesWithParent(result, parentResult, hbf);<z>
;<z>
task) {<z>
);<z>
= false;<z>
) {<z>
task);<z>
newTask = true;<z>
.taskScheduler != null) {<z>
));<z>
;<z>
(task, scheduledTask);<z>
newTask ? scheduledTask : null);<z>
(URL url) {<z>
) {<z>
();<z>
!file.isDirectory());<z>
con = url.openConnection();<z>
con);<z>
{<z>
);<z>
{<z>
disconnect();<z>
return false;<z>
contentLength = con.getContentLengthLong();<z>
(contentLength > 0) {<z>
true;<z>
== 0) {<z>
false;<z>
close();<z>
return true;<z>
{<z>
false;<z>
boolean checkDestinationPrefix(@Nullable String destination) {<z>
== null) {<z>
;<z>
{<z>
(destination);<z>
(String prefix : this.destinationPrefixes) {<z>
) {<z>
true;<z>
;<z>
) {<z>
if (processor.readyToCompleteAfterLastWrite) {<z>
;<z>
)) {<z>
.currentData;<z>
;<z>
write(data)) {<z>
, REQUESTED)) {<z>
;<z>
sourceCompleted) {<z>
;<z>
(REQUESTED);<z>
.writingPaused();<z>
subscription != null, "No subscription");<z>
1);<z>
changeStateToReceived(WRITING);<z>
) {<z>
.writingFailed(ex);<z>
) {<z>
(beanNameGenerator, "BeanNameGenerator must not be null");<z>
.localBeanNameGeneratorSet = true;<z>
;<z>
beanNameGenerator;<z>
) {<z>
result = null;<z>
("file." + extension);<z>
if (StringUtils.hasText(rawMimeType)) {<z>
);<z>
APPLICATION_OCTET_STREAM.equals(result)) {<z>
extension).orElse(null);<z>
;<z>
ConnectionFactory cf) {<z>
) {<z>
false;<z>
(cf);<z>
));<z>
getValuesToBind(ServerWebExchange exchange) {<z>
String> vars = exchange.getAttributeOrDefault(<z>
, Collections.emptyMap());<z>
.getRequest().getQueryParams();<z>
formData = exchange.getFormData();<z>
();<z>
queryParams), formData, multipartData)<z>
tuple -> {<z>
TreeMap<>();<z>
put);<z>
key, values));<z>
));<z>
, values));<z>
;<z>
;<z>
<A> of(<z>
attributes) {<z>
, attributes);<z>
public SocketAcceptor responder() {<z>
, sendingRSocket) -> {<z>
MessagingRSocket responder;<z>
responder = createResponder(setupPayload, sendingRSocket);<z>
{<z>
.error(ex);<z>
(responder));<z>
(DataBuffer buf) {<z>
(buf);<z>
(endIdx != -1) {<z>
)) {<z>
+ buf);<z>
, endIdx);<z>
buf);<z>
HeadersState(), headersBuf);<z>
(buf);<z>
();<z>
Nullable ClassLoader classLoader) {<z>
(classLoader, "ClassLoader must not be null");<z>
classLoader;<z>
instrumentableLoaderClass;<z>
instrumentableLoaderClass = classLoader.loadClass(INSTRUMENTABLE_LOADER_CLASS_NAME);<z>
(!instrumentableLoaderClass.isInstance(classLoader)) {<z>
= classLoader.getClass();<z>
ClassNotFoundException ex) {<z>
classLoader.getClass();<z>
("addTransformer", ClassFileTransformer.class);<z>
.getMethodIfAvailable(instrumentableLoaderClass, "copyWithoutTransformers");<z>
copyMethod == null) {<z>
copyMethod = instrumentableLoaderClass.getMethod("getThrowawayClassLoader");<z>
.copyMethod = copyMethod;<z>
{<z>
new IllegalStateException(<z>
"Could not initialize TomcatLoadTimeWeaver because Tomcat API classes are not available", ex);<z>
) {<z>
(EmbeddedDriver.class);<z>
, databaseName, "create=true"));<z>
"sa");<z>
setPassword("");<z>
void resetPathElementState() {<z>
.pathElementStart = -1;<z>
singleCharWildcardCount = 0;<z>
.insideVariableCapture = false;<z>
this.variableCaptureCount = 0;<z>
.wildcard = false;<z>
.isCaptureTheRestVariable = false;<z>
this.variableCaptureStart = -1;<z>
> initParameters(Extension extension) {<z>
Parameter> parameters = extension.getParameters();<z>
);<z>
{<z>
getValue());<z>
result;<z>
) {<z>
this.publicMethodsOnly = true;<z>
.notEmpty(annotationParsers, "At least one TransactionAnnotationParser needs to be specified");<z>
;<z>
Annotation> classAnnotationType,<z>
) {<z>
, methodAnnotationType, false);<z>
BeanFactory beanFactory) {<z>
) {<z>
;<z>
void close() {<z>
().close();<z>
{<z>
,<z>
boolean readOnly) {<z>
;<z>
previousFlushMode;<z>
.needsConnectionReset = connectionPrepared;<z>
previousIsolationLevel;<z>
.readOnly = readOnly;<z>
] getDependenciesForBean(String beanName) {<z>
beanName);<z>
if (dependenciesForBean == null) {<z>
new String[0];<z>
{<z>
return StringUtils.toStringArray(dependenciesForBean);<z>
, @Nullable Object value) {<z>
buffer, fieldName);<z>
value);<z>
);<z>
WebMvcConfigurer> configurers) {<z>
(configurers)) {<z>
this.configurers.addWebMvcConfigurers(configurers);<z>
equals(@Nullable Object other) {<z>
(this == other || (other instanceof DestinationCacheKey &&<z>
)));<z>
protected void doRegisterBeanDefinitions(Element root) {<z>
= this.delegate;<z>
parent);<z>
root)) {<z>
);<z>
(profileSpec)) {<z>
[] specifiedProfiles = StringUtils.tokenizeToStringArray(<z>
);<z>
getEnvironment().acceptsProfiles(specifiedProfiles)) {<z>
(logger.isDebugEnabled()) {<z>
.debug("Skipped XML bean definition file due to specified profiles [" + profileSpec +<z>
getReaderContext().getResource());<z>
preProcessXml(root);<z>
root, this.delegate);<z>
root);<z>
= parent;<z>
getThrowawayClassLoader() {<z>
if (this.getThrowawayClassLoaderMethod != null) {<z>
(ClassLoader)<z>
, this.classLoader);<z>
(target instanceof DecoratingClassLoader ? target :<z>
this.classLoader, target));<z>
);<z>
) throws Throwable {<z>
this.checkedInitMethods;<z>
LifecycleElement> initMethodsToIterate =<z>
;<z>
()) {<z>
LifecycleElement element : initMethodsToIterate) {<z>
) {<z>
.getMethod());<z>
;<z>
String pattern1, String pattern2) {<z>
.hasText(pattern2)) {<z>
"";<z>
StringUtils.hasText(pattern1)) {<z>
pattern2;<z>
!StringUtils.hasText(pattern2)) {<z>
return pattern1;<z>
!= -1);<z>
(pattern1, pattern2)) {<z>
pattern2;<z>
.getEndsOnWildCard())) {<z>
2), pattern2);<z>
getEndsOnDoubleWildCard())) {<z>
pattern2);<z>
.indexOf("*.");<z>
{<z>
;<z>
= pattern1.substring(starDotPos1 + 1);<z>
.indexOf('.');<z>
0, dotPos2));<z>
pattern2.substring(dotPos2));<z>
|| ext1.isEmpty());<z>
ext2.isEmpty());<z>
!ext2All) {<z>
("Cannot combine patterns: " + pattern1 + " vs " + pattern2);<z>
? ext2 : ext1);<z>
;<z>
public void setWriteTimeout(int writeTimeout) {<z>
.client = this.client.newBuilder()<z>
(writeTimeout, TimeUnit.MILLISECONDS)<z>
);<z>
() {<z>
.internal_static_SecondMsg_fieldAccessorTable<z>
.ensureFieldAccessorsInitialized(<z>
.class);<z>
) {<z>
= source;<z>
this.delegate = (delegate instanceof GenericApplicationListener ?<z>
);<z>
{<z>
applicationContext);<z>
beans) {<z>
getBeanType();<z>
if (beanType != null) {<z>
selectMethods(beanType, MODEL_ATTRIBUTE_METHODS);<z>
(!attrMethods.isEmpty()) {<z>
);<z>
= MethodIntrospector.selectMethods(beanType, INIT_BINDER_METHODS);<z>
)) {<z>
.initBinderAdviceCache.put(bean, binderMethods);<z>
= new ExceptionHandlerMethodResolver(beanType);<z>
()) {<z>
resolver);<z>
.isDebugEnabled()) {<z>
size();<z>
this.initBinderAdviceCache.size();<z>
.size();<z>
== 0) {<z>
"ControllerAdvice beans: none");<z>
"ControllerAdvice beans: " + modelSize + " @ModelAttribute, " + binderSize +<z>
handlerSize + " @ExceptionHandler");<z>
propertyResolver,<z>
) {<z>
, "ResourceLoader must not be null");<z>
this.resourceLoader = resourceLoader;<z>
propertyResolver = propertyResolver;<z>
.ignoreUnresolvablePlaceholders = ignoreUnresolvablePlaceholders;<z>
ClassUtils.isPresent("org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient", loader) &&<z>
;<z>
;<z>
private Map<String, ?> defaultUriVariables;<z>
UriBuilderFactory uriBuilderFactory;<z>
HttpHeaders defaultHeaders;<z>
private MultiValueMap<String, String> defaultCookies;<z>
<?>> defaultRequest;<z>
<ExchangeFilterFunction> filters;<z>
ClientHttpConnector connector;<z>
;<z>
<Consumer<ExchangeStrategies.Builder>> strategiesConfigurers;<z>
ExchangeFunction exchangeFunction;<z>
) {<z>
... arguments) {<z>
>(arguments.length);<z>
(Object argument : arguments) {<z>
TypeDescriptor.forObject(argument));<z>
descriptors);<z>
Collection<T> results) throws IncorrectResultSizeDataAccessException {<z>
results)) {<z>
;<z>
)) {<z>
, results.size());<z>
);<z>
throws BeansException {<z>
(urlMap.isEmpty()) {<z>
));<z>
)) {<z>
= entry.getKey();<z>
;<z>
"/")) {<z>
+ url;<z>
) {<z>
.trim();<z>
(url, handler);<z>
logMappings();<z>
) throws JMSException {<z>
CACHE_CONNECTION) {<z>
;<z>
>= CACHE_SESSION) {<z>
updateRecoveryMarker();<z>
));<z>
) {<z>
session);<z>
{<z>
++;<z>
context, Object targetObject, String name,<z>
TypeDescriptor> argumentTypes) throws AccessException {<z>
.getTypeConverter();<z>
.getClass());<z>
, targetObject));<z>
get(type) : null);<z>
filter != null) {<z>
= filter.filter(methods);<z>
;<z>
) > 1) {<z>
sort((m1, m2) -> {<z>
m1pl = m1.getParameterCount();<z>
getParameterCount();<z>
(m1pl == m2pl) {<z>
)) {<z>
1;<z>
) && !m2.isVarArgs()) {<z>
1;<z>
0;<z>
;<z>
});<z>
size(); i++) {<z>
.get(i)));<z>
new LinkedHashSet<>(methods);<z>
= null;<z>
closeMatchDistance = Integer.MAX_VALUE;<z>
Method matchRequiringConversion = null;<z>
false;<z>
{<z>
.equals(name)) {<z>
paramCount = method.getParameterCount();<z>
(paramCount);<z>
; i < paramCount; i++) {<z>
);<z>
.ArgumentsMatchInfo matchInfo = null;<z>
(paramCount - 1)) {<z>
paramDescriptors, argumentTypes, typeConverter);<z>
size()) {<z>
argumentTypes, typeConverter);<z>
(matchInfo != null) {<z>
matchInfo.isExactMatch()) {<z>
(method);<z>
if (matchInfo.isCloseMatch()) {<z>
.useDistance) {<z>
paramDescriptors, argumentTypes);<z>
closeMatchDistance) {<z>
closeMatch = method;<z>
closeMatchDistance = matchDistance;<z>
null) {<z>
method;<z>
isMatchRequiringConversion()) {<z>
) {<z>
true;<z>
;<z>
(closeMatch != null) {<z>
new ReflectiveMethodExecutor(closeMatch);<z>
(matchRequiringConversion != null) {<z>
{<z>
(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name);<z>
ReflectiveMethodExecutor(matchRequiringConversion);<z>
return null;<z>
ex) {<z>
;<z>
fallbackCharset) {<z>
responseCharset == null) {<z>
);<z>
;<z>
ex) {<z>
ex);<z>
, @Nullable Duration timeout) {<z>
notNull(o, "Argument to async must not be null");<z>
{<z>
ServerResponse>) o;<z>
timeout);<z>
if (reactiveStreamsPresent) {<z>
ReactiveAdapterRegistry registry = ReactiveAdapterRegistry.getSharedInstance();<z>
());<z>
(publisherAdapter != null) {<z>
toPublisher(o);<z>
(CompletableFuture.class);<z>
if (futureAdapter != null) {<z>
=<z>
(publisher);<z>
, timeout);<z>
());<z>
public long getRangeStart(long length) {<z>
suffixLength < length) {<z>
;<z>
return 0;<z>
(CloseStatus status) throws IOException {<z>
closeLock.lock();<z>
.closeInProgress) {<z>
{<z>
);<z>
ex) {<z>
limitExceeded) {<z>
isDebugEnabled()) {<z>
debug("Changing close status " + status + " to SESSION_NOT_RELIABLE.");<z>
SESSION_NOT_RELIABLE;<z>
true;<z>
close(status);<z>
this.closeLock.unlock();<z>
HttpServletRequest request, String pattern) {<z>
this.pathAttributeName);<z>
);<z>
match(request, pattern);<z>
this.pathAttributeName, previousPath);<z>
(<z>
parser, @Nullable JsonFormat.Printer printer) {<z>
) null);<z>
Class<T> requiredType) throws NamingException {<z>
) {<z>
(name);<z>
singleton != null) {<z>
(singleton)) {<z>
());<z>
singleton;<z>
= lookup(name, requiredType);<z>
.singletonObjects.put(name, jndiObject);<z>
return jndiObject;<z>
List<HttpMessageReader<?>> messageReaders) {<z>
;<z>
.messageReaders = messageReaders;<z>
return this;<z>
String getSockJsPath(HttpServletRequest servletRequest) {<z>
;<z>
servletRequest.getAttribute(attribute);<z>
;<z>
WebClientResponseException create(<z>
HttpHeaders headers, byte[] body,<z>
) {<z>
statusCode);<z>
null) {<z>
) {<z>
:<z>
;<z>
:<z>
request);<z>
:<z>
);<z>
NOT_FOUND:<z>
charset, request);<z>
METHOD_NOT_ALLOWED:<z>
request);<z>
:<z>
headers, body, charset, request);<z>
case CONFLICT:<z>
charset, request);<z>
case GONE:<z>
, charset, request);<z>
case UNSUPPORTED_MEDIA_TYPE:<z>
charset, request);<z>
:<z>
);<z>
UNPROCESSABLE_ENTITY:<z>
, charset, request);<z>
:<z>
, charset, request);<z>
case NOT_IMPLEMENTED:<z>
);<z>
:<z>
);<z>
SERVICE_UNAVAILABLE:<z>
, charset, request);<z>
case GATEWAY_TIMEOUT:<z>
;<z>
, request);<z>
List<WebFilter> filters) {<z>
notNull(handler, "WebHandler is required");<z>
.allFilters = Collections.unmodifiableList(filters);<z>
this.handler = handler;<z>
, handler);<z>
= chain.currentFilter;<z>
chain = chain.chain;<z>
) {<z>
Arrays.toString(bootstrapMethodArguments);<z>
readRecordComponent(<z>
, final Context context, final int recordComponentOffset) {<z>
= context.charBuffer;<z>
= recordComponentOffset;<z>
name = readUTF8(currentOffset, charBuffer);<z>
2, charBuffer);<z>
;<z>
null;<z>
= 0;<z>
int runtimeInvisibleAnnotationsOffset = 0;<z>
;<z>
runtimeInvisibleTypeAnnotationsOffset = 0;<z>
= null;<z>
currentOffset);<z>
currentOffset += 2;<z>
{<z>
readUTF8(currentOffset, charBuffer);<z>
= readInt(currentOffset + 2);<z>
currentOffset += 6;<z>
)) {<z>
, charBuffer);<z>
RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {<z>
= currentOffset;<z>
equals(attributeName)) {<z>
;<z>
.equals(attributeName)) {<z>
= currentOffset;<z>
attributeName)) {<z>
runtimeInvisibleTypeAnnotationsOffset = currentOffset;<z>
{<z>
=<z>
attributePrototypes,<z>
,<z>
);<z>
= attributes;<z>
= attribute;<z>
attributeLength;<z>
recordComponentVisitor =<z>
);<z>
if (recordComponentVisitor == null) {<z>
return currentOffset;<z>
runtimeVisibleAnnotationsOffset != 0) {<z>
int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);<z>
runtimeVisibleAnnotationsOffset + 2;<z>
-- > 0) {<z>
);<z>
currentAnnotationOffset += 2;<z>
),<z>
;<z>
(runtimeInvisibleAnnotationsOffset != 0) {<z>
numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);<z>
runtimeInvisibleAnnotationsOffset + 2;<z>
(numAnnotations-- > 0) {<z>
readUTF8(currentAnnotationOffset, charBuffer);<z>
2;<z>
annotationDescriptor, false),<z>
charBuffer);<z>
if (runtimeVisibleTypeAnnotationsOffset != 0) {<z>
= readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);<z>
int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;<z>
-- > 0) {<z>
;<z>
String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);<z>
;<z>
visitTypeAnnotation(<z>
context.currentTypeAnnotationTarget,<z>
currentTypeAnnotationTargetPath,<z>
),<z>
;<z>
0) {<z>
runtimeInvisibleTypeAnnotationsOffset);<z>
+ 2;<z>
) {<z>
context, currentAnnotationOffset);<z>
annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);<z>
+= 2;<z>
visitTypeAnnotation(<z>
currentTypeAnnotationTarget,<z>
.currentTypeAnnotationTargetPath,<z>
,<z>
charBuffer);<z>
attributes != null) {<z>
;<z>
attributes.nextAttribute = null;<z>
recordComponentVisitor.visitAttribute(attributes);<z>
nextAttribute;<z>
);<z>
return currentOffset;<z>
Nullable Class<?> requiredType) {<z>
== null || this.customEditors == null) {<z>
return null;<z>
(requiredType);<z>
(editor == null) {<z>
) {<z>
(requiredType);<z>
{<z>
customEditors.entrySet()) {<z>
= entry.getKey();<z>
(key.isAssignableFrom(requiredType)) {<z>
= entry.getValue();<z>
if (this.customEditorCache == null) {<z>
);<z>
, editor);<z>
!= null) {<z>
return editor;<z>
index) {<z>
Iterator namespaces;<z>
this.event.isStartElement()) {<z>
);<z>
event.isEndElement()) {<z>
asEndElement().getNamespaces();<z>
throw new IllegalStateException();<z>
count = 0;<z>
namespaces.hasNext()) {<z>
next();<z>
index) {<z>
namespace;<z>
count++;<z>
;<z>
response) {<z>
response);<z>
(request, response);<z>
null) {<z>
));<z>
afterPropertiesSet() {<z>
{<z>
RuntimeException("Cannot call afterPropertiesSet twice on the one bean");<z>
true;<z>
parseCacheAnnotations(DefaultCacheConfig cachingConfig, AnnotatedElement ae) {<z>
);<z>
) > 1) {<z>
ae, true);<z>
localOps != null) {<z>
;<z>
return ops;<z>
(Throwable ex) {<z>
.get();<z>
.isTraceEnabled()) {<z>
"]");<z>
state.onError(this, ex);<z>
() {<z>
(this.nativeSession != null) {<z>
;<z>
;<z>
,<z>
>> converterType,<z>
request, ServerHttpResponse response) {<z>
converterType, request, response);<z>
, byte[] body,<z>
Nullable Charset charset, @Nullable HttpRequest request) {<z>
charset,<z>
request);<z>
String protocols) {<z>
= this.specBuilderSupplier.get();<z>
(protocols)) {<z>
);<z>
(this.maxFramePayloadLength != null) {<z>
(this.maxFramePayloadLength);<z>
!= null) {<z>
this.handlePing);<z>
;<z>
(boolean mayInterruptIfRunning) {<z>
this.triggerContextMonitor) {<z>
).cancel(mayInterruptIfRunning);<z>
) {<z>
;<z>
{<z>
objectFactory);<z>
setTaskScheduler(TaskScheduler scheduler) {<z>
Assert.notNull(scheduler, "TaskScheduler is required");<z>
;<z>
return this;<z>
) {<z>
) {<z>
httpPolling;<z>
if (session instanceof StreamingSockJsSession) {<z>
;<z>
return this.webSocket;<z>
public boolean hasResource(Object key) {<z>
;<z>
(actualKey);<z>
);<z>
ref) {<z>
bean;<z>
= ref.getBeanType();<z>
isToParent()) {<z>
);<z>
parent == null) {<z>
throw new BeanCreationException(<z>
,<z>
+ ref +<z>
);<z>
null) {<z>
bean = parent.getBean(beanType);<z>
)));<z>
resolvedName;<z>
!= null) {<z>
beanType);<z>
);<z>
namedBean.getBeanName();<z>
ref.getBeanName()));<z>
resolvedName);<z>
;<z>
bean instanceof NullBean) {<z>
;<z>
bean;<z>
{<z>
new BeanCreationException(<z>
, this.beanName,<z>
argName, ex);<z>
() {<z>
.timeoutInProgress = false;<z>
.errorInProgress = false;<z>
;<z>
> input, ResolvableType elementType,<z>
> hints) {<z>
getDelimiterBytes(mimeType);<z>
));<z>
(delimiterBytes);<z>
.from(input)<z>
, matcher, chunks))<z>
concatWith(Mono.defer(() -> {<z>
()) {<z>
Mono.empty();<z>
);<z>
.clear();<z>
);<z>
)<z>
releaseAndClear)<z>
::release)<z>
);<z>
) {<z>
) {<z>
= createDefaultNamespaceHandlerResolver();<z>
;<z>
getValueInternal(ExpressionState state) throws EvaluationException {<z>
);<z>
state);<z>
valueRef.getValue();<z>
Object value = typedValue.getValue();<z>
TypedValue returnValue = typedValue;<z>
TypedValue newValue = null;<z>
instanceof Number op1) {<z>
if (op1 instanceof BigDecimal bigDecimal) {<z>
));<z>
else if (op1 instanceof Double) {<z>
1.0d, typedValue.getTypeDescriptor());<z>
{<z>
+ 1.0f, typedValue.getTypeDescriptor());<z>
else if (op1 instanceof BigInteger bigInteger) {<z>
getTypeDescriptor());<z>
instanceof Long) {<z>
+ 1L, typedValue.getTypeDescriptor());<z>
else if (op1 instanceof Integer) {<z>
getTypeDescriptor());<z>
{<z>
, typedValue.getTypeDescriptor());<z>
) {<z>
) 1, typedValue.getTypeDescriptor());<z>
, typedValue.getTypeDescriptor());<z>
== null) {<z>
);<z>
catch (SpelEvaluationException ex) {<z>
) {<z>
throw new SpelEvaluationException(operand.getStartPosition(),<z>
OPERAND_NOT_INCREMENTABLE, operand.toStringAST());<z>
ex;<z>
getValue());<z>
catch (SpelEvaluationException see) {<z>
() == SpelMessage.SETVALUE_NOT_SUPPORTED) {<z>
), SpelMessage.OPERAND_NOT_INCREMENTABLE);<z>
;<z>
) {<z>
;<z>
return returnValue;<z>
{<z>
);<z>
&&<z>
;<z>
Object doGetTransaction() {<z>
();<z>
(isNestedTransactionAllowed());<z>
ConnectionHolder conHolder =<z>
obtainDataSource());<z>
setConnectionHolder(conHolder, false);<z>
;<z>
action) {<z>
= Integer.MAX_VALUE;<z>
annotationResult = -1;<z>
annotationIndex++) {<z>
AnnotationTypeMapping mapping = getNextSuitableMapping(annotationIndex);<z>
{<z>
annotationResult = annotationIndex;<z>
lowestDistance = mapping.getDistance();<z>
) {<z>
1) {<z>
A> mergedAnnotation = createMergedAnnotationIfPossible(<z>
, this.mappingCursors[annotationResult]);<z>
annotationResult]++;<z>
null) {<z>
);<z>
.accept(mergedAnnotation);<z>
return true;<z>
return false;<z>
, LobHandler lobHandler) {<z>
.content = content;<z>
0);<z>
.lobCreator = lobHandler.getLobCreator();<z>
boolean sendMessage(WebSocketMessage message) throws IOException {<z>
message.getPayload().asByteBuffer();<z>
(message.getType())) {<z>
(false);<z>
.UTF_8);<z>
());<z>
getType())) {<z>
(false);<z>
());<z>
{<z>
);<z>
())) {<z>
);<z>
getType());<z>
return true;<z>
) throws Throwable {<z>
!(mi instanceof ProxyMethodInvocation pmi)) {<z>
mi);<z>
(BEAN_NAME_ATTRIBUTE, this.beanName);<z>
.proceed();<z>
visited)<z>
throws IOException {<z>
if (visited.add(sourceClass)) {<z>
annotation : sourceClass.getAnnotations()) {<z>
getClassName();<z>
) {<z>
, imports, visited);<z>
;<z>
boolean containsBeanInHierarchy(ParserContext context, String beanName) {<z>
.getRegistry();<z>
registry).containsBean(beanName) :<z>
));<z>
resolveBeanReference(Method beanMethod, Object[] beanMethodArgs,<z>
{<z>
(beanName);<z>
if (alreadyInCreation) {<z>
setCurrentlyInCreation(beanName, false);<z>
;<z>
isSingleton(beanName)) {<z>
: beanMethodArgs) {<z>
null) {<z>
= false;<z>
, beanMethodArgs) :<z>
beanFactory.getBean(beanName));<z>
), beanInstance)) {<z>
equals(null)) {<z>
) {<z>
debug(String.format("@Bean method %s.%s called as bean reference " +<z>
getName(),<z>
));<z>
= null;<z>
+<z>
getSimpleName(), beanMethod.getName(),<z>
));<z>
;<z>
);<z>
ex) {<z>
new IllegalStateException(msg);<z>
SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod();<z>
currentlyInvoked != null) {<z>
(currentlyInvoked);<z>
beanName, outerBeanName);<z>
return beanInstance;<z>
{<z>
true);<z>
() {<z>
viewClass = requiredViewClass();<z>
class == viewClass && jstlPresent) {<z>
.class;<z>
viewClass);<z>
public FullPathComponentBuilder cloneBuilder() {<z>
);<z>
toString());<z>
return builder;<z>
ValueRef getValueRef(ExpressionState state) throws EvaluationException {<z>
();<z>
= context.getValue();<z>
.getTypeDescriptor();<z>
;<z>
Object index;<z>
PropertyOrFieldReference reference)) {<z>
reference.getName();<z>
indexValue = new TypedValue(index);<z>
pushActiveContextObject(state.getRootContextObject());<z>
getValueInternal(state);<z>
index = indexValue.getValue();<z>
);<z>
);<z>
null) {<z>
, SpelMessage.CANNOT_INDEX_INTO_NULL_VALUE);<z>
, "No type descriptor");<z>
<?, ?> map) {<z>
= index;<z>
{<z>
getMapKeyTypeDescriptor());<z>
indexedType = IndexedType.MAP;<z>
), map, key, targetDescriptor);<z>
Collection || target instanceof String) {<z>
));<z>
getClass().isArray()) {<z>
ARRAY;<z>
);<z>
(target instanceof Collection) {<z>
instanceof List) {<z>
IndexedType.LIST;<z>
target, idx, targetDescriptor,<z>
.getConfiguration().isAutoGrowCollections(),<z>
.getMaximumAutoGrowSize());<z>
IndexedType.STRING;<z>
;<z>
);<z>
class == valueType.getType()) {<z>
IndexedType.OBJECT;<z>
return new PropertyIndexingValueRef(<z>
, targetDescriptor);<z>
SpelEvaluationException(<z>
INDEXING_NOT_SUPPORTED_FOR_TYPE, targetDescriptor);<z>
timeout) {<z>
).plus(timeout);<z>
(verifyInternal() == 0) {<z>
().isBefore(endTime));<z>
;<z>
void hookOnError(Throwable throwable) {<z>
.get().error(throwable);<z>
;<z>
);<z>
rollbackIfNecessary(Session session) throws JMSException {<z>
notNull(session, "Session must not be null");<z>
rollback();<z>
{<z>
) throws Exception {<z>
.notNull(this.unmarshaller, "Property 'unmarshaller' is required");<z>
.unmarshaller.unmarshal(source);<z>
result)) {<z>
new TypeMismatchException(result, clazz);<z>
return result;<z>
length) {<z>
) {<z>
this.writePosition + length);<z>
newCapacity);<z>
this;<z>
text, String message) {<z>
(!StringUtils.hasLength(text)) {<z>
IllegalArgumentException(message);<z>
void hookOnNext(DataBuffer dataBuffer) {<z>
.asByteBuffer();<z>
hasRemaining()) {<z>
;<z>
dataBuffer);<z>
1);<z>
catch (IOException ex) {<z>
dataBuffer);<z>
(ex);<z>
static String[] delimitedListToStringArray(<z>
String charsToDelete) {<z>
str == null) {<z>
;<z>
) {<z>
] {str};<z>
ArrayList<>();<z>
) {<z>
{<z>
), charsToDelete));<z>
= 0;<z>
;<z>
1) {<z>
, delPos), charsToDelete));<z>
length();<z>
str.length()) {<z>
.substring(pos), charsToDelete));<z>
);<z>
() {<z>
null) {<z>
0;<z>
).getActiveCount();<z>
Nullable Object other) {<z>
if (this == other) {<z>
true;<z>
{<z>
return false;<z>
equals(otherFlashMap) &&<z>
.targetRequestPath, otherFlashMap.targetRequestPath) &&<z>
);<z>
Throwable {<z>
{<z>
"equals":<z>
[0]);<z>
"hashCode":<z>
proxy);<z>
:<z>
;<z>
"getWrappedObject":<z>
();<z>
args);<z>
InvocationTargetException ex) {<z>
();<z>
String[]> paramConditions,<z>
) {<z>
("");<z>
paramConditions, "Parameter conditions must not be empty");<z>
paramConditions = paramConditions;<z>
this.actualParams = actualParams;<z>
beanName) throws BeansException {<z>
EmbeddedValueResolverAware ||<z>
instanceof ApplicationEventPublisherAware ||<z>
bean instanceof ApplicationContextAware ||<z>
)) {<z>
return bean;<z>
;<z>
bean;<z>
, String script,<z>
, String[] commentPrefixes, String blockCommentStartDelimiter,<z>
) throws ScriptException {<z>
.hasText(script, "'script' must not be null or empty");<z>
separator, "'separator' must not be null");<z>
"'commentPrefixes' must not be null or empty");<z>
String commentPrefix : commentPrefixes) {<z>
commentPrefix, "'commentPrefixes' must not contain null or empty elements");<z>
;<z>
hasText(blockCommentEndDelimiter, "'blockCommentEndDelimiter' must not be null or empty");<z>
);<z>
= false;<z>
inDoubleQuote = false;<z>
= false;<z>
length(); i++) {<z>
script.charAt(i);<z>
inEscape) {<z>
;<z>
c);<z>
c == '\\') {<z>
inEscape = true;<z>
sb.append(c);<z>
(c == '\'')) {<z>
inSingleQuote;<z>
!inSingleQuote && (c == '"')) {<z>
inDoubleQuote;<z>
{<z>
, i)) {<z>
() > 0) {<z>
));<z>
();<z>
) - 1;<z>
startsWithAny(script, commentPrefixes, i)) {<z>
script.indexOf('\n', i);<z>
> i) {<z>
;<z>
blockCommentStartDelimiter, i)) {<z>
indexOf(blockCommentEndDelimiter, i);<z>
) {<z>
;<z>
throw new ScriptParseException(<z>
, resource);<z>
c == '\n' || c == '\t') {<z>
) {<z>
c = ' ';<z>
append(c);<z>
.hasText(sb)) {<z>
add(sb.toString());<z>
private void awaitTerminationIfNecessary(ExecutorService executor) {<z>
(this.awaitTerminationMillis > 0) {<z>
MILLISECONDS)) {<z>
{<z>
+<z>
"") + " to terminate");<z>
(InterruptedException ex) {<z>
{<z>
warn("Interrupted while waiting for executor" +<z>
" to terminate");<z>
;<z>
{<z>
parseBeanDefinitionElement(ele);<z>
{<z>
= delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);<z>
());<z>
(BeanDefinitionStoreException ex) {<z>
getReaderContext().error("Failed to register bean definition with name '" +<z>
ex);<z>
fireComponentRegistered(new BeanComponentDefinition(bdHolder));<z>
MetadataReader metadataReader, @Nullable ConfigurationClass importedBy) {<z>
metadataReader.getAnnotationMetadata();<z>
metadataReader.getResource();<z>
importedBy);<z>
{<z>
super.invalidate();<z>
sessions) {<z>
(getId());<z>
request, getId());<z>
encoding, @Nullable Charset charset) {<z>
;<z>
, "Resource must not be null");<z>
.resource = resource;<z>
encoding = encoding;<z>
this.charset = charset;<z>
, WebHandler handler,<z>
currentFilter, @Nullable DefaultWebFilterChain chain) {<z>
= allFilters;<z>
;<z>
this.handler = handler;<z>
= chain;<z>
(Element element, ClassPathBeanDefinitionScanner scanner) {<z>
NAME_GENERATOR_ATTRIBUTE)) {<z>
= (BeanNameGenerator) instantiateUserDefinedStrategy(<z>
class,<z>
().getClassLoader());<z>
);<z>
(BodyContent bodyContent, TagWriter tagWriter) throws JspException {<z>
this.pageContext.getAttribute(VALUE_VARIABLE_NAME);<z>
label = bodyContent.getString();<z>
, label, tagWriter);<z>
Properties mergeProperties() throws IOException {<z>
;<z>
if (this.localOverride) {<z>
);<z>
.localProperties != null) {<z>
(Properties localProp : this.localProperties) {<z>
);<z>
this.localOverride) {<z>
result);<z>
return result;<z>
void addDataSource(String dataSourceName, DataSource dataSource) {<z>
;<z>
Assert.notNull(dataSource, "DataSource must not be null");<z>
put(dataSourceName, dataSource);<z>
) {<z>
);<z>
) {<z>
new IllegalStateException("Ambiguous @ExceptionHandler method mapped for [" +<z>
+ ", " + method + "}");<z>
Nullable Integer value) {<z>
) {<z>
);<z>
= HttpStatus.resolve(value);<z>
(httpStatus == null) {<z>
throw new IllegalStateException(<z>
"Unresolvable HttpStatus for general ServerHttpResponse: " + value);<z>
httpStatus);<z>
initDirectFieldAccess() {<z>
null,<z>
"DataBinder is already initialized - call initDirectFieldAccess before other configuration methods");<z>
.directFieldAccess = true;<z>
) {<z>
()) {<z>
);<z>
{<z>
{<z>
serverContainer =<z>
("jakarta.websocket.server.ServerContainer");<z>
invokeErrorHandler(Throwable ex) {<z>
;<z>
!= null) {<z>
);<z>
"Execution of JMS message listener failed, and no ErrorHandler has been set.", ex);<z>
configurer) {<z>
== null) {<z>
strategiesConfigurers = new ArrayList<>(4);<z>
;<z>
return this;<z>
, boolean allowEagerInit) {<z>
new ObjectProvider<>() {<z>
() throws BeansException {<z>
String[] beanNames = getBeanNamesForType(requiredType);<z>
if (beanNames.length == 1) {<z>
;<z>
(beanNames.length > 1) {<z>
(requiredType, beanNames);<z>
);<z>
(Object... args) throws BeansException {<z>
= getBeanNamesForType(requiredType);<z>
) {<z>
], args);<z>
1) {<z>
);<z>
throw new NoSuchBeanDefinitionException(requiredType);<z>
public T getIfAvailable() throws BeansException {<z>
requiredType);<z>
{<z>
(beanNames[0]);<z>
) {<z>
throw new NoUniqueBeanDefinitionException(requiredType, beanNames);<z>
return null;<z>
BeansException {<z>
= getBeanNamesForType(requiredType);<z>
(beanNames.length == 1) {<z>
T) getBean(beanNames[0]);<z>
return null;<z>
stream() {<z>
name));<z>
public Stream<T> orderedStream() {<z>
.INSTANCE);<z>
byteBuffer,<z>
{<z>
= new ArrayList<>();<z>
.hasRemaining()) {<z>
decodeMessage(byteBuffer, partialMessageHeaders);<z>
!= null) {<z>
add(message);<z>
;<z>
byteBuffer.hasRemaining()) {<z>
;<z>
?> targetClass) {<z>
this.transactionAttributeSources) {<z>
);<z>
) {<z>
attr;<z>
;<z>
uniqueCandidate, Method candidate) {<z>
);<z>
int candidateParameterCount = candidate.getParameterCount();<z>
(uniqueCandidateParameterCount != candidateParameterCount ||<z>
;<z>
void initApplicationContext() throws BeansException {<z>
(this.interceptors);<z>
;<z>
();<z>
) throws MessagingException, UnsupportedEncodingException {<z>
);<z>
(getEncoding() != null) ?<z>
(replyTo, personal);<z>
replyToAddress);<z>
public AbstractBeanDefinition parseBeanDefinitionElement(<z>
) {<z>
beanName));<z>
= null;<z>
.hasAttribute(CLASS_ATTRIBUTE)) {<z>
);<z>
= null;<z>
PARENT_ATTRIBUTE)) {<z>
.getAttribute(PARENT_ATTRIBUTE);<z>
AbstractBeanDefinition bd = createBeanDefinition(className, parent);<z>
, bd);<z>
ele, DESCRIPTION_ELEMENT));<z>
ele, bd);<z>
;<z>
(ele, bd.getMethodOverrides());<z>
(ele, bd);<z>
parsePropertyElements(ele, bd);<z>
parseQualifierElements(ele, bd);<z>
.getResource());<z>
(extractSource(ele));<z>
;<z>
{<z>
ele, ex);<z>
err) {<z>
, ele, err);<z>
ex) {<z>
;<z>
();<z>
return null;<z>
Nullable ServerWebExchange exchange,<z>
) {<z>
= getStrategyForPath(requestPath);<z>
(versionStrategy == null) {<z>
Mono.empty();<z>
(requestPath);<z>
!StringUtils.hasLength(candidate)) {<z>
);<z>
requestPath, candidate);<z>
(exchange, simplePath, locations)<z>
(resource)<z>
actual -> {<z>
if (candidate.equals(actual)) {<z>
;<z>
) {<z>
() : "";<z>
trace(logPrefix + "Found resource for \"" + requestPath +<z>
;<z>
false;<z>
))<z>
new FileNameVersionedResource(resource, candidate));<z>
throws IOException {<z>
(this.jsonPrefix != null) {<z>
);<z>
key) {<z>
);<z>
CACHE;<z>
= cache.get(loader);<z>
{<z>
synchronized (AbstractClassGenerator.class) {<z>
CACHE;<z>
;<z>
if (data == null) {<z>
ClassLoaderData>(cache);<z>
;<z>
, data);<z>
;<z>
.key = key;<z>
getUseCache());<z>
{<z>
firstInstance((Class) obj);<z>
(obj);<z>
ex) {<z>
throw ex;<z>
(Exception ex) {<z>
CodeGenerationException(ex);<z>
) {<z>
src.isEmpty()) {<z>
];<z>
decode(src.getBytes(DEFAULT_CHARSET));<z>
?>[] classes,<z>
? extends ApplicationContextInitializer<?>>> contextInitializerClasses,<z>
propertySourceProperties,<z>
resourceBasePath, ContextLoader contextLoader,<z>
parent) {<z>
activeProfiles, propertySourceLocations,<z>
contextCustomizers, contextLoader, cacheAwareContextLoaderDelegate, parent);<z>
resourceBasePath : "");<z>
,<z>
upgradeInfo, TyrusUpgradeResponse upgradeResponse) throws IOException, ServletException {<z>
setStatus(upgradeResponse.getStatus());<z>
.getHeaderFromList(value)));<z>
();<z>
.setTimeout(-1L);<z>
);<z>
(nativeRequest);<z>
getPropertyValue("connection.connectionHandler.rawConnection");<z>
.newInstance(request, httpSocket);<z>
));<z>
;<z>
request.getUserPrincipal() != null;<z>
isProtected);<z>
servletWriter, noOpCloseListener);<z>
connection);<z>
.setPropertyValue("connection", connection);<z>
webSocketHelper.registerForReadEvent(webSocket);<z>
pattern,<z>
> routerFunctionSupplier) {<z>
, routerFunctionSupplier);<z>
{<z>
AnnotationAttributes.fromMap(<z>
);<z>
.enableAsync == null) {<z>
(<z>
importMetadata.getClassName());<z>
intValue) {<z>
= length;<z>
+ 4 > data.length) {<z>
4);<z>
= data;<z>
>> 24);<z>
>>> 16);<z>
;<z>
;<z>
;<z>
this;<z>
other) {<z>
.notNull(other, "ClientRequest must not be null");<z>
= other.method();<z>
;<z>
;<z>
addAll(other.cookies()));<z>
attributes()));<z>
;<z>
);<z>
T> responseProvider) {<z>
predicate, "Predicate must not be null");<z>
notNull(responseProvider, "ResponseProvider must not be null");<z>
this.predicate = predicate;<z>
this.responseProvider = responseProvider;<z>
unsubscribe(@Nullable StompHeaders headers) {<z>
);<z>
null) {<z>
remove(id);<z>
.this.unsubscribe(id, headers);<z>
(<z>
jtaTransactionManager) {<z>
this(springSynchronization);<z>
UserTransactionAdapter(jtaTransactionManager);<z>
parseSqlStatement(final String sql) {<z>
Assert.notNull(sql, "SQL must not be null");<z>
<>();<z>
= new StringBuilder(sql);<z>
= new ArrayList<>();<z>
.toCharArray();<z>
;<z>
int unnamedParameterCount = 0;<z>
;<z>
int escapes = 0;<z>
;<z>
i < statement.length) {<z>
skipToPosition = i;<z>
< statement.length) {<z>
= skipCommentsAndQuotes(statement, i);<z>
i == skipToPosition) {<z>
= skipToPosition;<z>
i >= statement.length) {<z>
c = statement[i];<z>
c == ':' || c == '&') {<z>
int j = i + 1;<z>
) {<z>
+ 2;<z>
;<z>
{<z>
] != '}') {<z>
++;<z>
.length) {<z>
InvalidDataAccessApiUsageException("Non-terminated named parameter declaration " +<z>
+ i + " in statement: " + sql);<z>
) {<z>
throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +<z>
"' at position " + i + " in statement: " + sql);<z>
(j - i > 2) {<z>
substring(i + 2, j);<z>
namedParameters, namedParameterCount, parameter);<z>
addNamedParameter(<z>
, parameter);<z>
;<z>
isParameterSeparator(statement[j])) {<z>
++;<z>
i > 1) {<z>
1, j);<z>
namedParameters, namedParameterCount, parameter);<z>
addNamedParameter(<z>
, parameter);<z>
i = j - 1;<z>
{<z>
1;<z>
) {<z>
deleteCharAt(i - escapes);<z>
escapes++;<z>
+ 2;<z>
if (c == '?') {<z>
= i + 1;<z>
'&')) {<z>
i + 2;<z>
;<z>
totalParameterCount++;<z>
++;<z>
.toString());<z>
: parameterList) {<z>
());<z>
(namedParameterCount);<z>
.setUnnamedParameterCount(unnamedParameterCount);<z>
.setTotalParameterCount(totalParameterCount);<z>
parsedSql;<z>
Instant lastModified) {<z>
EPOCH)) {<z>
;<z>
getIfUnmodifiedSince();<z>
-1) {<z>
return false;<z>
Instant sinceInstant = Instant.ofEpochMilli(ifUnmodifiedSince);<z>
SECONDS));<z>
;<z>
String body) {<z>
);<z>
new LinkedMultiValueMap<>(pairs.length);<z>
(String pair : pairs) {<z>
indexOf('=');<z>
{<z>
;<z>
(0, idx), charset);<z>
+ 1), charset);<z>
, value);<z>
result;<z>
{<z>
id == null) {<z>
.id = initId();<z>
this.id == null) {<z>
(this);<z>
;<z>
consumer) {<z>
);<z>
consumer.accept(actual));<z>
;<z>
Nullable Object value) {<z>
null) {<z>
= false;<z>
, value, replaceHeader)) {<z>
, value, replaceHeader);<z>
(ByteBuf byteBuf, DataBufferFactory bufferFactory,<z>
) {<z>
) {<z>
String logPrefix = Hints.getLogPrefix(hints);<z>
() + " bytes");<z>
bufferFactory instanceof NettyDataBufferFactory) {<z>
NettyDataBufferFactory) bufferFactory).wrap(byteBuf);<z>
readableBytes()];<z>
readBytes(bytes);<z>
.release();<z>
(bytes);<z>
{<z>
"MessageChannel is required");<z>
.state(channel instanceof PollableChannel, "A PollableChannel is required to receive messages");<z>
= (timeout >= 0 ?<z>
) channel).receive());<z>
== null && logger.isTraceEnabled()) {<z>
timeout);<z>
return message;<z>
String reason) {<z>
()) {<z>
getLogPrefix() + reason);<z>
(new ServerWebInputException(reason));<z>
void handleMissingValueAfterConversion(<z>
MethodParameter parameter, NativeWebRequest request) throws Exception {<z>
, true);<z>
() {<z>
();<z>
i++) {<z>
= new SynthesizingMethodParameter(method, i);<z>
initParameterNameDiscovery(nameDiscoverer);<z>
) {<z>
);<z>
return matches;<z>
BodyBuilder eTag(String etag) {<z>
&& !etag.startsWith("W/\"")) {<z>
;<z>
) {<z>
+ "\"";<z>
setETag(etag);<z>
;<z>
Resource> clazz, HttpInputMessage inputMessage)<z>
IOException, HttpMessageNotReadableException {<z>
&& InputStreamResource.class == clazz) {<z>
getBody()) {<z>
() {<z>
();<z>
IOException {<z>
);<z>
());<z>
ByteArrayResource.class.isAssignableFrom(clazz)) {<z>
inputMessage.getBody());<z>
(body) {<z>
getFilename() {<z>
();<z>
HttpMessageNotReadableException("Unsupported resource class: " + clazz, inputMessage);<z>
(BeanDefinitionRegistry registry) {<z>
registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {<z>
definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);<z>
.TRUE);<z>
Object parsePointcutProperty(Element element, ParserContext parserContext) {<z>
)) {<z>
getReaderContext().error(<z>
.parseState.snapshot());<z>
null;<z>
) {<z>
;<z>
= createPointcutDefinition(expression);<z>
extractSource(element));<z>
return pointcutDefinition;<z>
(POINTCUT_REF)) {<z>
element.getAttribute(POINTCUT_REF);<z>
pointcutRef)) {<z>
.getReaderContext().error(<z>
);<z>
return null;<z>
pointcutRef;<z>
(<z>
());<z>
null;<z>
computeAllFrames() {<z>
firstHandler;<z>
null) {<z>
catchTypeDescriptor =<z>
catchTypeDescriptor;<z>
(symbolTable, catchTypeDescriptor);<z>
handlerBlock = handler.handlerPc.getCanonicalInstance();<z>
;<z>
.startPc.getCanonicalInstance();<z>
);<z>
{<z>
outgoingEdges =<z>
;<z>
handlerRangeBlock = handlerRangeBlock.nextBasicBlock;<z>
.nextHandler;<z>
.frame;<z>
maxLocals);<z>
this);<z>
;<z>
.nextListElement = Label.EMPTY_LIST;<z>
0;<z>
EMPTY_LIST) {<z>
listOfBlocksToProcess;<z>
nextListElement;<z>
null;<z>
FLAG_REACHABLE;<z>
;<z>
) {<z>
;<z>
outgoingEdges;<z>
) {<z>
= outgoingEdge.successor.getCanonicalInstance();<z>
successorBlockChanged =<z>
outgoingEdge.info);<z>
) {<z>
= listOfBlocksToProcess;<z>
= successorBlock;<z>
nextEdge;<z>
firstBasicBlock;<z>
basicBlock != null) {<z>
Label.FLAG_REACHABLE))<z>
) {<z>
;<z>
== 0) {<z>
;<z>
.bytecodeOffset;<z>
: nextBasicBlock.bytecodeOffset) - 1;<z>
) {<z>
++i) {<z>
] = Opcodes.NOP;<z>
(byte) Opcodes.ATHROW;<z>
= visitFrameStart(startOffset, 0, 1);<z>
currentFrame[frameIndex] =<z>
, "java/lang/Throwable");<z>
visitFrameEnd();<z>
(firstHandler, basicBlock, nextBasicBlock);<z>
max(maxStackSize, 1);<z>
nextBasicBlock;<z>
maxStack = maxStackSize;<z>
MergedAnnotation<A> createMergedAnnotationIfPossible(<z>
mappingIndex, IntrospectionFailureLogger logger) {<z>
return TypeMappedAnnotation.createIfPossible(<z>
), this.source,<z>
aggregateIndex, logger);<z>
{<z>
= executable.getParameterCount();<z>
1 && parameterIndex < count,<z>
;<z>
;<z>
> writers,<z>
) {<z>
registry);<z>
0);<z>
, Object[] args) throws Throwable {<z>
()) {<z>
:<z>
return (proxy == args[0]);<z>
"hashCode":<z>
);<z>
case "unwrap":<z>
;<z>
{<z>
.entityManagerFactoryBean.getNativeEntityManagerFactory();<z>
proxy)) {<z>
proxy;<z>
invokeProxyMethod(method, args);<z>
ex) {<z>
getTargetException();<z>
returnType, Message<?> message) {<z>
handler = getReturnValueHandler(returnType);<z>
(handler == null) {<z>
getParameterType());<z>
)) {<z>
trace("Processing return value with " + handler);<z>
message);<z>
) {<z>
);<z>
;<z>
= false;<z>
) throws SQLException {<z>
url = getUrl();<z>
state(url != null, "'url' not set");<z>
(logger.isDebugEnabled()) {<z>
.debug("Creating new JDBC DriverManager Connection to [" + url + "]");<z>
(url, props);<z>
value) {<z>
, value);<z>
entry = get(hashCode);<z>
{<z>
)) {<z>
entry;<z>
.next;<z>
addConstantUtf8(value));<z>
);<z>
Instant now) {<z>
isBefore(now)) {<z>
;<z>
.protobuf.Message other) {<z>
if (other instanceof Msg) {<z>
((Msg)other);<z>
else {<z>
(other);<z>
this;<z>
(ParserContext context, @Nullable Object source) {<z>
)) {<z>
new RootBeanDefinition(HandlerMappingIntrospector.class);<z>
;<z>
(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
);<z>
, beanDef);<z>
new BeanComponentDefinition(beanDef, HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME));<z>
String getCookieHeader(Cookie cookie) {<z>
= new StringBuilder();<z>
());<z>
())) {<z>
());<z>
) {<z>
());<z>
int maxAge = cookie.getMaxAge();<z>
) : null);<z>
) {<z>
(maxAge);<z>
.append("; Expires=");<z>
) {<z>
.RFC_1123_DATE_TIME));<z>
();<z>
1000L * maxAge : 0);<z>
.getFirst(HttpHeaders.EXPIRES));<z>
else if (expires != null) {<z>
append("; Expires=");<z>
.RFC_1123_DATE_TIME));<z>
) {<z>
append("; Secure");<z>
isHttpOnly()) {<z>
buf.append("; HttpOnly");<z>
mockCookie) {<z>
))) {<z>
.getSameSite());<z>
return buf.toString();<z>
{<z>
) {<z>
.triggerBeforeCommit(status.isReadOnly());<z>
springframework.protobuf.SecondMsg build() {<z>
result = buildPartial();<z>
) {<z>
newUninitializedMessageException(result);<z>
result;<z>
public ApplicationContext loadContext(MergedContextConfiguration mergedConfig) throws Exception {<z>
.notNull(mergedConfig, "MergedContextConfiguration must not be null");<z>
.format(<z>
getXmlLoader()),<z>
);<z>
)};<z>
loader : candidates) {<z>
) {<z>
loader, mergedConfig);<z>
{<z>
, mergedConfig);<z>
throw new IllegalStateException(String.format(<z>
)), mergedConfig));<z>
outputStream) throws IOException {<z>
instanceof Serializable)) {<z>
().getSimpleName() + " requires a Serializable payload " +<z>
);<z>
);<z>
;<z>
flush();<z>
name, HandlerMethod handlerMethod) {<z>
;<z>
) {<z>
;<z>
for (HandlerMethod current : oldList) {<z>
(current)) {<z>
.size() + 1);<z>
addAll(oldList);<z>
(handlerMethod);<z>
, newList);<z>
configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) {<z>
{<z>
{<z>
this.contextId);<z>
APPLICATION_CONTEXT_ID_PREFIX +<z>
getServletName());<z>
.setServletContext(getServletContext());<z>
;<z>
.setNamespace(getNamespace());<z>
));<z>
getEnvironment();<z>
(env instanceof ConfigurableWebEnvironment cwe) {<z>
));<z>
wac);<z>
applyInitializers(wac);<z>
;<z>
public NamespaceHandler resolve(String namespaceUri) {<z>
String, Object> handlerMappings = getHandlerMappings();<z>
.get(namespaceUri);<z>
if (handlerOrClassName == null) {<z>
null;<z>
else if (handlerOrClassName instanceof NamespaceHandler) {<z>
return (NamespaceHandler) handlerOrClassName;<z>
String) handlerOrClassName;<z>
className, this.classLoader);<z>
NamespaceHandler.class.isAssignableFrom(handlerClass)) {<z>
className + "] for namespace [" + namespaceUri +<z>
);<z>
);<z>
();<z>
namespaceHandler);<z>
namespaceHandler;<z>
(ClassNotFoundException ex) {<z>
throw new FatalBeanException("Could not find NamespaceHandler class [" + className +<z>
;<z>
LinkageError err) {<z>
FatalBeanException("Unresolvable class definition for NamespaceHandler class [" +<z>
, err);<z>
RSocketFrameTypeMessageCondition combine(RSocketFrameTypeMessageCondition other) {<z>
other.frameTypes)) {<z>
return other;<z>
>(this.frameTypes);<z>
other.frameTypes);<z>
);<z>
resourceHolder) {<z>
();<z>
catch (RuntimeException ex) {<z>
(ex);<z>
public int accept(Method method) {<z>
length; i++) {<z>
;<z>
) callback).isMatch(method)) {<z>
return i;<z>
+ method.getName());<z>
{<z>
RequestMethod requestMethod;<z>
httpMethodValue);<z>
contains(requestMethod)) {<z>
.get(httpMethodValue);<z>
(RequestMethod.GET)) {<z>
(HttpMethod.GET.name());<z>
(IllegalArgumentException ex) {<z>
return null;<z>
> mappedClass) {<z>
;<z>
);<z>
();<z>
(mappedClass)) {<z>
.getWriteMethod() != null) {<z>
lowerCaseName(pd.getName());<z>
pd);<z>
= underscoreName(pd.getName());<z>
.equals(underscoreName)) {<z>
underscoreName, pd);<z>
;<z>
String>> initFormData(ServerHttpRequest request,<z>
{<z>
;<z>
(contentType)) {<z>
.getReaders().stream()<z>
.canRead(FORM_DATA_TYPE, MediaType.APPLICATION_FORM_URLENCODED))<z>
findFirst()<z>
))<z>
.from(Hints.LOG_PREFIX_HINT, logPrefix))<z>
EMPTY_FORM_DATA)<z>
.cache();<z>
) {<z>
EMPTY_FORM_DATA;<z>
(Element persistenceUnit, SpringPersistenceUnitInfo unitInfo) {<z>
, MANAGED_CLASS_NAME);<z>
element : classes) {<z>
getTextValue(element).trim();<z>
.hasText(value)) {<z>
);<z>
String outcome) {<z>
handler = getDelegate(facesContext);<z>
DecoratingNavigationHandler) {<z>
((DecoratingNavigationHandler) handler).handleNavigation(<z>
);<z>
facesContext, fromAction, outcome);<z>
opcode) {<z>
null) {<z>
mv.visitInsn(opcode);<z>
void applyHeaders() {<z>
headerValues) -> {<z>
{<z>
;<z>
;<z>
;<z>
getContentType();<z>
catch (Exception ex) {<z>
);<z>
response.setContentType(rawContentType);<z>
{<z>
setContentType(contentType.toString());<z>
? contentType.getCharset() : null);<z>
null) {<z>
.setCharacterEncoding(charset.name());<z>
getHeaders().getContentLength();<z>
) {<z>
;<z>
prependLeadingSlash(String pattern) {<z>
"/")) {<z>
pattern;<z>
return pattern;<z>
SpelCompiler getCompiler(@Nullable ClassLoader classLoader) {<z>
);<z>
.get(clToUse);<z>
compiler == null) {<z>
compilers) {<z>
);<z>
{<z>
= new SpelCompiler(clToUse);<z>
clToUse, compiler);<z>
compiler;<z>
outputChannel) {<z>
.getId());<z>
(session);<z>
);<z>
;<z>
this.eventPublisher != null) {<z>
);<z>
getId(), closeStatus, user));<z>
(message);<z>
(session.getId());<z>
();<z>
);<z>
> handleException(Throwable exception, HandlerMethod handlerMethod,<z>
{<z>
this.methodResolver != null, "Not initialized");<z>
(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);<z>
();<z>
handlerMethod);<z>
invocable != null) {<z>
{<z>
+ invocable);<z>
;<z>
.getCause();<z>
) {<z>
;<z>
, bindingContext, exception, handlerMethod);<z>
catch (Throwable invocationEx) {<z>
{<z>
;<z>
);<z>
protected Object evaluateScript(ScriptSource scriptSource) {<z>
.scriptEngine;<z>
scriptEngine == null) {<z>
;<z>
== null) {<z>
);<z>
scriptEngine;<z>
);<z>
ex) {<z>
);<z>
Resource> locations) {<z>
clear();<z>
{<z>
locationResources.addAll(locations);<z>
start(String taskName) throws IllegalStateException {<z>
this.currentTaskName != null) {<z>
("Can't start StopWatch: it's already running");<z>
this.currentTaskName = taskName;<z>
this.startTimeNanos = System.nanoTime();<z>
String getFoo() {<z>
;<z>
{<z>
) ref)<z>
toStringUtf8();<z>
= s;<z>
;<z>
else {<z>
;<z>
void configureViewResolvers(ViewResolverRegistry registry) {<z>
.delegates) {<z>
;<z>
headers, String sourceDest) {<z>
;<z>
;<z>
, "Expected destination pattern \"/user/{userId}/**\"");<z>
userEnd);<z>
, prefixEnd - 1) + actualDest;<z>
sourceDest.substring(prefixEnd, userEnd);<z>
, "%2F", "/");<z>
;<z>
> sessionIds;<z>
)) {<z>
null;<z>
);<z>
getSessionIdsByUser(userName, sessionId);<z>
isRemoveLeadingSlash()) {<z>
= actualDest.substring(1);<z>
, userName);<z>
{<z>
{<z>
;<z>
);<z>
, @Nullable Class<?> targetClass) {<z>
Collection<CacheOperation> ops = null;<z>
.cacheOperationSources) {<z>
source.getCacheOperations(method, targetClass);<z>
cacheOperations != null) {<z>
(ops == null) {<z>
new ArrayList<>();<z>
addAll(cacheOperations);<z>
ops;<z>
) {<z>
.isStompConnected = true;<z>
incrementConnectedCount();<z>
initHeartbeats(connectedHeaders);<z>
, Object singletonObject) throws IllegalStateException {<z>
;<z>
notNull(singletonObject, "Singleton object must not be null");<z>
(this.singletonObjects) {<z>
;<z>
) {<z>
IllegalStateException("Could not register object [" + singletonObject +<z>
+ beanName + "': there is already object [" + oldObject + "] bound");<z>
);<z>
) String country) {<z>
, 1);<z>
);<z>
setCountry(country);<z>
;<z>
, HandshakeInfo info, DataBufferFactory factory,<z>
.MonoProcessor<Void> completionMono) {<z>
completionMono);<z>
public JdkClientHttpConnector(<z>
Builder clientBuilder, @Nullable JdkHttpClientResourceFactory resourceFactory) {<z>
resourceFactory != null) {<z>
();<z>
);<z>
httpClient = clientBuilder.build();<z>
{<z>
, "]");<z>
; i++) {<z>
));<z>
return sj.toString();<z>
ReactiveTransactionInfo txInfo) {<z>
&& txInfo.getReactiveTransaction() != null) {<z>
{<z>
getJoinpointIdentification() + "] after cancellation");<z>
.rollback(txInfo.getReactiveTransaction());<z>
Mono.empty();<z>
getResolvers() {<z>
delegate.getResolvers().stream()<z>
) resolver)<z>
);<z>
(CacheLoader<Object, Object> cacheLoader) {<z>
cacheLoader)) {<z>
.cacheLoader = cacheLoader;<z>
();<z>
... args) throws IOException {<z>
);<z>
) {<z>
;<z>
{<z>
;<z>
);<z>
(Exception ex) {<z>
(ex);<z>
IllegalStateException("Invalid code path reached");<z>
addForwardReference(<z>
final int referenceHandle) {<z>
null) {<z>
new int[FORWARD_REFERENCES_CAPACITY_INCREMENT];<z>
];<z>
length) {<z>
;<z>
.length);<z>
= newValues;<z>
forwardReferences[++lastElementIndex] = sourceInsnBytecodeOffset;<z>
referenceType | referenceHandle;<z>
0] = lastElementIndex;<z>
<ContentChunkInfo> linksToAdd) {<z>
index)) {<z>
isTraceEnabled()) {<z>
index);<z>
index;<z>
initHttpHandlerBuilder() {<z>
, this.handlerStrategies);<z>
(webHandler)<z>
))<z>
handlerStrategies.exceptionHandlers()))<z>
handlerStrategies.localeContextResolver());<z>
int api, final FieldVisitor fieldVisitor) {<z>
ASM9<z>
ASM8<z>
ASM7<z>
api != Opcodes.ASM6<z>
.ASM5<z>
ASM4<z>
Opcodes.ASM10_EXPERIMENTAL) {<z>
api);<z>
= api;<z>
fieldVisitor;<z>
(T item) {<z>
State.READY_TO_WRITE) {<z>
;<z>
synchronized (this) {<z>
state == State.READY_TO_WRITE) {<z>
item);<z>
) {<z>
.item = item;<z>
;<z>
Void> result;<z>
= writeFunction.apply(this);<z>
{<z>
(ex);<z>
(this.writeCompletionBarrier);<z>
null) {<z>
.cancel();<z>
"Unexpected item."));<z>
MethodParameter parameter, @Nullable Object value,<z>
Object> uriVariables, ConversionService conversionService) {<z>
= parameter.getNestedParameterType();<z>
Part.class == paramType) {<z>
);<z>
name()) ?<z>
() : parameter.getParameterName());<z>
!= null, "Unresolvable parameter name");<z>
.nestedIfOptional();<z>
Optional) {<z>
.orElse(null);<z>
{<z>
!= null &&<z>
equals(ValueConstants.DEFAULT_NONE))) {<z>
;<z>
(value instanceof Collection) {<z>
) value) {<z>
parameter, 1), element);<z>
queryParam(name, element);<z>
(parameter), value));<z>
) {<z>
getMajorVersion() < Opcodes.V1_5;<z>
mask = useSyntheticAttribute ? Opcodes.ACC_SYNTHETIC : 0;<z>
);<z>
attributesCount = 0;<z>
{<z>
attributesCount;<z>
) != 0 && useSyntheticAttribute) {<z>
attributesCount;<z>
signatureIndex != 0) {<z>
;<z>
0) {<z>
attributesCount;<z>
null) {<z>
attributesCount;<z>
!= null) {<z>
;<z>
null) {<z>
attributesCount;<z>
{<z>
attributesCount;<z>
firstAttribute != null) {<z>
+= firstAttribute.getAttributeCount();<z>
(attributesCount);<z>
) {<z>
.addConstantUtf8(Constants.CONSTANT_VALUE))<z>
2)<z>
.putShort(constantValueIndex);<z>
;<z>
(<z>
output);<z>
if (firstAttribute != null) {<z>
putAttributes(symbolTable, output);<z>
ByteVector output) {<z>
) {<z>
.putByte(0);<z>
} else {<z>
* 2 + 1;<z>
.typePathOffset, length);<z>
protected String determineBeanNameFromAnnotation(AnnotatedBeanDefinition annotatedDef) {<z>
getMetadata();<z>
);<z>
beanName = null;<z>
String type : types) {<z>
attributesFor(amd, type);<z>
) {<z>
type, key -> {<z>
key);<z>
) : result);<z>
});<z>
{<z>
;<z>
instanceof String strVal) {<z>
if (StringUtils.hasLength(strVal)) {<z>
strVal.equals(beanName)) {<z>
throw new IllegalStateException("Stereotype annotations suggest inconsistent " +<z>
+ "'");<z>
strVal;<z>
;<z>
HttpServletRequest request, @Nullable String name) {<z>
String result = null;<z>
name != null) {<z>
name);<z>
getLookupPathForRequest(request));<z>
MockHttpServletRequestBuilder cookie(Cookie... cookies) {<z>
cookies, "'cookies' must not be empty");<z>
.asList(cookies));<z>
return this;<z>
> clazz, Object target) {<z>
, target instanceof Class);<z>
null && target instanceof Class) {<z>
(), false);<z>
return method;<z>
dispose() {<z>
{<z>
.closeChannel(this.channel);<z>
int hashCode() {<z>
= getBeanClass().hashCode();<z>
));<z>
;<z>
hashCode;<z>
@Nullable PropertyDescriptor pd) {<z>
member, pd);<z>
(Resource.class);<z>
);<z>
);<z>
(resourceName);<z>
this.isDefaultName) {<z>
;<z>
.length() > 3) {<z>
(3));<z>
null) {<z>
(resourceName);<z>
.class != resourceType) {<z>
checkResourceType(resourceType);<z>
();<z>
);<z>
;<z>
= resource.lookup();<z>
;<z>
ae.getAnnotation(Lazy.class);<z>
));<z>
) throws TransactionException {<z>
++rollbacks;<z>
;<z>
Mono.empty();<z>
decorateIfRequired(<z>
, @Nullable BeanDefinition containingBd) {<z>
;<z>
&& !isDefaultNamespace(namespaceUri)) {<z>
);<z>
{<z>
decorated =<z>
));<z>
decorated != null) {<z>
;<z>
.startsWith("http://www.springframework.org/schema/")) {<z>
+ namespaceUri + "]", node);<z>
()) {<z>
"]");<z>
return originalDef;<z>
? extends CharSequence> messageSupplier) {<z>
.log.isErrorEnabled()) {<z>
));<z>
(@Nullable ReactiveTransactionInfo txInfo) {<z>
) {<z>
()) {<z>
.getJoinpointIdentification() + "]");<z>
);<z>
();<z>
) {<z>
= candidate.getAnnotation(ConstructorProperties.class);<z>
) {<z>
.value();<z>
paramCount) {<z>
throw new IllegalStateException("Constructor annotated with @ConstructorProperties but not " +<z>
);<z>
;<z>
null;<z>
ObjectFactory<?> singletonFactory) {<z>
notNull(beanName, "Bean name must not be null");<z>
this.singletonObjects) {<z>
;<z>
(singletonObject == null) {<z>
{<z>
,<z>
);<z>
{<z>
debug("Creating shared instance of singleton bean '" + beanName + "'");<z>
beforeSingletonCreation(beanName);<z>
;<z>
recordSuppressedExceptions = (this.suppressedExceptions == null);<z>
) {<z>
LinkedHashSet<>();<z>
;<z>
true;<z>
catch (IllegalStateException ex) {<z>
beanName);<z>
{<z>
;<z>
) {<z>
if (recordSuppressedExceptions) {<z>
Exception suppressedException : this.suppressedExceptions) {<z>
addRelatedCause(suppressedException);<z>
ex;<z>
(recordSuppressedExceptions) {<z>
;<z>
;<z>
(newSingleton) {<z>
);<z>
singletonObject;<z>
(Class<?> clazz) {<z>
: this.filters) {<z>
{<z>
;<z>
return false;<z>
(String name) {<z>
);<z>
) {<z>
new BeanDefinitionValidationException("Could not find unique destroy method on bean with name '" +<z>
());<z>
response) throws IOException, ServletException {<z>
;<z>
notNull(response, "Response must not be null");<z>
this.request == null, "This FilterChain has already been called!");<z>
.iterator == null) {<z>
.iterator();<z>
{<z>
();<z>
(request, response, this);<z>
request = request;<z>
response = response;<z>
int getScheduledConsumerCount() {<z>
(this.lifecycleMonitor) {<z>
;<z>
Nullable String valueProperty,<z>
, int itemIndex) throws JspException {<z>
();<z>
Object mapValue = entry.getValue();<z>
);<z>
forBeanPropertyAccess(mapValue);<z>
?<z>
());<z>
labelProperty != null ?<z>
.toString());<z>
);<z>
listener,<z>
.SynchronizationCallback> callbacks) {<z>
.event = event;<z>
this.listener = listener;<z>
;<z>
parseComponent(Element element) {<z>
Component.class);<z>
getAttribute("name"));<z>
);<z>
?> clazz) {<z>
(this.supportedClasses)) {<z>
return true;<z>
?> supportedClass : this.supportedClasses) {<z>
)) {<z>
;<z>
false;<z>
invocableClone() {<z>
cloneArguments = this.arguments;<z>
this.arguments.length > 0) {<z>
clone();<z>
;<z>
,<z>
Nullable String servletName) {<z>
;<z>
.getClass());<z>
.getMessage());<z>
, ex);<z>
());<z>
{<z>
request, ERROR_SERVLET_NAME_ATTRIBUTE, servletName);<z>
String path) {<z>
= false;<z>
(); i++) {<z>
i) == '/') {<z>
true;<z>
{<z>
) {<z>
return path;<z>
) : path.substring(i);<z>
path;<z>
? "/" : "");<z>
rootDir, String subPattern) throws IOException {<z>
)) {<z>
getPath() + "]");<z>
retrieveMatchingFiles(rootDir, subPattern);<z>
;<z>
matchingFiles) {<z>
(file));<z>
result;<z>
applicationContext, ServletContext servletContext,<z>
Nullable UrlPathHelper pathHelper) {<z>
Assert.notNull(applicationContext, "ApplicationContext is required");<z>
.applicationContext = applicationContext;<z>
.servletContext = servletContext;<z>
;<z>
pathHelper = pathHelper;<z>
testClass, Set<Method> methods) {<z>
(testClass, this::isAnnotated));<z>
{<z>
;<z>
) {<z>
!= null) {<z>
.putAll(mediaTypes);<z>
return this;<z>
javaScriptEscape(String input) {<z>
StringBuilder(input.length());<z>
0000';<z>
c;<z>
); i++) {<z>
.charAt(i);<z>
'"') {<z>
"\\\"");<z>
if (c == '\'') {<z>
;<z>
'\\') {<z>
filtered.append("\\\\");<z>
(c == '/') {<z>
"\\/");<z>
) {<z>
.append("\\t");<z>
== '\n') {<z>
prevChar != '\r') {<z>
.append("\\n");<z>
(c == '\r') {<z>
"\\n");<z>
if (c == '\f') {<z>
);<z>
(c == '\b') {<z>
.append("\\b");<z>
'\013') {<z>
("\\v");<z>
'<') {<z>
append("\\u003C");<z>
(c == '>') {<z>
);<z>
else if (c == '\u2028') {<z>
filtered.append("\\u2028");<z>
'\u2029') {<z>
("\\u2029");<z>
(c);<z>
= c;<z>
();<z>
{<z>
;<z>
this.path;<z>
("/")) {<z>
;<z>
('/');<z>
.startsWith("/")) {<z>
);<z>
builder.append(pathToUse);<z>
append(']');<z>
toString();<z>
[] statement, int position) {<z>
START_SKIP.length; i++) {<z>
].charAt(0)) {<z>
true;<z>
++) {<z>
) {<z>
= false;<z>
) {<z>
= START_SKIP[i].length();<z>
< statement.length; m++) {<z>
].charAt(0)) {<z>
;<z>
int endPos = m;<z>
(); n++) {<z>
length) {<z>
length;<z>
[i].charAt(n)) {<z>
= false;<z>
+ n;<z>
endMatch) {<z>
+ 1;<z>
length;<z>
;<z>
> determineTargetConnectionFactory() {<z>
;<z>
).defaultIfEmpty(FALLBACK_MARKER);<z>
{<z>
resolvedConnectionFactories.get(key);<z>
key == FALLBACK_MARKER || this.lenientFallback)) {<z>
this.resolvedDefaultConnectionFactory;<z>
) {<z>
new IllegalStateException(String.format(<z>
;<z>
next(connectionFactory);<z>
});<z>
) {<z>
= new PathPatternParser();<z>
MESSAGE_ROUTE);<z>
(false);<z>
int getColumnType(int column) throws InvalidResultSetAccessException {<z>
(column);<z>
SQLException se) {<z>
se);<z>
HttpServletRequest request, HttpServletResponse response, Object handler,<z>
Nullable Exception ex) throws Exception {<z>
, response), ex);<z>
mavContainer,<z>
binderFactory) throws Exception {<z>
= webRequest.getNativeRequest(HttpServletRequest.class);<z>
request == null) {<z>
throw new IllegalStateException("Current request is not of type HttpServletRequest: " + webRequest);<z>
();<z>
isInstance(principal)) {<z>
IllegalStateException("Current user principal is not of type [" +<z>
() + "]: " + principal);<z>
;<z>
void applyAfterHandshake(<z>
Exception failure) {<z>
i >= 0; i--) {<z>
(i);<z>
wsHandler, failure);<z>
ex) {<z>
(logger.isWarnEnabled()) {<z>
);<z>
String getParameter(String name) {<z>
) {<z>
;<z>
);<z>
handleMissingServletRequestParameter(MissingServletRequestParameterException ex,<z>
handler) throws IOException {<z>
));<z>
();<z>
resource, DataBufferFactory dataBufferFactory,<z>
) {<z>
.getResource(), dataBufferFactory, 8192))<z>
) -> {<z>
{<z>
= (resource.getCharset() != null ?<z>
;<z>
);<z>
);<z>
(script);<z>
);<z>
Exception ex) {<z>
;<z>
);<z>
;<z>
(SqlParameterSource parameterSource) {<z>
;<z>
parameterSource);<z>
);<z>
{<z>
{<z>
);<z>
null) {<z>
getPathPatterns());<z>
) throws IllegalArgumentException {<z>
);<z>
enterMessage);<z>
, PLACEHOLDER_RETURN_VALUE,<z>
PLACEHOLDER_RETURN_VALUE);<z>
.doesNotContain(enterMessage, PLACEHOLDER_EXCEPTION,<z>
);<z>
(enterMessage, PLACEHOLDER_INVOCATION_TIME,<z>
+ PLACEHOLDER_INVOCATION_TIME);<z>
enterMessage;<z>
Object[] validationHints, MethodParameter param,<z>
{<z>
Conventions.getVariableNameForParameter(param);<z>
);<z>
);<z>
.getBindingResult().hasErrors()) {<z>
param, binder.getBindingResult());<z>
) throws BeansException {<z>
requiredType, "Required type must not be null");<z>
false);<z>
if (resolved == null) {<z>
new NoSuchBeanDefinitionException(requiredType);<z>
resolved;<z>
(<z>
String beanName, Class<?> targetClass) {<z>
null && beanFactory.containsBeanDefinition(beanName)) {<z>
targetClass);<z>
<?> targetType) {<z>
;<z>
{<z>
= enumType.getSuperclass();<z>
.getName() + " does not refer to an enum");<z>
enumType;<z>
DOMResult domResult) throws XmlMappingException {<z>
domResult.getNode() == null) {<z>
());<z>
(graph, domResult.getNode());<z>
) {<z>
{<z>
setCacheLimit(this.cacheLimit);<z>
int hashCode() {<z>
7;<z>
genericArgumentValues) {<z>
hashCode + valueHolder.contentHashCode();<z>
= 29 * hashCode;<z>
{<z>
());<z>
return hashCode;<z>
, URI uri,<z>
>> requestCallback) {<z>
doConnect(httpMethod, uri, requestCallback))<z>
));<z>
() {<z>
.beanFactory.getType(this.name);<z>
) {<z>
this.name)) {<z>
;<z>
getOrder(type, Ordered.LOWEST_PRECEDENCE);<z>
LOWEST_PRECEDENCE;<z>
{<z>
.propertySources != null) {<z>
{<z>
(key)) {<z>
true;<z>
;<z>
Mono<Connection> prepareConnection(Connection connection) {<z>
();<z>
(autoCommit != null) {<z>
)).thenReturn(connection);<z>
;<z>
>> classes) {<z>
)) {<z>
"[]";<z>
, "[", "]");<z>
clazz : classes) {<z>
.add(clazz.getName());<z>
();<z>
@Nullable V value) {<z>
, TaskOption.SKIP_IF_EMPTY) {<z>
V> entry) {<z>
null) {<z>
V oldValue = entry.getValue();<z>
entry.setValue(value);<z>
return oldValue;<z>
return null;<z>
);<z>
) throws IOException {<z>
;<z>
(expectedLength < 256) {<z>
;<z>
, MAX_BUFFER_SIZE);<z>
(<z>
Label... labels) {<z>
null) {<z>
labels);<z>
public final void onNext(T data) {<z>
)) {<z>
getSimpleName());<z>
onNext(this, data);<z>
, String transport) {<z>
transport)) {<z>
);<z>
;<z>
)) {<z>
);<z>
;<z>
;<z>
Connection con) {<z>
;<z>
) {<z>
;<z>
conToUse;<z>
() {<z>
;<z>
{<z>
.defaultUseWrapper != null ?<z>
defaultUseWrapper, this.factory) :<z>
this.factory));<z>
());<z>
mapper);<z>
mapper;<z>
clearErrorRequestAttributes(HttpServletRequest request) {<z>
request.removeAttribute(ERROR_STATUS_CODE_ATTRIBUTE);<z>
removeAttribute(ERROR_EXCEPTION_TYPE_ATTRIBUTE);<z>
request.removeAttribute(ERROR_MESSAGE_ATTRIBUTE);<z>
removeAttribute(ERROR_EXCEPTION_ATTRIBUTE);<z>
.removeAttribute(ERROR_REQUEST_URI_ATTRIBUTE);<z>
);<z>
afterPropertiesSet() {<z>
(getDataSource() == null) {<z>
);<z>
(!isLazyInit()) {<z>
();<z>
resolveMediaTypes(NativeWebRequest request)<z>
throws HttpMediaTypeNotAcceptableException {<z>
getHeaderValues(HttpHeaders.ACCEPT);<z>
null) {<z>
MEDIA_TYPE_ALL_LIST;<z>
(headerValueArray);<z>
);<z>
);<z>
? mediaTypes : MEDIA_TYPE_ALL_LIST;<z>
catch (InvalidMediaTypeException ex) {<z>
HttpMediaTypeNotAcceptableException(<z>
+ ex.getMessage());<z>
<Void> handlePreFlight(ServerWebExchange exchange) {<z>
))<z>
(exchange))<z>
setStatusCode(HttpStatus.FORBIDDEN)))<z>
next()<z>
then();<z>
) {<z>
(this.beanFactory != null, "No BeanFactory set");<z>
.aspectBeanName != null, "No 'aspectBeanName' set");<z>
beanFactory.getBean(this.aspectBeanName);<z>
tb, int num, Integer something) {<z>
something != null) {<z>
throw new IllegalStateException("Should never be called with non-null value");<z>
null, num);<z>
resolveCorsAnnotationValue(String value) {<z>
{<z>
resolveStringValue(value);<z>
"");<z>
value;<z>
static Object createJndiObjectProxy(JndiObjectFactoryBean jof) throws NamingException {<z>
new JndiObjectTargetSource();<z>
setJndiTemplate(jof.getJndiTemplate());<z>
;<z>
, "No JNDI name specified");<z>
;<z>
setExpectedType(jof.getExpectedType());<z>
());<z>
);<z>
.setCache(jof.cache);<z>
();<z>
;<z>
if (jof.proxyInterfaces != null) {<z>
;<z>
?> targetClass = targetSource.getTargetClass();<z>
) {<z>
new IllegalStateException(<z>
);<z>
, jof.beanClassLoader);<z>
) {<z>
{<z>
);<z>
jof.exposeAccessContext) {<z>
JndiContextExposingInterceptor(jof.getJndiTemplate()));<z>
targetSource);<z>
.getProxy(jof.beanClassLoader);<z>
, @Nullable HttpServletRequest request, Resource location) {<z>
shouldDecodeRelativePath(location, request)) {<z>
);<z>
{<z>
);<z>
();<z>
(path, "/");<z>
while (tokenizer.hasMoreTokens()) {<z>
tokenizer.nextToken(), charset);<z>
sb.append(value);<z>
('/');<z>
.endsWith("/")) {<z>
() - 1);<z>
;<z>
path;<z>
(Class superclass) {<z>
!= null && superclass.isInterface()) {<z>
superclass});<z>
(superclass);<z>
class)) {<z>
;<z>
= superclass;<z>
setContextClass(superclass);<z>
) {<z>
this.lifecycleMetadataCache == null) {<z>
);<z>
= this.lifecycleMetadataCache.get(clazz);<z>
if (metadata == null) {<z>
{<z>
get(clazz);<z>
null) {<z>
buildLifecycleMetadata(clazz);<z>
.lifecycleMetadataCache.put(clazz, metadata);<z>
metadata;<z>
;<z>
(String contentId, DataSource dataSource) throws MessagingException {<z>
, "Content ID must not be null");<z>
);<z>
);<z>
setDisposition(Part.INLINE);<z>
contentId + ">");<z>
(new DataHandler(dataSource));<z>
getMimeMultipart().addBodyPart(mimeBodyPart);<z>
Nullable BeanFactory beanFactory, String qualifier) {<z>
) {<z>
) +<z>
"'");<z>
beanFactory, Executor.class, qualifier);<z>
) {<z>
"Unregistering JMX-exposed beans on shutdown");<z>
unregisterNotificationListeners();<z>
unregisterBeans();<z>
Class<?> bodyClass) {<z>
size());<z>
> converter : this.messageConverters) {<z>
(converter.getSupportedMediaTypes(bodyClass));<z>
(result);<z>
result;<z>
, MessageConverter converter, long expirationPeriod) {<z>
.fromMessage(message, UserRegistrySnapshot.class);<z>
{<z>
init(expirationPeriod, this.sessionLookup);<z>
(registry.getId(), registry);<z>
) {<z>
StringBuilder sb = new StringBuilder();<z>
)).append(" error(s): ");<z>
.getAllErrors()) {<z>
).append("] ");<z>
;<z>
configureIndentation(Transformer transformer) {<z>
{<z>
(transformer);<z>
TransformerUtils.disableIndenting(transformer);<z>
resolveFor() throws JspException {<z>
{<z>
FOR_ATTRIBUTE, this.forId));<z>
autogenerateFor();<z>
public void start() {<z>
if (!isRunning()) {<z>
running = true;<z>
();<z>
) {<z>
(exceptionMessage, "exceptionMessage must not be empty");<z>
exceptionMessage);<z>
Assert.doesNotContain(exceptionMessage, PLACEHOLDER_RETURN_VALUE,<z>
);<z>
= exceptionMessage;<z>
session, @Nullable Object conversionHint)<z>
throws JMSException {<z>
;<z>
) {<z>
"No message converter, cannot handle '" + payload + "'");<z>
{<z>
session, conversionHint);<z>
payload, session);<z>
) throws ELException {<z>
if (base == null) {<z>
.toString();<z>
getWebApplicationContext(elContext);<z>
wac.containsBean(beanName)) {<z>
{<z>
true);<z>
new PropertyNotWritableException(<z>
);<z>
... buffers) {<z>
{<z>
: buffers) {<z>
;<z>
;<z>
) throws EvaluationException {<z>
compiledAst;<z>
{<z>
);<z>
).getValue(), context);<z>
null) {<z>
;<z>
return ExpressionUtils.convertTypedValue(<z>
, new TypedValue(result), expectedResultType);<z>
catch (Throwable ex) {<z>
.getCompilerMode() == SpelCompilerMode.MIXED) {<z>
;<z>
.set(0);<z>
new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);<z>
getEvaluationContext(), this.configuration);<z>
.ast.getTypedValue(expressionState);<z>
);<z>
return ExpressionUtils.convertTypedValue(<z>
expectedResultType);<z>
) {<z>
getPathSegments();<z>
;<z>
) {<z>
expandUriComponent(pathSegment, uriVariables, encoder);<z>
add(expandedPathSegment);<z>
;<z>
private void logicalClose(Session proxy) throws JMSException {<z>
target.getTransacted()) {<z>
;<z>
;<z>
.hasNext();) {<z>
it.next();<z>
subscription != null) {<z>
().close();<z>
.remove();<z>
false;<z>
) {<z>
proxy)) {<z>
;<z>
;<z>
&& logger.isTraceEnabled()) {<z>
.trace("Returned cached Session: " + this.target);<z>
RSocketFrameTypeMessageCondition getMatchingCondition(Message<?> message) {<z>
FRAME_TYPE_HEADER, FrameType.class);<z>
actual != null) {<z>
frameTypes) {<z>
) {<z>
type.name());<z>
null;<z>
bufferFactory) {<z>
= handshakeInfo;<z>
= handler;<z>
= bufferFactory;<z>
static void addAttributesIfNotNull(<z>
Nullable Map<String, Object> attributes) {<z>
!= null) {<z>
;<z>
boolean isIn(Adapt... adaptations) {<z>
: adaptations) {<z>
{<z>
;<z>
return false;<z>
(<z>
:<z>
()));<z>
<DecodingException, ServerWebInputException> DECODING_MAPPER =<z>
, ex);<z>
exchange;<z>
private final Headers headers;<z>
>> messageReaders;<z>
?>> messageReaders) {<z>
.exchange = exchange;<z>
);<z>
.headers = new DefaultHeaders();<z>
, @Nullable Exception ex) throws DataAccessException {<z>
{<z>
= (EntityManagerHolder)<z>
obtainEntityManagerFactory());<z>
debug("Closing JPA EntityManager in OpenEntityManagerInViewInterceptor");<z>
());<z>
protected ConnectionBuilder createConnectionBuilder(URI url) {<z>
= io.undertow.websockets.client.WebSocketClient<z>
, url);<z>
builder);<z>
return builder;<z>
String[] headers) {<z>
result = null;<z>
isEmpty(headers)) {<z>
header : headers) {<z>
.HeaderExpression(header);<z>
"Accept".equalsIgnoreCase(expr.name)) {<z>
expr.value)) {<z>
>());<z>
.isNegated));<z>
)) {<z>
{<z>
));<z>
.add(new ProduceMediaTypeExpression(produce));<z>
());<z>
obtainSessionFactory() {<z>
();<z>
state(sessionFactory != null, "No SessionFactory set");<z>
return sessionFactory;<z>
BeanDefinition beanDefinition) {<z>
= beanDefinition.getFactoryBeanName();<z>
null) {<z>
resolveStringValue(factoryBeanName);<z>
)) {<z>
;<z>
Nullable Object other) {<z>
this == other) {<z>
true;<z>
(other instanceof RequestMappingInfo otherInfo)) {<z>
false;<z>
patternsCondition) &&<z>
otherInfo.methodsCondition) &&<z>
.paramsCondition.equals(otherInfo.paramsCondition) &&<z>
equals(otherInfo.headersCondition) &&<z>
(otherInfo.consumesCondition) &&<z>
.producesCondition.equals(otherInfo.producesCondition) &&<z>
(otherInfo.customConditionHolder));<z>
(String contentId, Resource resource) throws MessagingException {<z>
resource, "Resource must not be null");<z>
resource.getFilename());<z>
, contentType);<z>
Object requestBody, @Nullable Type responseType) {<z>
);<z>
{<z>
requestBody;<z>
else if (requestBody != null) {<z>
new HttpEntity<>(requestBody);<z>
EMPTY;<z>
{<z>
if (logger.isDebugEnabled()) {<z>
.sessionId);<z>
if (this.isRemoteClientSession) {<z>
sessionId);<z>
;<z>
> conn = this.tcpConnection;<z>
.tcpConnection = null;<z>
!= null) {<z>
if (logger.isDebugEnabled()) {<z>
.sessionId);<z>
close();<z>
getJarFile(String jarFileUrl) throws IOException {<z>
ResourceUtils.FILE_URL_PREFIX)) {<z>
(jarFileUrl).getSchemeSpecificPart());<z>
ex) {<z>
.FILE_URL_PREFIX.length()));<z>
jarFileUrl);<z>
Exception {<z>
);<z>
{<z>
;<z>
;<z>
]> clientMessage) {<z>
() == null) {<z>
;<z>
clientMessage, ex);<z>
{<z>
getAccessor(message, StompHeaderAccessor.class);<z>
state(accessor != null, "No StompHeaderAccessor");<z>
, message.getPayload());<z>
getAsyncExecutor(Element element) {<z>
(element, "async-support");<z>
asyncElement.hasAttribute("task-executor")) {<z>
RuntimeBeanReference(asyncElement.getAttribute("task-executor"));<z>
null;<z>
NamingException {<z>
{<z>
.class));<z>
builder) {<z>
;<z>
isEmpty()) {<z>
, scripts, "INIT"));<z>
"DESTROY"));<z>
JmsTemplate(ConnectionFactory connectionFactory) {<z>
;<z>
);<z>
);<z>
(Field field) {<z>
.getName();<z>
declaringClass = field.getDeclaringClass();<z>
= field;<z>
public File getFile() throws IOException {<z>
if (this.uri != null) {<z>
this.uri);<z>
;<z>
) {<z>
accessors = this.propertyAccessors;<z>
(accessors == null) {<z>
accessors = new ArrayList<>(5);<z>
));<z>
;<z>
return accessors;<z>
isAutowireCandidate(<z>
beanName, DependencyDescriptor descriptor, AutowireCandidateResolver resolver)<z>
NoSuchBeanDefinitionException {<z>
BeanFactoryUtils.transformedBeanName(beanName);<z>
containsBeanDefinition(bdName)) {<z>
resolver);<z>
{<z>
descriptor, resolver);<z>
= getParentBeanFactory();<z>
DefaultListableBeanFactory) {<z>
);<z>
parent instanceof ConfigurableListableBeanFactory) {<z>
;<z>
;<z>
{<z>
{<z>
symbolTable.addConstantUtf8(attributeName);<z>
= 8;<z>
;<z>
null) {<z>
;<z>
annotationWriter = annotationWriter.previousAnnotation;<z>
attributeSize;<z>
setClock(Clock clock) {<z>
notNull(clock, "Clock is required");<z>
this.clock = clock;<z>
();<z>
{<z>
, getMessage());<z>
getLoggerName());<z>
);<z>
;<z>
(getSourceClassName());<z>
));<z>
.setSequenceNumber(getSequenceNumber());<z>
(getParameters());<z>
());<z>
setInstant(getInstant());<z>
));<z>
serialized;<z>
String, String> headers) {<z>
).stream()<z>
entry -> {<z>
.getValue();<z>
(values.size() == 1 ?<z>
"\"" :<z>
Collectors.joining(", ")));<z>
);<z>
static Object getContentNegotiationManager(ParserContext context) {<z>
name = AnnotationDrivenBeanDefinitionParser.HANDLER_MAPPING_BEAN_NAME;<z>
.containsBeanDefinition(name)) {<z>
;<z>
);<z>
name = AnnotationDrivenBeanDefinitionParser.CONTENT_NEGOTIATION_MANAGER_BEAN_NAME;<z>
)) {<z>
new RuntimeBeanReference(name);<z>
null;<z>
{<z>
return result -> {<z>
);<z>
);<z>
;<z>
createBodyFlushProcessor() {<z>
();<z>
= processor;<z>
return processor;<z>
<T> results) throws IncorrectResultSizeDataAccessException {<z>
.isEmpty(results)) {<z>
return null;<z>
.size() > 1) {<z>
());<z>
().next();<z>
String allowedHeader) {<z>
.allowedHeaders == null) {<z>
new ArrayList<>(4);<z>
DEFAULT_PERMIT_ALL) {<z>
;<z>
);<z>
startConnection) throws JmsException {<z>
;<z>
con = null;<z>
Session session = null;<z>
= createConnection();<z>
.createSession(false, Session.AUTO_ACKNOWLEDGE);<z>
if (startConnection) {<z>
.start();<z>
) {<z>
logger.debug("Executing callback on JMS Session: " + session);<z>
action.doInJms(session);<z>
) {<z>
ex);<z>
(session);<z>
;<z>
HttpServletResponse response) {<z>
(this.cacheControl != null) {<z>
)) {<z>
trace("Applying default " + getCacheControl());<z>
, this.cacheControl);<z>
logger.isTraceEnabled()) {<z>
("Applying default cacheSeconds=" + this.cacheSeconds);<z>
cacheSeconds);<z>
varyByRequestHeaders != null) {<z>
.varyByRequestHeaders)) {<z>
addHeader("Vary", value);<z>
destroy() {<z>
!= null) {<z>
shutdown();<z>
(this.awaitTerminationSeconds > 0) {<z>
, TimeUnit.SECONDS);<z>
{<z>
).interrupt();<z>
Attributes getAttributes() {<z>
new AttributesImpl();<z>
++) {<z>
;<z>
hasNamespacesFeature()) {<z>
"";<z>
i);<z>
(type == null) {<z>
= "CDATA";<z>
.reader.getAttributeLocalName(i),<z>
;<z>
if (hasNamespacePrefixesFeature()) {<z>
.getNamespaceCount(); i++) {<z>
.getNamespacePrefix(i);<z>
;<z>
;<z>
if (StringUtils.hasLength(prefix)) {<z>
;<z>
"xmlns";<z>
qName, "CDATA", namespaceUri);<z>
;<z>
() {<z>
;<z>
!= null);<z>
catch (MalformedURLException ex) {<z>
false;<z>
static Log getLogger() {<z>
logger = IntrospectionFailureLogger.logger;<z>
if (logger == null) {<z>
;<z>
IntrospectionFailureLogger.logger = logger;<z>
logger;<z>
public int getPrecision(int column) throws InvalidResultSetAccessException {<z>
column);<z>
SQLException se) {<z>
;<z>
,<z>
@Nullable NavigationHandler originalNavigationHandler) {<z>
= getDecoratedNavigationHandler();<z>
instanceof DecoratingNavigationHandler decHandler) {<z>
;<z>
!= null) {<z>
, outcome);<z>
) {<z>
);<z>
,<z>
TransactionException {<z>
{<z>
), suspendedResources);<z>
.empty();<z>
;<z>
InvocationHandler visitor) throws IOException {<z>
= Proxy.newProxyInstance(<z>
,<z>
[] {VIRTUAL_FILE_VISITOR_INTERFACE}, visitor);<z>
VIRTUAL_FILE_METHOD_VISIT, resource, visitorProxy);<z>
public Object getOrderSource(Object obj) {<z>
this.instancesToBeanNames.get(obj);<z>
!containsBeanDefinition(beanName)) {<z>
null;<z>
RootBeanDefinition beanDefinition = getMergedLocalBeanDefinition(beanName);<z>
ArrayList<>(2);<z>
Method factoryMethod = beanDefinition.getResolvedFactoryMethod();<z>
) {<z>
add(factoryMethod);<z>
);<z>
!= obj.getClass()) {<z>
;<z>
();<z>
() {<z>
();<z>
MimeType mimeType : READABLE_MIME_TYPES) {<z>
{<z>
true;<z>
;<z>
() {<z>
routeMatcher : initRouteMatcher());<z>
.adapterRegistry != null ?<z>
.getSharedInstance());<z>
!= null ?<z>
: new NettyDataBufferFactory(PooledByteBufAllocator.DEFAULT));<z>
.metadataExtractor != null ?<z>
));<z>
if (extractor instanceof MetadataExtractorRegistry) {<z>
));<z>
DefaultRSocketStrategies(<z>
;<z>
(ClassLoader classLoader, String templatePath) throws IOException {<z>
parse(templatePath);<z>
getLocale();<z>
));<z>
null) {<z>
).toString());<z>
== null) {<z>
null).toString());<z>
if (url == null) {<z>
);<z>
url;<z>
<Void> doCleanupAfterCompletion(TransactionSynchronizationManager synchronizationManager,<z>
{<z>
empty();<z>
afterPropertiesSet() {<z>
);<z>
this.argumentResolvers == null) {<z>
;<z>
().addResolvers(resolvers);<z>
(this.initBinderArgumentResolvers == null) {<z>
resolvers = getDefaultInitBinderArgumentResolvers();<z>
).addResolvers(resolvers);<z>
(this.returnValueHandlers == null) {<z>
HandlerMethodReturnValueHandler> handlers = getDefaultReturnValueHandlers();<z>
);<z>
) {<z>
(this.sourceList == null) {<z>
("'sourceList' is required");<z>
;<z>
!= null) {<z>
;<z>
.sourceList.size());<z>
> valueType = null;<z>
this.targetListClass != null) {<z>
.asCollection().resolveGeneric();<z>
(valueType != null) {<z>
TypeConverter converter = getBeanTypeConverter();<z>
{<z>
);<z>
(this.sourceList);<z>
return result;<z>
protected SavepointManager getSavepointManager() {<z>
transaction;<z>
(transaction instanceof SavepointManager)) {<z>
NestedTransactionNotSupportedException(<z>
.transaction + "] does not support savepoints");<z>
(SavepointManager) transaction;<z>
ApplicationContext context) {<z>
= null;<z>
{<z>
=<z>
;<z>
.isEmpty()) {<z>
<>(matchingBeans.values());<z>
handlerMappings);<z>
(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);<z>
(hm);<z>
ex) {<z>
{<z>
;<z>
.isTraceEnabled()) {<z>
) +<z>
);<z>
for (HandlerMapping mapping : this.handlerMappings) {<z>
(mapping.usesPathPatterns()) {<z>
this.parseRequestPath = true;<z>
testClass) {<z>
(localSqlConfig, false, false);<z>
enforceCommentPrefixAliases(localAttributes);<z>
;<z>
{<z>
;<z>
, false);<z>
(globalAttributes);<z>
globalAttributes.keySet()) {<z>
Object value = localAttributes.get(key);<z>
(isExplicitValue(value)) {<z>
.put(key, value);<z>
(COMMENT_PREFIXES))) {<z>
(COMMENT_PREFIXES, value);<z>
)) {<z>
COMMENT_PREFIX, value);<z>
globalAttributes;<z>
public HandlerStrategies build() {<z>
codecConfigurer.getReaders(),<z>
.webFilters,<z>
);<z>
extractPayload(Message message) throws JMSException {<z>
extractMessage(message);<z>
) {<z>
();<z>
JMSException ex) {<z>
ex);<z>
;<z>
> T reset(T temporal) {<z>
this.lowerOrders) {<z>
(lowerOrder)) {<z>
));<z>
temporal;<z>
(Object managedBean, String beanKey) throws JMException {<z>
;<z>
ModelMBeanInfoSupport(<z>
(managedBean, beanKey),<z>
getConstructorInfo(managedBean, beanKey),<z>
;<z>
getMBeanDescriptor();<z>
desc, managedBean, beanKey);<z>
;<z>
return info;<z>
void rejectValue(<z>
String defaultMessage) {<z>
, errorArgs, defaultMessage);<z>
void afterPropertiesSet() {<z>
) {<z>
IllegalArgumentException("'refreshOnConnectFailure' does not work when setting " +<z>
);<z>
connectOnStartup) {<z>
();<z>
) throws JspException {<z>
if (shouldRender()) {<z>
"No TagWriter set");<z>
.getString())) {<z>
bodyContent, this.tagWriter);<z>
renderDefaultContent(this.tagWriter);<z>
EVAL_PAGE;<z>
public String toString() {<z>
).iterator();<z>
;<z>
()) {<z>
> entry = entries.next();<z>
.getKey());<z>
.append('=');<z>
entry.getValue()));<z>
if (entries.hasNext()) {<z>
.append(", ");<z>
sb.append('}');<z>
toString();<z>
) throws IOException, ServletException {<z>
)<z>
getName,<z>
new,<z>
);<z>
HttpHeaders getResponseHeaders() {<z>
instanceof HttpResource httpResource ?<z>
());<z>
version + "\"");<z>
headers;<z>
) {<z>
;<z>
resolved != null && resolved != Object.class;<z>
result : ResolvableType.NONE);<z>
inserts) {<z>
formatMessage(inserts), cause);<z>
this.message = message;<z>
this.inserts = inserts;<z>
() {<z>
afterPropertiesSet();<z>
);<z>
initialize();<z>
() {<z>
event.isStartElement()) {<z>
.asStartElement().getNamespaceContext();<z>
);<z>
String text, Locale locale) throws ParseException {<z>
format = getNumberFormat(locale);<z>
= new ParsePosition(0);<z>
);<z>
{<z>
, position.getIndex());<z>
lenient) {<z>
)) {<z>
);<z>
return number;<z>
<A>> condition)<z>
NoSuchElementException {<z>
.empty());<z>
{<z>
.keySet());<z>
: keyNames) {<z>
(name);<z>
value)) {<z>
= BindingResult.MODEL_KEY_PREFIX + name;<z>
!model.containsAttribute(bindingResultKey)) {<z>
, value, name);<z>
bindingResultKey, dataBinder.getBindingResult());<z>
Void> invokeModelAttributeMethods(BindingContext bindingContext,<z>
List<InvocableHandlerMethod> modelMethods, ServerWebExchange exchange) {<z>
);<z>
bindingContext)));<z>
resultList, objectArray -><z>
stream(objectArray)<z>
(HandlerResult) object), bindingContext))<z>
)))<z>
Mono::when);<z>
unitName, @Nullable String requestingBeanName)<z>
throws NoSuchBeanDefinitionException {<z>
, "ListableBeanFactory required for EntityManagerFactory bean lookup");<z>
);<z>
ConfigurableBeanFactory cbf) {<z>
);<z>
return emf;<z>
(BeanNameGenerator beanNameGenerator) {<z>
reader.setBeanNameGenerator(beanNameGenerator);<z>
);<z>
getBeanFactory().registerSingleton(<z>
beanNameGenerator);<z>
Object handler)<z>
{<z>
.getAttribute("test2") != null) {<z>
"Wrong interceptor order");<z>
, "test1");<z>
"test1x", "test1x");<z>
);<z>
true;<z>
profile) {<z>
);<z>
();<z>
return (currentActiveProfiles.contains(profile) ||<z>
contains(profile)));<z>
ClassNotFoundException {<z>
defaultReadObject();<z>
();<z>
testClass) {<z>
(testClass, "Class must not be null");<z>
Class<ContextConfiguration> annotationType = ContextConfiguration.class;<z>
annotationType);<z>
(descriptor, () -> String.format(<z>
, testClass.getName()));<z>
> attributesList = new ArrayList<>();<z>
ContextConfiguration previousAnnotation = null;<z>
previousDeclaringClass = null;<z>
) {<z>
);<z>
&& hasResources(currentAnnotation)) {<z>
isDebugEnabled()) {<z>
String.format("Ignoring duplicate %s declaration on [%s], "<z>
,<z>
));<z>
convertContextConfigToConfigAttributesAndAddToList(currentAnnotation,<z>
, attributesList);<z>
currentAnnotation;<z>
.getRootDeclaringClass();<z>
descriptor.next();<z>
attributesList;<z>
(String attributeName) throws JspException {<z>
currentState().isBlockTag()) {<z>
throw new IllegalStateException("Cannot write attributes after opening tag is closed.");<z>
.append(attributeName);<z>
{<z>
.notNull(interfaces, "Interfaces must not be null");<z>
();<z>
{<z>
);<z>
Resource location) throws IOException {<z>
resource = location.createRelative(resourcePath);<z>
if (resource.isReadable()) {<z>
(resource, location)) {<z>
return resource;<z>
logger.isWarnEnabled()) {<z>
;<z>
(LogFormatUtils.formatValue(<z>
+<z>
resource.getURL() + "\" is neither under " +<z>
getURL() + "\" nor under any of " +<z>
1, true));<z>
return null;<z>
Void> save() {<z>
;<z>
) {<z>
State.NEW, State.STARTED);<z>
(isStarted()) {<z>
;<z>
{<z>
remove(this.getId());<z>
("Session was invalidated"));<z>
.empty();<z>
(StompHeaders headers, boolean consumed) {<z>
= checkOrAddReceipt(headers);<z>
(receiptId);<z>
.NACK);<z>
;<z>
(headers);<z>
);<z>
(message);<z>
;<z>
Class<?> outputClass) {<z>
String localPart;<z>
namespaceUri;<z>
)) {<z>
(XmlRootElement.class);<z>
;<z>
.namespace();<z>
XmlType.class)) {<z>
.getAnnotation(XmlType.class);<z>
= annotation.name();<z>
namespaceUri = annotation.namespace();<z>
"Output class [" + outputClass.getName() +<z>
);<z>
(localPart)) {<z>
(outputClass);<z>
.equals(namespaceUri)) {<z>
getPackage();<z>
.class)) {<z>
(XmlSchema.class);<z>
;<z>
= XMLConstants.NULL_NS_URI;<z>
;<z>
dayOfWeekInMonth(int ordinal, DayOfWeek dayOfWeek) {<z>
(ordinal, dayOfWeek);<z>
{<z>
temporal);<z>
, result);<z>
(String constantName) throws IllegalArgumentException {<z>
.startsWith(PREFIX_PROPAGATION)) {<z>
throw new IllegalArgumentException("Only propagation constants allowed");<z>
);<z>
{<z>
null) {<z>
, module);<z>
module.getTypeId(), module);<z>
) throws RestClientException {<z>
RequestCallback requestCallback = httpEntityCallback(request);<z>
());<z>
: null);<z>
SpelNodeImpl eatLogicalOrExpression() {<z>
;<z>
{<z>
;<z>
);<z>
(t, expr, rhExpr);<z>
, t.endPos, expr, rhExpr);<z>
return expr;<z>
@Nullable String contextPath) {<z>
)) {<z>
);<z>
), contextPath);<z>
length = contextPath.length();<z>
;<z>
) {<z>
.elements().get(i);<z>
);<z>
== counter) {<z>
+ 1);<z>
+<z>
);<z>
{<z>
reactiveEntityProducer = null;<z>
this.byteBufferFlux != null) {<z>
HttpHeaders.CONTENT_ENCODING);<z>
ContentType contentType = null;<z>
{<z>
;<z>
),<z>
, contentEncoding);<z>
BasicRequestProducer(this.httpRequest, reactiveEntityProducer);<z>
member) {<z>
if (member instanceof Method) {<z>
);<z>
instanceof Constructor) {<z>
.getExceptionTypes());<z>
"Cannot get exception types of a field");<z>
) {<z>
this.state.get();<z>
(rsWriteLogger.isTraceEnabled()) {<z>
"]");<z>
);<z>
MessagingException {<z>
] parsed = InternetAddress.parse(address);<z>
!= 1) {<z>
;<z>
= parsed[0];<z>
) != null ?<z>
)) : raw);<z>
catch (UnsupportedEncodingException ex) {<z>
MessagingException("Failed to parse embedded personal name to correct encoding", ex);<z>
>... actualInterfaces)<z>
ScriptCompilationException {<z>
clazz;<z>
synchronized (this.scriptClassMonitor) {<z>
.wasModifiedForTypeCheck && this.scriptClass == null);<z>
this.wasModifiedForTypeCheck = false;<z>
requiresScriptEvaluation) {<z>
result = BshScriptUtils.evaluateBshScript(<z>
), actualInterfaces, this.beanClassLoader);<z>
(result instanceof Class) {<z>
;<z>
result;<z>
= this.scriptClass;<z>
catch (EvalError ex) {<z>
this.scriptClass = null;<z>
);<z>
null) {<z>
(clazz).newInstance();<z>
catch (Throwable ex) {<z>
new ScriptCompilationException(<z>
+ clazz.getName(), ex);<z>
(<z>
actualInterfaces, this.beanClassLoader);<z>
catch (EvalError ex) {<z>
scriptSource, ex);<z>
request, String requestPath,<z>
? extends Resource> locations, ResourceResolverChain chain) {<z>
);<z>
(BeanPostProcessor o) {<z>
add(o);<z>
;<z>
;<z>
formatterRegistry) {<z>
formatterRegistry.addFormatterForFieldAnnotation(new NumberFormatAnnotationFormatterFactory());<z>
) {<z>
());<z>
));<z>
new Jsr354NumberFormatAnnotationFormatterFactory());<z>
DateTimeFormatterRegistrar().registerFormatters(formatterRegistry);<z>
().registerFormatters(formatterRegistry);<z>
static RuntimeException translateIfNecessary(<z>
) {<z>
"PersistenceExceptionTranslator must not be null");<z>
= pet.translateExceptionIfPossible(rawException);<z>
);<z>
void setEntityManagerHolder(<z>
boolean newEntityManagerHolder) {<z>
entityManagerHolder;<z>
newEntityManagerHolder = newEntityManagerHolder;<z>
, String>> matrixVars) {<z>
.uriVariables = Collections.unmodifiableMap(uriVars);<z>
this.matrixVariables = (matrixVars != null ?<z>
;<z>
Method attribute, AliasFor aliasFor, boolean checkAliasPair) {<z>
)) {<z>
throw new AnnotationConfigurationException(String.format(<z>
),<z>
()));<z>
;<z>
== Annotation.class) {<z>
targetAnnotation = this.annotationType;<z>
);<z>
.hasLength(targetAttributeName)) {<z>
= aliasFor.value();<z>
StringUtils.hasLength(targetAttributeName)) {<z>
targetAttributeName = attribute.getName();<z>
(targetAnnotation).get(targetAttributeName);<z>
(target == null) {<z>
(targetAnnotation == this.annotationType) {<z>
throw new AnnotationConfigurationException(String.format(<z>
);<z>
new AnnotationConfigurationException(String.format(<z>
attribute)),<z>
describe(targetAnnotation, targetAttributeName)));<z>
equals(attribute)) {<z>
new AnnotationConfigurationException(String.format(<z>
);<z>
{<z>
format(<z>
describe(attribute),<z>
;<z>
isAliasPair(target) && checkAliasPair) {<z>
.class);<z>
(targetAliasFor != null) {<z>
resolveAliasTarget(target, targetAliasFor, false);<z>
attribute)) {<z>
throw new AnnotationConfigurationException(String.format(<z>
(target)),<z>
));<z>
target;<z>
putByteArray(<z>
) {<z>
+ byteLength > data.length) {<z>
byteLength);<z>
byteArrayValue != null) {<z>
;<z>
+= byteLength;<z>
;<z>
servletConfig) {<z>
.servletConfig = servletConfig;<z>
null && this.servletContext == null) {<z>
this.servletContext = servletConfig.getServletContext();<z>
(StompHeaderAccessor connectedHeaders) {<z>
(taskScheduler != null) {<z>
)[1];<z>
, this.clientSendInterval);<z>
void setBeanFactory(BeanFactory beanFactory) {<z>
;<z>
beanFactory instanceof ListableBeanFactory)) {<z>
throw new IllegalArgumentException(<z>
);<z>
advisor = new PersistenceExceptionTranslationAdvisor(<z>
(ListableBeanFactory) beanFactory, this.repositoryAnnotationType);<z>
{<z>
delegate = delegate;<z>
{<z>
?<z>
) :<z>
pd));<z>
(IntrospectionException ex) {<z>
if (logger.isDebugEnabled()) {<z>
"': " + ex.getMessage());<z>
);<z>
!= null) {<z>
)) {<z>
method);<z>
ex) {<z>
(logger.isDebugEnabled()) {<z>
);<z>
) {<z>
= resolveReturnValueType(result);<z>
if (isSupportedType(valueType)) {<z>
true;<z>
;<z>
() &&<z>
().toClass());<z>
{<z>
{<z>
CollectionUtils.unmodifiableMultiValueMap(initCookies());<z>
this.cookies;<z>
) {<z>
clear();<z>
ObjectUtils.isEmpty(allowedOriginPatterns)) {<z>
;<z>
return this;<z>
public void setBeanFactory(BeanFactory beanFactory) {<z>
.targetBeanName)) {<z>
"Property 'targetBeanName' is required");<z>
(this.methodName)) {<z>
throw new IllegalArgumentException("Property 'methodName' is required");<z>
);<z>
) {<z>
.targetBeanName + "'");<z>
.resolveSignature(this.methodName, beanClass);<z>
.method == null) {<z>
methodName +<z>
+ "]");<z>
viewName, Locale locale) throws Exception {<z>
(locale);<z>
.class);<z>
ex) {<z>
;<z>
{<z>
.class);<z>
validatedAnn == null) {<z>
();<z>
;<z>
Validated.class);<z>
?>[0]);<z>
() default BeanNameGenerator.class;<z>
scopeResolver() default AnnotationScopeMetadataResolver.class;<z>
.DEFAULT;<z>
() default ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN;<z>
true;<z>
};<z>
ResolvableType type, String message) {<z>
+ message);<z>
this.beanName = null;<z>
type;<z>
() {<z>
!= null) {<z>
);<z>
!= null) {<z>
).getDeclaringClass();<z>
return null;<z>
addTriggerTask(TriggerTask task) {<z>
if (this.triggerTasks == null) {<z>
ArrayList<>();<z>
add(task);<z>
) {<z>
) == null) {<z>
IllegalArgumentException("Property 'notificationListener' is required");<z>
(ServerWebExchange exchange) {<z>
()) {<z>
;<z>
matchingConditions = new RequestConditionHolder[getLength()];<z>
< getLength(); i++) {<z>
exchange);<z>
] == null) {<z>
return null;<z>
new CompositeRequestCondition(matchingConditions);<z>
) {<z>
if (this.canConvertToString) {<z>
(String.class));<z>
return null;<z>
assertNotPreparedOperation() {<z>
.sqlSupplier instanceof PreparedOperation<?>) {<z>
InvalidDataAccessApiUsageException(<z>
;<z>
destination) {<z>
Route ?<z>
((RouteMatcher.Route) destination) :<z>
destination);<z>
{<z>
= new ArrayList<>();<z>
instanceof ConfigurableBeanFactory ?<z>
: null);<z>
.conversionService, beanFactory));<z>
);<z>
this.messageConverter));<z>
!= null) {<z>
addAll(this.customArgumentResolvers);<z>
, "MessageConverter not configured");<z>
, this.validator));<z>
;<z>
{<z>
);<z>
); en.hasMoreElements();) {<z>
(String) en.nextElement();<z>
beanKey));<z>
(methodNames)));<z>
EntityManager doGetTransactionalEntityManager(<z>
> properties, boolean synchronizedWithTransaction)<z>
PersistenceException {<z>
.notNull(emf, "No EntityManagerFactory specified");<z>
EntityManagerHolder emHolder =<z>
(EntityManagerHolder) TransactionSynchronizationManager.getResource(emf);<z>
null) {<z>
synchronizedWithTransaction) {<z>
isSynchronizedWithTransaction()) {<z>
{<z>
emHolder.getEntityManager().joinTransaction();<z>
TransactionRequiredException ex) {<z>
, ex);<z>
) {<z>
emHolder.getEntityManager(), emf);<z>
(<z>
emf, transactionData, false));<z>
true);<z>
();<z>
getEntityManager();<z>
!emHolder.isOpen()) {<z>
) {<z>
;<z>
.unbindResource(emf);<z>
;<z>
{<z>
;<z>
debug("Opening JPA EntityManager");<z>
null;<z>
(!synchronizedWithTransaction) {<z>
;<z>
AbstractMethodError err) {<z>
em == null) {<z>
));<z>
em);<z>
(synchronizedWithTransaction) {<z>
;<z>
registerSynchronization(<z>
emHolder, emf, transactionData, true));<z>
;<z>
registerSynchronization(<z>
(emHolder, emf));<z>
bindResource(emf, emHolder);<z>
catch (RuntimeException ex) {<z>
;<z>
;<z>
em;<z>
public void afterPropertiesSet() {<z>
.dataSource == null) {<z>
;<z>
null) {<z>
new IllegalArgumentException("Property 'incrementerName' is required");<z>
) {<z>
currentConvertedValue;<z>
== requiredType && this.targetObject != null) {<z>
= trimmedValue.lastIndexOf('.');<z>
) {<z>
= trimmedValue.substring(0, index);<z>
);<z>
.getClass().getClassLoader();<z>
(enumType, cl);<z>
enumField = enumValueType.getField(fieldName);<z>
null);<z>
catch (ClassNotFoundException ex) {<z>
(logger.isTraceEnabled()) {<z>
("Enum class [" + enumType + "] cannot be loaded", ex);<z>
{<z>
()) {<z>
+ enumType + "]", ex);<z>
) {<z>
= requiredType.getField(trimmedValue);<z>
.makeAccessible(enumField);<z>
enumField.get(null);<z>
(Throwable ex) {<z>
(logger.isTraceEnabled()) {<z>
convertedValue + "] isn't an enum value", ex);<z>
;<z>
setConnectionFactory(ConnectionFactory connectionFactory) {<z>
{<z>
connectionFactory);<z>
jmsTemplate = new JmsTemplate(connectionFactory);<z>
(ProceedingJoinPoint pjp) throws Throwable {<z>
invocations;<z>
;<z>
;<z>
Nullable MimeType mimeType) {<z>
<?> encoder : encoders()) {<z>
)) {<z>
<T>) encoder;<z>
);<z>
paramOrFileName) {<z>
paramOrFileName);<z>
!= null) {<z>
= new HttpHeaders();<z>
() != null) {<z>
;<z>
;<z>
= getPart(paramOrFileName);<z>
) {<z>
HttpHeaders();<z>
headerName : part.getHeaderNames()) {<z>
);<z>
;<z>
{<z>
"Could not access multipart servlet request", ex);<z>
null;<z>
{<z>
, "ServerHttpRequest is required");<z>
.uri = original.getURI();<z>
getHeaders());<z>
.getMethod();<z>
).contextPath().value();<z>
.remoteAddress = original.getRemoteAddress();<z>
getBody();<z>
;<z>
concurrency) {<z>
= concurrency.indexOf('-');<z>
if (separatorIndex != -1) {<z>
, separatorIndex, 10));<z>
, 10));<z>
);<z>
parseInt(concurrency));<z>
ex) {<z>
concurrency + "]: only " +<z>
;<z>
Class<? extends Throwable> findClosestMatch(<z>
>> exceptionTypes, Throwable targetException) {<z>
(exceptionTypes, "Exception types must not be empty");<z>
() == 1) {<z>
next();<z>
exceptionTypes);<z>
(new ExceptionDepthComparator(targetException));<z>
0);<z>
{<z>
ALL) {<z>
return Stream.empty();<z>
spliterator(annotationType), false);<z>
{<z>
"First ClassFilter must not be null");<z>
;<z>
cf2});<z>
{<z>
"handlers", new HandlersBeanDefinitionParser());<z>
(isSpringMessagingPresent) {<z>
());<z>
> action) throws DataAccessException {<z>
, "Callback object must not be null");<z>
= getConnection().map(<z>
;<z>
, connectionCloseHolder -> {<z>
connection);<z>
.apply(connectionToUse);<z>
R2dbcException ex) {<z>
getSql(action);<z>
convertR2dbcException("doInConnection", sql, ex));<z>
-> it.close(),<z>
)<z>
.onErrorMap(R2dbcException.class,<z>
), ex));<z>
void afterTransportClosed(@Nullable CloseStatus closeStatus) {<z>
.closeStatus;<z>
) {<z>
= closeStatus;<z>
closeStatus = closeStatus;<z>
(cs != null, "CloseStatus not available");<z>
()) {<z>
this);<z>
CLOSED;<z>
, cs);<z>
ex) {<z>
"WebSocketHandler.afterConnectionClosed threw an exception", ex);<z>
document) {<z>
return new AbstractJdbc4SqlXmlValue() {<z>
SQLXML xmlObject) throws SQLException, IOException {<z>
.setNode(document);<z>
unitInfo) {<z>
persistenceUnit, PROPERTIES);<z>
null) {<z>
getChildElementsByTagName(propRoot, "property");<z>
for (Element property : properties) {<z>
.getAttribute("name");<z>
;<z>
, value);<z>
)<z>
{<z>
t, null, outputMessage);<z>
(<z>
, PathMatcher pathMatcher) throws IOException {<z>
findRoot(rootDirURL);<z>
visitor =<z>
locationPattern, pathMatcher);<z>
root, visitor);<z>
.getResources();<z>
, String subPattern, PathMatcher pathMatcher) {<z>
subPattern = subPattern;<z>
pathMatcher = pathMatcher;<z>
? rootPath : rootPath + "/");<z>
private boolean hasOpeningTag(String content) {<z>
) {<z>
return false;<z>
;<z>
length() > openTagIndex + 1) &&<z>
;<z>
() {<z>
this.transactionStack.peek();<z>
if (context == null) {<z>
new NoTransactionException("No transaction in context");<z>
;<z>
(<z>
{<z>
;<z>
this.transactionData = txData;<z>
emf instanceof EntityManagerFactoryInfo ?<z>
null);<z>
this.newEntityManager = newEm;<z>
inValueType) {<z>
inValueType) &&<z>
inValueType) ||<z>
||<z>
inValueType)));<z>
parse(String pathPattern) throws PatternParseException {<z>
);<z>
pathPattern.toCharArray();<z>
length;<z>
.headPE = null;<z>
null;<z>
= null;<z>
;<z>
0;<z>
);<z>
) {<z>
= this.pathPatternData[this.pos];<z>
;<z>
if (ch == separator) {<z>
1) {<z>
createPathElement());<z>
{<z>
);<z>
2;<z>
SeparatorPathElement(this.pos, separator));<z>
pathElementStart == -1) {<z>
;<z>
(ch == '?') {<z>
this.singleCharWildcardCount++;<z>
) {<z>
(this.insideVariableCapture) {<z>
.pathPatternData,<z>
PatternMessage.ILLEGAL_NESTED_CAPTURE);<z>
insideVariableCapture = true;<z>
.variableCaptureStart = this.pos;<z>
== '}') {<z>
{<z>
this.pathPatternData,<z>
;<z>
this.insideVariableCapture = false;<z>
{<z>
pos + 1, this.pathPatternData,<z>
.NO_MORE_DATA_EXPECTED_AFTER_CAPTURE_THE_REST);<z>
;<z>
(ch == ':') {<z>
.isCaptureTheRestVariable) {<z>
skipCaptureRegex();<z>
false;<z>
this.variableCaptureCount++;<z>
else if (ch == '*') {<z>
.variableCaptureStart == this.pos - 1) {<z>
.isCaptureTheRestVariable = true;<z>
wildcard = true;<z>
if (this.insideVariableCapture) {<z>
&&<z>
) {<z>
this.pos, this.pathPatternData,<z>
PatternMessage.ILLEGAL_CHARACTER_AT_START_OF_CAPTURE_DESCRIPTOR,<z>
;<z>
)) &&<z>
'-')) {<z>
pos, this.pathPatternData,<z>
PatternMessage.ILLEGAL_CHARACTER_IN_CAPTURE_DESCRIPTOR,<z>
.toString(ch));<z>
pos++;<z>
1) {<z>
());<z>
headPE);<z>
(Executable executable, int parameterIndex) {<z>
(executable instanceof Method) {<z>
executable, parameterIndex);<z>
) {<z>
;<z>
new IllegalArgumentException("Not a Method/Constructor: " + executable);<z>
) throws IOException {<z>
{<z>
"Response already committed");<z>
();<z>
) {<z>
()) {<z>
hasLocations());<z>
;<z>
,<z>
{<z>
channel = channel;<z>
sink = sink;<z>
AtomicLong(position);<z>
.dataBufferFactory = dataBufferFactory;<z>
bufferSize = bufferSize;<z>
cf) {<z>
).generateCode(mv, cf);<z>
;<z>
= this.exitTypeDescriptor;<z>
"No exit type descriptor");<z>
charAt(0);<z>
.insertNumericUnboxOrPrimitiveTypeCoercion(mv, leftDesc, targetDesc);<z>
this.children.length > 1) {<z>
cf.enterCompilationScope();<z>
generateCode(mv, cf);<z>
String rightDesc = getRightOperand().exitTypeDescriptor;<z>
.exitCompilationScope();<z>
insertNumericUnboxOrPrimitiveTypeCoercion(mv, rightDesc, targetDesc);<z>
) {<z>
case 'I':<z>
mv.visitInsn(IDIV);<z>
:<z>
;<z>
'F':<z>
);<z>
case 'D':<z>
;<z>
(<z>
exitTypeDescriptor + "'");<z>
exitTypeDescriptor);<z>
String, Object> retrieveAttributes(WebSession session) {<z>
);<z>
name -> {<z>
name);<z>
{<z>
put(name, value);<z>
;<z>
;<z>
void applyHeaders() {<z>
();<z>
contentType = null;<z>
).getContentType();<z>
ex) {<z>
);<z>
;<z>
null) {<z>
));<z>
().remove(HttpHeaders.CONTENT_TYPE);<z>
) : null);<z>
!= null) {<z>
;<z>
getContentLength();<z>
1) {<z>
(contentLength);<z>
;<z>
MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,<z>
{<z>
;<z>
MediaType contentType, Charset charset)<z>
throws IOException, HttpMessageConversionException {<z>
)) {<z>
.print(message, output, charset);<z>
.isCompatibleWith(APPLICATION_XML)) {<z>
charset);<z>
(contentType.isCompatibleWith(TEXT_HTML)) {<z>
);<z>
HttpMessageConversionException(<z>
+ contentType);<z>
Builder produces(String... produces) {<z>
isEmpty(produces) ?<z>
.options.getContentNegotiationManager()));<z>
;<z>
@Nullable SqlParameterSource paramSource) {<z>
String originalSql = parsedSql.getOriginalSql();<z>
getParameterNames();<z>
) {<z>
;<z>
));<z>
int lastIndex = 0;<z>
size(); i++) {<z>
);<z>
] indexes = parsedSql.getParameterIndexes(i);<z>
0];<z>
1];<z>
startIndex);<z>
&& paramSource.hasValue(paramName)) {<z>
getValue(paramName);<z>
instanceof SqlParameterValue) {<z>
);<z>
instanceof Iterable) {<z>
value).iterator();<z>
= 0;<z>
) {<z>
) {<z>
", ");<z>
;<z>
);<z>
entryItem instanceof Object[] expressionList) {<z>
.append('(');<z>
++) {<z>
m > 0) {<z>
actualSql.append(", ");<z>
actualSql.append('?');<z>
);<z>
actualSql.append('?');<z>
);<z>
);<z>
= endIndex;<z>
lastIndex, originalSql.length());<z>
return actualSql.toString();<z>
Locale getFallbackLocale() {<z>
{<z>
getJstlLocale(getPageContext());<z>
{<z>
;<z>
();<z>
String destination, Message<?> message) {<z>
subscriptionRegistry.findSubscriptions(message);<z>
logger.isDebugEnabled()) {<z>
subscriptions.size() + " sessions.");<z>
= System.currentTimeMillis();<z>
sessionId, subscriptionIds) -> {<z>
subscriptionId : subscriptionIds) {<z>
SimpMessageType.MESSAGE);<z>
;<z>
.setSessionId(sessionId);<z>
);<z>
(message.getHeaders());<z>
;<z>
= message.getPayload();<z>
payload, headerAccessor.getMessageHeaders());<z>
this.sessions.get(sessionId);<z>
{<z>
;<z>
) {<z>
if (logger.isErrorEnabled()) {<z>
.error("Failed to send " + message, ex);<z>
(now);<z>
);<z>
cacheBuilder) {<z>
)) {<z>
this.cacheBuilder = cacheBuilder;<z>
();<z>
{<z>
parseCustomElement(ele, containingBd);<z>
{<z>
"Incorrect usage of element '" + ele.getNodeName() + "' in a nested manner. " +<z>
, ele);<z>
null;<z>
.GENERATED_BEAN_NAME_SEPARATOR +<z>
innerDefinition);<z>
.isTraceEnabled()) {<z>
.trace("Using generated bean name [" + id +<z>
);<z>
(innerDefinition, id);<z>
dtd) throws SAXException {<z>
null) {<z>
= dtd.getLocation();<z>
(), location.getSystemId());<z>
!= null) {<z>
getLexicalHandler().endDTD();<z>
throws Exception {<z>
;<z>
privateKey());<z>
createHttpHandlerAdapter();<z>
.http.server.HttpServer.create()<z>
))<z>
.port(getPort())<z>
sslContextSpec.sslContext(http11SslContextSpec));<z>
) {<z>
(method));<z>
().getClassifier();<z>
, (scope, continuation) -><z>
, continuation))<z>
.INSTANCE))<z>
.class, InvocationTargetException::getTargetException);<z>
.getKotlinClass(Flow.class))) {<z>
asFlux);<z>
mono;<z>
) throws Throwable {<z>
SessionFactory sf = getSessionFactory();<z>
"No SessionFactory set");<z>
TransactionSynchronizationManager.hasResource(sf)) {<z>
);<z>
sf, new SessionHolder(session));<z>
invocation.proceed();<z>
.closeSession(session);<z>
TransactionSynchronizationManager.unbindResource(sf);<z>
;<z>
) {<z>
Arrays.stream(cookies)<z>
? "" : c.getValue()))<z>
));<z>
, String actual) throws Exception {<z>
, actual);<z>
hasDifferences()) {<z>
toString());<z>
Long timestamp) {<z>
: new HashMap<>());<z>
if (id == null) {<z>
.generateId());<z>
== ID_VALUE_NONE) {<z>
.headers.remove(ID);<z>
);<z>
{<z>
, System.currentTimeMillis());<z>
timestamp < 0) {<z>
(TIMESTAMP);<z>
put(TIMESTAMP, timestamp);<z>
{<z>
synchronized (this.scriptClassMonitor) {<z>
.groovyClassLoader == null) {<z>
());<z>
return this.groovyClassLoader;<z>
{<z>
= getJdbcTemplate();<z>
"No JdbcTemplate set");<z>
;<z>
() {<z>
;<z>
superclass.getName() : null,<z>
ReflectUtils.getNames(interfaces),<z>
(filter),<z>
serialVersionUID);<z>
currentKey = key;<z>
= super.create(key);<z>
result;<z>
dataSource) throws CannotGetJdbcConnectionException {<z>
return doGetConnection(dataSource);<z>
catch (SQLException ex) {<z>
, ex);<z>
(IllegalStateException ex) {<z>
);<z>
{<z>
AnnotationTypeFilter) {<z>
getAnnotationType();<z>
class, annotation) ||<z>
;<z>
instanceof AssignableTypeFilter) {<z>
) filter).getTargetType();<z>
;<z>
;<z>
<?>[] classes,<z>
extends ApplicationContextInitializer<?>>> contextInitializerClasses,<z>
,<z>
contextLoader,<z>
,<z>
Nullable MergedContextConfiguration parent) {<z>
, locations, classes, contextInitializerClasses, activeProfiles,<z>
propertySourceLocations, propertySourceProperties,<z>
, contextLoader,<z>
, parent);<z>
checkAndPrepare(<z>
HttpServletResponse response, int cacheSeconds, boolean lastModified)<z>
ServletException {<z>
);<z>
applyCacheSeconds(response, cacheSeconds);<z>
String password) {<z>
);<z>
= username;<z>
;<z>
, String uriTemplate, Object... uriVars) {<z>
method;<z>
.uri = null;<z>
.uriTemplate = uriTemplate;<z>
.uriVarsArray = uriVars;<z>
null;<z>
) {<z>
if (key instanceof String headerName) {<z>
= get(key);<z>
removeHeader(headerName);<z>
previousValues;<z>
null;<z>
Throwable ex) {<z>
msg = ex.getMessage();<z>
contains("exceed")) {<z>
, ex);<z>
MultipartException("Failed to parse multipart servlet request", ex);<z>
pss)<z>
DataAccessException {<z>
.debug("Executing prepared SQL update");<z>
psc, ps -> {<z>
!= null) {<z>
pss.setValues(ps);<z>
rows = ps.executeUpdate();<z>
isTraceEnabled()) {<z>
+ " rows");<z>
;<z>
instanceof ParameterDisposer) {<z>
ParameterDisposer) pss).cleanupParameters();<z>
}, true));<z>
determineTargetClass(<z>
, @Nullable String beanName) {<z>
{<z>
return null;<z>
if (beanFactory.containsBeanDefinition(beanName)) {<z>
beanFactory.getMergedBeanDefinition(beanName);<z>
bd.getAttribute(ORIGINAL_TARGET_CLASS_ATTRIBUTE);<z>
(targetClass != null) {<z>
return targetClass;<z>
;<z>
public void setMetadataReaderFactory(MetadataReaderFactory metadataReaderFactory) {<z>
.notNull(metadataReaderFactory, "MetadataReaderFactory must not be null");<z>
this.metadataReaderFactory = metadataReaderFactory;<z>
= true;<z>
String propertyPath, PropertyEditor propertyEditor) {<z>
== null) {<z>
;<z>
) {<z>
) {<z>
customEditorsForPath = new LinkedHashMap<>(16);<z>
requiredType));<z>
.customEditors == null) {<z>
<>(16);<z>
(requiredType, propertyEditor);<z>
= null;<z>
localIndex, final int abstractType) {<z>
outputLocals == null) {<z>
int[10];<z>
outputLocals.length;<z>
) {<z>
* outputLocalsLength)];<z>
newOutputLocals, 0, outputLocalsLength);<z>
outputLocals = newOutputLocals;<z>
localIndex] = abstractType;<z>
mapping, @Nullable ClassLoader classLoader,<z>
rootAttributes, ValueExtractor valueExtractor,<z>
resolvedRootMirrors) {<z>
this.mapping = mapping;<z>
= classLoader;<z>
source = source;<z>
rootAttributes;<z>
this.valueExtractor = valueExtractor;<z>
aggregateIndex;<z>
this.useMergedValues = true;<z>
attributeFilter = null;<z>
= (resolvedRootMirrors != null ? resolvedRootMirrors :<z>
;<z>
resolvedRootMirrors :<z>
::getValueForMirrorResolution));<z>
{<z>
.sessions.remove(sessionId);<z>
;<z>
create(SimpMessageType.DISCONNECT_ACK);<z>
setSessionId(sessionId);<z>
{<z>
setUser(user);<z>
!= null) {<z>
SimpMessageHeaderAccessor.DISCONNECT_MESSAGE_HEADER, origMessage);<z>
initHeaders(accessor);<z>
;<z>
;<z>
{<z>
();<z>
State.NO_DEMAND) {<z>
if (this.completionPending) {<z>
);<z>
.get().onAllDataRead(this);<z>
;<z>
this.errorPending;<z>
!= null) {<z>
isTraceEnabled()) {<z>
;<z>
;<z>
;<z>
return false;<z>
String resourcePath, Resource location) {<z>
{<z>
, StandardCharsets.UTF_8);<z>
location.createRelative(resourcePath);<z>
()) {<z>
)) {<z>
;<z>
else if (logger.isWarnEnabled()) {<z>
);<z>
warn(LogFormatUtils.formatValue(<z>
+ "\" was successfully resolved " +<z>
+ "\" is neither under the " +<z>
location.getURL() + "\" nor under any of the " +<z>
true));<z>
.empty();<z>
{<z>
isDebugEnabled()) {<z>
+ location + "] due to error";<z>
(logger.isTraceEnabled()) {<z>
;<z>
);<z>
Mono.error(ex);<z>
RequestMethodsRequestCondition combine(RequestMethodsRequestCondition other) {<z>
.isEmpty()) {<z>
return this;<z>
isEmpty()) {<z>
this;<z>
else if (isEmpty()) {<z>
return other;<z>
(this.methods);<z>
(other.methods);<z>
set);<z>
(<z>
) throws JMSException {<z>
target = obtainTargetConnectionFactory();<z>
)) {<z>
jakarta.jms.IllegalStateException("'targetConnectionFactory' is not a TopicConnectionFactory");<z>
if (StringUtils.hasLength(username)) {<z>
return queueFactory.createTopicConnection(username, password);<z>
.createTopicConnection();<z>
default "SS";<z>
;<z>
() default "";<z>
] fallbackPatterns() default {};<z>
public PathPatternsRequestCondition combine(PathPatternsRequestCondition other) {<z>
other.isEmptyPathMapping()) {<z>
return this;<z>
)) {<z>
;<z>
)) {<z>
;<z>
<>();<z>
patterns) {<z>
: other.patterns) {<z>
combine(pattern2));<z>
);<z>
Builder PUT(String pattern, RequestPredicate predicate,<z>
{<z>
).and(predicate), handlerFunction);<z>
executable) {<z>
;<z>
ex) {<z>
);<z>
phase() default TransactionPhase.AFTER_COMMIT;<z>
false;<z>
.class, attribute = "classes")<z>
;<z>
] boundary, Part part, DataBufferFactory bufferFactory) {<z>
(part.headers());<z>
String name = part.name();<z>
{<z>
setContentDispositionFormData(name,<z>
: null));<z>
(<z>
, bufferFactory),<z>
generatePartHeaders(headers, bufferFactory),<z>
content(),<z>
generateNewLine(bufferFactory));<z>
(@Nullable AnnotationTypeMapping source,<z>
Annotation> annotationType, @Nullable Annotation annotation) {<z>
.source = source;<z>
getRoot() : this);<z>
getDistance() + 1);<z>
.annotationType = annotationType;<z>
.metaTypes = merge(<z>
? source.getMetaTypes() : null,<z>
);<z>
this.annotation = annotation;<z>
(annotationType);<z>
new MirrorSets();<z>
this.attributes.size());<z>
this.attributes.size());<z>
this.attributes.size());<z>
.attributes.size()];<z>
();<z>
processAliases();<z>
();<z>
);<z>
();<z>
FixedChainStaticTargetInterceptor(<z>
, @Nullable Class<?> targetClass) {<z>
adviceChain = adviceChain;<z>
.target = target;<z>
;<z>
void initialize() {<z>
&&<z>
ResourceTransactionManager &&<z>
sameResourceFactory(<z>
, obtainConnectionFactory())) {<z>
(true);<z>
() == null) {<z>
String beanName = getBeanName();<z>
) {<z>
this.transactionDefinition.setName(beanName);<z>
super.initialize();<z>
throws InstantiationException {<z>
= ContextLoader.getCurrentWebApplicationContext();<z>
) {<z>
message = "Failed to find the root WebApplicationContext. Was ContextLoaderListener not used?";<z>
(message);<z>
(message);<z>
.getShortNameAsProperty(endpointClass);<z>
{<z>
, endpointClass);<z>
(logger.isTraceEnabled()) {<z>
+ endpoint);<z>
return endpoint;<z>
.findAnnotation(endpointClass, Component.class);<z>
(ann.value())) {<z>
);<z>
(logger.isTraceEnabled()) {<z>
;<z>
return endpoint;<z>
beanName = getBeanNameByType(wac, endpointClass);<z>
) {<z>
.getBean(beanName);<z>
)) {<z>
endpointClass);<z>
endpointClass);<z>
BeansException {<z>
= getIfUnique();<z>
dependency != null) {<z>
);<z>
{<z>
null) {<z>
;<z>
(this.keyGenerator != null, "No key generator");<z>
keyGenerator;<z>
List<PropertyAccessor> getPropertyAccessorsToTry(<z>
) {<z>
specificAccessors = new ArrayList<>();<z>
);<z>
propertyAccessors) {<z>
targets = resolver.getSpecificTargetClasses();<z>
null) {<z>
);<z>
null) {<z>
) {<z>
{<z>
specificAccessors.add(resolver);<z>
) {<z>
add(resolver);<z>
+ generalAccessors.size());<z>
);<z>
addAll(generalAccessors);<z>
resolvers;<z>
{<z>
connectionMonitor) {<z>
);<z>
config,<z>
String, Object> attributes) {<z>
, config, wsHandler, attributes);<z>
);<z>
{<z>
new SimpleBrokerRegistration(<z>
this.clientOutboundChannel, destinationPrefixes);<z>
simpleBrokerRegistration;<z>
private void maybeBindPrimitiveArgsFromPointcutExpression() {<z>
;<z>
if (numUnboundPrimitives > 1) {<z>
("Found '" + numUnboundPrimitives +<z>
"' unbound primitive arguments with no way to distinguish between them.");<z>
1) {<z>
varNames = new ArrayList<>();<z>
, " ");<z>
++) {<z>
)) {<z>
getPointcutBody(tokens, i);<z>
;<z>
(body.text, varNames);<z>
varNames.size() > 1) {<z>
("Found " + varNames.size() +<z>
;<z>
{<z>
.argumentTypes.length; i++) {<z>
i].isPrimitive()) {<z>
, varNames.get(0));<z>
AddressException {<z>
{<z>
.validate();<z>
Nullable Object other) {<z>
(this == other) {<z>
true;<z>
otherCron)) {<z>
;<z>
.equals(otherCron.daysOfMonth) &&<z>
.equals(otherCron.hours) &&<z>
.seconds));<z>
tokenize(String headerValue) {<z>
headerValue.indexOf(';');<z>
index) : headerValue).trim();<z>
)) {<z>
);<z>
;<z>
(type);<z>
if (index >= 0) {<z>
index + 1;<z>
;<z>
escaped = false;<z>
< headerValue.length()) {<z>
headerValue.charAt(nextIndex);<z>
ch == ';') {<z>
(!quoted) {<z>
escaped && ch == '"') {<z>
;<z>
= (!escaped && ch == '\\');<z>
++;<z>
trim();<z>
isEmpty()) {<z>
add(part);<z>
= nextIndex;<z>
index < headerValue.length());<z>
return parts;<z>
getLastTaskTimeNanos() throws IllegalStateException {<z>
lastTaskInfo == null) {<z>
("No tasks run: can't get last task interval");<z>
lastTaskInfo.getTimeNanos();<z>
{<z>
{<z>
;<z>
;<z>
> matcher)<z>
throws Exception {<z>
class);<z>
.expression, actual, matcher);<z>
(Element element, ParserContext parserContext) {<z>
JCACHE_ASPECT_BEAN_NAME)) {<z>
source = parserContext.extractSource(element);<z>
= createJCacheOperationSourceBeanDefinition(element, source);<z>
(cacheOperationSourceDef);<z>
jcacheAspectDef = new RootBeanDefinition();<z>
;<z>
setFactoryMethodName("aspectOf");<z>
, new RuntimeBeanReference(cacheOperationSourceName));<z>
jcacheAspectDef);<z>
), source);<z>
));<z>
(jcacheAspectDef, CacheManagementConfigUtils.JCACHE_ASPECT_BEAN_NAME));<z>
parserContext.registerComponent(compositeDef);<z>
CallbackFilter ALL_ZERO = new CallbackFilter() {<z>
) {<z>
0;<z>
{<z>
, "Callback object must not be null");<z>
DataSourceUtils.getConnection(obtainDataSource());<z>
null;<z>
= con.createStatement();<z>
stmt);<z>
.doInStatement(stmt);<z>
);<z>
;<z>
catch (SQLException ex) {<z>
getSql(action);<z>
(stmt);<z>
stmt = null;<z>
);<z>
null;<z>
, ex);<z>
{<z>
.closeStatement(stmt);<z>
con, getDataSource());<z>
) {<z>
equals(EncodingMode.URI_COMPONENT)) {<z>
encode();<z>
));<z>
SqlParameter otherParam) {<z>
notNull(otherParam, "SqlParameter object must not be null");<z>
.name;<z>
otherParam.sqlType;<z>
otherParam.typeName;<z>
= otherParam.scale;<z>
value) {<z>
.notNull(name, "Attribute name must not be null");<z>
null) {<z>
(name, value);<z>
name);<z>
) {<z>
)) {<z>
return true;<z>
(headers);<z>
if (mimeType == null) {<z>
();<z>
getSupportedMimeTypes()) {<z>
equals(mimeType.getSubtype())) {<z>
;<z>
false;<z>
() {<z>
result = buildPartial();<z>
) {<z>
throw newUninitializedMessageException(result);<z>
;<z>
] transformedContent) {<z>
;<z>
filename = original.getFilename();<z>
);<z>
ex) {<z>
);<z>
getResponseHeaders(MockHttpServletResponse response) {<z>
;<z>
response.getHeaderNames()) {<z>
);<z>
headers;<z>
(<z>
registry, RootBeanDefinition definition, String beanName) {<z>
.ROLE_INFRASTRUCTURE);<z>
registerBeanDefinition(beanName, definition);<z>
definition, beanName);<z>
(Type type, @Nullable TypeProvider typeProvider,<z>
@Nullable ResolvableType componentType) {<z>
;<z>
.typeProvider = typeProvider;<z>
this.variableResolver = variableResolver;<z>
;<z>
this.hash = null;<z>
);<z>
(ByteBuffer source, TypeDescriptor targetType) {<z>
()];<z>
(bytes);<z>
.isAssignableTo(BYTE_ARRAY_TYPE)) {<z>
bytes;<z>
;<z>
singletonInstance) {<z>
= null;<z>
;<z>
singletonInstance;<z>
T> responseType,<z>
uriVariables) throws RestClientException {<z>
responseType);<z>
HttpMessageConverterExtractor<T> responseExtractor =<z>
), logger);<z>
responseExtractor, uriVariables);<z>
> headers, HttpServletRequest request,<z>
)<z>
URISyntaxException {<z>
));<z>
"'bufferFactory' must not be null");<z>
isTrue(bufferSize > 0, "'bufferSize' must be higher than 0");<z>
this.request = request;<z>
bufferFactory = bufferFactory;<z>
.buffer = new byte[bufferSize];<z>
();<z>
request.getInputStream();<z>
;<z>
);<z>
moveToNextSegment() {<z>
= null;<z>
;<z>
.length) {<z>
this.segmentIndex].references;<z>
segmentIndex++;<z>
Mono<Object> resolveArgument(<z>
bindingContext, ServerWebExchange exchange) {<z>
getParameterType();<z>
, parameter, false, bindingContext, exchange)<z>
)))<z>
getRequest()));<z>
method, URI uri,<z>
) {<z>
.apply(method, uri);<z>
.getCookieStore() == null) {<z>
setCookieStore(new BasicCookieStore());<z>
HttpComponentsClientHttpRequest request = new HttpComponentsClientHttpRequest(method, uri,<z>
context, this.dataBufferFactory);<z>
(request, context)));<z>
) {<z>
{<z>
case PROXY:<z>
class.getName(),<z>
;<z>
:<z>
()};<z>
return null;<z>
, Class<T> targetClass,<z>
requestPostProcessor) throws MessagingException {<z>
, request, null, targetClass, requestPostProcessor);<z>
MessageChannel channel, Message<?> requestMessage) {<z>
);<z>
requestMessage.getHeaders().getReplyChannel();<z>
();<z>
= sendTimeout(requestMessage);<z>
long receiveTimeout = receiveTimeout(requestMessage);<z>
(this.throwExceptionOnLateReply);<z>
fromMessage(requestMessage).setReplyChannel(tempReplyChannel)<z>
setHeader(this.sendTimeoutHeader, null)<z>
.setHeader(this.receiveTimeoutHeader, null)<z>
;<z>
sendTimeout);<z>
(RuntimeException ex) {<z>
setSendFailed(true);<z>
ex;<z>
, receiveTimeout);<z>
(replyMessage != null) {<z>
replyMessage)<z>
MessageHeaders.REPLY_CHANNEL, originalReplyChannelHeader)<z>
)<z>
);<z>
replyMessage;<z>
(<z>
ClassLoader classLoader)<z>
throws EvalError {<z>
);<z>
Interpreter();<z>
;<z>
interpreter.eval(scriptSource);<z>
{<z>
return result;<z>
(scriptInterfaces)) {<z>
("Given script requires a script proxy: " +<z>
);<z>
interpreter.eval("return this");<z>
));<z>
(Runnable task) {<z>
executor = getThreadPoolExecutor();<z>
(task);<z>
ex) {<z>
, ex);<z>
throws IOException {<z>
HttpClient client = getHttpClient();<z>
httpMethod, uri);<z>
postProcessHttpRequest(httpRequest);<z>
createHttpContext(httpMethod, uri);<z>
) {<z>
.create();<z>
null) {<z>
;<z>
if (httpRequest instanceof Configurable) {<z>
(Configurable) httpRequest).getConfig();<z>
(config == null) {<z>
(client);<z>
!= null) {<z>
.REQUEST_CONFIG, config);<z>
) {<z>
;<z>
new HttpComponentsStreamingClientHttpRequest(client, httpRequest, context);<z>
problemReporter) {<z>
.class.getName());<z>
("proxyBeanMethods")) {<z>
()) {<z>
(new FinalConfigurationProblem());<z>
.beanMethods) {<z>
validate(problemReporter);<z>
TypeDescriptor typeDescriptor) {<z>
);<z>
!typesAssignable) {<z>
false;<z>
)) {<z>
);<z>
() && typeDescriptor.isCollection()) {<z>
.getElementTypeDescriptor());<z>
)) {<z>
typeDescriptor.getMapKeyTypeDescriptor()) &&<z>
(), typeDescriptor.getMapValueTypeDescriptor());<z>
;<z>
> completion) {<z>
JettyWebSocketSession> sessionFactory = session -> {<z>
HandshakeInfo info = createHandshakeInfo(url, session);<z>
, info, DefaultDataBufferFactory.sharedInstance, completion);<z>
, sessionFactory);<z>
mm1, MethodMatcher mm2) {<z>
(mm1, "First MethodMatcher must not be null");<z>
;<z>
.mm1 = mm1;<z>
mm2 = mm2;<z>
request) {<z>
(WebUtils.FORWARD_REQUEST_URI_ATTRIBUTE) != null) ||<z>
{<z>
WebUtils.FORWARD_QUERY_STRING_ATTRIBUTE);<z>
request.getQueryString();<z>
HttpServletRequest request, String source) {<z>
.urlDecode) {<z>
, source);<z>
source;<z>
) {<z>
-> {<z>
name(), toBodyPublisher(body));<z>
();<z>
;<z>
) {<z>
this.mimeMessage = mimeMessage;<z>
? encoding : getDefaultEncoding(mimeMessage));<z>
;<z>
> relativeClass, String... resourceNames) {<z>
];<z>
length; i++) {<z>
ClassPathResource(resourceNames[i], relativeClass);<z>
load(resources);<z>
, SqlParameterSource paramSource) {<z>
();<z>
.size());<z>
{<z>
(new SqlParameter(<z>
getTypeName(paramName)));<z>
return params;<z>
, boolean stripDelimiter, MimeType... mimeTypes) {<z>
mimeTypes);<z>
delimiters, "'delimiters' must not be empty");<z>
delimiters);<z>
;<z>
{<z>
ResolvableType eventType = eventTypeCache.get(listenerType);<z>
eventType == null) {<z>
class).getGeneric();<z>
, eventType);<z>
NONE ? eventType : null);<z>
MultipartInserter withPublisher(<z>
> typeReference) {<z>
, publisher, typeReference);<z>
;<z>
) {<z>
context);<z>
== null && context instanceof WebApplicationContext) {<z>
.getServletContext();<z>
.servletContext != null) {<z>
(this.servletContext);<z>
,<z>
, TyrusWebSocketEngine engine) throws DeploymentException {<z>
;<z>
.getPropertyValue("sessionListener");<z>
accessor.getPropertyValue("clusterContext");<z>
if (constructorWithBooleanArgument) {<z>
getEndpoint(), registration, provider, container,<z>
, Boolean.TRUE);<z>
(), registration, provider, container,<z>
, null);<z>
(Exception ex) {<z>
ex);<z>
() {<z>
)) {<z>
getKey()));<z>
createBean(<z>
, BeanInstanceProducer fallbackProducer) {<z>
.useJpaCompliantCreation()) {<z>
;<z>
, false);<z>
bean, name);<z>
.initializeBean(bean, name);<z>
name, beanInstance));<z>
);<z>
catch (BeansException ex) {<z>
)) {<z>
("Falling back to Hibernate's default producer after bean creation failure for " +<z>
ex);<z>
(name, beanType));<z>
) {<z>
ex instanceof BeanCreationException) {<z>
)) {<z>
+ name + "': " + ex2);<z>
throw ex;<z>
ex2;<z>
actualType, ResolvableType elementType,<z>
,<z>
<String, Object> hints) {<z>
hints,<z>
request, response));<z>
, elementType, mediaType, response, allHints);<z>
visitLabel(final Label label) {<z>
null) {<z>
.visitLabel(label);<z>
public ConcurrentReferenceHashMap(<z>
referenceType) {<z>
"Initial capacity must not be negative");<z>
"Load factor must be positive");<z>
.isTrue(concurrencyLevel > 0, "Concurrency level must be positive");<z>
);<z>
.loadFactor = loadFactor;<z>
concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL);<z>
= 1 << this.shift;<z>
referenceType = referenceType;<z>
1L) / size);<z>
roundedUpSegmentCapacity, MAXIMUM_SEGMENT_SIZE);<z>
, size);<z>
;<z>
; i++) {<z>
resizeThreshold);<z>
segments = segments;<z>
method) {<z>
hasText(method)) {<z>
null) {<z>
= new ArrayList<>(4);<z>
;<z>
DEFAULT_PERMIT_METHODS) {<z>
(DEFAULT_PERMIT_METHODS);<z>
add(method);<z>
)) {<z>
= null;<z>
{<z>
;<z>
> entrySet() {<z>
this.entrySet;<z>
{<z>
new EntrySet();<z>
this.entrySet = entrySet;<z>
;<z>
) {<z>
"Property 'targetConnectionFactories' must not be null");<z>
size());<z>
forEach((key, value) -> {<z>
;<z>
connectionFactory = resolveSpecifiedConnectionFactory(value);<z>
;<z>
});<z>
this.defaultTargetConnectionFactory != null) {<z>
= resolveSpecifiedConnectionFactory(this.defaultTargetConnectionFactory);<z>
@Nullable String catalogName,<z>
{<z>
procedureColumnMetaDataUsed = true;<z>
(databaseMetaData, catalogName, schemaName, procedureName);<z>
{<z>
(getTaskScheduler() != null, "No TaskScheduler configured");<z>
System.currentTimeMillis();<z>
scheduleWithFixedDelay(() -> {<z>
.lastWriteTime > duration) {<z>
();<z>
) {<z>
) {<z>
.debug("WriteInactivityTask failure", ex);<z>
);<z>
dataSource) throws SQLException {<z>
(con == null) {<z>
if (dataSource != null) {<z>
(dataSource);<z>
connectionEquals(conHolder, con)) {<z>
.released();<z>
;<z>
Method findInterfaceMethod(Class iface) {<z>
) {<z>
);<z>
iface.getDeclaredMethods();<z>
) {<z>
"expecting exactly 1 method in " + iface);<z>
];<z>
{<z>
())) {<z>
return false;<z>
.constructType(targetClass);<z>
();<z>
, causeRef)) {<z>
true;<z>
());<z>
return false;<z>
(String pattern, RequestPredicate predicate,<z>
HandlerFunction<ServerResponse> handlerFunction) {<z>
and(predicate), handlerFunction);<z>
servletResponse) {<z>
headerName, headerValues) -> {<z>
String headerValue : headerValues) {<z>
(headerName, headerValue);<z>
});<z>
null) {<z>
toString());<z>
if (servletResponse.getCharacterEncoding() == null &&<z>
headers.getContentType() != null &&<z>
) != null) {<z>
());<z>
{<z>
) {<z>
("Property 'resourceAdapter' is required");<z>
messageListenerSet) {<z>
(this.endpointFactory);<z>
null) {<z>
(), this.activationSpecConfig));<z>
afterPropertiesSet();<z>
> paramTypes, List<TypeDescriptor> argTypes) {<z>
0;<z>
); i++) {<z>
(i);<z>
i) : null);<z>
null) {<z>
{<z>
;<z>
.getType();<z>
argType.getType())) {<z>
Integer.MAX_VALUE;<z>
) {<z>
= Object.class;<z>
();<z>
!= null) {<z>
(paramTypeClazz.equals(superClass)) {<z>
+ 2;<z>
= null;<z>
, superClass)) {<z>
result = result + 2;<z>
;<z>
= null;<z>
)) {<z>
result + 1;<z>
result;<z>
{<z>
this.parameterIndex < 0) {<z>
);<z>
= this.parameter;<z>
(parameter == null) {<z>
getParameters()[this.parameterIndex];<z>
this.parameter = parameter;<z>
return parameter;<z>
Object other) {<z>
this == other) {<z>
true;<z>
other instanceof SingletonTargetSource otherTargetSource)) {<z>
;<z>
target.equals(otherTargetSource.target);<z>
{<z>
this.mergeEnabled) {<z>
throw new IllegalStateException("Not allowed to merge when the 'mergeEnabled' property is set to 'false'");<z>
== null) {<z>
;<z>
Properties)) {<z>
;<z>
Properties merged = new ManagedProperties();<z>
) parent);<z>
(this);<z>
return merged;<z>
htmlEscape) throws IllegalStateException {<z>
.requestContext = requestContext;<z>
.path = path;<z>
= htmlEscape;<z>
String beanName;<z>
.indexOf('.');<z>
dotPos == -1) {<z>
beanName = path;<z>
= null;<z>
(0, dotPos);<z>
dotPos + 1);<z>
requestContext.getErrors(beanName, false);<z>
) {<z>
(this.expression != null) {<z>
(this.expression)) {<z>
getAllErrors();<z>
this.expression.endsWith("*")) {<z>
errors.getFieldErrors(this.expression);<z>
.expression);<z>
;<z>
);<z>
instanceof BindingResult) {<z>
.bindingResult = (BindingResult) this.errors;<z>
.bindingResult.getRawFieldValue(this.expression);<z>
.findEditor(this.expression, null);<z>
value;<z>
this.errors.getGlobalErrors();<z>
errorCodes = initErrorCodes(this.objectErrors);<z>
getModelObject(beanName);<z>
{<z>
"Neither BindingResult nor plain target object for bean name '" +<z>
;<z>
.expression.endsWith("*")) {<z>
BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(target);<z>
expression);<z>
= bw.getPropertyType(this.expression);<z>
this.actualValue = this.value;<z>
0];<z>
this.errorMessages = new String[0];<z>
) {<z>
.value);<z>
.websocket.Session session, ByteBuffer payload) {<z>
(payload);<z>
handleMessage(this.wsSession, pongMessage);<z>
(Exception ex) {<z>
(this.wsSession, ex, logger);<z>
RenderingContext(ApplicationContext applicationContext, Locale locale,<z>
String url) {<z>
;<z>
this.locale = locale;<z>
;<z>
url;<z>
request) {<z>
.CONTENT_LENGTH);<z>
= request.getHeader(HttpHeaders.TRANSFER_ENCODING);<z>
return StringUtils.hasText(transferEncoding) ||<z>
);<z>
ResourceAdapter adapter, JmsActivationSpecConfig config) {<z>
.activationSpecClass;<z>
) {<z>
adapter);<z>
null) {<z>
IllegalStateException("Property 'activationSpecClass' is required");<z>
activationSpecClassToUse);<z>
BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(spec);<z>
.defaultProperties != null) {<z>
.defaultProperties);<z>
;<z>
return spec;<z>
) {<z>
();<z>
XMLStreamConstants.SPACE || eventType == XMLStreamConstants.CHARACTERS ||<z>
.CDATA ||<z>
;<z>
collection, String message) {<z>
if (collection != null) {<z>
: collection) {<z>
if (element == null) {<z>
IllegalArgumentException(message);<z>
URI getURI() {<z>
return this.httpRequest.getUri();<z>
catch (URISyntaxException ex) {<z>
+ ex.getMessage());<z>
@Nullable String beanName) {<z>
));<z>
this.method = method;<z>
.beanName = beanName;<z>
) {<z>
= new StringBuilder(64);<z>
());<z>
) {<z>
;<z>
.length - 1; i++) {<z>
).append(values[i]);<z>
.append(')');<z>
values[values.length - 1];<z>
(" < ").append(maxValue);<z>
sb.toString();<z>
beanName) {<z>
) {<z>
.getClass(), beanName);<z>
) != bean) {<z>
, cacheKey);<z>
bean;<z>
) {<z>
getCacheMillis() >= 0) {<z>
locale);<z>
;<z>
) {<z>
(locale);<z>
if (bundle != null) {<z>
;<z>
basename, locale);<z>
) {<z>
new ConcurrentHashMap<>());<z>
localeMap.put(locale, bundle);<z>
return bundle;<z>
ex) {<z>
logger.isWarnEnabled()) {<z>
));<z>
return null;<z>
) {<z>
"META-INF")) {<z>
return true;<z>
)) {<z>
substring(1) : path);<z>
)) {<z>
true;<z>
(path).contains("../");<z>
(Method introspectedMethod, boolean nestedAnnotationsAsMap) {<z>
, "Method must not be null");<z>
introspectedMethod = introspectedMethod;<z>
= nestedAnnotationsAsMap;<z>
MergedAnnotations.from(<z>
RepeatableContainers.none());<z>
remove() {<z>
last != null, "No element to remove");<z>
.last.getKey());<z>
= null;<z>
void processInjectionBasedOnServletContext(Object target, ServletContext servletContext) {<z>
target, "Target object must not be null");<z>
cc = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);<z>
AutowiredAnnotationBeanPostProcessor();<z>
getAutowireCapableBeanFactory());<z>
);<z>
> argumentResolvers) {<z>
configurers) {<z>
(argumentResolvers);<z>
, IOException {<z>
{<z>
, response, this.nextFilterChain);<z>
"Neither a Filter not a Servlet set");<z>
;<z>
) throws MailException {<z>
;<z>
transport = null;<z>
mimeMessages.length; i++) {<z>
|| !transport.isConnected()) {<z>
) {<z>
;<z>
ex) {<z>
transport = null;<z>
connectTransport();<z>
{<z>
);<z>
catch (Exception ex) {<z>
; j++) {<z>
mimeMessages[j]);<z>
, ex);<z>
, failedMessages);<z>
[i];<z>
() == null) {<z>
setSentDate(new Date());<z>
();<z>
;<z>
if (messageId != null) {<z>
(HEADER_MESSAGE_ID, messageId);<z>
.getAllRecipients();<z>
Address[0]));<z>
{<z>
[i] : mimeMessage);<z>
failedMessages.put(original, ex);<z>
{<z>
.close();<z>
catch (Exception ex) {<z>
{<z>
,<z>
failedMessages);<z>
;<z>
!failedMessages.isEmpty()) {<z>
throw new MailSendException(failedMessages);<z>
uri, HttpMethod method)<z>
throws MalformedURLException {<z>
= getContentType(headers);<z>
length > 0 ||<z>
?<z>
null);<z>
;<z>
-> {<z>
headerValue : headerValues) {<z>
);<z>
);<z>
.build();<z>
(@Nullable float[] array) {<z>
null) {<z>
;<z>
int hash = INITIAL_HASH;<z>
for (float element : array) {<z>
;<z>
;<z>
) {<z>
array == null) {<z>
return NULL_STRING;<z>
length;<z>
) {<z>
return EMPTY_ARRAY;<z>
ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);<z>
(Object o : array) {<z>
);<z>
);<z>
) {<z>
;<z>
;<z>
.repeatExpectations.reset();<z>
beans) {<z>
(beans.size());<z>
ControllerAdviceBean bean : beans) {<z>
MessagingControllerAdviceBean(bean));<z>
result;<z>
) {<z>
typeDescriptor = this.typeDescriptor;<z>
{<z>
= (this.field != null ?<z>
, getDependencyType(), getAnnotations()) :<z>
()));<z>
;<z>
typeDescriptor;<z>
Charset getContentTypeCharset(@Nullable MimeType mimeType) {<z>
mimeType.getCharset() != null) {<z>
.getCharset();<z>
this.defaultCharset;<z>
) {<z>
);<z>
super.getHandlerInternal(exchange)<z>
-> ProducesRequestCondition.clearMediaTypesAttribute(exchange));<z>
container) {<z>
Assert.state(this.messageHandlerMethodFactory != null,<z>
"Could not create message listener - MessageHandlerMethodFactory not set");<z>
;<z>
;<z>
= getMethod();<z>
, "No bean+method set on endpoint");<z>
invocableHandlerMethod =<z>
(bean, method);<z>
);<z>
String responseDestination = getDefaultResponseDestination();<z>
{<z>
container.isReplyPubSubDomain()) {<z>
);<z>
(responseDestination);<z>
QosSettings responseQosSettings = container.getReplyQosSettings();<z>
(responseQosSettings != null) {<z>
);<z>
getMessageConverter();<z>
(messageConverter != null) {<z>
);<z>
;<z>
{<z>
destinationResolver);<z>
return messageListener;<z>
{<z>
= false;<z>
false;<z>
this.deadline = null;<z>
ModelAndView doResolveException(<z>
, @Nullable Object handler, Exception ex) {<z>
null);<z>
, ex);<z>
) throws Exception {<z>
getUrl() == null) {<z>
;<z>
() {<z>
= this.dataBuffer.get();<z>
!= null, "DataBuffer should not be null");<z>
this.sink.next(dataBuffer);<z>
set(null);<z>
Flux<DataBuffer> readAsynchronousFileChannel(<z>
position,<z>
bufferFactory, int bufferSize) {<z>
;<z>
Assert.notNull(bufferFactory, "'dataBufferFactory' must not be null");<z>
"'position' must be >= 0");<z>
(bufferSize > 0, "'bufferSize' must be > 0");<z>
.using(channelSupplier,<z>
sink -> {<z>
handler =<z>
;<z>
sink.onCancel(handler::cancel);<z>
(handler::request);<z>
}),<z>
{<z>
;<z>
release);<z>
) {<z>
.getClass()) {<z>
resource.contentLength();<z>
(IOException ignored) {<z>
;<z>
validate(Object... validationHints) {<z>
();<z>
state(target != null, "No target to validate");<z>
= getBindingResult();<z>
validator : getValidators()) {<z>
{<z>
validationHints);<z>
!= null) {<z>
validate(target, bindingResult);<z>
, MethodParameter parameter,<z>
{<z>
return body;<z>
> map, StringBuilder builder) {<z>
{<z>
.append(';');<z>
(key);<z>
builder.append('=');<z>
);<z>
;<z>
) {<z>
) {<z>
if (isTimeoutFailure) {<z>
this;<z>
);<z>
ex);<z>
(fallbackRequest != null) {<z>
" failed. Falling back on next transport.", ex);<z>
;<z>
;<z>
{<z>
ex);<z>
) {<z>
Runnable runnable : timeoutTasks) {<z>
();<z>
{<z>
"Transport failed to run timeout tasks for " + DefaultTransportRequest.this, ex2);<z>
("Connect success/failure events already took place for " +<z>
);<z>
SourceClass doProcessConfigurationClass(<z>
sourceClass, Predicate<String> filter)<z>
IOException {<z>
())) {<z>
processMemberClasses(configClass, sourceClass, filter);<z>
for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(<z>
class,<z>
class)) {<z>
instanceof ConfigurableEnvironment) {<z>
;<z>
().getClassName() +<z>
;<z>
Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(<z>
ComponentScan.class);<z>
!componentScans.isEmpty() &&<z>
{<z>
{<z>
BeanDefinitionHolder> scannedBeanDefinitions =<z>
.getMetadata().getClassName());<z>
: scannedBeanDefinitions) {<z>
();<z>
bdCand == null) {<z>
();<z>
)) {<z>
.getBeanName());<z>
sourceClass), filter, true);<z>
=<z>
), ImportResource.class);<z>
importResource != null) {<z>
] resources = importResource.getStringArray("locations");<z>
readerClass = importResource.getClass("reader");<z>
: resources) {<z>
= this.environment.resolveRequiredPlaceholders(resource);<z>
configClass.addImportedResource(resolvedResource, readerClass);<z>
beanMethods = retrieveBeanMethodMetadata(sourceClass);<z>
: beanMethods) {<z>
BeanMethod(methodMetadata, configClass));<z>
, sourceClass);<z>
getMetadata().hasSuperClass()) {<z>
().getSuperClassName();<z>
) &&<z>
knownSuperclasses.containsKey(superclass)) {<z>
;<z>
);<z>
null;<z>
) {<z>
getUrl();<z>
, "'url' not set");<z>
{<z>
.debug("Applying stylesheet [" + url + "]");<z>
.getResource(url);<z>
);<z>
{<z>
"'", ex);<z>
<Void> renderInternal(<z>
) {<z>
(model, exchange);<z>
);<z>
extends BufferedImage> clazz, HttpInputMessage inputMessage)<z>
throws IOException, HttpMessageNotReadableException {<z>
imageInputStream = null;<z>
= null;<z>
);<z>
getContentType();<z>
contentType == null) {<z>
;<z>
(contentType.toString());<z>
if (imageReaders.hasNext()) {<z>
= imageReaders.next();<z>
);<z>
;<z>
imageInputStream, true);<z>
imageReader.read(0, irp);<z>
(<z>
,<z>
inputMessage);<z>
(imageReader != null) {<z>
imageReader.dispose();<z>
imageInputStream != null) {<z>
close();<z>
catch (IOException ex) {<z>
) {<z>
(compute == COMPUTE_ALL_FRAMES) {<z>
);<z>
(compute == COMPUTE_MAX_STACK_AND_LOCAL) {<z>
();<z>
} else if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES) {<z>
;<z>
} else {<z>
.maxStack = maxStack;<z>
maxLocals = maxLocals;<z>
... headerValues) {<z>
for (String headerValue : headerValues) {<z>
);<z>
this;<z>
Nullable TypeDescriptor sourceElementType,<z>
targetElementType, ConversionService conversionService) {<z>
{<z>
true;<z>
) {<z>
true;<z>
sourceElementType, targetElementType)) {<z>
return true;<z>
, targetElementType.getType())) {<z>
return true;<z>
false;<z>
setImmutable() {<z>
) {<z>
(getId() == null) {<z>
.this.idGenerator != null ?<z>
());<z>
UUID id = idGenerator.generateId();<z>
!= MessageHeaders.ID_VALUE_NONE) {<z>
.put(ID, id);<z>
) == null) {<z>
{<z>
System.currentTimeMillis());<z>
= false;<z>
) {<z>
;<z>
notNull(connectionFactory, "ConnectionFactory must not be null");<z>
put(connectionFactoryName, connectionFactory);<z>
{<z>
> sessions =<z>
;<z>
sessionType);<z>
) throws IOException, ClassNotFoundException {<z>
;<z>
.params);<z>
Properties statusCodes) {<z>
; enumeration.hasMoreElements();) {<z>
) enumeration.nextElement();<z>
;<z>
viewName, statusCode);<z>
SubscribableChannel clientInboundChannel,<z>
clientOutboundChannel, SimpMessageSendingOperations brokerTemplate) {<z>
clientInboundChannel, "clientInboundChannel must not be null");<z>
notNull(clientOutboundChannel, "clientOutboundChannel must not be null");<z>
Assert.notNull(brokerTemplate, "brokerTemplate must not be null");<z>
this.clientInboundChannel = clientInboundChannel;<z>
SimpMessagingTemplate(clientOutboundChannel);<z>
= brokerTemplate;<z>
> converters = new ArrayList<>();<z>
StringMessageConverter());<z>
;<z>
(converters);<z>
> newInstance(<z>
@Nullable ConversionService conversionService) {<z>
;<z>
.setConversionService(conversionService);<z>
return rowMapper;<z>
?> aspectClass) {<z>
);<z>
= createAspectMetadata(aspectClass, aspectName);<z>
(am, aspectClass, aspectName);<z>
instanceFactory);<z>
) throws IOException {<z>
) {<z>
null;<z>
new ServletServerHttpRequest(request) {<z>
IOException {<z>
();<z>
null, inputMessage);<z>
<MediaType> supportedTypes,<z>
@Nullable ResolvableType bodyType) {<z>
contentType, bodyType));<z>
= contentType;<z>
supportedTypes);<z>
bodyType = bodyType;<z>
other) {<z>
this == other) {<z>
true;<z>
{<z>
;<z>
(Source) other;<z>
equals(otherSource.declaringClassName) &&<z>
equals(otherSource.descriptor));<z>
ApplicationContext obtainApplicationContext() {<z>
getApplicationContext();<z>
);<z>
return applicationContext;<z>
{<z>
if (this.cacheManager != null) {<z>
.cacheManager.close();<z>
String targetUrl, ServerHttpRequest request) {<z>
;<z>
StringUtils.hasText(query)) {<z>
);<z>
.indexOf('#');<z>
);<z>
= new StringBuilder();<z>
) : targetUrl);<z>
: '&').append(query);<z>
!= null) {<z>
;<z>
;<z>
() {<z>
active = false;<z>
(this.cachedSessions) {<z>
.cachedSessions.values()) {<z>
(sessionList) {<z>
for (Session session : sessionList) {<z>
);<z>
Throwable ex) {<z>
);<z>
;<z>
;<z>
this.active = true;<z>
<String, Object>> getModelAttributes(<z>
) {<z>
attributes;<z>
{<z>
());<z>
entry : model.entrySet()) {<z>
(entry.getValue() != null) {<z>
));<z>
>(0);<z>
, exchange)<z>
().remove(BINDING_CONTEXT_ATTRIBUTE))<z>
.thenReturn(attributes);<z>
) {<z>
= new TreeSet<>();<z>
.parse(cssContent, links));<z>
(links.isEmpty()) {<z>
Collections.emptyList();<z>
;<z>
result = new ArrayList<>();<z>
link : links) {<z>
, false));<z>
link);<z>
link.getEnd();<z>
) {<z>
, false));<z>
;<z>
, ?> paramMap) throws DataAccessException {<z>
));<z>
.state(result != null, "No result map");<z>
;<z>
annotations, RoundEnvironment roundEnv) {<z>
(roundEnv);<z>
forEach(this::processElement);<z>
)) {<z>
;<z>
;<z>
static Map<String, DefaultValueHolder> getDefaultValues(<z>
<? extends Annotation> annotationType) {<z>
computeIfAbsent(annotationType,<z>
);<z>
, HttpInputMessage inputMessage) throws IOException {<z>
);<z>
setNamespaceAware(true);<z>
(<z>
, !isSupportDtd());<z>
setFeature(<z>
"http://xml.org/sax/features/external-general-entities", isProcessExternalEntities());<z>
);<z>
if (!isProcessExternalEntities()) {<z>
documentBuilder.setEntityResolver(NO_OP_ENTITY_RESOLVER);<z>
;<z>
);<z>
{<z>
()) {<z>
throw new HttpMessageNotReadableException("NPE while unmarshalling: This can happen " +<z>
ex, inputMessage);<z>
throw ex;<z>
) {<z>
new HttpMessageNotReadableException(<z>
, inputMessage);<z>
(SAXException ex) {<z>
(<z>
(), ex, inputMessage);<z>
String elementTypeName, int size) {<z>
);<z>
;<z>
;<z>
> sessionType) {<z>
.class);<z>
;<z>
;<z>
, payload);<z>
= (payload.length > 0 &&<z>
.class.isAssignableFrom(sessionType)) &&<z>
isCompatibleWith(accessor.getContentType()));<z>
bytes));<z>
<ClientResponse> exchange() {<z>
.inserter != null ?<z>
.inserter).build() :<z>
());<z>
defer(() -> {<z>
= exchangeFunction.exchange(request)<z>
uri + " [DefaultWebClient]")<z>
.switchIfEmpty(NO_HTTP_CLIENT_RESPONSE_ERROR);<z>
!= null) {<z>
(this.contextModifier);<z>
return responseMono;<z>
);<z>
) {<z>
startPos;<z>
endPos;<z>
ObjectUtils.isEmpty(operands)) {<z>
;<z>
(SpelNodeImpl operand : operands) {<z>
.notNull(operand, "Operand must not be null");<z>
.parent = this;<z>
(<z>
) {<z>
= exceptionMethodResolverFactory;<z>
initHandlerRegistry() {<z>
== null) {<z>
);<z>
(this.handlerRegistry);<z>
.handlerRegistry;<z>
public String toString() {<z>
(this)<z>
, this.testClass.getName())<z>
))<z>
.toString();<z>
() {<z>
null) {<z>
sessionLookup.findSessions(getName());<z>
values());<z>
(this.sessions);<z>
IOException {<z>
(response.getRawStatusCode());<z>
{<z>
= getResponseBody(response);<z>
message = getErrorMessage(response.getRawStatusCode(),<z>
, body, getCharset(response));<z>
new UnknownHttpStatusCodeException(message,<z>
(),<z>
), body, getCharset(response));<z>
(response, statusCode);<z>
{<z>
(target instanceof TargetSource) {<z>
) target;<z>
SingletonTargetSource(target);<z>
) {<z>
{<z>
.externallyManagedConfigMembers != null ?<z>
externallyManagedConfigMembers)) :<z>
);<z>
[] getStreamingMediaTypeSeparator(@Nullable MimeType mimeType) {<z>
{<z>
) {<z>
STREAM_SEPARATOR;<z>
null;<z>
Object> execute(Object... inParams) {<z>
new HashMap<>();<z>
inParams);<z>
;<z>
SqlParameter sqlParameter : getDeclaredParameters()) {<z>
{<z>
(), inParams[i++]);<z>
getDeclaredParameters());<z>
{<z>
.rootMimeMultipart == null) {<z>
+<z>
);<z>
this.rootMimeMultipart;<z>
(EvaluationContext evaluationContext,<z>
, Object[] arguments) {<z>
);<z>
if (value == null) {<z>
argumentTypes);<z>
TypedValue.NULL;<z>
;<z>
!= null) {<z>
arguments);<z>
{<z>
);<z>
this.cachedExecutor = null;<z>
);<z>
(<z>
null), targetType, argumentTypes);<z>
, arguments);<z>
AccessException ex) {<z>
);<z>
(), ex,<z>
,<z>
getMessage());<z>
String subscriptionId, Message<?> message) {<z>
= this.sessionRegistry.getSession(sessionId);<z>
null) {<z>
subscriptionId);<z>
{<z>
, subscription);<z>
, Throwable exception, Log logger) {<z>
(logger.isErrorEnabled()) {<z>
exception);<z>
isOpen()) {<z>
session.close(CloseStatus.SERVER_ERROR);<z>
) {<z>
{<z>
.viewResolvers) {<z>
{<z>
)viewResolver).setServletContext(servletContext);<z>
boolean containsProperty(String name) {<z>
nonOptionArgsPropertyName.equals(name)) {<z>
this.getNonOptionArgs().isEmpty();<z>
;<z>
method(HttpMethod httpMethod) {<z>
, "HttpMethod must not be null");<z>
= httpMethod;<z>
;<z>
Nullable Clock clock) {<z>
();<z>
{<z>
;<z>
block();<z>
(session != null, "WebSession must not be null");<z>
this.delegate = session;<z>
afterPropertiesSet() {<z>
)) {<z>
;<z>
();<z>
TypedValue getValue() {<z>
targetObjectRuntimeClass = getObjectClass(this.targetObject);<z>
cachedReadName.equals(this.name) &&<z>
null &&<z>
) {<z>
PropertyAccessor accessor = Indexer.this.cachedReadAccessor;<z>
, "No cached read accessor");<z>
.targetObject, this.name);<z>
(<z>
getPropertyAccessors());<z>
PropertyAccessor accessor : accessorsToTry) {<z>
name)) {<z>
) {<z>
reflectivePropertyAccessor.createOptimalAccessor(<z>
this.name);<z>
;<z>
;<z>
.cachedReadTargetType = targetObjectRuntimeClass;<z>
.OptimalPropertyAccessor optimalAccessor) {<z>
member = optimalAccessor.member;<z>
member instanceof Method method ?<z>
).getType());<z>
.name);<z>
(AccessException ex) {<z>
,<z>
toString());<z>
throw new SpelEvaluationException(getStartPosition(),<z>
.toString());<z>
() {<z>
getScheme());<z>
.nullSafeHashCode(this.userInfo);<z>
ObjectUtils.nullSafeHashCode(this.host);<z>
this.port);<z>
);<z>
hashCode();<z>
getFragment());<z>
return result;<z>
propertySource) {<z>
this.propertySourceList) {<z>
;<z>
.propertySourceList.add(0, propertySource);<z>
) {<z>
(pattern == null || str == null) {<z>
return false;<z>
firstIndex = pattern.indexOf('*');<z>
) {<z>
equals(str);<z>
== 0) {<z>
{<z>
;<z>
indexOf('*', 1);<z>
== -1) {<z>
pattern.substring(1));<z>
, nextIndex);<z>
)) {<z>
, str);<z>
.indexOf(part);<z>
-1) {<z>
) {<z>
;<z>
part, partIndex + 1);<z>
return false;<z>
length() >= firstIndex &&<z>
firstIndex)) &&<z>
));<z>
typeName)<z>
SQLException {<z>
Types.BLOB) {<z>
] || this.content == null) {<z>
);<z>
instanceof String) {<z>
getBytes());<z>
) {<z>
length);<z>
(<z>
;<z>
) {<z>
instanceof String || this.content == null) {<z>
.content);<z>
instanceof InputStream) {<z>
);<z>
{<z>
this.content, this.length);<z>
throw new IllegalArgumentException(<z>
) + "] not supported for CLOB columns");<z>
("SqlLobValue only supports SQL types BLOB and CLOB");<z>
other) {<z>
this == other) {<z>
return true;<z>
(!(other instanceof JCacheOperationSourcePointcut otherPc)) {<z>
return false;<z>
());<z>
) {<z>
;<z>
{<z>
();<z>
"Could not determine reply qosSettings - no activation spec config is set");<z>
<String> removeNativeHeader(String headerName) {<z>
, "Already immutable");<z>
= getNativeHeaders();<z>
(CollectionUtils.isEmpty(nativeHeaders)) {<z>
return null;<z>
;<z>
(ClientHttpResponse response, ExchangeStrategies strategies,<z>
String requestDescription, Supplier<HttpRequest> requestSupplier) {<z>
= response;<z>
strategies;<z>
= new DefaultHeaders();<z>
logPrefix;<z>
= requestDescription;<z>
= requestSupplier;<z>
Context() {<z>
<HttpMessageReader<?>> messageReaders() {<z>
();<z>
<ServerHttpResponse> serverResponse() {<z>
return Optional.empty();<z>
() {<z>
from(Hints.LOG_PREFIX_HINT, logPrefix);<z>
protected SQLErrorCodesFactory() {<z>
SQLErrorCodes> errorCodes;<z>
lbf = new DefaultListableBeanFactory();<z>
;<z>
);<z>
resource = loadResource(SQL_ERROR_CODE_DEFAULT_PATH);<z>
)) {<z>
loadBeanDefinitions(resource);<z>
;<z>
SQL_ERROR_CODE_OVERRIDE_PATH);<z>
.exists()) {<z>
resource);<z>
);<z>
false);<z>
)) {<z>
("SQLErrorCodes loaded: " + errorCodes.keySet());<z>
{<z>
, ex);<z>
Collections.emptyMap();<z>
this.errorCodesMap = errorCodes;<z>
subject) throws MessagingException {<z>
(subject, "Subject must not be null");<z>
!= null) {<z>
setSubject(subject, getEncoding());<z>
setSubject(subject);<z>
) {<z>
if (this == NONE) {<z>
;<z>
resolve();<z>
|| resolved == type) {<z>
;<z>
ResolvableType interfaceType : getInterfaces()) {<z>
ResolvableType interfaceAsType = interfaceType.as(type);<z>
{<z>
return interfaceAsType;<z>
);<z>
Mono<Void> afterCompletion(int status) {<z>
(() -> {<z>
;<z>
()) {<z>
;<z>
if (this.holderActive) {<z>
false;<z>
(this.resourceKey);<z>
releaseNecessary = true;<z>
= shouldReleaseAfterCompletion(this.resourceObject);<z>
if (releaseNecessary) {<z>
, this.resourceKey);<z>
));<z>
return sync;<z>
;<z>
body, MethodParameter returnType,<z>
extends HttpMessageConverter<?>> converterType,<z>
response) {<z>
== null) {<z>
;<z>
(body);<z>
request, response);<z>
return container;<z>
handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,<z>
throws SockJsException {<z>
);<z>
StringUtils.hasText(callback)) {<z>
.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);<z>
UTF_8));<z>
catch (IOException ex) {<z>
;<z>
(), ex);<z>
;<z>
,<z>
TaskScheduler scheduler) {<z>
notNull(userRegistry, "'userRegistry' is required");<z>
notNull(brokerTemplate, "'brokerTemplate' is required");<z>
, "'broadcastDestination' is required");<z>
Assert.notNull(scheduler, "'scheduler' is required");<z>
;<z>
brokerTemplate;<z>
broadcastDestination = broadcastDestination;<z>
this.scheduler = scheduler;<z>
ClassFilterAwareUnionIntroductionAwareMethodMatcher(<z>
, ClassFilter cf2) {<z>
, cf2);<z>
findTransactionSynchronizationRegistry(<z>
TransactionManager tm) throws TransactionSystemException {<z>
{<z>
jndiName = DEFAULT_TRANSACTION_SYNCHRONIZATION_REGISTRY_NAME;<z>
;<z>
.isDebugEnabled()) {<z>
jndiName + "]");<z>
tsr;<z>
{<z>
.isDebugEnabled()) {<z>
, ex);<z>
ut instanceof TransactionSynchronizationRegistry) {<z>
;<z>
TransactionSynchronizationRegistry) {<z>
) tm;<z>
return null;<z>
) {<z>
{<z>
asyncRequestTimeout);<z>
) {<z>
initHandlerMethods();<z>
total = getHandlerMethods().size();<z>
> 0) ) {<z>
));<z>
<String> allowedOrigins) {<z>
);<z>
Assert.notNull(allowedOrigins, "Allowed origins must not be null");<z>
();<z>
allowedOrigins.contains("*")) {<z>
true;<z>
)) {<z>
request);<z>
.contains(origin);<z>
) {<z>
(conversionHint instanceof MethodParameter methodParam) {<z>
;<z>
null) {<z>
= methodParam.getMethodAnnotation(JsonView.class);<z>
== null) {<z>
return null;<z>
extractViewClass(annotation, conversionHint);<z>
(conversionHint instanceof JsonView) {<z>
conversionHint);<z>
Class) {<z>
) conversionHint;<z>
return null;<z>
PersistenceUnitTransactionType getTransactionType() {<z>
this.transactionType != null) {<z>
;<z>
return (this.jtaDataSource != null ?<z>
;<z>
(MethodInvocation invocation, Log logger) throws Throwable {<z>
invocation);<z>
logger, "Entering " + invocationDescription);<z>
);<z>
+ invocationDescription);<z>
return rval;<z>
ex) {<z>
logger, "Exception thrown in " + invocationDescription, ex);<z>
;<z>
Object target, Errors errors) {<z>
if (this.targetValidator != null) {<z>
errors);<z>
RequestContext createRequestContext(<z>
<String, Object> model) {<z>
, response, getServletContext(), model);<z>
, Object value) {<z>
Assert.notNull(typeName, "Type name must not be null");<z>
= typeName;<z>
setAttribute(VALUE_KEY, value);<z>
(final String methodDescriptor) {<z>
1;<z>
{<z>
methodDescriptor.charAt(currentOffset) == '[') {<z>
;<z>
'L') {<z>
;<z>
semiColumnOffset + 1);<z>
1;<z>
) {<z>
== SCOPE_REQUEST) {<z>
{<z>
name);<z>
.removeAttribute(name);<z>
session = getSession(false);<z>
(session != null) {<z>
sessionAttributesToUpdate.remove(name);<z>
name);<z>
removeAttribute(name);<z>
ex) {<z>
session) {<z>
Certificate[] certificates;<z>
);<z>
(Throwable ex) {<z>
return null;<z>
<>(certificates.length);<z>
for (Certificate certificate : certificates) {<z>
(certificate instanceof X509Certificate) {<z>
result.add((X509Certificate) certificate);<z>
null);<z>
{<z>
();<z>
) {<z>
t = takeToken();<z>
= eatUnaryExpression();<z>
, rhExpr);<z>
, rhExpr);<z>
.DEC)) {<z>
;<z>
{<z>
t.endPos, true, expr);<z>
t.endPos, true, expr);<z>
expr;<z>
) {<z>
remove(persistenceUnitName);<z>
) {<z>
contains(persistenceUnitName)) {<z>
throw new IllegalArgumentException(<z>
;<z>
(<z>
"' already obtained");<z>
;<z>
public ResultMatcher attributeHasFieldErrorCode(String name, String fieldName,<z>
Matcher<? super String> matcher) {<z>
-> {<z>
mav = getModelAndView(mvcResult);<z>
name);<z>
+ "'", result.hasErrors());<z>
fieldName);<z>
fieldError);<z>
code = fieldError.getCode();<z>
;<z>
[] patterns, PathPatternParser parser) {<z>
) {<z>
();<z>
<>(patterns.length);<z>
for (String path : patterns) {<z>
"/")) {<z>
"/" + path;<z>
;<z>
return result;<z>
namesAndDescriptors, Method[] methods) {<z>
HashMap();<z>
++) {<z>
methods[i];<z>
method);<z>
length / 2];<z>
++) {<z>
namesAndDescriptors[i * 2 + 1]);<z>
{<z>
result;<z>
> consumer, Class<T> targetType) {<z>
;<z>
) value);<z>
;<z>
) {<z>
0) {<z>
return SimpleKey.EMPTY;<z>
{<z>
param = params[0];<z>
) {<z>
return param;<z>
new SimpleKey(params);<z>
String toString() {<z>
String.format("%s[name=%s, propertyType=%s, indexedPropertyType=%s, " +<z>
(),<z>
);<z>
(int statusCode, HttpHeaders headers,<z>
ResponseCookie> cookies,<z>
, Object> hints) {<z>
headers, cookies, hints);<z>
);<z>
this.inserter = body;<z>
) {<z>
ArrayList<>();<z>
fixedField = fixedField(field);<z>
ObjectError objectError : this.errors) {<z>
)) {<z>
((FieldError) objectError);<z>
;<z>
T> BodyInserter<T, ReactiveHttpOutputMessage> fromProducer(<z>
) {<z>
;<z>
;<z>
getClass());<z>
Assert.notNull(adapter, "'producer' type is unknown to ReactiveAdapterRegistry");<z>
) -><z>
elementTypeRef), adapter);<z>
{<z>
;<z>
isWildcardType();<z>
other.isWildcardType();<z>
{<z>
return false;<z>
(!thisWildcard && otherWildcard) {<z>
true;<z>
();<z>
isWildcardSubtype();<z>
{<z>
false;<z>
else if (!thisWildcardSubtype && otherWildcardSubtype) {<z>
;<z>
{<z>
;<z>
.size();<z>
paramsSize1 > paramsSize2;<z>
return false;<z>
ANNOTATION;<z>
@AliasFor("classes")<z>
] value() default {};<z>
name, MethodParameter parameter, NativeWebRequest request)<z>
Exception {<z>
request, false);<z>
int status) {<z>
shouldUnbindAtCompletion()) {<z>
releaseNecessary = false;<z>
.holderActive) {<z>
holderActive = false;<z>
;<z>
this.resourceHolder.unbound();<z>
releaseNecessary = true;<z>
resourceHolder);<z>
) {<z>
this.resourceHolder, this.resourceKey);<z>
STATUS_COMMITTED));<z>
;<z>
void updateBindingResult(BindingContext context, ServerWebExchange exchange) {<z>
asMap();<z>
entrySet()) {<z>
.getKey();<z>
);<z>
, value)) {<z>
(BindingResult.MODEL_KEY_PREFIX + name)) {<z>
name);<z>
getBindingResult());<z>
{<z>
response);<z>
();<z>
(final String file, final String debug) {<z>
) {<z>
);<z>
{<z>
, 0, Integer.MAX_VALUE);<z>
void start() {<z>
(!isRunning()) {<z>
webSocketClient instanceof Lifecycle) {<z>
) this.webSocketClient).start();<z>
this.running = true;<z>
) {<z>
{<z>
return null;<z>
);<z>
= this.beanFactory.getMergedBeanDefinition(beanName);<z>
beanName;<z>
;<z>
;<z>
scriptFactoryBeanName, ScriptFactory.class);<z>
());<z>
();<z>
);<z>
if (scriptedType != null) {<z>
return scriptedType;<z>
!ObjectUtils.isEmpty(interfaces)) {<z>
[0] : createCompositeInterface(interfaces));<z>
(bd.isSingleton()) {<z>
getBean(scriptedObjectBeanName).getClass();<z>
catch (Exception ex) {<z>
&&<z>
() instanceof BeanCurrentlyInCreationException) {<z>
logger.isTraceEnabled()) {<z>
beanName + "': " +<z>
());<z>
isDebugEnabled()) {<z>
+ beanName + "'", ex);<z>
;<z>
tm,<z>
String joinpointIdentification,<z>
Nullable TransactionStatus status) {<z>
, txAttr, joinpointIdentification);<z>
null) {<z>
)) {<z>
txInfo.getJoinpointIdentification() + "]");<z>
);<z>
(logger.isTraceEnabled()) {<z>
("No need to create transaction for [" + joinpointIdentification +<z>
"]: This method is not transactional.");<z>
.bindToThread();<z>
txInfo;<z>
) {<z>
);<z>
headers.containsKey(HttpHeaders.CONTENT_DISPOSITION)) {<z>
.getServletResponse().getStatus();<z>
) {<z>
ex) {<z>
request.getServletRequest();<z>
servletRequest);<z>
;<z>
index);<z>
;<z>
(';');<z>
(index != -1) {<z>
;<z>
(0, index);<z>
, filename);<z>
);<z>
.defaultInstance.decodeRequestString(servletRequest, pathParams);<z>
StringUtils.getFilenameExtension(pathParams);<z>
) {<z>
HttpHeaders.CONTENT_DISPOSITION, "inline;filename=f.txt");<z>
, String name) {<z>
message);<z>
("nativeHeaders.")) {<z>
("nativeHeaders.".length());<z>
(name)) {<z>
null;<z>
> nativeHeaderValues = nativeHeaders.get(name);<z>
get(0) : nativeHeaderValues);<z>
{<z>
{<z>
this.stats.incrementSessionCount(session);<z>
(session);<z>
, new WebSocketSessionHolder(session));<z>
this.clientInboundChannel);<z>
source, A annotation) {<z>
"Annotation must not be null");<z>
);<z>
);<z>
) {<z>
this.subscription, s)) {<z>
= s;<z>
.writeCompletionBarrier.connect();<z>
request(1);<z>
?> headersToCopy) {<z>
== null || this.headers == headersToCopy) {<z>
.forEach((key, value) -> {<z>
if (!isReadOnly(key)) {<z>
key, value);<z>
});<z>
) {<z>
();<z>
) {<z>
" [" + state + "]");<z>
ex);<z>
,<z>
{<z>
(request) &&<z>
getOrigin()) == null) {<z>
response.setStatusCode(HttpStatus.FORBIDDEN);<z>
isDebugEnabled()) {<z>
+<z>
.getOrigin() + " not allowed");<z>
return false;<z>
;<z>
static BeanDefinition registerAutoProxyCreatorIfNecessary(<z>
@Nullable Object source) {<z>
, source);<z>
addMappedInterceptors(<z>
[] pathPatterns, HandlerInterceptor... interceptors) {<z>
(HandlerInterceptor interceptor : interceptors) {<z>
);<z>
;<z>
boolean isPrototype(String name) throws NoSuchBeanDefinitionException {<z>
= getBean(name);<z>
()) ||<z>
)));<z>
, String> params) {<z>
params);<z>
queryParams.addAll(params);<z>
return this;<z>
{<z>
 '\u200C' && ch <= '\u200F') ||<z>
'\u2060' && ch <= '\u206F') ||<z>
00' && ch <= '\uDFFF');<z>
) throws IOException, TemplateException {<z>
{<z>
= createConfiguration();<z>
loader, MergedContextConfiguration mergedConfig)<z>
throws Exception {<z>
if (logger.isDebugEnabled()) {<z>
;<z>
loader.loadContext(mergedConfig);<z>
ResponseEntity<Object> handleServletRequestBindingException(<z>
HttpHeaders headers, HttpStatus status, WebRequest request) {<z>
request);<z>
candidate, @Nullable ClassLoader parent) {<z>
{<z>
;<z>
(candidate == null) {<z>
false;<z>
candidate;<z>
) {<z>
classLoaderToCheck = classLoaderToCheck.getParent();<z>
) {<z>
return true;<z>
false;<z>
PropertySource<?> get(String name) {<z>
<?> propertySource : this.propertySourceList) {<z>
equals(name)) {<z>
;<z>
;<z>
loadInitializer(<z>
{<z>
className, wac.getClassLoader());<z>
Class<?> initializerContextClass =<z>
, ApplicationContextInitializer.class);<z>
isInstance(wac)) {<z>
throw new ApplicationContextException(String.format(<z>
getName(),<z>
).getName()));<z>
instantiateClass(initializerClass, ApplicationContextInitializer.class);<z>
(ClassNotFoundException ex) {<z>
format("Could not load class [%s] specified " +<z>
, className), ex);<z>
setTaskScheduler(@Nullable TaskScheduler taskScheduler) {<z>
taskScheduler = taskScheduler;<z>
.heartbeatValue == null) {<z>
[] {10000, 10000};<z>
providedArgs) {<z>
();<z>
)) {<z>
EMPTY_ARGS;<z>
);<z>
parameters) {<z>
.initParameterNameDiscovery(this.parameterNameDiscoverer);<z>
, providedArgs);<z>
providedArg != null) {<z>
Mono.just(providedArg));<z>
.supportsParameter(parameter)) {<z>
error(new MethodArgumentResolutionException(<z>
parameter, "No suitable resolver")));<z>
.resolvers.resolveArgument(parameter, message)<z>
NO_ARG_VALUE)<z>
ex)));<z>
{<z>
ex);<z>
Mono.error(ex));<z>
, values -><z>
).toArray());<z>
resolveId() throws JspException {<z>
("id", getId());<z>
id != null) {<z>
idString = id.toString();<z>
, this.pageContext) : null);<z>
;<z>
) {<z>
if (this.resolvedDefaultConnectionFactory != null) {<z>
this.resolvedDefaultConnectionFactory.getMetadata();<z>
throw new UnsupportedOperationException(<z>
;<z>
) {<z>
.getName());<z>
ex) {<z>
) {<z>
.getClassName() + "]: " + ex);<z>
return false;<z>
) {<z>
return result -> {<z>
.getSession();<z>
"No HttpSession");<z>
(name);<z>
, value, matcher);<z>
{<z>
;<z>
== null) {<z>
0);<z>
else {<z>
length);<z>
String module : modules) {<z>
).index);<z>
;<z>
{<z>
) {<z>
instant());<z>
maxSessions) {<z>
);<z>
{<z>
.notNull(bcc, "Bcc address must not be null");<z>
(bcc);<z>
.RecipientType.BCC, bcc);<z>
, Object propertyValue) {<z>
if (propertyValue instanceof GroovyBeanDefinitionWrapper) {<z>
;<z>
add(propertyName, propertyValue);<z>
this;<z>
HttpServletRequest request) {<z>
CorsUtils.isPreFlightRequest(request)) {<z>
EMPTY_CONDITION;<z>
isEmpty()) {<z>
;<z>
MediaType> acceptedMediaTypes;<z>
(request);<z>
HttpMediaTypeException ex) {<z>
return null;<z>
result = getMatchingExpressions(acceptedMediaTypes);<z>
(result)) {<z>
;<z>
isPresentIn(acceptedMediaTypes)) {<z>
return EMPTY_CONDITION;<z>
return null;<z>
createAnnotationMethodMessageHandler(<z>
AbstractSubscribableChannel clientOutboundChannel,<z>
{<z>
return new WebSocketAnnotationMethodMessageHandler(<z>
clientOutboundChannel, brokerMessagingTemplate);<z>
beanClass, String beanName) {<z>
(beanClass)) {<z>
;<z>
);<z>
;<z>
+ beanName;<z>
SCRIPTED_OBJECT_NAME_PREFIX + beanName;<z>
bd, scriptFactoryBeanName, scriptedObjectBeanName);<z>
ScriptFactory.class);<z>
;<z>
isFactoryBean = false;<z>
scriptSource);<z>
!= null) {<z>
class.isAssignableFrom(scriptedObjectType);<z>
{<z>
new BeanCreationException(beanName,<z>
ex);<z>
);<z>
refreshCheckDelay >= 0) {<z>
= scriptFactory.getScriptInterfaces();<z>
= new RefreshableScriptTargetSource(this.scriptBeanFactory,<z>
scriptedObjectBeanName, scriptFactory, scriptSource, isFactoryBean);<z>
bd);<z>
);<z>
))) {<z>
throw new BeanDefinitionValidationException(<z>
language + "'");<z>
.setRefreshCheckDelay(refreshCheckDelay);<z>
ts, interfaces, proxyTargetClass);<z>
if (isFactoryBean) {<z>
FACTORY_BEAN_PREFIX + scriptedObjectBeanName;<z>
);<z>
{<z>
Annotation ann : descriptor.getAnnotations()) {<z>
)) {<z>
return true;<z>
false;<z>
short[] array) {<z>
array == null) {<z>
0;<z>
hash = INITIAL_HASH;<z>
array) {<z>
hash = MULTIPLIER * hash + element;<z>
return hash;<z>
, Object... args) {<z>
bodySpec = spec;<z>
this.content = content;<z>
expression, args);<z>
(TransportType transportType) {<z>
sockJsUrl)<z>
.scheme(getScheme(transportType))<z>
))<z>
())<z>
(transportType.toString())<z>
build(true).toUri();<z>
{<z>
) {<z>
(valueBegin - 1, valueEnd + 1);<z>
INTERNAL) {<z>
(valueBegin, valueEnd) + ';';<z>
else {<z>
.substring(valueBegin, valueEnd);<z>
public RequestMatcher isNotEmpty() {<z>
AbstractJsonPathRequestMatcher() {<z>
) throws IOException, ParseException {<z>
());<z>
public void setup() {<z>
eventTemplate = "id:$1\n" +<z>
).length();<z>
= this.totalSize / eventLength;<z>
DataBufferFactory bufferFactory = new DefaultDataBufferFactory();<z>
1, eventCount)<z>
)<z>
this.chunkSize / eventLength : 1)<z>
"", strings))<z>
chunk -> {<z>
chunk.getBytes(CHARSET);<z>
;<z>
bytes);<z>
;<z>
)<z>
;<z>
) {<z>
forEach((name, values) -> {<z>
;<z>
values.forEach(value -> {<z>
;<z>
.addParameter(urlDecodedName, value);<z>
});<z>
;<z>
webRequest.getRequestParameters()) {<z>
KeyDataPair pair) {<z>
);<z>
;<z>
null) {<z>
));<z>
getData());<z>
valueOf(pair.getMimeType()) :<z>
.APPLICATION_OCTET_STREAM);<z>
mediaType);<z>
request.addPart(part);<z>
);<z>
private HttpHeaders initHeaders() {<z>
null) {<z>
= new HttpHeaders();<z>
.headers;<z>
public int hashCode() {<z>
hashCode = 0;<z>
);<z>
for (Advisor advisor : advisors) {<z>
.getAdvice();<z>
hashCode();<z>
;<z>
isExposeProxy() ? 1 : 0);<z>
.isOptimize() ? 1 : 0);<z>
);<z>
return hashCode;<z>
equals(@Nullable Object other) {<z>
(this == other) {<z>
return true;<z>
!(other instanceof EngineKey otherKey)) {<z>
return false;<z>
.scripts));<z>
status) {<z>
status.getReason());<z>
)) {<z>
null);<z>
.empty();<z>
Resource> locations,<z>
chain) {<z>
resolveUrlPathInternal(resourceUrlPath, locations, chain);<z>
request, HttpServletResponse response)<z>
IOException {<z>
SimpleWebApplicationContext)) {<z>
new ServletException("Incorrect WebApplicationContext");<z>
)) {<z>
ServletException("Incorrect LocaleResolver");<z>
RequestContextUtils.getLocale(request))) {<z>
throw new ServletException("Incorrect Locale");<z>
return null;<z>
) {<z>
;<z>
if (ccValue != null) {<z>
);<z>
response.containsHeader(HEADER_PRAGMA)) {<z>
.setHeader(HEADER_PRAGMA, "");<z>
HEADER_EXPIRES)) {<z>
HEADER_EXPIRES, "");<z>
extends byte[]> inputStream,<z>
MimeType mimeType,<z>
> hints) {<z>
((byte[] bytes) -><z>
bufferFactory, elementType, mimeType, hints));<z>
(<z>
int stackMapFrameOffset,<z>
final boolean compressed,<z>
boolean expand,<z>
Context context) {<z>
currentOffset = stackMapFrameOffset;<z>
= context.charBuffer;<z>
;<z>
;<z>
) {<z>
classFileBuffer[currentOffset++] & 0xFF;<z>
{<z>
;<z>
1;<z>
int offsetDelta;<z>
0;<z>
< Frame.SAME_LOCALS_1_STACK_ITEM_FRAME) {<z>
offsetDelta = frameType;<z>
context.currentFrameType = Opcodes.F_SAME;<z>
= 0;<z>
.RESERVED) {<z>
- Frame.SAME_LOCALS_1_STACK_ITEM_FRAME;<z>
, labels);<z>
.F_SAME1;<z>
currentFrameStackCount = 1;<z>
frameType >= Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {<z>
= readUnsignedShort(currentOffset);<z>
+= 2;<z>
SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {<z>
;<z>
;<z>
1;<z>
< Frame.SAME_FRAME_EXTENDED) {<z>
.currentFrameType = Opcodes.F_CHOP;<z>
frameType;<z>
currentFrameLocalCount -= context.currentFrameLocalCountDelta;<z>
= 0;<z>
else if (frameType == Frame.SAME_FRAME_EXTENDED) {<z>
Opcodes.F_SAME;<z>
0;<z>
Frame.FULL_FRAME) {<z>
expand ? context.currentFrameLocalCount : 0;<z>
--) {<z>
, labels);<z>
F_APPEND;<z>
- Frame.SAME_FRAME_EXTENDED;<z>
;<z>
;<z>
{<z>
= readUnsignedShort(currentOffset);<z>
currentOffset += 2;<z>
= Opcodes.F_FULL;<z>
= numberOfLocals;<z>
context.currentFrameLocalCount = numberOfLocals;<z>
numberOfLocals; ++local) {<z>
currentFrameLocalTypes, local, charBuffer, labels);<z>
(currentOffset);<z>
currentOffset += 2;<z>
context.currentFrameStackCount = numberOfStackItems;<z>
{<z>
;<z>
else {<z>
();<z>
offsetDelta + 1;<z>
, labels);<z>
;<z>
messageSupplier) {<z>
()) {<z>
(messageSupplier));<z>
void establishSharedConnection() throws JMSException {<z>
(this.sharedConnectionMonitor) {<z>
null) {<z>
;<z>
.debug("Established shared JMS Connection");<z>
?>> converters,<z>
ContentNegotiationManager manager) {<z>
manager);<z>
) throws BeansException, IllegalStateException {<z>
(urlPaths, "URL path array must not be null");<z>
{<z>
, beanName);<z>
ClassLoader classLoader) {<z>
;<z>
name.startsWith("org.apache.catalina")) {<z>
return new TomcatLoadTimeWeaver(classLoader);<z>
startsWith("org.glassfish")) {<z>
return new GlassFishLoadTimeWeaver(classLoader);<z>
startsWith("org.jboss.modules")) {<z>
;<z>
(Exception ex) {<z>
) {<z>
;<z>
return null;<z>
(String userTransactionName)<z>
throws TransactionSystemException {<z>
)) {<z>
+ "]");<z>
UserTransaction.class);<z>
NamingException ex) {<z>
new TransactionSystemException(<z>
+ userTransactionName + "]", ex);<z>
protected void assertUri(URI uri) {<z>
.notNull(uri, "URI must not be null");<z>
.getScheme();<z>
{<z>
"Invalid scheme: " + scheme);<z>
{<z>
(source == null) {<z>
;<z>
getProtectionDomain();<z>
Attribute attribute) {<z>
!= null) {<z>
;<z>
private void logRequest(HttpServletRequest request) {<z>
{<z>
params;<z>
request.getContentType(), "multipart/")) {<z>
"multipart";<z>
)) {<z>
.stream()<z>
)))<z>
joining(", "));<z>
;<z>
);<z>
queryString : "");<z>
?<z>
"");<z>
+<z>
+ params + "}");<z>
if (traceOn) {<z>
());<z>
? "masked" : "";<z>
)) {<z>
)<z>
.joining(", "));<z>
"'";<z>
message;<z>
});<z>
getAspectClassLoader() {<z>
?<z>
) :<z>
ClassUtils.getDefaultClassLoader());<z>
void onSubscribe(Subscription subscription) {<z>
subscription;<z>
() -> {<z>
()) {<z>
.emitter);<z>
;<z>
complete();<z>
});<z>
emitter::completeWithError);<z>
.request(1);<z>
request) {<z>
request);<z>
));<z>
builder;<z>
(String name) {<z>
);<z>
name);<z>
if (resource.exists()) {<z>
return resource.getInputStream();<z>
) {<z>
logger.isWarnEnabled()) {<z>
logger.warn("Could not load " + resource);<z>
return null;<z>
getResourceAsStream(name);<z>
contentType, HttpOutputMessage outputMessage)<z>
HttpMessageNotWritableException {<z>
();<z>
public ResourcePropertySource withResourceName() {<z>
resourceName == null) {<z>
return this;<z>
resourceName, null, this.source);<z>
) {<z>
event);<z>
== null) {<z>
null;<z>
method.getParameterCount() == 0) {<z>
new Object[0];<z>
toClass();<z>
class.isAssignableFrom(declaredEventClass) &&<z>
instanceof PayloadApplicationEvent) {<z>
.getPayload();<z>
(payload)) {<z>
[] {payload};<z>
{event};<z>
(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,<z>
webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {<z>
SuppressWarnings("unchecked")<z>
String> uriTemplateVars =<z>
) webRequest.getAttribute(<z>
;<z>
) {<z>
return new LinkedHashMap<>(uriTemplateVars);<z>
return Collections.emptyMap();<z>
<?> message) {<z>
);<z>
{<z>
send(defaultDestination, message);<z>
getRequiredDefaultDestinationName(), message);<z>
Class generate(ClassLoaderData data) {<z>
;<z>
get();<z>
;<z>
ClassLoader classLoader = data.getClassLoader();<z>
== null) {<z>
new IllegalStateException("ClassLoader is null while trying to define class " +<z>
() + ". It seems that the loader has been expired from a weak reference somehow. " +<z>
;<z>
classLoader) {<z>
(data.getUniqueNamePredicate());<z>
data.reserveName(name);<z>
.setClassName(name);<z>
attemptLoad) {<z>
(getClassName());<z>
gen;<z>
(ClassNotFoundException e) {<z>
= strategy.generate(this);<z>
ClassReader(b));<z>
ProtectionDomain protectionDomain = getProtectionDomain();<z>
) {<z>
, protectionDomain, contextClass);<z>
gen;<z>
(RuntimeException | Error ex) {<z>
;<z>
ex) {<z>
CodeGenerationException(ex);<z>
(save);<z>
) {<z>
();<z>
) {<z>
;<z>
{<z>
seen.add(element);<z>
("java.lang") ? element : null);<z>
value, final int hashCode) {<z>
0);<z>
.hashCode = hashCode;<z>
(Object methodOrConstructor, int parameterIndex) {<z>
) {<z>
(<z>
"] is neither a Method nor a Constructor");<z>
parameterIndex);<z>
private static boolean hasSameGenericTypeParameters(<z>
, Class<?>[] rootParameterTypes) {<z>
sourceDeclaringClass = rootMethod.getDeclaringClass();<z>
;<z>
{<z>
false;<z>
{<z>
ResolvableType.forMethodParameter(<z>
sourceDeclaringClass).resolve();<z>
) {<z>
;<z>
;<z>
void afterPropertiesSet() throws Exception {<z>
);<z>
{<z>
;<z>
;<z>
() == null) {<z>
this.resourceHttpMessageWriter = new ResourceHttpMessageWriter();<z>
);<z>
resolverChain, this.resourceTransformers);<z>
? super Node> matcher) {<z>
new AbstractXmlRequestMatcher() {<z>
protected void matchInternal(MockClientHttpRequest request) throws Exception {<z>
);<z>
MethodParameter param) {<z>
;<z>
();<z>
index == -1) {<z>
getKotlinFunction(method);<z>
());<z>
;<z>
predicate;<z>
(method != null) {<z>
) {<z>
true;<z>
.getKotlinFunction(method);<z>
);<z>
.getConstructor();<z>
null, "Neither method nor constructor found");<z>
(ctor);<z>
p.getKind()) ||<z>
equals(p.getKind()));<z>
) {<z>
0;<z>
: function.getParameters()) {<z>
kParameter)) {<z>
{<z>
));<z>
false;<z>
{<z>
{<z>
CorsRegistry();<z>
addCorsMappings(registry);<z>
this.corsConfigurations = registry.getCorsConfigurations();<z>
.corsConfigurations;<z>
?> targetType) {<z>
(sourceType, targetType)) {<z>
return true;<z>
.isAssignableFrom(targetType)) {<z>
false;<z>
) {<z>
!= null;<z>
null;<z>
(<z>
Object> hints) {<z>
.notNull(elementType, "'elementType' must not be null");<z>
contextClass = getContextClass(elementType);<z>
hints != null) {<z>
.get(ACTUAL_TYPE_HINT));<z>
elementType.getType(), contextClass);<z>
JSON_VIEW_HINT) : null);<z>
null ?<z>
forType(javaType) :<z>
javaType);<z>
ByteBuf... byteBufs) {<z>
!ObjectUtils.isEmpty(byteBufs)) {<z>
{<z>
.byteBuf.writeBytes(byteBuf);<z>
return this;<z>
) {<z>
CODE_SEPARATOR);<z>
String element : elements) {<z>
(element)) {<z>
add(element);<z>
return rtn.toString();<z>
{<z>
for (SpelNodeImpl child: this.children) {<z>
()) {<z>
return false;<z>
true;<z>
targetMediaType) {<z>
this.objectMapperRegistrations)) {<z>
;<z>
.entrySet()) {<z>
{<z>
entrySet()) {<z>
.includes(targetMediaType)) {<z>
getValue();<z>
null;<z>
this.defaultObjectMapper;<z>
{<z>
ConcurrentMap) {<z>
.metadataReaderCache.get(resource);<z>
== null) {<z>
(resource);<z>
metadataReader);<z>
return metadataReader;<z>
) {<z>
.metadataReaderCache) {<z>
resource);<z>
{<z>
;<z>
.metadataReaderCache.put(resource, metadataReader);<z>
;<z>
.getMetadataReader(resource);<z>
{<z>
) {<z>
);<z>
);<z>
MockMultipartFile(<z>
String contentType, InputStream contentStream)<z>
IOException {<z>
(contentStream));<z>
MultiValueMap<String, String> headers,<z>
,<z>
String, ?> uriVarsMap) {<z>
, method, null, type);<z>
= uriTemplate;<z>
;<z>
= uriVarsMap;<z>
setContext(String context) {<z>
startsWith("/")) {<z>
context;<z>
.context = "/" + context;<z>
@Nullable RequestPath requestPath, ServletRequest request) {<z>
) {<z>
;<z>
(PATH_ATTRIBUTE);<z>
Map<String, Object> model,<z>
response) throws Exception {<z>
String url = getUrl();<z>
, "'url' not set");<z>
template = getTemplate(url);<z>
)));<z>
public int run(Object... parameters) {<z>
Object obj = super.findObject(parameters);<z>
) {<z>
+ "] to int");<z>
;<z>
] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw) {<z>
));<z>
::isExcludedFromDependencyCheck);<z>
new PropertyDescriptor[0]);<z>
String fieldName, @Nullable Object value) {<z>
printFieldSeparatorIfNecessary();<z>
, value);<z>
;<z>
(HttpServletRequest request) {<z>
.isPreFlightRequest(request)) {<z>
;<z>
) {<z>
return this;<z>
{<z>
;<z>
MediaType contentType;<z>
(request.getContentType()) ?<z>
.parseMediaType(request.getContentType()) :<z>
.APPLICATION_OCTET_STREAM;<z>
) {<z>
;<z>
getMatchingExpressions(contentType);<z>
) : null;<z>
ResponseSpec httpOnly(String name, boolean expected) {<z>
= getCookie(name).isHttpOnly();<z>
-> {<z>
name) + " httpOnly";<z>
isHttpOnly);<z>
);<z>
return this.responseSpec;<z>
(String pattern, String path) {<z>
LinkedHashMap<>();<z>
, true, variables);<z>
) {<z>
+ "\"");<z>
return variables;<z>
mimeType) {<z>
getType());<z>
isAssignableFrom(elementType.toClass()) &&<z>
isAssignableFrom(elementType.toClass()));<z>
ex) {<z>
;<z>
SockJsResponseListener listener) {<z>
.isTraceEnabled()) {<z>
;<z>
method(HttpMethod.POST);<z>
(httpRequest, headers);<z>
send(listener);<z>
, @Nullable Object[] errorArgs,<z>
defaultMessage) {<z>
;<z>
@Nullable String beanName) {<z>
(beanName != null) {<z>
;<z>
.remove();<z>
types) {<z>
|| ObjectUtils.isEmpty(types)) {<z>
return null;<z>
type : types) {<z>
Object value = findValueOfType(collection, type);<z>
(value != null) {<z>
;<z>
return null;<z>
) {<z>
.notNull(attributesConsumer, "AttributesConsumer must not be null");<z>
(this.routerFunctions.isEmpty()) {<z>
("attributes can only be called after any other method (GET, path, etc.)");<z>
size() - 1;<z>
routerFunctions.get(lastIdx)<z>
(attributesConsumer);<z>
;<z>
this;<z>
, ConstraintDescriptor<?> descriptor) {<z>
new ArrayList<>();<z>
field));<z>
> attributesToExpose = new TreeMap<>();<z>
{<z>
) {<z>
{<z>
(str);<z>
);<z>
});<z>
attributesToExpose.values());<z>
.toArray();<z>
{<z>
;<z>
resource;<z>
) {<z>
) resourceRef).getWrappedObject();<z>
if (aopAvailable) {<z>
resourceRef);<z>
return resourceRef;<z>
() throws Exception {<z>
)<z>
.setHandler(initHttpHandlerAdapter())<z>
.build();<z>
{<z>
SEC_WEBSOCKET_PROTOCOL);<z>
CollectionUtils.isEmpty(values)) {<z>
();<z>
1) {<z>
getValuesAsList(SEC_WEBSOCKET_PROTOCOL);<z>
return values;<z>
) {<z>
null ? strategy : new StdInstantiatorStrategy());<z>
IGNORE_OBJENESIS_PROPERTY_NAME)) {<z>
.FALSE;<z>
String getDefaultResponseDestination() {<z>
();<z>
(specificMethod == null) {<z>
;<z>
;<z>
(ann != null) {<z>
= ann.value();<z>
1) {<z>
.getSimpleName() + " annotation on '" +<z>
destinations) + ")");<z>
) destinations[0]);<z>
null;<z>
String> initCookies() {<z>
)) {<z>
);<z>
CollectionUtils.isEmpty(defaultCookies)) {<z>
;<z>
();<z>
result.putAll(defaultCookies);<z>
.cookies);<z>
result;<z>
] charBuffer) {<z>
= classReader.classFileBuffer;<z>
;<z>
0; --i) {<z>
readUTF8(currentAttributeOffset, charBuffer);<z>
equals(attributeName)) {<z>
classReader.readUnsignedShort(currentAttributeOffset + 6);<z>
+ classReader.readInt(currentAttributeOffset + 2);<z>
{<z>
8;<z>
.readInt(currentAttributeOffset + 2) - 2;<z>
bootstrapMethodsLength);<z>
);<z>
;<z>
{<z>
= currentOffset - bootstrapMethodsOffset;<z>
int bootstrapMethodRef = classReader.readUnsignedShort(currentOffset);<z>
2;<z>
= classReader.readUnsignedShort(currentOffset);<z>
;<z>
bootstrapMethodRef, charBuffer).hashCode();<z>
> 0) {<z>
= classReader.readUnsignedShort(currentOffset);<z>
+= 2;<z>
bootstrapArgument, charBuffer).hashCode();<z>
offset, hashCode & 0x7FFFFFFF));<z>
(Predicate<String> extensionPredicate) {<z>
);<z>
this.extensionPredicate = extensionPredicate;<z>
= null;<z>
int end) {<z>
{<z>
));<z>
, start, end));<z>
array, @Nullable O obj) {<z>
= Object.class;<z>
(array != null) {<z>
array.getClass().getComponentType();<z>
obj != null) {<z>
();<z>
: 1);<z>
("unchecked")<z>
compType, newArrLength);<z>
array != null) {<z>
array.length);<z>
obj;<z>
newArr;<z>
argumentIndexOffset) {<z>
int numParametersToRemove = argumentIndexOffset;<z>
if (this.returningName != null) {<z>
;<z>
if (this.throwingName != null) {<z>
++;<z>
length - numParametersToRemove];<z>
>[pointcutParameterNames.length];<z>
.aspectJAdviceMethod.getParameterTypes();<z>
= 0;<z>
++) {<z>
< argumentIndexOffset) {<z>
.returningName) ||<z>
)) {<z>
pointcutParameterNames[index] = argumentNames[i];<z>
index] = methodParameterTypes[i];<z>
index++;<z>
setParameterNames(pointcutParameterNames);<z>
;<z>
public ViewControllerRegistration addViewController(String urlPathOrPattern) {<z>
new ViewControllerRegistration(urlPathOrPattern);<z>
;<z>
this.registrations.add(registration);<z>
;<z>
(HttpServletRequest servletRequest,<z>
,<z>
<?> deferredResult) {<z>
servletRequest;<z>
= new NoContentLengthResponseWrapper(servletResponse);<z>
context = context;<z>
this.deferredResult = deferredResult;<z>
) {<z>
= getShortName(clazz);<z>
shortName.lastIndexOf(PACKAGE_SEPARATOR);<z>
) : shortName);<z>
decapitalize(shortName);<z>
byte[] body,<z>
Nullable Charset charset, @Nullable HttpRequest request) {<z>
), statusText, headers, body, charset,<z>
request);<z>
(Charset charset) {<z>
) {<z>
return this;<z>
(value, charset, Type.URI);<z>
UriTemplateEncoder(charset);<z>
);<z>
null);<z>
, Type.USER_INFO) : null);<z>
: null);<z>
;<z>
;<z>
, fragmentTo, userInfoTo,<z>
, EncodeState.TEMPLATE_ENCODED, this.variableEncoder);<z>
protected ExecutorService initializeExecutor(<z>
{<z>
ScheduledExecutorService executor =<z>
.poolSize, threadFactory, rejectedExecutionHandler);<z>
(this.removeOnCancelPolicy) {<z>
ScheduledThreadPoolExecutor) {<z>
executor).setRemoveOnCancelPolicy(true);<z>
("Could not apply remove-on-cancel policy - not a ScheduledThreadPoolExecutor");<z>
(this.scheduledExecutorTasks)) {<z>
;<z>
.exposeUnconfigurableExecutor ?<z>
unconfigurableScheduledExecutorService(executor) : executor);<z>
return executor;<z>
(String missingField, BindingResult bindingResult) {<z>
.getNestedPath() + missingField;<z>
missingField);<z>
(), fixedField);<z>
,<z>
+ "' is required");<z>
;<z>
transport) {<z>
getRSocketStrategies();<z>
();<z>
rsocketStrategies);<z>
initConnector(<z>
metaMimeType, dataMimeType, rsocketStrategies);<z>
(rsocket -><z>
);<z>
{<z>
);<z>
(value == null) {<z>
;<z>
return BooleanTypedValue.forValue(!value);<z>
) {<z>
0).getStartPosition());<z>
;<z>
T createCollection(Class<?> collectionClass) {<z>
isInterface()) {<z>
newInstance();<z>
catch (Throwable ex) {<z>
new IllegalArgumentException(<z>
collectionClass.getName(), ex);<z>
else if (List.class == collectionClass) {<z>
T) new ArrayList();<z>
SortedSet.class == collectionClass) {<z>
TreeSet();<z>
T) new LinkedHashSet();<z>
> resolveArgument(<z>
BindingContext bindingContext, ServerWebExchange exchange) {<z>
.class);<z>
.required());<z>
?> paramType = parameter.getParameterType();<z>
(parameter, requestPart, isRequired, exchange);<z>
) {<z>
.class);<z>
(paramType)) {<z>
parameter.nested();<z>
{<z>
Object.class);<z>
partValues.next()<z>
isRequired))<z>
.emptyList());<z>
getAdapterRegistry().getAdapter(paramType);<z>
{<z>
next().flatMap(part -><z>
, isRequired));<z>
MethodParameter elementType = parameter.nested();<z>
())) {<z>
(partValues));<z>
));<z>
.fromPublisher(flux));<z>
getWriteMethodForActualAccess() {<z>
.writeMethod != null, "No write method available");<z>
this.ambiguousWriteMethods;<z>
ambiguousCandidates != null) {<z>
this.ambiguousWriteMethods = null;<z>
("Non-unique JavaBean property '" +<z>
) + "' being accessed! Ambiguous write methods found next to actually used [" +<z>
+ ambiguousCandidates);<z>
return this.writeMethod;<z>
UnsatisfiedDependencyException(<z>
@Nullable InjectionPoint injectionPoint, BeansException ex) {<z>
"");<z>
ex);<z>
void autowireByName(<z>
MutablePropertyValues pvs) {<z>
bw);<z>
(String propertyName : propertyNames) {<z>
{<z>
;<z>
);<z>
;<z>
)) {<z>
.trace("Added autowiring by name from bean name '" + beanName +<z>
"' to bean named '" + propertyName + "'");<z>
()) {<z>
+ beanName +<z>
);<z>
String pointcutBeanName, BeanDefinition pointcutDefinition, String expression) {<z>
, "Bean name must not be null");<z>
pointcutDefinition, "Pointcut definition must not be null");<z>
;<z>
.pointcutBeanName = pointcutBeanName;<z>
pointcutDefinition;<z>
+ "]>";<z>
) {<z>
.tokenStreamLength) {<z>
);<z>
);<z>
List<WebSocketExtension> getSupportedExtensions(ServerHttpRequest request) {<z>
;<z>
{<z>
).getServletRequest();<z>
servletRequest));<z>
= extensions;<z>
;<z>
> resolveResourceUrl(ServerWebExchange exchange, PathContainer lookupPath) {<z>
entrySet().stream()<z>
))<z>
, entry2) -><z>
()))<z>
map(entry -> {<z>
);<z>
.elements().size();<z>
, endIndex);<z>
= entry.getValue();<z>
();<z>
DefaultResourceResolverChain(resolvers);<z>
, handler.getLocations())<z>
resolvedPath);<z>
.orElseGet(() ->{<z>
{<z>
+ "\"");<z>
.empty();<z>
);<z>
{<z>
Object key = SimpleKeyGenerator.generateKey(id);<z>
key);<z>
valueWrapper != null) {<z>
new AssertionError("Value with key " + key + " expected to be already remove from cache");<z>
clear() throws DataAccessException {<z>
-> {<z>
);<z>
null;<z>
});<z>
ProducerCallback<T> action) throws JmsException {<z>
notNull(action, "Callback object must not be null");<z>
-> {<z>
Destination destination = resolveDestinationName(session, destinationName);<z>
producer = createProducer(session, destination);<z>
);<z>
(producer);<z>
false);<z>
protected void addSubscriptionInternal(<z>
message) {<z>
pathMatcher.isPattern(destination);<z>
getHeaders());<z>
(subscriptionId, destination, isPattern, expression);<z>
(sessionId, subscription);<z>
sessionId, subscription);<z>
(<z>
HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)<z>
{<z>
= lookupMultipartResolver(request);<z>
= request;<z>
{<z>
)) {<z>
;<z>
.resolveMultipart(processedRequest);<z>
) {<z>
"Not a multipart request");<z>
processedRequest, response);<z>
) {<z>
) processedRequest);<z>
protected void send(Object element) throws IOException {<z>
{<z>
= (ServerSentEvent<?>) element;<z>
adapt(event));<z>
);<z>
{<z>
, "LocaleContextResolver must not be null");<z>
= localeContextResolver;<z>
this;<z>
protected void resumePausedTasks() {<z>
this.lifecycleMonitor) {<z>
{<z>
;) {<z>
= it.next();<z>
doRescheduleTask(task);<z>
);<z>
) {<z>
"Resumed paused task: " + task);<z>
(RuntimeException ex) {<z>
(task, ex);<z>
filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw, boolean cache) {<z>
;<z>
(filtered == null) {<z>
= filterPropertyDescriptorsForDependencyCheck(bw);<z>
) {<z>
=<z>
.getWrappedClass(), filtered);<z>
{<z>
= existing;<z>
filtered;<z>
Class<E> type) {<z>
notNull(type, "Type must not be null");<z>
;<z>
]) getRequiredAttributeValue(attributeName, arrayType);<z>
{<z>
Runnable() {<z>
() {<z>
"Transport timed out"));<z>
) {<z>
()) {<z>
this + " after transport timeout", ex);<z>
void check(Object[] args) {<z>
{<z>
== null) {<z>
+ i);<z>
typesToMatch)<z>
{<z>
;<z>
= beanClassLoader;<z>
;<z>
(!ObjectUtils.isEmpty(typesToMatch)) {<z>
();<z>
{<z>
dynamicLoader = tempClassLoader;<z>
freshResolve = true;<z>
if (tempClassLoader instanceof DecoratingClassLoader dcl) {<z>
) {<z>
(typeToMatch.getName());<z>
getBeanClassName();<z>
{<z>
, mbd);<z>
(evaluated)) {<z>
) {<z>
return (Class<?>) evaluated;<z>
String) {<z>
String) evaluated;<z>
= true;<z>
throw new IllegalStateException("Invalid class name expression result: " + evaluated);<z>
freshResolve) {<z>
(dynamicLoader != null) {<z>
dynamicLoader.loadClass(className);<z>
ex) {<z>
{<z>
dynamicLoader + ": " + ex);<z>
;<z>
.resolveBeanClass(beanClassLoader);<z>
{<z>
.class);<z>
(annotation == null) {<z>
, ResponseStatus.class);<z>
annotation != null) {<z>
;<z>
messageSource != null ?<z>
, LocaleContextHolder.getLocale()) :<z>
reason);<z>
this.responseStatus = annotation.code();<z>
;<z>
, StringBuilder builder)<z>
{<z>
algorithm, inputStream);<z>
.append(hexDigest);<z>
, Type rhsType) {<z>
] lUpperBounds = lhsType.getUpperBounds();<z>
.length == 0) {<z>
};<z>
] lLowerBounds = lhsType.getLowerBounds();<z>
== 0) {<z>
Type[] { null };<z>
instanceof WildcardType rhsWcType) {<z>
rhsWcType.getUpperBounds();<z>
if (rUpperBounds.length == 0) {<z>
Object.class };<z>
getLowerBounds();<z>
length == 0) {<z>
] { null };<z>
: lUpperBounds) {<z>
(Type rBound : rUpperBounds) {<z>
, rBound)) {<z>
false;<z>
(Type rBound : rLowerBounds) {<z>
) {<z>
return false;<z>
for (Type lBound : lLowerBounds) {<z>
rBound : rUpperBounds) {<z>
rBound, lBound)) {<z>
;<z>
{<z>
) {<z>
return false;<z>
lBound : lUpperBounds) {<z>
rhsType)) {<z>
;<z>
lLowerBounds) {<z>
isAssignableBound(rhsType, lBound)) {<z>
false;<z>
return true;<z>
Object handler, Method method) {<z>
;<z>
instanceof String) {<z>
= getApplicationContext();<z>
;<z>
= (String) handler;<z>
);<z>
new HandlerMethod(handler, method);<z>
return handlerMethod;<z>
String getForwardedPrefix(ServerHttpRequest request) {<z>
();<z>
getFirst("X-Forwarded-Prefix");<z>
header == null) {<z>
;<z>
header.length());<z>
.tokenizeToStringArray(header, ",");<z>
rawPrefixes) {<z>
rawPrefix.length();<z>
- 1) == '/') {<z>
--;<z>
endIndex) : rawPrefix));<z>
prefix.toString();<z>
{<z>
().getFirst(name);<z>
-> {<z>
= getMessage(name);<z>
value, matcher);<z>
});<z>
this.responseSpec;<z>
public GroovyBeanDefinitionReader(BeanDefinitionRegistry registry) {<z>
;<z>
;<z>
(registry);<z>
(false);<z>
() {<z>
);<z>
);<z>
builders) {<z>
.build();<z>
(pathComponent != null) {<z>
);<z>
if (components.isEmpty()) {<z>
NULL_PATH_COMPONENT;<z>
size() == 1) {<z>
(0);<z>
components);<z>
BindParameterSource parameterSource) {<z>
expandedSql = expandedSql;<z>
= parameters;<z>
parameterSource;<z>
Object getProxy(@Nullable ClassLoader classLoader) {<z>
logger.isTraceEnabled()) {<z>
.getTargetSource());<z>
getTargetClass();<z>
, "Target class must be available for creating a CGLIB proxy");<z>
Class<?> proxySuperClass = rootClass;<z>
{<z>
();<z>
();<z>
> additionalInterface : additionalInterfaces) {<z>
additionalInterface);<z>
);<z>
();<z>
classLoader != null) {<z>
.setClassLoader(classLoader);<z>
SmartClassLoader &&<z>
{<z>
(false);<z>
);<z>
.advised));<z>
.INSTANCE);<z>
;<z>
[] callbacks = getCallbacks(rootClass);<z>
.length];<z>
) {<z>
.getClass();<z>
ProxyCallbackFilter(<z>
this.fixedInterceptorOffset));<z>
);<z>
callbacks);<z>
catch (CodeGenerationException | IllegalArgumentException ex) {<z>
advised.getTargetClass() +<z>
);<z>
(Throwable ex) {<z>
;<z>
{<z>
.isCompilable()) {<z>
()) {<z>
);<z>
;<z>
) {<z>
.newInstance();<z>
Throwable ex) {<z>
ex);<z>
()) {<z>
"SpEL: unable to compile " + expression.toStringAST());<z>
;<z>
Object right) {<z>
null) {<z>
return true;<z>
&& right instanceof Number) {<z>
;<z>
left instanceof Comparable && right instanceof Comparable) {<z>
.getClass());<z>
.class.isAssignableFrom(ancestor);<z>
;<z>
Throwable {<z>
) : null);<z>
targetClass, new CoroutinesInvocationCallback() {<z>
{<z>
;<z>
public Object getTarget() {<z>
getThis();<z>
) {<z>
);<z>
);<z>
(String pattern, String lookupPath) {<z>
pattern.equals(lookupPath)) {<z>
;<z>
) {<z>
-1) {<z>
this.fileExtensions) {<z>
pattern + extension, lookupPath)) {<z>
pattern + extension;<z>
1;<z>
pattern + ".*", lookupPath)) {<z>
return pattern + ".*";<z>
)) {<z>
pattern;<z>
if (this.useTrailingSlashMatch) {<z>
(pattern + "/", lookupPath)) {<z>
;<z>
return null;<z>
value, final boolean overwriteExisting) {<z>
.RESIZE) {<z>
entries) {<z>
!= null) {<z>
;<z>
(overwriteExisting) {<z>
;<z>
;<z>
null, "No entries segment");<z>
add(value);<z>
;<z>
);<z>
(Object other) {<z>
) {<z>
true;<z>
EmptyTargetSource otherTs)) {<z>
;<z>
isStatic == otherTs.isStatic);<z>
) {<z>
result = cache.get(classLoader);<z>
(result != null) {<z>
result;<z>
();<z>
> urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);<z>
while (urls.hasMoreElements()) {<z>
.nextElement();<z>
resource = new UrlResource(url);<z>
Properties properties = PropertiesLoaderUtils.loadProperties(resource);<z>
) {<z>
();<z>
[] factoryImplementationNames =<z>
);<z>
factoryImplementationNames) {<z>
)<z>
());<z>
.toList());<z>
, result);<z>
) {<z>
("Unable to load factories from location [" +<z>
FACTORIES_RESOURCE_LOCATION + "]", ex);<z>
result;<z>
) {<z>
ClassUtils.getQualifiedName(requiredType) +<z>
;<z>
beanName;<z>
= requiredType;<z>
.actualType = actualType;<z>
, Object value) {<z>
(identifier);<z>
null) {<z>
value);<z>
) {<z>
;<z>
iterator();<z>
);<z>
(iterator.hasNext()) {<z>
= iterator.next();<z>
if (valueToBind instanceof Object[]) {<z>
valueToBind;<z>
(Object object : objects) {<z>
markers, object);<z>
markers, valueToBind);<z>
BindMarker bindMarker : bindMarkers) {<z>
);<z>
public ChildBeanDefinition(<z>
, ConstructorArgumentValues cargs, MutablePropertyValues pvs) {<z>
super(cargs, pvs);<z>
;<z>
beanClassName);<z>
, String message) {<z>
!expression) {<z>
message);<z>
(HttpServletRequest request) {<z>
= getThemeResolver(request);<z>
getThemeSource(request);<z>
null) {<z>
= themeResolver.resolveThemeName(request);<z>
(themeName);<z>
return null;<z>
(CorsRegistry registry) {<z>
{<z>
registry);<z>
throws DataAccessException {<z>
;<z>
rowMapper = newRowMapper(params, context);<z>
rowMapper);<z>
handleMissingValue(String name, MethodParameter parameter) {<z>
().getSimpleName();<z>
= "Missing cookie '" + name + "' for method parameter of type " + type;<z>
parameter);<z>
boolean equals(@Nullable Object other) {<z>
(this == other) {<z>
;<z>
) {<z>
false;<z>
eventType) &&<z>
;<z>
Charset getCharset(@Nullable MediaType contentType) {<z>
null) {<z>
contentType.getCharset();<z>
;<z>
> getConsumableMediaTypes() {<z>
();<z>
for (ConsumeMediaTypeExpression expression : this.expressions) {<z>
()) {<z>
add(expression.getMediaType());<z>
return result;<z>
private void sendSystemSubscriptions() {<z>
;<z>
{<z>
);<z>
i++));<z>
accessor.setDestination(destination);<z>
()) {<z>
.debug("Subscribing to " + destination + " on \"system\" connection.");<z>
byte[]> conn = getTcpConnection();<z>
{<z>
;<z>
createMessage(EMPTY_PAYLOAD, headers)).addCallback(<z>
,<z>
ex -> {<z>
= "Failed to subscribe in \"system\" session.";<z>
);<z>
;<z>
request) throws Exception {<z>
HttpHeaders();<z>
if (ex instanceof HttpRequestMethodNotSupportedException) {<z>
HttpStatus.METHOD_NOT_ALLOWED;<z>
, request);<z>
) {<z>
.UNSUPPORTED_MEDIA_TYPE;<z>
request);<z>
(ex instanceof HttpMediaTypeNotAcceptableException) {<z>
HttpStatus.NOT_ACCEPTABLE;<z>
;<z>
else if (ex instanceof MissingPathVariableException) {<z>
= HttpStatus.INTERNAL_SERVER_ERROR;<z>
;<z>
if (ex instanceof MissingServletRequestParameterException) {<z>
BAD_REQUEST;<z>
headers, status, request);<z>
else if (ex instanceof ServletRequestBindingException) {<z>
= HttpStatus.BAD_REQUEST;<z>
headers, status, request);<z>
{<z>
status = HttpStatus.INTERNAL_SERVER_ERROR;<z>
headers, status, request);<z>
{<z>
BAD_REQUEST;<z>
, status, request);<z>
(ex instanceof HttpMessageNotReadableException) {<z>
;<z>
, request);<z>
) {<z>
.INTERNAL_SERVER_ERROR;<z>
;<z>
MethodArgumentNotValidException) {<z>
;<z>
status, request);<z>
instanceof MissingServletRequestPartException) {<z>
HttpStatus status = HttpStatus.BAD_REQUEST;<z>
request);<z>
if (ex instanceof BindException) {<z>
HttpStatus.BAD_REQUEST;<z>
, request);<z>
if (ex instanceof NoHandlerFoundException) {<z>
HttpStatus status = HttpStatus.NOT_FOUND;<z>
ex, headers, status, request);<z>
else if (ex instanceof AsyncRequestTimeoutException) {<z>
.SERVICE_UNAVAILABLE;<z>
request);<z>
;<z>
(Map<String, Object> source) {<z>
();<z>
null);<z>
return result;<z>
void parseConstructorArgElements(Element beanEle, BeanDefinition bd) {<z>
= beanEle.getChildNodes();<z>
i++) {<z>
Node node = nl.item(i);<z>
node, CONSTRUCTOR_ARG_ELEMENT)) {<z>
, bd);<z>
getEntityResolver() {<z>
null) {<z>
getResourceLoader();<z>
resourceLoader != null) {<z>
= new ResourceEntityResolver(resourceLoader);<z>
= new DelegatingEntityResolver(getBeanClassLoader());<z>
entityResolver;<z>
param, String beanName,<z>
) {<z>
param.getParameterType();<z>
isAssignableFrom(paramType)) {<z>
InjectionPoint injectionPoint = currentInjectionPoint.get();<z>
) {<z>
);<z>
return injectionPoint;<z>
beanFactory.resolveDependency(<z>
, autowiredBeanNames, typeConverter);<z>
NoUniqueBeanDefinitionException ex) {<z>
;<z>
NoSuchBeanDefinitionException ex) {<z>
{<z>
isArray()) {<z>
(paramType.getComponentType(), 0);<z>
) {<z>
, 0);<z>
isApproximableMapType(paramType)) {<z>
CollectionFactory.createMap(paramType, 0);<z>
throw ex;<z>
String, String> definition) {<z>
{<z>
entry : definition.entrySet()) {<z>
();<z>
();<z>
if (uri == null) {<z>
IllegalArgumentException("Namespace definition must supply a non-null URI");<z>
=<z>
(uri);<z>
null) {<z>
new BeanDefinitionParsingException(new Problem("No namespace handler found for URI: " + uri,<z>
);<z>
;<z>
> targetClass) {<z>
) {<z>
null;<z>
AopUtils.getMostSpecificMethod(method, targetClass);<z>
= findTransactionAttribute(specificMethod);<z>
if (txAttr != null) {<z>
;<z>
.getDeclaringClass());<z>
&& ClassUtils.isUserLevelMethod(method)) {<z>
txAttr;<z>
if (specificMethod != method) {<z>
);<z>
(txAttr != null) {<z>
return txAttr;<z>
getDeclaringClass());<z>
(method)) {<z>
return txAttr;<z>
;<z>
int expectedCount) throws Exception {<z>
, encoding, NodeList.class);<z>
this.expression, expectedCount,<z>
getLength() : 0));<z>
getAdvice() {<z>
= this.advice;<z>
) {<z>
return advice;<z>
this.adviceBeanName != null, "'adviceBeanName' must be specified");<z>
;<z>
beanFactory.isSingleton(this.adviceBeanName)) {<z>
adviceBeanName, Advice.class);<z>
this.advice = advice;<z>
;<z>
(this.adviceMonitor) {<z>
advice;<z>
(advice == null) {<z>
class);<z>
advice;<z>
return advice;<z>
void doRollback(DefaultTransactionStatus status) {<z>
;<z>
).getTransaction();<z>
"No Hibernate transaction");<z>
if (status.isDebug()) {<z>
+<z>
().getSession() + "]");<z>
hibTx.rollback();<z>
catch (org.hibernate.TransactionException ex) {<z>
);<z>
HibernateException ex) {<z>
(ex);<z>
PersistenceException ex) {<z>
() instanceof HibernateException) {<z>
HibernateException) ex.getCause());<z>
throw ex;<z>
hibernateManagedSession) {<z>
getSession().clear();<z>
task, boolean isRepeatingTask) {<z>
task, this.errorHandler, isRepeatingTask);<z>
) {<z>
, task.toString());<z>
result;<z>
) throws SQLException {<z>
new BeanWrapperImpl();<z>
;<z>
T mappedObject = constructMappedInstance(rs, bw);<z>
bw.setBeanInstance(mappedObject);<z>
getMetaData();<z>
;<z>
new HashSet<>() : null);<z>
; index <= columnCount; index++) {<z>
(rsmd, index);<z>
.delete(column, " "));<z>
.get(field) : null);<z>
pd != null) {<z>
rs, index, pd);<z>
&& logger.isDebugEnabled()) {<z>
+ pd.getName() +<z>
;<z>
pd.getName(), value);<z>
(TypeMismatchException ex) {<z>
{<z>
) {<z>
("Intercepted TypeMismatchException for row " + rowNumber +<z>
column + "' with null value when setting property '" +<z>
"' of type '" +<z>
.getPropertyType()) +<z>
;<z>
throw ex;<z>
{<z>
pd.getName());<z>
catch (NotWritablePropertyException ex) {<z>
(<z>
.getName() + "'", ex);<z>
logger.isDebugEnabled()) {<z>
column + "' mapped to field '" + field + "'");<z>
.equals(this.mappedProperties)) {<z>
new InvalidDataAccessApiUsageException("Given ResultSet does not contain all fields " +<z>
mappedProperties);<z>
return mappedObject;<z>
ConfigurableBeanFactory containingFactory) {<z>
(containingFactory);<z>
internalBeanFactory.copyConfigurationFrom(containingFactory);<z>
).removeIf(beanPostProcessor -><z>
);<z>
internalBeanFactory;<z>
void addViewControllers(ViewControllerRegistry registry) {<z>
{<z>
(registry);<z>
{<z>
(<z>
+ DEFAULT_ORM_XML_RESOURCE);<z>
)) {<z>
= ormXml.createRelative(PERSISTENCE_XML_FILENAME);<z>
)) {<z>
ormXml;<z>
) {<z>
return ormXml;<z>
;<z>
computeAttributesSize() {<z>
.addConstantUtf8(Constants.MODULE);<z>
size =<z>
.length;<z>
{<z>
;<z>
.length;<z>
0) {<z>
Constants.MODULE_MAIN_CLASS);<z>
8;<z>
;<z>
, MethodMetadata factoryMethodMetadata) {<z>
this(metadata);<z>
;<z>
(factoryMethodMetadata.getMethodName());<z>
factoryMethodMetadata;<z>
cancel() {<z>
;<z>
subscription;<z>
subscription != null) {<z>
cancel();<z>
> body) {<z>
(<z>
)),<z>
.asHttpHeaders(),<z>
));<z>
>>> result = applyStatusHandlers(response);<z>
.just(entity));<z>
Map<String, Object> model) {<z>
;<z>
model.keySet());<z>
(clazz, value) -> {<z>
contains(clazz) &&<z>
.class.getName()) &&<z>
.getName())) {<z>
);<z>
);<z>
.next() : result);<z>
... uriVariableValues) {<z>
this.uriComponents.expand(uriVariableValues);<z>
.encode();<z>
;<z>
RequestExpectation matchRequest(ClientHttpRequest request) throws IOException {<z>
.remainingExpectations.findExpectation(request);<z>
(expectation == null) {<z>
(request);<z>
update(expectation);<z>
expectation;<z>
, String> uriTemplateVariables) {<z>
(this.exactMatch) {<z>
;<z>
.pattern != null) {<z>
pattern.matcher(str);<z>
if (matcher.matches()) {<z>
uriTemplateVariables != null) {<z>
!= matcher.groupCount()) {<z>
"The number of capturing groups in the pattern segment " +<z>
+<z>
);<z>
{<z>
;<z>
name.startsWith("*")) {<z>
name + ") are not " +<z>
"supported by the AntPathMatcher. Use the PathPatternParser instead.");<z>
);<z>
name, value);<z>
;<z>
;<z>
) {<z>
this.postProcessingLock) {<z>
!= null &&<z>
.externallyManagedConfigMembers.contains(configMember));<z>
T> void registerMetadata(<z>
Map<String, Object>> mapper) {<z>
decoder : this.decoders) {<z>
canDecode(targetType, mimeType)) {<z>
toString(),<z>
targetType, mapper));<z>
;<z>
Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement,<z>
{<z>
, annotationType, null);<z>
operations, Method method,<z>
{<z>
());<z>
op : operations) {<z>
);<z>
determineSyncFlag(method);<z>
{<z>
(ModelAttribute.class);<z>
ann.value() : null);<z>
;<z>
(Resource resource) {<z>
.getInputStream());<z>
);<z>
) {<z>
resource, ex);<z>
@Nullable Annotation[] annotations) {<z>
= resolvableType;<z>
);<z>
;<z>
requiredType) {<z>
= webRequest.getNativeResponse(requiredType);<z>
== null) {<z>
(<z>
;<z>
return nativeResponse;<z>
(ParserContext context, @Nullable Object source) {<z>
containsBeanDefinition(SIMPLE_CONTROLLER_HANDLER_ADAPTER_BEAN_NAME)) {<z>
(SimpleControllerHandlerAdapter.class);<z>
);<z>
beanDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
);<z>
SIMPLE_CONTROLLER_HANDLER_ADAPTER_BEAN_NAME));<z>
XMLEventReader getXMLEventReader(Source source) {<z>
StAXSource) {<z>
).getXMLEventReader();<z>
instanceof StaxSource) {<z>
();<z>
("Source '" + source + "' is neither StaxSource nor StAXSource");<z>
{<z>
(logger.isTraceEnabled()) {<z>
+ this);<z>
, future);<z>
(connectCallback);<z>
addCallback(connectCallback);<z>
{<z>
response);<z>
Response)<z>
COYOTE_RESPONSE_FIELD, responseFacade);<z>
;<z>
();<z>
;<z>
);<z>
(ConnectionFactory connectionFactory) {<z>
.forCurrentTransaction()<z>
isSynchronizationActive)<z>
(synchronizationManager -> {<z>
);<z>
() || conHolder.isSynchronizedWithTransaction());<z>
synchronizationManager -> connectionFactory);<z>
public void cleanup() {<z>
.xmlObject != null) {<z>
.xmlObject.free();<z>
catch (SQLException ex) {<z>
);<z>
varName) {<z>
) {<z>
.parameterNameBindings[i])) {<z>
true;<z>
;<z>
{<z>
= super.getRawStatusCode();<z>
!= null) {<z>
;<z>
String alias, @Nullable Object source) {<z>
"Bean name must not be null");<z>
.notNull(alias, "Alias must not be null");<z>
this.beanName = beanName;<z>
alias;<z>
.source = source;<z>
{<z>
;<z>
);<z>
DelegatingIntroductionInterceptor(endpoint);<z>
introduction.suppressInterface(MethodInterceptor.class);<z>
.addAdvice(introduction);<z>
;<z>
{<z>
closing = true;<z>
;<z>
)) {<z>
debug(error);<z>
;<z>
IllegalStateException(error));<z>
isFile() {<z>
url = getURL();<z>
ResourceUtils.URL_PROTOCOL_VFS)) {<z>
;<z>
equals(url.getProtocol());<z>
{<z>
false;<z>
(@Nullable byte[] bytes) {<z>
(bytes == null) {<z>
null;<z>
new ByteArrayInputStream(bytes))) {<z>
readObject();<z>
) {<z>
ex);<z>
ClassNotFoundException ex) {<z>
("Failed to deserialize object type", ex);<z>
method) {<z>
ParameterNameDiscoverer pnd : this.parameterNameDiscoverers) {<z>
pnd.getParameterNames(method);<z>
) {<z>
;<z>
;<z>
IOException, ClassNotFoundException {<z>
;<z>
ConcurrentHashMap<>(32);<z>
, HttpHeaders headers,<z>
entity, Type entityType) {<z>
, entity, entityType);<z>
, final Edge nextEdge) {<z>
;<z>
= successor;<z>
this.nextEdge = nextEdge;<z>
sourceType, TypeDescriptor targetType) {<z>
(source == null) {<z>
;<z>
);<z>
(targetElementType != null, "No target element type");<z>
;<z>
, targetElementType);<z>
);<z>
target;<z>
, Object value) {<z>
(paramName, "Parameter name must not be null");<z>
"Value must not be null");<z>
.getClass()));<z>
this;<z>
CacheOperationInvocationContext<CacheRemoveOperation> context) {<z>
generateKey(context);<z>
context);<z>
.isTraceEnabled()) {<z>
+<z>
());<z>
;<z>
> getWriteHints(ResolvableType streamType, ResolvableType elementType,<z>
) {<z>
.encoder instanceof HttpMessageEncoder) {<z>
(HttpMessageEncoder<?>) this.encoder;<z>
, request, response);<z>
);<z>
attributeExists(String... names) {<z>
-> {<z>
mav = getModelAndView(result);<z>
String name : names) {<z>
(name));<z>
, final StompHeaderAccessor accessor) {<z>
]> conn = this.tcpConnection;<z>
!this.isStompConnected || conn == null) {<z>
) {<z>
{<z>
"TCP connection closed already, ignoring " +<z>
)));<z>
EMPTY_TASK;<z>
("Cannot forward messages " +<z>
!= null ? "before STOMP CONNECTED. " : "while inactive. ") +<z>
;<z>
.clientSendMessageCount != null) {<z>
clientSendMessageCount.incrementAndGet();<z>
) && accessor.isModified()) ?<z>
) : message;<z>
command = accessor.getCommand();<z>
SUBSCRIBE.equals(command) ||<z>
{<z>
.getPayload()));<z>
{<z>
);<z>
byte[]>) messageToSend);<z>
) {<z>
public void onSuccess(@Nullable Void result) {<z>
) {<z>
;<z>
public void onFailure(Throwable ex) {<z>
{<z>
+<z>
);<z>
) {<z>
(message.getPayload()));<z>
);<z>
return future;<z>
@Nullable Object... paramValues) {<z>
!= null) {<z>
cleanupParameters(Arrays.asList(paramValues));<z>
(String attributeName, boolean enabled) {<z>
if (!enabled) {<z>
.add(attributeName);<z>
remove(attributeName);<z>
) {<z>
) {<z>
pw);<z>
{<z>
this.relatedCauses) {<z>
;<z>
pw);<z>
String message, String statusText,<z>
, @Nullable Charset charset) {<z>
);<z>
afterPropertiesSet() {<z>
(isSingleton()) {<z>
= createMap();<z>
String headerName) {<z>
equals(headerName)) {<z>
CONTENT_TYPE_PROPERTY;<z>
.fromHeaderName(headerName);<z>
scheduleNewInvokerIfAppropriate() {<z>
isRunning()) {<z>
);<z>
synchronized (this.lifecycleMonitor) {<z>
this.maxConcurrentConsumers &&<z>
getIdleInvokerCount() < this.idleConsumerLimit) {<z>
;<z>
(logger.isDebugEnabled()) {<z>
size());<z>
public ReactorServerHttpResponse(HttpServerResponse response, DataBufferFactory bufferFactory) {<z>
(response.responseHeaders())));<z>
;<z>
response = response;<z>
{<z>
HASH)) {<z>
return false;<z>
= takeToken();<z>
functionOrVariableName = eatToken(TokenKind.IDENTIFIER);<z>
] args = maybeEatMethodArgs();<z>
(args == null) {<z>
),<z>
));<z>
return true;<z>
,<z>
functionOrVariableName.endPos, args));<z>
return true;<z>
match) {<z>
(logger.isTraceEnabled()) {<z>
.format("%s \"%s\" %s against value \"%s\"",<z>
actual));<z>
IllegalStateException {<z>
= requestContext;<z>
path = path;<z>
;<z>
String beanName;<z>
int dotPos = path.indexOf('.');<z>
) {<z>
= path;<z>
expression = null;<z>
0, dotPos);<z>
dotPos + 1);<z>
beanName, false);<z>
.errors != null) {<z>
if (this.expression != null) {<z>
this.expression)) {<z>
.errors.getAllErrors();<z>
{<z>
.errors.getFieldErrors(this.expression);<z>
);<z>
.errors.getFieldValue(this.expression);<z>
.expression);<z>
) {<z>
;<z>
expression);<z>
null);<z>
.value;<z>
();<z>
.errorCodes = initErrorCodes(this.objectErrors);<z>
= requestContext.getModelObject(beanName);<z>
if (target == null) {<z>
IllegalStateException(<z>
+ "' available as request attribute");<z>
endsWith("*")) {<z>
target);<z>
bw.getPropertyValue(this.expression);<z>
.getPropertyType(this.expression);<z>
.value;<z>
[0];<z>
];<z>
{<z>
value);<z>
() throws SAXException {<z>
{<z>
= this.reader.getLocation();<z>
());<z>
() != null) {<z>
();<z>
Annotation> MergedAnnotation<T>[] getAnnotationArray(<z>
) throws NoSuchElementException {<z>
throw new NoSuchElementException(<z>
"Unable to get attribute value for missing annotation");<z>
ObjectOutputStream oos) throws IOException {<z>
();<z>
());<z>
writeObject(getTransactionManager());<z>
oos.writeObject(getTransactionAttributeSource());<z>
;<z>
> getConsumableMediaTypes() {<z>
hasMethodsMatch).<z>
).stream()).<z>
new));<z>
, @Nullable LockMode lockMode) throws DataAccessException {<z>
-> {<z>
(session);<z>
) {<z>
(lockMode)).lock(entity);<z>
(entity);<z>
return null;<z>
});<z>
@Nullable MediaType mediaType) {<z>
{<z>
return true;<z>
supportedMediaType : getSupportedMediaTypes()) {<z>
(mediaType)) {<z>
true;<z>
;<z>
String, String> params) {<z>
((name, values) -> {<z>
(String value : values) {<z>
(name, value);<z>
;<z>
;<z>
encode(Charset charset) {<z>
encodeTemplate = true;<z>
= charset;<z>
return this;<z>
static void clearSynchronization() throws IllegalStateException {<z>
if (!isSynchronizationActive()) {<z>
new IllegalStateException("Cannot deactivate transaction synchronization - not active");<z>
remove();<z>
{<z>
BeanDefinition beanDefinition;<z>
{<z>
.getBeanDefinition(SCRIPT_FACTORY_POST_PROCESSOR_BEAN_NAME);<z>
;<z>
registerBeanDefinition(SCRIPT_FACTORY_POST_PROCESSOR_BEAN_NAME, beanDefinition);<z>
beanDefinition;<z>
(T temporal, int goal) {<z>
;<z>
.range(this.field);<z>
{<z>
{<z>
with(this.field, goal));<z>
) - current + 1;<z>
, amount);<z>
();<z>
).addTo(temporal, amount);<z>
public EntityManagerFactory getNativeEntityManagerFactory() {<z>
) {<z>
return this.nativeEntityManagerFactory;<z>
, "No native EntityManagerFactory available");<z>
get();<z>
{<z>
().interrupt();<z>
"Interrupted during initialization of native EntityManagerFactory", ex);<z>
(ExecutionException ex) {<z>
= ex.getCause();<z>
) {<z>
persistenceException;<z>
throw new IllegalStateException("Failed to asynchronously initialize native EntityManagerFactory: " +<z>
;<z>
, HttpOutputMessage outputMessage) throws IOException {<z>
"ResourceRegion must not be null");<z>
;<z>
getPosition();<z>
) - 1;<z>
.getResource().contentLength();<z>
);<z>
long rangeLength = end - start + 1;<z>
end + '/' + resourceLength);<z>
setContentLength(rangeLength);<z>
).getInputStream();<z>
(), start, end);<z>
close();<z>
catch (IOException ex) {<z>
{<z>
return new AbstractJsonPathRequestMatcher() {<z>
ParseException {<z>
expectedValue);<z>
{<z>
)) {<z>
true;<z>
String prefix = getAdvisorBeanNamePrefix();<z>
(prefix));<z>
deferredResult) {<z>
>= 0; i--) {<z>
i).afterCompletion(request, deferredResult);<z>
(Throwable ex) {<z>
, ex);<z>
status) {<z>
HibernateTransactionObject) status.getTransaction();<z>
;<z>
;<z>
.isDebug()) {<z>
logger.debug("Committing Hibernate transaction on Session [" +<z>
+ "]");<z>
);<z>
) {<z>
("Could not commit Hibernate transaction", ex);<z>
) {<z>
convertHibernateAccessException(ex);<z>
ex) {<z>
ex.getCause() instanceof HibernateException) {<z>
) ex.getCause());<z>
throw ex;<z>
Principal principal) {<z>
(principal, "'principal' must not be null");<z>
principal;<z>
this;<z>
String> headers) {<z>
[]> decodedMessage = null;<z>
byteBuffer);<z>
.mark();<z>
(byteBuffer);<z>
.length() > 0) {<z>
StompHeaderAccessor headerAccessor = null;<z>
byte[] payload = null;<z>
.remaining() > 0) {<z>
);<z>
stompCommand);<z>
;<z>
readHeaders(byteBuffer, headerAccessor, stompCommand);<z>
);<z>
) {<z>
0) {<z>
StompCommand stompCommand = headerAccessor.getCommand();<z>
!stompCommand.isBodyAllowed()) {<z>
+<z>
+ ", headers=" + headers);<z>
headerAccessor.updateSimpMessageHeadersFromStompHeaders();<z>
;<z>
(payload, headerAccessor.getMessageHeaders());<z>
.isTraceEnabled()) {<z>
;<z>
;<z>
null) {<z>
String name = NativeMessageHeaderAccessor.NATIVE_HEADERS;<z>
@SuppressWarnings("unchecked")<z>
String>) headerAccessor.getHeader(name);<z>
) {<z>
(map);<z>
.reset();<z>
= StompHeaderAccessor.createForHeartbeat();<z>
headerAccessor);<z>
);<z>
));<z>
(logger.isTraceEnabled()) {<z>
);<z>
;<z>
Nullable ConfigurableBeanFactory factory,<z>
registry) {<z>
);<z>
(HttpServletRequest request, HttpServletResponse response) throws Exception {<z>
;<z>
;<z>
multipartRequestParsed = false;<z>
(request);<z>
mv = null;<z>
= null;<z>
);<z>
multipartRequestParsed = (processedRequest != request);<z>
mappedHandler = getHandler(processedRequest);<z>
{<z>
);<z>
));<z>
method = request.getMethod();<z>
method);<z>
HttpMethod.HEAD.matches(method)) {<z>
;<z>
&& isGet) {<z>
, response)) {<z>
());<z>
(asyncManager.isConcurrentHandlingStarted()) {<z>
);<z>
processedRequest, response, mv);<z>
(Exception ex) {<z>
ex;<z>
) {<z>
err);<z>
, mappedHandler, mv, dispatchException);<z>
{<z>
, response, mappedHandler, ex);<z>
(Throwable err) {<z>
, response, mappedHandler,<z>
);<z>
asyncManager.isConcurrentHandlingStarted()) {<z>
mappedHandler != null) {<z>
);<z>
if (multipartRequestParsed) {<z>
cleanupMultipart(processedRequest);<z>
{<z>
== null) {<z>
return new ArrayList<>();<z>
types.length);<z>
type : types) {<z>
add(new SqlParameter(type));<z>
;<z>
() {<z>
shouldReleaseBeforeCompletion()) {<z>
;<z>
resource, String script,<z>
,<z>
String blockCommentEndDelimiter) throws ScriptException {<z>
inSingleQuote = false;<z>
= false;<z>
false;<z>
++) {<z>
i);<z>
) {<z>
;<z>
(c == '\\') {<z>
;<z>
&& (c == '\'')) {<z>
inSingleQuote;<z>
!inSingleQuote && (c == '"')) {<z>
;<z>
{<z>
) {<z>
true;<z>
) {<z>
('\n', i);<z>
indexOfNextNewline > i) {<z>
i = indexOfNextNewline;<z>
, i)) {<z>
);<z>
if (indexOfCommentEnd > i) {<z>
indexOfCommentEnd + blockCommentEndDelimiter.length() - 1;<z>
new ScriptParseException(<z>
resource);<z>
return false;<z>
String viewName) throws Exception {<z>
buildView(viewName);<z>
) {<z>
setSourceKey(this.sourceKey);<z>
!= null) {<z>
.uriResolver);<z>
this.errorListener != null) {<z>
errorListener);<z>
(this.indent);<z>
{<z>
(this.outputProperties);<z>
.setCacheTemplates(this.cacheTemplates);<z>
return view;<z>
SearchStrategy searchStrategy,<z>
annotationFilter) {<z>
element;<z>
element = element;<z>
.searchStrategy = searchStrategy;<z>
.annotations = null;<z>
this.repeatableContainers = repeatableContainers;<z>
annotationFilter = annotationFilter;<z>
typeName)<z>
throws SQLException {<z>
sqlType, typeName);<z>
== TYPE_UNKNOWN) {<z>
setObject(paramIndex, value);<z>
.setObject(paramIndex, value, sqlType);<z>
ResponseSpec valueEqualsDate(String headerName, long value) {<z>
.exchangeResult.assertWithDiagnostics(() -> {<z>
= getHeaders().getFirst(headerName);<z>
headerValue);<z>
headers = new HttpHeaders();<z>
"expected", value);<z>
("actual", headerValue);<z>
"Response header '" + headerName + "'='" + headerValue + "' " +<z>
getFirst("expected") + "'",<z>
("actual"));<z>
;<z>
.responseSpec;<z>
index, boolean isValueAttribute,<z>
{<z>
{<z>
true;<z>
= this.annotationValueSource[index].distance;<z>
mapping.distance;<z>
<? extends Message> clazz, HttpInputMessage inputMessage)<z>
, HttpMessageNotReadableException {<z>
getContentType();<z>
== null) {<z>
;<z>
.getCharset();<z>
== null) {<z>
DEFAULT_CHARSET;<z>
(clazz);<z>
) {<z>
.extensionRegistry);<z>
(TEXT_PLAIN.isCompatibleWith(contentType)) {<z>
, charset);<z>
(reader, this.extensionRegistry, builder);<z>
.protobufFormatSupport != null) {<z>
merge(<z>
, this.extensionRegistry, builder);<z>
return builder.build();<z>
, SpelMessage message, Object... inserts) {<z>
inserts), cause);<z>
message;<z>
this.inserts = inserts;<z>
public static Series resolve(int statusCode) {<z>
;<z>
) {<z>
if (series.value == seriesCode) {<z>
return series;<z>
null;<z>
protected WebDataBinder createBinderInstance(<z>
{<z>
);<z>
?> defaultUriVariables) {<z>
.defaultUriVariables.clear();<z>
if (defaultUriVariables != null) {<z>
this.defaultUriVariables.putAll(defaultUriVariables);<z>
) {<z>
FastClass.Generator();<z>
);<z>
setContextClass(type);<z>
ci.c2.getClassLoader());<z>
ci.namingPolicy);<z>
;<z>
);<z>
g.create();<z>
, int repeat) {<z>
this.next = next;<z>
.testMethod = testMethod;<z>
(1, repeat);<z>
(Method method, @Nullable EventListener ann) {<z>
getParameterCount();<z>
if (count > 1) {<z>
throw new IllegalStateException(<z>
);<z>
ann != null) {<z>
ann.classes();<z>
.length > 0) {<z>
length);<z>
Class<?> eventType : classes) {<z>
(ResolvableType.forClass(eventType));<z>
types;<z>
{<z>
(<z>
+ method);<z>
.forMethodParameter(method, 0));<z>
, @Nullable MimeType mimeType) {<z>
();<z>
class) ||<z>
;<z>
.Builder configureClient() {<z>
.build();<z>
new MockMvcHttpConnector(mockMvc);<z>
;<z>
(String pattern, @Nullable PathPatternParser parser) {<z>
defaultInstance).parse(pattern);<z>
PatternParseException ex) {<z>
;<z>
) {<z>
em != null) {<z>
if (em.isOpen()) {<z>
em.close();<z>
ex) {<z>
logger.error("Failed to release JPA EntityManager", ex);<z>
@Nullable Method method) {<z>
method == null) {<z>
false;<z>
(method.getParameterCount() != 1) {<z>
;<z>
"equals")) {<z>
;<z>
class;<z>
matchName(HttpServletRequest request) {<z>
for (String current : this.namesToMatch) {<z>
) != null) {<z>
return true;<z>
);<z>
Nullable ClassLoader compilerClassLoader,<z>
int maximumAutoGrowSize) {<z>
? compilerMode : defaultCompilerMode);<z>
;<z>
.autoGrowNullReferences = autoGrowNullReferences;<z>
;<z>
.maximumAutoGrowSize = maximumAutoGrowSize;<z>
resourceUrlPath,<z>
ResourceResolverChain chain) {<z>
locations);<z>
StringUtils.hasText(baseUrl)) {<z>
);<z>
if (versionStrategy == null) {<z>
baseUrl;<z>
, locations);<z>
resource != null, "Unresolvable resource");<z>
String version = versionStrategy.getResourceVersion(resource);<z>
versionStrategy.addVersion(baseUrl, version);<z>
return baseUrl;<z>
systemId) throws IOException {<z>
logger.isTraceEnabled()) {<z>
+<z>
);<z>
{<z>
lastIndexOf('/');<z>
lastPathSeparator);<z>
dtdNameStart != -1) {<z>
DTD_NAME + DTD_EXTENSION;<z>
.isTraceEnabled()) {<z>
"Trying to locate [" + dtdFile + "] in Spring jar on classpath");<z>
));<z>
getInputStream());<z>
.setPublicId(publicId);<z>
(systemId);<z>
) {<z>
+ systemId + "] in classpath: " + dtdFile);<z>
;<z>
) {<z>
isDebugEnabled()) {<z>
"Could not resolve beans DTD [" + systemId + "]: not found in classpath", ex);<z>
return null;<z>
private static SubProtocolWebSocketHandler unwrapSubProtocolWebSocketHandler(WebSocketHandler handler) {<z>
(handler);<z>
{<z>
IllegalArgumentException("No SubProtocolWebSocketHandler in " + handler);<z>
(SubProtocolWebSocketHandler) actual;<z>
ManagedAttribute sma) {<z>
)));<z>
.getDefaultValue());<z>
setField(FIELD_DEFAULT, defaultValue);<z>
);<z>
{<z>
(FIELD_PERSIST_POLICY, persistPolicy);<z>
;<z>
persistPeriod >= 0) {<z>
FIELD_PERSIST_PERIOD, Integer.toString(persistPeriod));<z>
,<z>
) {<z>
newByteArray = (byte[]) newArray;<z>
++) {<z>
);<z>
toByte(typeConverter, typedValue);<z>
throws MessagingException {<z>
, "Cc address array must not be null");<z>
.length];<z>
; i++) {<z>
;<z>
);<z>
(Object bean, String beanName) throws BeansException {<z>
{<z>
;<z>
beanType, String qualifier) {<z>
, beanType);<z>
= null;<z>
) {<z>
qualifier::equals, beanName, bf)) {<z>
(matchingBean != null) {<z>
beanName);<z>
= beanName;<z>
matchingBean != null) {<z>
return bf.getBean(matchingBean, beanType);<z>
bf.containsBean(qualifier)) {<z>
;<z>
qualifier, "No matching " + beanType.getSimpleName() +<z>
+ "' - neither qualifier match nor bean name match!");<z>
ObjectRetrievalFailureException(<z>
String msg, @Nullable Throwable cause) {<z>
super(msg, cause);<z>
;<z>
identifier = identifier;<z>
private void handleFrame() {<z>
SockJsFrame.CHARSET);<z>
outputStream.reset();<z>
()) {<z>
;<z>
content)) {<z>
content);<z>
{<z>
.getAccessor(message, SimpMessageHeaderAccessor.class);<z>
, "Expected mutable SimpMessageHeaderAccessor");<z>
, task);<z>
{<z>
);<z>
) {<z>
instanceof ConditionalConverter,<z>
;<z>
;<z>
: convertibleTypes) {<z>
add(converter);<z>
IntPredicate predicate, int fromIndex) {<z>
notNull(predicate, "IntPredicate must not be null");<z>
this.writePosition - 1);<z>
; i >= 0; i--) {<z>
= this.byteBuffer.get(i);<z>
(predicate.test(b)) {<z>
return i;<z>
return -1;<z>
throws IOException {<z>
Assert.notNull(in, "No input String specified");<z>
.notNull(out, "No Writer specified");<z>
out.write(in);<z>
out);<z>
() {<z>
;<z>
if (this.currentInterval >= maxInterval) {<z>
return maxInterval;<z>
< 0) {<z>
;<z>
initialInterval, maxInterval);<z>
multiplyInterval(maxInterval);<z>
return this.currentInterval;<z>
BackOffExecution execution) {<z>
recovering && this.interrupted) {<z>
;<z>
long interval = execution.nextBackOff();<z>
{<z>
;<z>
{<z>
);<z>
(InterruptedException interEx) {<z>
currentThread().interrupt();<z>
) {<z>
true;<z>
true;<z>
createXmlReader() throws SAXException, ParserConfigurationException {<z>
newInstance();<z>
;<z>
());<z>
isProcessExternalEntities());<z>
();<z>
();<z>
)) {<z>
);<z>
xmlReader;<z>
createRequest(HttpServletRequest request, AsyncContext context)<z>
URISyntaxException {<z>
(getServletPath(), "Servlet path is not initialized");<z>
new JettyServerHttpRequest(<z>
;<z>
Void> upgrade(ServerWebExchange exchange, WebSocketHandler handler,<z>
) {<z>
ServerHttpResponse response = exchange.getResponse();<z>
ServerHttpResponseDecorator.getNativeResponse(response);<z>
HandshakeInfo handshakeInfo = handshakeInfoFactory.get();<z>
.bufferFactory();<z>
exchange.getRequest().getURI();<z>
response.setComplete()<z>
) -> {<z>
= buildSpec(subProtocol);<z>
in, out) -> {<z>
session =<z>
ReactorNettyWebSocketSession(<z>
;<z>
.checkpoint(uri + " [ReactorNettyRequestUpgradeStrategy]");<z>
spec);<z>
}));<z>
(String name) {<z>
.currentAttributes();<z>
.getSessionMutex()) {<z>
value = simpAttributes.getAttribute(name);<z>
if (value != null) {<z>
.removeAttribute(name);<z>
;<z>
;<z>
{<z>
)) {<z>
;<z>
.clientSendMessageTimestamp = now;<z>
{<z>
).putAll(headers);<z>
));<z>
;<z>
new BufferingClientHttpResponseWrapper(response);<z>
Class<?> clazz) {<z>
clazz.getSuperclass() == null) {<z>
;<z>
+ MBEAN_SUFFIX;<z>
;<z>
implementedInterfaces) {<z>
getName().equals(mbeanInterfaceName)) {<z>
;<z>
));<z>
read() throws IOException {<z>
);<z>
(pooledByteBuffer) {<z>
;<z>
read(byteBuffer);<z>
rsReadLogger.isTraceEnabled()) {<z>
1 ? " bytes" : ""));<z>
if (read > 0) {<z>
);<z>
read);<z>
write(byteBuffer);<z>
return dataBuffer;<z>
if (read == -1) {<z>
);<z>
return null;<z>
, Destination destination, Message response) throws JMSException {<z>
session.createProducer(destination);<z>
, response);<z>
settings = getResponseQosSettings();<z>
if (settings != null) {<z>
), settings.getPriority(),<z>
;<z>
producer.send(response);<z>
JmsUtils.closeMessageProducer(producer);<z>
,<z>
Nullable Object transaction) throws TransactionException {<z>
(synchronizationManager.isSynchronizationActive()) {<z>
doSuspendSynchronization(synchronizationManager);<z>
-> {<z>
>> suspendedResources = (transaction != null ?<z>
(Optional.empty()) :<z>
(Optional.empty()));<z>
{<z>
getCurrentTransactionName();<z>
;<z>
();<z>
(false);<z>
;<z>
);<z>
= synchronizationManager.isActualTransactionActive();<z>
setActualTransactionActive(false);<z>
return new SuspendedResourcesHolder(<z>
, name, readOnly, isolationLevel, wasActive);<z>
(ErrorPredicates.RUNTIME_OR_ERROR,<z>
synchronizationManager, synchronizations)<z>
(SuspendedResourcesHolder.class));<z>
});<z>
(transaction != null) {<z>
> suspendedResources =<z>
);<z>
.orElse(null)));<z>
);<z>
Resource createRelative(String relativePath) {<z>
);<z>
) :<z>
getFileSystem(), pathToUse));<z>
) {<z>
for (WebSocketMessageBrokerConfigurer configurer : this.configurers) {<z>
;<z>
) {<z>
Type type) {<z>
Constants.TYPE_CLASS)) {<z>
Constants.TYPE_CLASS, GET_NAME);<z>
<? super String> matcher) {<z>
-> {<z>
name);<z>
matcher);<z>
isFactoryBean(String beanName, RootBeanDefinition mbd) {<z>
Boolean result = mbd.isFactoryBean;<z>
== null) {<z>
, FactoryBean.class);<z>
isAssignableFrom(beanType));<z>
= result;<z>
return result;<z>
afterSendCompletion(<z>
, @Nullable Exception ex) {<z>
if (!sent) {<z>
.getMessageType(message.getHeaders());<z>
messageType)) {<z>
);<z>
handleMessage(message);<z>
() {<z>
.cookies == null) {<z>
= new LinkedMultiValueMap<>(3);<z>
this.cookies;<z>
public Object invoke(MethodInvocation invocation) throws Throwable {<z>
invocation.getMethod())) {<z>
proceed();<z>
groups = determineValidationGroups(invocation);<z>
.forExecutables();<z>
();<z>
>> result;<z>
getThis();<z>
!= null, "Target must not be null");<z>
;<z>
catch (IllegalArgumentException ex) {<z>
methodToValidate = BridgeMethodResolver.findBridgedMethod(<z>
));<z>
groups);<z>
{<z>
);<z>
returnValue = invocation.proceed();<z>
, groups);<z>
.isEmpty()) {<z>
ConstraintViolationException(result);<z>
;<z>
equals(@Nullable Object other) {<z>
other) {<z>
return true;<z>
)) {<z>
false;<z>
overrides);<z>
(<z>
) {<z>
= asyncContext;<z>
completionFlag = completionFlag;<z>
logPrefix;<z>
throws Exception {<z>
)) {<z>
) == 1) {<z>
get(0);<z>
instanceof Error error) {<z>
error;<z>
(exception instanceof Exception ex) {<z>
throw ex;<z>
new AssertionError(exception.getMessage());<z>
);<z>
assertionError;<z>
StringBuilder message = new StringBuilder();<z>
).append("):");<z>
exception : this.exceptions) {<z>
'\n');<z>
);<z>
AssertionError(message);<z>
::addSuppressed);<z>
;<z>
) {<z>
class);<z>
getCommand())) {<z>
.getDestination();<z>
== null) {<z>
) {<z>
.debug("Got message on \"system\" connection, with no destination: " +<z>
)));<z>
{<z>
)) {<z>
debug("Got message on \"system\" connection with no handler: " +<z>
message.getPayload()));<z>
(destination);<z>
;<z>
catch (Throwable ex) {<z>
{<z>
("Error while handling message on \"system\" connection.", ex);<z>
objectIdGeneratorInstance(MapperConfig<?> config,<z>
<?> implClass) {<z>
.beanFactory.createBean(implClass);<z>
requiredType, PropertyEditor editor) {<z>
(registry instanceof PropertyEditorRegistrySupport) {<z>
overrideDefaultEditor(requiredType, editor);<z>
, editor);<z>
{<z>
WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE);<z>
(requestUri == null) {<z>
getRequestURI();<z>
servlet4Present) {<z>
(request);<z>
StringUtils.hasText(servletPathPrefix)) {<z>
);<z>
.getContextPath());<z>
() {<z>
!this.store.isEmpty();<z>
this.store.clear();<z>
notEmpty;<z>
String name) {<z>
;<z>
{<z>
(name);<z>
new IllegalArgumentException("No path variable with name \"" + name + "\" available");<z>
Object handler) {<z>
{<z>
mappedHandlers.contains(handler)) {<z>
true;<z>
null) {<z>
{<z>
)) {<z>
;<z>
return !hasHandlerMappings();<z>
, @Nullable Class<?> editable,<z>
String... ignoreProperties) throws BeansException {<z>
(source, "Source must not be null");<z>
.notNull(target, "Target must not be null");<z>
);<z>
editable != null) {<z>
(target)) {<z>
target.getClass().getName() +<z>
;<z>
;<z>
;<z>
: null);<z>
{<z>
writeMethod = targetPd.getWriteMethod();<z>
()))) {<z>
(), targetPd.getName());<z>
sourcePd != null) {<z>
);<z>
!= null) {<z>
= ResolvableType.forMethodReturnType(readMethod);<z>
;<z>
isAssignable =<z>
hasUnresolvableGenerics() || targetResolvableType.hasUnresolvableGenerics() ?<z>
()) :<z>
.isAssignableFrom(sourceResolvableType));<z>
) {<z>
())) {<z>
(true);<z>
Object value = readMethod.invoke(source);<z>
().getModifiers())) {<z>
;<z>
invoke(target, value);<z>
Throwable ex) {<z>
throw new FatalBeanException(<z>
.getName() + "' from source to target", ex);<z>
) {<z>
);<z>
result, value.getValue())) {<z>
setDynamic();<z>
;<z>
void afterAccess() {<z>
0) {<z>
this.monitor) {<z>
this.concurrencyCount--;<z>
if (logger.isDebugEnabled()) {<z>
.concurrencyCount);<z>
notify();<z>
HttpRequest createRequest(ClientRequest request) {<z>
{<z>
public HttpMethod getMethod() {<z>
;<z>
getMethodValue() {<z>
.name();<z>
() {<z>
;<z>
getHeaders() {<z>
return request.headers();<z>
void initTemplateConfig() {<z>
getJdbcTemplate();<z>
if (jdbcTemplate != null) {<z>
(jdbcTemplate);<z>
Class<? extends Source> sourceClass)<z>
{<z>
xmlObject = rs.getSQLXML(columnIndex);<z>
== null) {<z>
null;<z>
.class));<z>
maybeExtractVariableName(@Nullable String candidateToken) {<z>
)) {<z>
return candidateToken;<z>
return null;<z>
private static boolean isMappingForType(AnnotationTypeMapping mapping,<z>
requiredType) {<z>
;<z>
matches(actualType) &&<z>
)));<z>
MediaType contentType,<z>
msg) {<z>
super(msg, supportedMediaTypes);<z>
contentType = contentType;<z>
{<z>
end; ++i) {<z>
);<z>
content)<z>
throws SQLException {<z>
(content != null) {<z>
ps.getConnection().createClob();<z>
1, content);<z>
;<z>
.setClob(paramIndex, clob);<z>
(Clob) null);<z>
logger.isDebugEnabled()) {<z>
content.length() :<z>
);<z>
{<z>
null) {<z>
nodeExists(path)) {<z>
;<z>
null;<z>
catch (BackingStoreException ex) {<z>
("Cannot access specified node path [" + path + "]", ex);<z>
;<z>
Session session, Marshaller marshaller, MessageType targetType)<z>
, IOException, XmlMappingException {<z>
IllegalArgumentException("Unsupported message type [" + targetType +<z>
);<z>
() {<z>
getDelegate().getInbound()<z>
maxFramePayloadLength)<z>
receiveFrames()<z>
::toMessage)<z>
{<z>
()) {<z>
getLogPrefix() + "Received " + message);<z>
});<z>
(Session session, Destination destination, MessageCreator messageCreator)<z>
JMSException {<z>
;<z>
producer = createProducer(session, destination);<z>
message = messageCreator.createMessage(session);<z>
)) {<z>
.debug("Sending created message: " + message);<z>
producer, message);<z>
getTransacted() && isSessionLocallyTransacted(session)) {<z>
;<z>
);<z>
,<z>
registry, boolean proxyTargetClass) {<z>
);<z>
targetDefinition = definition.getBeanDefinition();<z>
= getTargetBeanName(originalBeanName);<z>
ScopedProxyFactoryBean.class);<z>
);<z>
.setOriginatingBeanDefinition(targetDefinition);<z>
setSource(definition.getSource());<z>
);<z>
.add("targetBeanName", targetBeanName);<z>
{<z>
TRUE);<z>
.FALSE);<z>
setAutowireCandidate(targetDefinition.isAutowireCandidate());<z>
(targetDefinition.isPrimary());<z>
) {<z>
);<z>
(false);<z>
(false);<z>
, targetDefinition);<z>
definition.getAliases());<z>
(String code, Locale locale) {<z>
< 0) {<z>
propHolder = getMergedProperties(locale);<z>
, locale);<z>
(result != null) {<z>
return result;<z>
for (String basename : getBasenameSet()) {<z>
;<z>
filename : filenames) {<z>
filename);<z>
locale);<z>
{<z>
return result;<z>
return null;<z>
{<z>
;<z>
this.requestDescription + " [DefaultClientResponse]";<z>
(result instanceof Mono) {<z>
>) result).checkpoint(description);<z>
result instanceof Flux) {<z>
).checkpoint(description);<z>
return result;<z>
,<z>
locations) {<z>
nextChain != null ?<z>
requestPath, locations, this.nextChain) :<z>
empty());<z>
DataBufferFactory bufferFactory,<z>
Map<String, Object> hints) {<z>
.isLoggingSuppressed(hints)) {<z>
getLogPrefix(hints);<z>
);<z>
, this.bufferSize);<z>
private HttpHeaders initHeaders() {<z>
CollectionUtils.isEmpty(this.headers)) {<z>
());<z>
{<z>
this.headers;<z>
= new HttpHeaders();<z>
.putAll(defaultHeaders);<z>
(this.headers);<z>
return result;<z>
) {<z>
;<z>
= contextRelative;<z>
.http10Compatible = http10Compatible;<z>
false);<z>
public ResultMatcher attributeDoesNotExist(String... names) {<z>
-> {<z>
;<z>
: names) {<z>
;<z>
JspException {<z>
Object value = resolveValue();<z>
);<z>
);<z>
;<z>
)));<z>
) {<z>
name)<z>
.statusCode)<z>
(this.headers)<z>
)<z>
.modelAttributes(model)<z>
()<z>
));<z>
, Object> urlMap, ParserContext context) {<z>
"path");<z>
pathAttribute, ",");<z>
(element.getAttribute("handler"));<z>
ConstructorArgumentValues();<z>
cargs.addIndexedArgumentValue(0, handlerReference);<z>
;<z>
;<z>
(element));<z>
ROLE_INFRASTRUCTURE);<z>
.interceptorsList);<z>
).registerWithGeneratedName(requestHandlerDef);<z>
(requestHandlerName);<z>
mappings) {<z>
.put(mapping, requestHandlerRef);<z>
int actualSize) {<z>
", actual " + actualSize);<z>
.expectedSize = expectedSize;<z>
;<z>
JmsMessageEndpointManager container) {<z>
= container.getActivationSpecConfig();<z>
== null) {<z>
;<z>
);<z>
) != null) {<z>
));<z>
) {<z>
;<z>
() != null) {<z>
activationSpecConfig.setMessageSelector(getSelector());<z>
!= null) {<z>
setConcurrency(getConcurrency());<z>
;<z>
) {<z>
this.transactionManagerCache.get(qualifier);<z>
== null) {<z>
= BeanFactoryAnnotationUtils.qualifiedBeanOfType(<z>
, qualifier);<z>
txManager);<z>
txManager;<z>
Supplier<String> message, Throwable ex) {<z>
getClass());<z>
.isDebugEnabled()) {<z>
.get(), ex);<z>
) {<z>
Object value = headers.get(name);<z>
if (value == null) {<z>
;<z>
(value.getClass())) {<z>
)) {<z>
+ "], but got [" +<z>
);<z>
return null;<z>
;<z>
ListableBeanFactory bf) {<z>
ChainedPersistenceExceptionTranslator();<z>
forEach(cpet::addDelegate);<z>
return cpet;<z>
Object invoke(MethodInvocation mi) throws Throwable {<z>
)) {<z>
getIntroductionDelegateFor(mi.getThis());<z>
(), mi.getArguments());<z>
ProxyMethodInvocation) {<z>
(ProxyMethodInvocation) mi).getProxy();<z>
;<z>
doProceed(mi);<z>
{<z>
();<z>
if (!result.isInitialized()) {<z>
throw newUninitializedMessageException(result);<z>
;<z>
ParserContext parserContext) {<z>
)) {<z>
ASYNC_EXECUTION_ASPECT_CLASS_NAME);<z>
);<z>
String executor = element.getAttribute("executor");<z>
)) {<z>
builder.addPropertyReference("executor", executor);<z>
);<z>
(exceptionHandler)) {<z>
, exceptionHandler);<z>
getBeanDefinition(),<z>
ASYNC_EXECUTION_ASPECT_BEAN_NAME));<z>
descriptor, @Nullable String beanName) {<z>
NestedDependencyDescriptor(descriptor);<z>
getDependencyType() == Optional.class);<z>
;<z>
(CompositeMessageCondition composite, HandlerMethod handler) {<z>
.getMessageConditions();<z>
.size() == 2 &&<z>
(0) instanceof RSocketFrameTypeMessageCondition &&<z>
get(1) instanceof DestinationPatternsMessageCondition,<z>
);<z>
0) != RSocketFrameTypeMessageCondition.EMPTY_CONDITION) {<z>
return composite;<z>
handler.getReturnType());<z>
= 0;<z>
parameter : handler.getMethodParameters()) {<z>
).getArgumentResolver(parameter) instanceof PayloadMethodArgumentResolver) {<z>
;<z>
new CompositeMessageCondition(<z>
responseCardinality),<z>
));<z>
void rejectIfEmptyOrWhitespace(<z>
defaultMessage) {<z>
.notNull(errors, "Errors object must not be null");<z>
value = errors.getFieldValue(field);<z>
value.toString())) {<z>
, errorCode, errorArgs, defaultMessage);<z>
Element element) {<z>
LinkedHashSet<>();<z>
getKind();<z>
.INTERFACE) {<z>
return stereotypes;<z>
HashSet<>();<z>
, stereotypes, element);<z>
();<z>
stereotypes, element);<z>
;<z>
() {<z>
, MediaType mediaType2) {<z>
quality1 = mediaType1.getQualityValue();<z>
mediaType2.getQualityValue();<z>
, quality1);<z>
) {<z>
qualityComparison;<z>
, mediaType2);<z>
() {<z>
new PathSegmentComponentBuilder();<z>
addAll(this.pathSegments);<z>
builder;<z>
queryParam(String key, String value) {<z>
key, "'key' must not be null");<z>
(value, "'value' must not be null");<z>
.add(key, value);<z>
this;<z>
) throws SQLException {<z>
(this.connectionMonitor) {<z>
null) {<z>
();<z>
connection.isClosed()) {<z>
throw new SQLException(<z>
);<z>
connection;<z>
(ValueHolder newValue) {<z>
, "ValueHolder must not be null");<z>
{<z>
addOrMergeGenericArgumentValue(newValue);<z>
dataSource) {<z>
sqlErrorCodes =<z>
resolveErrorCodes(dataSource));<z>
;<z>
String annotationType,<z>
, Object> attributes) {<z>
= annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME) ||<z>
contains(COMPONENT_ANNOTATION_CLASSNAME) ||<z>
equals("jakarta.annotation.ManagedBean") ||<z>
annotationType.equals("jakarta.inject.Named");<z>
);<z>
) {<z>
.debug("Registering beans for JMX exposure on startup");<z>
);<z>
);<z>
(RuntimeException ex) {<z>
;<z>
);<z>
throw ex;<z>
{<z>
Throwable endpointEx = null;<z>
hasBeforeDeliveryBeenCalled();<z>
if (applyDeliveryCalls) {<z>
beforeDelivery(null);<z>
catch (ResourceException ex) {<z>
adaptExceptionIfNecessary(methodInvocation, ex);<z>
;<z>
{<z>
ex;<z>
);<z>
ex;<z>
applyDeliveryCalls) {<z>
();<z>
ex) {<z>
== null) {<z>
adaptExceptionIfNecessary(methodInvocation, ex);<z>
destroy() throws BeansException {<z>
{<z>
factory.close();<z>
clear();<z>
);<z>
findMergedRepeatableAnnotations(AnnotatedElement element,<z>
<A> annotationType) {<z>
);<z>
<?>... declaredExceptions) {<z>
) {<z>
;<z>
{<z>
) {<z>
)) {<z>
return true;<z>
;<z>
, Throwable ex) {<z>
ex);<z>
logger = IntrospectionFailureLogger.INFO;<z>
meta = false;<z>
?>) element)) {<z>
;<z>
true;<z>
logger.isEnabled()) {<z>
String message = meta ?<z>
element + ": " + ex);<z>
)<z>
throws IOException, HttpMessageNotReadableException {<z>
new UnsupportedOperationException();<z>
create) {<z>
session = super.getSession(false);<z>
&& create) {<z>
(this);<z>
);<z>
newSession.setNew(true);<z>
String sessionid = newSession.getId();<z>
) {<z>
.sessions.put(sessionid, newSession);<z>
sessionid);<z>
= newSession;<z>
;<z>
Series valueOf(int statusCode) {<z>
series = resolve(statusCode);<z>
== null) {<z>
new IllegalArgumentException("No matching constant for [" + statusCode + "]");<z>
return series;<z>
, Throwable exception) {<z>
this.logger.isTraceEnabled()) {<z>
valueOf(message), exception);<z>
<MethodMetadata> retrieveBeanMethodMetadata(SourceClass sourceClass) {<z>
sourceClass.getMetadata();<z>
class.getName());<z>
StandardAnnotationMetadata) {<z>
AnnotationMetadata asm =<z>
)).getAnnotationMetadata();<z>
);<z>
>= beanMethods.size()) {<z>
());<z>
for (MethodMetadata asmMethod : asmMethods) {<z>
) {<z>
) {<z>
selectedMethods.add(beanMethod);<z>
size()) {<z>
;<z>
(IOException ex) {<z>
;<z>
;<z>
String beanName) throws Throwable {<z>
> checkedDestroyMethods = this.checkedDestroyMethods;<z>
destroyMethodsToUse =<z>
);<z>
)) {<z>
destroyMethodsToUse) {<z>
(logger.isTraceEnabled()) {<z>
element.getMethod());<z>
target);<z>
(ServerWebExchange exchange) {<z>
= HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE;<z>
.getRequiredAttribute(name);<z>
);<z>
(path)) {<z>
.empty();<z>
{<z>
empty();<z>
!= null, "ResourceResolverChain not initialized");<z>
transformerChain != null, "ResourceTransformerChain not initialized");<z>
())<z>
resource));<z>
String encoding) {<z>
if (encoding.startsWith("UTF-")){<z>
(character){<z>
case '<':<z>
"&lt;";<z>
:<z>
;<z>
case '"':<z>
"&quot;";<z>
:<z>
"&amp;";<z>
case '\'':<z>
;<z>
>= 8000 && character < 10000)) {<z>
? character : character - 7000);<z>
.characterToEntityReferenceMap[index];<z>
{<z>
entityReference;<z>
return null;<z>
ResolvableType actualType,<z>
request,<z>
hints) {<z>
hints);<z>
handler, Method method) {<z>
) {<z>
);<z>
register(mapping, handler, method);<z>
<String> value) {<z>
this.headers.getAll(key);<z>
value);<z>
previousValues;<z>
String> initHeaders(<z>
{<z>
HttpHeaders headers = null;<z>
null;<z>
getFirst(HttpHeaders.CONTENT_TYPE))) {<z>
requestContentType = request.getContentType();<z>
requestContentType)) {<z>
;<z>
new HttpHeaders(headerValues);<z>
headers.setContentType(contentType);<z>
.getCharset() == null) {<z>
String encoding = request.getCharacterEncoding();<z>
encoding)) {<z>
new LinkedCaseInsensitiveMap<>();<z>
(contentType.getParameters());<z>
.toString());<z>
));<z>
null) {<z>
contentLength = request.getContentLength();<z>
if (contentLength != -1) {<z>
headers : new HttpHeaders(headerValues));<z>
(contentLength);<z>
headers : headerValues);<z>
{<z>
, "Value must not be null");<z>
valueClass;<z>
= false;<z>
.getClass().isArray()) {<z>
().getComponentType();<z>
true;<z>
if (value instanceof Collection) {<z>
?>) value;<z>
()) {<z>
IllegalArgumentException(<z>
);<z>
);<z>
;<z>
;<z>
);<z>
valueClass);<z>
: name);<z>
String beanName) {<z>
);<z>
(beanName);<z>
clearByTypeCache();<z>
MessagingException {<z>
);<z>
== null) {<z>
;<z>
if (lookupDestination == null) {<z>
MessageHeaderAccessor.getMutableAccessor(message);<z>
;<z>
setLeaveMutable(true);<z>
, headerAccessor.getMessageHeaders());<z>
(logger.isDebugEnabled()) {<z>
debug("Searching methods to handle " +<z>
getShortLogMessage(message.getPayload()) +<z>
"'");<z>
(message, lookupDestination);<z>
.setImmutable();<z>
targetType) {<z>
sourceType.getType());<z>
(targetType.getType());<z>
Class<?> sourceCandidate : sourceCandidates) {<z>
Class<?> targetCandidate : targetCandidates) {<z>
sourceCandidate, targetCandidate);<z>
convertiblePair);<z>
!= null) {<z>
;<z>
;<z>
, ConcurrentMap<Object, Object> store,<z>
allowNullValues, @Nullable SerializationDelegate serialization) {<z>
super(allowNullValues);<z>
"Name must not be null");<z>
Assert.notNull(store, "Store must not be null");<z>
name = name;<z>
this.store = store;<z>
= serialization;<z>
(SortDefinition source) {<z>
;<z>
ignoreCase = source.isIgnoreCase();<z>
isAscending();<z>
BooleanTypedValue getValueInternal(ExpressionState state) throws EvaluationException {<z>
.getValueInternal(state).getValue();<z>
.getValue();<z>
= CodeFlow.toDescriptorFromObject(left);<z>
right);<z>
, left, right));<z>
) {<z>
metadata;<z>
.method, args);<z>
target = target;<z>
;<z>
= createCacheNames(this.caches);<z>
(String nestedProperty) {<z>
null) {<z>
);<z>
PropertyTokenHolder tokens = getPropertyNameTokens(nestedProperty);<z>
tokens.canonicalName;<z>
Object value = getPropertyValue(tokens);<z>
)) {<z>
()) {<z>
= setDefaultValue(tokens);<z>
nestedPath + canonicalName);<z>
(canonicalName);<z>
) {<z>
(logger.isTraceEnabled()) {<z>
+ canonicalName + "'");<z>
NESTED_PROPERTY_SEPARATOR);<z>
;<z>
(nestedPa, canonicalName);<z>
.put(canonicalName, nestedPa);<z>
)) {<z>
"'");<z>
nestedPa;<z>
configLocations) {<z>
ObjectUtils.isEmpty(configLocations)) {<z>
UnsupportedOperationException(<z>
);<z>
Marshaller marshaller) {<z>
;<z>
;<z>
marshaller instanceof Unmarshaller) {<z>
;<z>
{<z>
;<z>
idx != -1) {<z>
;<z>
if (idx != 0) {<z>
new IllegalArgumentException("Unrecognized characters before 'L' in '" + value + "'");<z>
) {<z>
);<z>
== 1) {<z>
();<z>
value.length(), 10);<z>
if (offset >= 0) {<z>
"'");<z>
= lastDayWithOffset(offset);<z>
(Type.DAY_OF_MONTH, adjuster, value);<z>
('W');<z>
-1) {<z>
idx == 0) {<z>
);<z>
.length() - 1) {<z>
+ value + "'");<z>
idx, 10);<z>
.checkValidValue(dayOfMonth);<z>
dayOfMonth);<z>
, value);<z>
("No 'L' or 'W' found in '" + value + "'");<z>
Object managedBean, String beanKey) throws JMException {<z>
(managedBean, beanKey);<z>
getAttributes()) &&<z>
())) {<z>
info("Bean with key '" + beanKey +<z>
"' has been registered as an MBean but has no exposed attributes or operations");<z>
info;<z>
getScriptedObjectType(ScriptSource scriptSource)<z>
throws IOException, ScriptCompilationException {<z>
.scriptClassMonitor) {<z>
()) {<z>
true;<z>
BshScriptUtils.determineBshObjectType(<z>
beanClassLoader);<z>
scriptClass;<z>
) {<z>
.scriptClass = null;<z>
);<z>
(AspectJExpressionPointcut declaredPointcut,<z>
Pointcut preInstantiationPointcut, MetadataAwareAspectInstanceFactory aspectInstanceFactory) {<z>
declaredPointcut = declaredPointcut;<z>
= preInstantiationPointcut;<z>
if (aspectInstanceFactory instanceof LazySingletonAspectInstanceFactoryDecorator) {<z>
aspectInstanceFactory = (LazySingletonAspectInstanceFactoryDecorator) aspectInstanceFactory;<z>
) {<z>
new DefaultListableBeanFactory();<z>
.class);<z>
) {<z>
case "simple":<z>
"dependencyCheck":<z>
class);<z>
);<z>
LifecycleBean.PostProcessor());<z>
"constructor":<z>
.getConstructorArgumentValues().addGenericArgumentValue("juergen");<z>
.getConstructorArgumentValues().addGenericArgumentValue("99");<z>
"constructorArgument":<z>
addGenericArgumentValue(new RuntimeBeanReference("spouse"));<z>
rbd);<z>
new RootBeanDefinition(TestBean.class));<z>
"properties":<z>
.add("name", "juergen");<z>
.add("age", "99");<z>
:<z>
new RuntimeBeanReference("spouse"));<z>
TestBean.class));<z>
SCOPE_PROTOTYPE);<z>
.beanFactory.registerBeanDefinition("test", rbd);<z>
beanFactory.freezeConfiguration();<z>
getExpiredFlashMaps(List<FlashMap> allMaps) {<z>
ArrayList<>();<z>
for (FlashMap map : allMaps) {<z>
isExpired()) {<z>
result.add(map);<z>
;<z>
CharSequence substring) {<z>
) > str.length()) {<z>
return false;<z>
++) {<z>
substring.charAt(i)) {<z>
return false;<z>
;<z>
<?>> build() {<z>
this.parts.size());<z>
) {<z>
)) {<z>
entity = builder.build();<z>
);<z>
;<z>
getHeaders() {<z>
== null) {<z>
new HttpHeaders();<z>
.getAllHeaders()) {<z>
.getValue());<z>
return this.headers;<z>
valueToString(Object value) {<z>
== this) {<z>
"(this Map)";<z>
) {<z>
+ "]";<z>
return String.valueOf(value);<z>
) {<z>
|= 0x00000001;<z>
= value;<z>
();<z>
this;<z>
() {<z>
();<z>
hashCode();<z>
;<z>
return result;<z>
{<z>
||<z>
&&<z>
FACTORY_BEAN_PREFIX.length()))));<z>
message, HttpOutputMessage outputMessage)<z>
{<z>
.getHeaders().getContentType();<z>
contentType == null) {<z>
getDefaultContentType(message);<z>
contentType != null, "No content type");<z>
Charset charset = contentType.getCharset();<z>
charset == null) {<z>
DEFAULT_CHARSET;<z>
)) {<z>
outputMessage, message);<z>
));<z>
;<z>
;<z>
TEXT_PLAIN.isCompatibleWith(contentType)) {<z>
outputMessage.getBody(), charset);<z>
outputStreamWriter);<z>
outputStreamWriter.flush();<z>
();<z>
null) {<z>
.getBody(), contentType, charset);<z>
();<z>
request, HttpServletResponse response, @Nullable ModelAndView mv)<z>
Exception {<z>
{<z>
= this.interceptorList.get(i);<z>
handler, mv);<z>
BeansException {<z>
= initFactory();<z>
getBean(viewName, View.class);<z>
{<z>
return null;<z>
{<z>
s = this.subscription;<z>
null) {<z>
();<z>
{<z>
();<z>
);<z>
getRequestURI());<z>
includeClientInfo) {<z>
();<z>
hasLength(client)) {<z>
append(client);<z>
false);<z>
null) {<z>
;<z>
getRemoteUser();<z>
)) {<z>
";user=").append(user);<z>
toString();<z>
callbacks) {<z>
callbacks);<z>
primaryConstructorArgTypes == argumentTypes ||<z>
equals(primaryConstructorArgTypes, argumentTypes)) {<z>
.newInstance(primaryConstructor, arguments);<z>
newInstance(generatedClass, argumentTypes, arguments);<z>
;<z>
public int getResolvedAutowireMode() {<z>
this.autowireMode == AUTOWIRE_AUTODETECT) {<z>
.getConstructors();<z>
Constructor<?> constructor : constructors) {<z>
() == 0) {<z>
AUTOWIRE_BY_TYPE;<z>
return AUTOWIRE_CONSTRUCTOR;<z>
.autowireMode;<z>
{<z>
.getProperty())) {<z>
>(sortDefinition));<z>
getExecutorStatsInfo(@Nullable Executor executor) {<z>
(executor == null) {<z>
"null";<z>
executor instanceof ThreadPoolTaskExecutor) {<z>
getThreadPoolExecutor();<z>
(executor instanceof ThreadPoolExecutor) {<z>
str = executor.toString();<z>
.indexOf("pool");<z>
) {<z>
() - 1);<z>
return "unknown";<z>
) {<z>
;<z>
this.currentConnection != null) {<z>
connectionHandle != null) {<z>
;<z>
= null;<z>
(Object payload, Type resolvedType) {<z>
) {<z>
;<z>
(payload);<z>
> getInterceptors() {<z>
)<z>
)<z>
::getInterceptor)<z>
collect(Collectors.toList());<z>
, MethodParameter returnType, Message<?> message)<z>
throws Exception {<z>
returnValue == null) {<z>
= message.getHeaders();<z>
= SimpMessageHeaderAccessor.getSessionId(headers);<z>
subscriptionId = SimpMessageHeaderAccessor.getSubscriptionId(headers);<z>
destination = SimpMessageHeaderAccessor.getDestination(headers);<z>
subscriptionId == null) {<z>
throw new IllegalStateException("No simpSubscriptionId in " + message +<z>
getMethod());<z>
(destination == null) {<z>
("No simpDestination in " + message +<z>
;<z>
()) {<z>
);<z>
returnType);<z>
headersToSend);<z>
protected Session openSession() throws DataAccessResourceFailureException {<z>
openSession();<z>
session.setHibernateFlushMode(FlushMode.MANUAL);<z>
;<z>
ex) {<z>
throw new DataAccessResourceFailureException("Could not open Hibernate Session", ex);<z>
(Class<?> clazz) {<z>
(clazz, "Class must not be null");<z>
getName();<z>
className.lastIndexOf(PACKAGE_SEPARATOR);<z>
+ 1) + CLASS_FILE_SUFFIX;<z>
(MessageConsumer consumer, long timeout) throws JMSException {<z>
> 0) {<z>
;<z>
< 0) {<z>
consumer.receiveNoWait();<z>
;<z>
List<MediaType> getAcceptableMediaTypes(HttpServletRequest request)<z>
HttpMediaTypeNotAcceptableException {<z>
ServletWebRequest(request));<z>
void setBlobAsBinaryStream(<z>
)<z>
SQLException {<z>
) {<z>
;<z>
setBinaryStream(1));<z>
ex) {<z>
throw new DataAccessResourceFailureException("Could not copy into LOB stream", ex);<z>
temporaryBlobs.add(blob);<z>
blob);<z>
;<z>
()) {<z>
.debug(binaryStream != null ?<z>
:<z>
);<z>
Object> getHints(ResolvableType resolvableType) {<z>
);<z>
if (param != null) {<z>
;<z>
.hasGenerics()) {<z>
HashMap<>(2);<z>
;<z>
;<z>
(annotation != null) {<z>
);<z>
);<z>
>(1));<z>
, classes[0]);<z>
null) {<z>
return hints;<z>
return Hints.none();<z>
exception, Message<?> message) {<z>
, exception);<z>
(invocable == null) {<z>
;<z>
;<z>
if (logger.isDebugEnabled()) {<z>
"Invoking " + invocable.getShortLogMessage());<z>
exception.getCause();<z>
(cause != null ?<z>
cause, handlerMethod) :<z>
));<z>
returnType = invocable.getReturnType();<z>
returnType.getParameterType()) {<z>
.handleReturnValue(returnValue, returnType, message);<z>
catch (Throwable ex2) {<z>
error("Error while processing handler method exception", ex2);<z>
sql,<z>
>> resultFunction,<z>
Integer>> updatedRowsFunction,<z>
mappingFunction) {<z>
sql;<z>
connectionAccessor = connectionAccessor;<z>
= resultFunction;<z>
updatedRowsFunction;<z>
.mappingFunction = mappingFunction;<z>
isEligibleAttribute(String name) {<z>
.equals("render-object") ||<z>
.equals("content-type") ||<z>
equals("resource-loader-path"));<z>
{<z>
) {<z>
;<z>
.getClassLoader();<z>
, @Nullable String tableName,<z>
) {<z>
(schemaName != null) {<z>
toUpperCase());<z>
{<z>
"Unable to locate table meta-data for '" +<z>
+ "' schema");<z>
tmd;<z>
) {<z>
;<z>
tableMeta.get(getDefaultSchema());<z>
(tmd == null) {<z>
"");<z>
null) {<z>
;<z>
== null) {<z>
tableMeta.get("DBO");<z>
tmd == null) {<z>
(<z>
"' in the default schema");<z>
return tmd;<z>
WebSocketTransportRegistration getTransportRegistration() {<z>
.transportRegistration == null) {<z>
.transportRegistration = new WebSocketTransportRegistration();<z>
configureWebSocketTransport(this.transportRegistration);<z>
;<z>
) {<z>
"Body must not be null");<z>
releaseBody();<z>
;<z>
;<z>
context, MergedContextConfiguration mergedConfig) {<z>
);<z>
.getClasses());<z>
(@Nullable Object handler, HttpServletRequest request) {<z>
handler instanceof HandlerExecutionChain ?<z>
() : handler);<z>
&& handler instanceof WebSocketHttpRequestHandler) {<z>
HttpHeaders.UPGRADE);<z>
().equals("GET") &&<z>
));<z>
return true;<z>
) {<z>
addDateConverters(registry);<z>
.dateFormatter != null) {<z>
);<z>
this.dateFormatter);<z>
(new DateTimeFormatAnnotationFormatterFactory());<z>
) {<z>
= getParameterNameDiscoverer();<z>
method) : null);<z>
null) {<z>
;<z>
info = new MBeanParameterInfo[paramNames.length];<z>
= method.getParameterTypes();<z>
i < info.length; i++) {<z>
);<z>
return info;<z>
{<z>
transformerFactoryClass);<z>
this.errorListener);<z>
if (this.uriResolver != null) {<z>
(this.uriResolver);<z>
if (this.cacheTemplates) {<z>
);<z>
Object existingBean, int autowireMode, boolean dependencyCheck)<z>
throws BeansException {<z>
(autowireMode == AUTOWIRE_CONSTRUCTOR) {<z>
new IllegalArgumentException("AUTOWIRE_CONSTRUCTOR not supported for existing bean instance");<z>
=<z>
, autowireMode, dependencyCheck);<z>
(SCOPE_PROTOTYPE);<z>
(existingBean);<z>
initBeanWrapper(bw);<z>
;<z>
T> deferredResult)<z>
{<z>
;<z>
> Flux<T> unsupportedErrorHandler(<z>
) {<z>
;<z>
{<z>
.map(buffer -> {<z>
.release(buffer);<z>
ex;<z>
);<z>
message instanceof ClientHttpResponse ?<z>
.error(ex);<z>
return result;<z>
) {<z>
])arg;<z>
instanceof Closure) {<z>
) args[0]);<z>
"ref".equals(name)) {<z>
;<z>
[0] == null) {<z>
IllegalArgumentException("Argument to ref() is not a valid bean or was not found");<z>
) {<z>
).getBeanName();<z>
toString();<z>
;<z>
) {<z>
Boolean) args[1];<z>
(refName, parentRef);<z>
args[0] instanceof Closure) {<z>
GroovyDynamicElementReader reader = createDynamicElementReader(name);<z>
.invokeMethod("doCall", args);<z>
args[0] instanceof Closure) {<z>
args);<z>
(args.length > 0 &&<z>
Map)) {<z>
);<z>
instanceof Closure) {<z>
, args);<z>
;<z>
name, args).isEmpty()){<z>
args);<z>
this;<z>
) {<z>
{<z>
();<z>
.getDefaultTypeConverter();<z>
<ApplicationListener<?>> getApplicationListeners() {<z>
this.defaultRetriever) {<z>
);<z>
{<z>
;<z>
if (contentType != null) {<z>
MediaType.parseMediaType(contentType);<z>
) != null) {<z>
().name());<z>
) {<z>
().indexOf(CHARSET_PREFIX);<z>
{<z>
+ CHARSET_PREFIX.length()));<z>
;<z>
state) {<z>
.getTypeConverter();<z>
valueOf(String.class);<z>
value.getTypeDescriptor(), typeDescriptor)) {<z>
typeConverter.convertValue(value.getValue(),<z>
), typeDescriptor));<z>
));<z>
protobuf.SecondMsg parseFrom(<z>
CodedInputStream input)<z>
.io.IOException {<z>
return PARSER.parseFrom(input);<z>
MockCookie parse(String setCookieHeader) {<z>
setCookieHeader, "Set-Cookie header must not be null");<z>
setCookieHeader.split("\\s*=\\s*", 2);<z>
) -> "Invalid Set-Cookie header '" + setCookieHeader + "'");<z>
];<z>
split("\\s*;\\s*", 2);<z>
valueAndAttributes[0];<z>
[] attributes =<z>
) : new String[0]);<z>
cookie = new MockCookie(name, value);<z>
for (String attribute : attributes) {<z>
"Domain")) {<z>
, setCookieHeader));<z>
.startsWithIgnoreCase(attribute, "Max-Age")) {<z>
(extractAttributeValue(attribute, setCookieHeader)));<z>
.startsWithIgnoreCase(attribute, "Expires")) {<z>
setCookieHeader),<z>
RFC_1123_DATE_TIME));<z>
) {<z>
)) {<z>
, setCookieHeader));<z>
) {<z>
cookie.setSecure(true);<z>
{<z>
);<z>
attribute, "SameSite")) {<z>
, setCookieHeader));<z>
;<z>
) {<z>
;<z>
"Path must not be null");<z>
.cleanPath(path);<z>
.file = null;<z>
);<z>
byte[] boundary) throws IOException {<z>
);<z>
('-');<z>
write(boundary);<z>
'-');<z>
write('-');<z>
);<z>
public Message<?> receive() {<z>
;<z>
) {<z>
defaultDestination);<z>
);<z>
, DataBufferFactory factory,<z>
{<z>
session, info, factory, completionSink);<z>
suspendReceiving();<z>
Object path) {<z>
.delegate = delegate;<z>
this.path = path;<z>
= (path instanceof RequestPath ?<z>
.PATH_ATTRIBUTE : UrlPathHelper.PATH_ATTRIBUTE);<z>
?> getObjectClass(@Nullable Object obj) {<z>
) {<z>
;<z>
.getClass());<z>
Nullable Object other) {<z>
other) {<z>
;<z>
)) {<z>
;<z>
) &&<z>
otherResolvable.getArguments()) &&<z>
getDefaultMessage()));<z>
) {<z>
true;<z>
(annotationParsers, "At least one CacheAnnotationParser needs to be specified");<z>
(annotationParsers));<z>
getTransaction(@Nullable TransactionDefinition definition)<z>
throws TransactionException {<z>
());<z>
);<z>
boolean debugEnabled = logger.isDebugEnabled();<z>
) {<z>
(def, transaction, debugEnabled);<z>
) {<z>
());<z>
== TransactionDefinition.PROPAGATION_MANDATORY) {<z>
throw new IllegalTransactionStateException(<z>
;<z>
.PROPAGATION_REQUIRED ||<z>
.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||<z>
PROPAGATION_NESTED) {<z>
= suspend(null);<z>
if (debugEnabled) {<z>
+ "]: " + def);<z>
debugEnabled, suspendedResources);<z>
| Error ex) {<z>
(null, suspendedResources);<z>
ex;<z>
) {<z>
logger.warn("Custom isolation level specified but no actual transaction initiated; " +<z>
;<z>
SYNCHRONIZATION_ALWAYS);<z>
debugEnabled, null);<z>
getVaryRequestHeadersToAdd(HttpHeaders responseHeaders, HttpHeaders entityHeaders) {<z>
> entityHeadersVary = entityHeaders.getVary();<z>
responseHeaders.get(HttpHeaders.VARY);<z>
if (vary != null) {<z>
>(entityHeadersVary);<z>
) {<z>
{<z>
(existing)) {<z>
();<z>
) {<z>
) {<z>
value);<z>
result;<z>
entityHeadersVary;<z>
getOrder(@Nullable Object obj) {<z>
obj != null) {<z>
order = findOrder(obj);<z>
order != null) {<z>
;<z>
Ordered.LOWEST_PRECEDENCE;<z>
ServerResponse.BodyBuilder cookie(Cookie cookie) {<z>
"Cookie must not be null");<z>
getName(), cookie);<z>
;<z>
(AsyncRequestTimeoutException ex,<z>
{<z>
response.isCommitted()) {<z>
(HttpServletResponse.SC_SERVICE_UNAVAILABLE);<z>
warn("Async request timed out");<z>
();<z>
> entrySet() {<z>
(SimpleImmutableEntry::new)<z>
(Collectors.collectingAndThen(<z>
.toCollection(LinkedHashSet::new),<z>
::unmodifiableSet));<z>
(Class<?> targetClass) {<z>
source : this.cacheOperationSources) {<z>
.isCandidateClass(targetClass)) {<z>
;<z>
;<z>
void setReturnGeneratedKeys(boolean returnGeneratedKeys) {<z>
{<z>
(<z>
"The returnGeneratedKeys flag must be set before the operation is compiled");<z>
returnGeneratedKeys;<z>
protected void visitList(List listVal) {<z>
); i++) {<z>
(i);<z>
(elem);<z>
(newVal, elem)) {<z>
;<z>
BeanComponentDefinition(BeanDefinitionHolder beanDefinitionHolder) {<z>
super(beanDefinitionHolder);<z>
);<z>
> references = new ArrayList<>();<z>
getPropertyValues();<z>
propertyValues.getPropertyValues()) {<z>
;<z>
instanceof BeanDefinitionHolder) {<z>
.getBeanDefinition());<z>
{<z>
.add((BeanDefinition) value);<z>
) {<z>
);<z>
);<z>
]);<z>
element) {<z>
(iterator != null) {<z>
) {<z>
;<z>
) {<z>
return true;<z>
false;<z>
> content() {<z>
) -> {<z>
charset(headers()));<z>
));<z>
});<z>
T> publisher) {<z>
)) {<z>
;<z>
;<z>
Nullable Object result) {<z>
())) {<z>
= createEvaluationContext(result);<z>
.metadata.methodKey, evaluationContext);<z>
, this.args);<z>
DataBuffer encodeValue(CharSequence charSequence, DataBufferFactory bufferFactory,<z>
Nullable Map<String, Object> hints) {<z>
(!Hints.isLoggingSuppressed(hints)) {<z>
LogFormatUtils.traceDebug(logger, traceOn -> {<z>
traceOn);<z>
+ formatted;<z>
);<z>
= true;<z>
= getCharset(mimeType);<z>
charset);<z>
DataBuffer dataBuffer = bufferFactory.allocateBuffer(capacity);<z>
;<z>
= false;<z>
ex) {<z>
), ex);<z>
if (release) {<z>
(dataBuffer);<z>
return dataBuffer;<z>
public BeanFactoryJCacheOperationSourceAdvisor cacheAdvisor(<z>
JCacheOperationSource jCacheOperationSource, JCacheInterceptor jCacheInterceptor) {<z>
BeanFactoryJCacheOperationSourceAdvisor advisor = new BeanFactoryJCacheOperationSourceAdvisor();<z>
jCacheOperationSource);<z>
jCacheInterceptor);<z>
this.enableCaching != null) {<z>
.<Integer>getNumber("order"));<z>
;<z>
){<z>
> initialValue() {<z>
4);<z>
{<z>
other) {<z>
return true;<z>
{<z>
false;<z>
);<z>
void pushActiveContextObject(TypedValue obj) {<z>
) {<z>
.contextObjects = new ArrayDeque<>();<z>
contextObjects.push(obj);<z>
HttpServletRequest request) {<z>
;<z>
matches(request.getMethod())) {<z>
request);<z>
{<z>
result;<z>
request);<z>
if (result != 0) {<z>
result;<z>
getParamsCondition(), request);<z>
(result != 0) {<z>
;<z>
(other.getHeadersCondition(), request);<z>
!= 0) {<z>
result;<z>
other.getConsumesCondition(), request);<z>
(result != 0) {<z>
;<z>
, request);<z>
!= 0) {<z>
return result;<z>
(), request);<z>
) {<z>
return result;<z>
, request);<z>
) {<z>
;<z>
;<z>
() {<z>
;<z>
targetSet) {<z>
.targetSet) {<z>
target);<z>
();<z>
();<z>
PropertyDescriptor pd) {<z>
(member, pd);<z>
class);<z>
= resource.beanName();<z>
();<z>
;<z>
{<z>
resourceName = this.member.getName();<z>
) > 3) {<z>
.substring(3));<z>
();<z>
) {<z>
checkResourceType(resourceType);<z>
= getResourceType();<z>
.beanName = resourceBeanName;<z>
;<z>
= resourceType;<z>
mappedName();<z>
ServerWebExchange exchange) {<z>
)) {<z>
matchPreFlight(exchange.getRequest());<z>
)) {<z>
).getMethod())) {<z>
return null;<z>
return this;<z>
.getMethod());<z>
(Class<T> clazz) {<z>
Assert.notNull(clazz, "Class must not be null");<z>
isKotlinType(clazz)) {<z>
KotlinDelegate.findPrimaryConstructor(clazz);<z>
null;<z>
{<z>
this.targetObject == null) {<z>
;<z>
.getClass();<z>
boolean localResource) {<z>
(targetDefinition);<z>
= timeout;<z>
= localResource;<z>
subscriptionShared) {<z>
subscriptionShared;<z>
) {<z>
setPubSubDomain(true);<z>
@Nullable Object value,<z>
itemIndex) throws JspException {<z>
);<z>
0) {<z>
));<z>
resolvedDelimiter != null) {<z>
resolvedDelimiter.toString());<z>
;<z>
resolveId();<z>
id != null, "Attribute 'id' is required");<z>
id);<z>
, getName());<z>
writeOptionalAttributes(tagWriter);<z>
.writeAttribute("type", getInputType());<z>
(item, value, tagWriter);<z>
);<z>
startTag("label");<z>
"for", id);<z>
);<z>
();<z>
;<z>
String content, SortedSet<ContentChunkInfo> result) {<z>
position = 0;<z>
) {<z>
position);<z>
if (position == -1) {<z>
).length();<z>
content.charAt(position))) {<z>
;<z>
charAt(position) == '\'') {<z>
, content, result);<z>
content.charAt(position) == '"') {<z>
result);<z>
;<z>
{<z>
Supplier<T>) null,<z>
-> {<z>
{<z>
(arg);<z>
);<z>
{<z>
);<z>
.clear();<z>
.locationValues.addAll(locations);<z>
)<z>
throws ServletException {<z>
);<z>
{<z>
checkHttpMethod(request.getMethod())) {<z>
;<z>
localeResolver == null) {<z>
(<z>
"No LocaleResolver found: not in a DispatcherServlet request?");<z>
));<z>
catch (IllegalArgumentException ex) {<z>
(isIgnoreInvalidLocale()) {<z>
) {<z>
));<z>
ex;<z>
;<z>
void put(<z>
) {<z>
(flags & FLAG_RESOLVED) == 0) {<z>
{<z>
;<z>
);<z>
else {<z>
length);<z>
(-1);<z>
else {<z>
if (wideReference) {<z>
- sourceInsnBytecodeOffset);<z>
else {<z>
);<z>
Nullable Class<? extends Group> type) {<z>
: DefaultDeferredImportSelectorGroup.class);<z>
,<z>
this.environment,<z>
ConfigurationClassParser.this.resourceLoader,<z>
.registry);<z>
DataBufferFactory bufferFactory,<z>
String, Object> hints) {<z>
).flux();<z>
) {<z>
this.headers,<z>
,<z>
this.localAddress,<z>
);<z>
String className) {<z>
, ClassUtils.getDefaultClassLoader());<z>
.isAssignableFrom(clazz)) {<z>
throw new ApplicationContextException(<z>
clazz);<z>
ConfigurableApplicationContext>>) clazz;<z>
{<z>
, ex);<z>
?> types) {<z>
-> types.stream()<z>
) : type.toString())<z>
);<z>
Supplier<String> messageSupplier) {<z>
if (!expression) {<z>
IllegalStateException(nullSafeGet(messageSupplier));<z>
attributeValues) {<z>
!= null) {<z>
(Object attributeValue : attributeValues) {<z>
addAttribute(attributeValue);<z>
this;<z>
cancelRefresh(BeansException ex) {<z>
beanFactory = this.beanFactory;<z>
{<z>
);<z>
cancelRefresh(ex);<z>
Nullable Class<?> containingClass) {<z>
executable, "Executable must not be null");<z>
;<z>
(executable, parameterIndex);<z>
this.nestingLevel = 1;<z>
;<z>
) {<z>
();<z>
handlers.add(new ModelAndViewMethodReturnValueHandler());<z>
));<z>
);<z>
handlers.add(new HttpEntityMethodProcessor(<z>
, this.responseBodyAdvice));<z>
;<z>
(new RequestResponseBodyMethodProcessor(<z>
contentNegotiationManager, this.responseBodyAdvice));<z>
new ViewNameMethodReturnValueHandler());<z>
add(new MapMethodProcessor());<z>
getCustomReturnValueHandlers() != null) {<z>
);<z>
add(new ServletModelAttributeMethodProcessor(true));<z>
handlers;<z>
columnIndex) throws SQLException {<z>
;<z>
.wrapAsLob) {<z>
(columnIndex);<z>
blob.getBinaryStream();<z>
(columnIndex);<z>
BodyBuilder eTag(String etag) {<z>
startsWith("W/\"")) {<z>
= "\"" + etag;<z>
"\"")) {<z>
etag = etag + "\"";<z>
);<z>
this;<z>
@Nullable PlatformTransactionManager transactionManager,<z>
TransactionAttribute transactionAttribute, String joinpointIdentification) {<z>
;<z>
this.transactionAttribute = transactionAttribute;<z>
this.joinpointIdentification = joinpointIdentification;<z>
, SearchStrategy searchStrategy,<z>
RepeatableContainers repeatableContainers) {<z>
, repeatableContainers, AnnotationFilter.PLAIN);<z>
ResolvableType actualType,<z>
request,<z>
<String, Object> hints) {<z>
allHints = Hints.merge(hints,<z>
elementType, mediaType, request, response));<z>
;<z>
{<z>
if (predicate instanceof Target target) {<z>
target.changeParser(this.parser);<z>
String[] getSingletonNames() {<z>
) {<z>
registeredSingletons);<z>
]> executableMap) {<z>
ASM_VERSION);<z>
;<z>
executableMap;<z>
initCookies() {<z>
cookies = new LinkedMultiValueMap<>();<z>
keySet()) {<z>
().get(name)) {<z>
, cookie.value());<z>
httpCookie);<z>
;<z>
) {<z>
(destination, "Byte array must not be null");<z>
- length,<z>
this.writePosition);<z>
tmp = this.byteBuffer.duplicate();<z>
this.readPosition + length;<z>
.readPosition).limit(limit);<z>
);<z>
.readPosition += length;<z>
return this;<z>
adaptRequest(<z>
Void>> requestCallback) {<z>
;<z>
<>();<z>
dataBuffers -><z>
DataBufferUtils.join(dataBuffers)<z>
.doOnNext(buffer -> {<z>
;<z>
);<z>
;<z>
bytes);<z>
);<z>
(httpRequest).block(TIMEOUT);<z>
=<z>
, httpRequest, contentRef.get());<z>
;<z>
{<z>
{<z>
cookie.getValue()));<z>
requestBuilder;<z>
{<z>
) {<z>
(defaultConversionService == null) {<z>
new DefaultConversionService();<z>
this.conversionService = defaultConversionService;<z>
method) {<z>
;<z>
;<z>
return invocable;<z>
protected boolean isExcluded(String className) {<z>
.contains(className)) {<z>
true;<z>
packageName : this.excludedPackages) {<z>
{<z>
true;<z>
;<z>
String getProperty(String name) {<z>
.nonOptionArgsPropertyName.equals(name)) {<z>
= this.getNonOptionArgs();<z>
()) {<z>
return null;<z>
nonOptionArguments);<z>
this.getOptionValues(name);<z>
) {<z>
;<z>
optionValues);<z>
{<z>
get(beanMethod);<z>
== null) {<z>
getName();<z>
=<z>
, Bean.class, false, false);<z>
bean != null) {<z>
] names = bean.getStringArray("name");<z>
if (names.length > 0) {<z>
names[0];<z>
beanMethod, beanName);<z>
return beanName;<z>
s2) {<z>
)) {<z>
);<z>
if (s2.isEmpty()) {<z>
;<z>
() + 1];<z>
i++) {<z>
i;<z>
; j++) {<z>
j] = j;<z>
s1.length(); i++) {<z>
1);<z>
length(); j++) {<z>
cost;<z>
- 1);<z>
== c2) {<z>
= 0;<z>
cost = 1;<z>
j - 1] + cost);<z>
;<z>
(String name, @Nullable Object value) {<z>
notNull(name, "Name must not be null");<z>
{<z>
name, value);<z>
);<z>
CloseStatus closeStatus) throws Exception {<z>
logger.isDebugEnabled()) {<z>
+ closeStatus);<z>
.afterConnectionClosed(session, closeStatus);<z>
inheritListeners() default true;<z>
;<z>
enum MergeMode {<z>
String name) {<z>
switch (logApi) {<z>
case LOG4J:<z>
name);<z>
case SLF4J_LAL:<z>
(name);<z>
:<z>
(name);<z>
return JavaUtilAdapter.createLog(name);<z>
HttpServletRequest request, HttpServletResponse response) {<z>
1; i >= 0; i--) {<z>
(i);<z>
if (interceptor instanceof AsyncHandlerInterceptor asyncInterceptor) {<z>
, response, this.handler);<z>
(Throwable ex) {<z>
)) {<z>
("Interceptor [" + interceptor + "] failed in afterConcurrentHandlingStarted", ex);<z>
getValueParameter(Object... values) {<z>
= this.valueParameterDetail.getParameterPosition();<z>
values.length) {<z>
new IllegalStateException("Values mismatch, value parameter at position " +<z>
" cannot be matched against " + values.length + " value(s)");<z>
values[parameterPosition]);<z>
MediaType getMediaType(@Nullable MediaType mediaType) {<z>
null) {<z>
return DEFAULT_FORM_DATA_MEDIA_TYPE;<z>
null) {<z>
getDefaultCharset());<z>
;<z>
parseCacheAnnotations(<z>
DefaultCacheConfig cachingConfig, AnnotatedElement ae, boolean localOnly) {<z>
extends Annotation> anns = (localOnly ?<z>
(ae, CACHE_OPERATION_ANNOTATIONS) :<z>
findAllMergedAnnotations(ae, CACHE_OPERATION_ANNOTATIONS));<z>
)) {<z>
return null;<z>
(1);<z>
instanceof Cacheable).forEach(<z>
);<z>
).forEach(<z>
) ann)));<z>
CachePut).forEach(<z>
, (CachePut) ann)));<z>
forEach(<z>
ops));<z>
ops;<z>
) throws IOException {<z>
this.webSocketSession != null) {<z>
.close(status);<z>
[] bufferedOutput) throws IOException {<z>
, headers);<z>
{<z>
.setDoOutput(false);<z>
{<z>
.length);<z>
connection.connect();<z>
this.connection.getDoOutput()) {<z>
());<z>
;<z>
this.connection);<z>
{<z>
isTrue(idleConsumerLimit > 0, "'idleConsumerLimit' must be 1 or higher");<z>
{<z>
.idleConsumerLimit = idleConsumerLimit;<z>
(Connection connection) throws ScriptException {<z>
;<z>
(populator -> populator.populate(connection))<z>
();<z>
() {<z>
) {<z>
: this.requestDestructionCallbacks.values()) {<z>
);<z>
;<z>
A>> action) {<z>
.mappingCursors == null) {<z>
aggregate.size()];<z>
MAX_VALUE;<z>
-1;<z>
.size(); annotationIndex++) {<z>
= getNextSuitableMapping(aggregate, annotationIndex);<z>
&& mapping.getDistance() < lowestDistance) {<z>
;<z>
getDistance();<z>
== 0) {<z>
1) {<z>
A> mergedAnnotation = aggregate.createMergedAnnotationIfPossible(<z>
[annotationResult],<z>
: IntrospectionFailureLogger.DEBUG);<z>
[annotationResult]++;<z>
if (mergedAnnotation == null) {<z>
, action);<z>
action.accept(mergedAnnotation);<z>
true;<z>
false;<z>
{<z>
== null) {<z>
null;<z>
supportedMethods.length);<z>
value : this.supportedMethods) {<z>
;<z>
);<z>
;<z>
(<z>
] data,<z>
.ExtensionRegistryLite extensionRegistry)<z>
google.protobuf.InvalidProtocolBufferException {<z>
);<z>
) {<z>
RequestAttribute.class);<z>
null, "No RequestAttribute annotation");<z>
required(), ValueConstants.DEFAULT_NONE);<z>
) {<z>
();<z>
());<z>
getFieldErrors());<z>
Collections.unmodifiableList(result);<z>
createElement(int index) {<z>
.newInstance();<z>
NoSuchMethodException ex) {<z>
new ElementInstantiationException(<z>
elementClass.getName(), ex);<z>
catch (InstantiationException ex) {<z>
throw new ElementInstantiationException(<z>
elementClass.getName(), ex);<z>
{<z>
throw new ElementInstantiationException(<z>
.elementClass.getName(), ex);<z>
InvocationTargetException ex) {<z>
ElementInstantiationException(<z>
;<z>
hashCode() {<z>
.beanName.hashCode();<z>
: 0);<z>
result;<z>
extractJarFileURL(URL jarUrl) throws MalformedURLException {<z>
String urlFile = jarUrl.getFile();<z>
int separatorIndex = urlFile.indexOf(JAR_URL_SEPARATOR);<z>
if (separatorIndex != -1) {<z>
= urlFile.substring(0, separatorIndex);<z>
URL(jarFile);<z>
ex) {<z>
("/")) {<z>
;<z>
return new URL(FILE_URL_PREFIX + jarFile);<z>
jarUrl;<z>
ServerHttpRequest request, ServerHttpResponse response) throws IOException {<z>
{<z>
logger.error(LogFormatUtils.formatValue(<z>
, true));<z>
setStatusCode(HttpStatus.BAD_REQUEST);<z>
"\"Connection\" must be \"upgrade\".".getBytes(StandardCharsets.UTF_8));<z>
) {<z>
);<z>
() -> "Required attribute '" + name + "' is missing");<z>
value;<z>
private void processEventWithCallbacks() {<z>
preProcessEvent(this.event));<z>
event);<z>
catch (RuntimeException | Error ex) {<z>
);<z>
;<z>
this.event, null));<z>
) {<z>
"Class must not be null");<z>
clazz);<z>
== null) {<z>
.getDeclaredMethods();<z>
clazz);<z>
null) {<z>
];<z>
declaredMethods.length);<z>
= declaredMethods.length;<z>
(Method defaultMethod : defaultMethods) {<z>
index] = defaultMethod;<z>
index++;<z>
declaredMethods;<z>
);<z>
ex) {<z>
getName() +<z>
;<z>
();<z>
setValue(List<String> value) {<z>
);<z>
removeHeader(this.key);<z>
);<z>
previous;<z>
.Entry> getImports() {<z>
.deferredImports) {<z>
getConfigurationClass().getMetadata(),<z>
));<z>
return this.group.selectImports();<z>
public RequestHeaderMethodArgumentResolver(@Nullable ConfigurableBeanFactory factory,<z>
{<z>
registry);<z>
{<z>
this.destructionCallbacks) {<z>
.destructionCallbacks.put(name, callback);<z>
{<z>
pathWithinApplication();<z>
this.pattern.matches(pathContainer)) {<z>
();<z>
= this.pattern.extractPathWithinPattern(pathContainer);<z>
;<z>
"%")) {<z>
, StandardCharsets.UTF_8);<z>
(path)) {<z>
.empty();<z>
this.location.createRelative(path);<z>
isResourceUnderLocation(resource)) {<z>
.of(resource);<z>
();<z>
(IOException ex) {<z>
(ex);<z>
) {<z>
copy = new AdvisedSupport();<z>
;<z>
, getTargetSource().isStatic());<z>
.advisorChainFactory = this.advisorChainFactory;<z>
interfaces);<z>
>(this.advisors);<z>
copy;<z>
, boolean continueOnError,<z>
String separator,<z>
throws ScriptException {<z>
isDebugEnabled()) {<z>
debug("Executing SQL script from " + resource);<z>
long startTime = System.currentTimeMillis();<z>
;<z>
;<z>
(IOException ex) {<z>
);<z>
{<z>
;<z>
separator) &&<z>
,<z>
blockCommentStartDelimiter, blockCommentEndDelimiter)) {<z>
FALLBACK_STATEMENT_SEPARATOR;<z>
<>();<z>
, commentPrefixes, blockCommentStartDelimiter,<z>
blockCommentEndDelimiter, statements);<z>
int stmtNumber = 0;<z>
;<z>
for (String statement : statements) {<z>
;<z>
;<z>
.getUpdateCount();<z>
) {<z>
+ " returned as update count for SQL: " + statement);<z>
= stmt.getWarnings();<z>
(warningToLog != null) {<z>
("SQLWarning ignored: SQL state '" + warningToLog.getSQLState() +<z>
+<z>
() + "]");<z>
getNextWarning();<z>
ex) {<z>
);<z>
) {<z>
isDebugEnabled()) {<z>
statement, stmtNumber, resource), ex);<z>
resource, ex);<z>
();<z>
) {<z>
logger.trace("Could not close JDBC Statement", ex);<z>
= System.currentTimeMillis() - startTime;<z>
if (logger.isDebugEnabled()) {<z>
;<z>
(Exception ex) {<z>
if (ex instanceof ScriptException) {<z>
) ex;<z>
UncategorizedScriptException(<z>
"Failed to execute database script from resource [" + resource + "]", ex);<z>
StringValueResolver valueResolver) {<z>
);<z>
synchronized (this.aliasMap) {<z>
this.aliasMap);<z>
-> {<z>
String resolvedAlias = valueResolver.resolveStringValue(alias);<z>
valueResolver.resolveStringValue(registeredName);<z>
equals(resolvedName)) {<z>
.remove(alias);<z>
equals(alias)) {<z>
(resolvedAlias);<z>
null) {<z>
(existingName.equals(resolvedName)) {<z>
alias);<z>
(<z>
+ "' (original: '" + alias +<z>
"') for name '" + resolvedName + "': It is already registered for name '" +<z>
;<z>
checkForAliasCircle(resolvedName, resolvedAlias);<z>
.aliasMap.remove(alias);<z>
resolvedAlias, resolvedName);<z>
{<z>
alias, resolvedName);<z>
});<z>
{<z>
= descriptor.getResolvableType();<z>
Class) {<z>
return true;<z>
;<z>
;<z>
RootBeanDefinition rbd = null;<z>
bdHolder.getBeanDefinition() instanceof RootBeanDefinition) {<z>
getBeanDefinition();<z>
rbd != null) {<z>
rbd.targetType;<z>
== null) {<z>
true;<z>
rbd, descriptor);<z>
) {<z>
;<z>
null) {<z>
= dbd.targetType;<z>
== null) {<z>
dbd, descriptor);<z>
== null) {<z>
{<z>
);<z>
null) {<z>
.getUserClass(beanType));<z>
null) {<z>
();<z>
isAssignableFrom(beanClass)) {<z>
forClass(ClassUtils.getUserClass(beanClass));<z>
targetType == null) {<z>
return true;<z>
cacheType) {<z>
targetType;<z>
) &&<z>
() == Properties.class)) {<z>
true;<z>
targetType);<z>
{<z>
getCommand();<z>
stompAccessor.getMessageHeaders(), payload);<z>
&&<z>
()));<z>
if (useBinary) {<z>
(bytes));<z>
new TextMessage(bytes));<z>
ex) {<z>
throw ex;<z>
Throwable ex) {<z>
()) {<z>
), ex);<z>
StompCommand.ERROR;<z>
) {<z>
PROTOCOL_ERROR);<z>
{<z>
protected String getRequestDetails() {<z>
new StringBuilder();<z>
.append(" request(s) executed");<z>
()) {<z>
;<z>
(ClientHttpRequest request : this.requests) {<z>
);<z>
.append(".\n");<z>
);<z>
, Object handler)<z>
ServletException {<z>
{<z>
("Wrong interceptor order");<z>
{<z>
false;<z>
request.setAttribute("test2", "test2");<z>
request.setAttribute("test2x", "test2x");<z>
);<z>
;<z>
) {<z>
().value());<z>
);<z>
length = contextPath.length();<z>
{<z>
(length - 1);<z>
;<z>
T> action) throws DataAccessException {<z>
.notNull(action, "Callback object must not be null");<z>
obtainDataSource());<z>
= createConnectionProxy(con);<z>
.doInConnection(conToUse);<z>
) {<z>
action);<z>
(con, getDataSource());<z>
;<z>
);<z>
, getDataSource());<z>
protected String getDefaultMessage(String code) {<z>
if (isUseCodeAsDefaultMessage()) {<z>
return code;<z>
return null;<z>
{<z>
text);<z>
catch (ParseException ex) {<z>
)) {<z>
) {<z>
(pattern, locale));<z>
) {<z>
;<z>
.parse(text);<z>
catch (ParseException ignoredException) {<z>
(this.source != null) {<z>
= new ParseException(<z>
, this.source),<z>
;<z>
(ex);<z>
parseException;<z>
;<z>
) {<z>
();<z>
);<z>
iso());<z>
.style());<z>
)) {<z>
.setStylePattern(style);<z>
annotation.pattern());<z>
(StringUtils.hasLength(pattern)) {<z>
;<z>
= new ArrayList<>();<z>
) {<z>
fallbackPattern);<z>
resolvedFallbackPattern)) {<z>
resolvedFallbackPatterns.add(resolvedFallbackPattern);<z>
!resolvedFallbackPatterns.isEmpty()) {<z>
[0]));<z>
;<z>
) {<z>
forEach(this.responseHeaders::put);<z>
null) {<z>
.delegate.afterRequest(headers);<z>
writeInternal(T t, HttpOutputMessage outputMessage)<z>
, HttpMessageNotWritableException {<z>
);<z>
transform(t, result);<z>
(TransformerException ex) {<z>
("Could not transform [" + t + "] to output message", ex);<z>
) {<z>
()) {<z>
())) {<z>
return true;<z>
false;<z>
Nullable MimeType mimeType) {<z>
: getEncoders()) {<z>
) {<z>
return (Encoder<T>) encoder;<z>
;<z>
) {<z>
) {<z>
(TransactionAwareDataSourceProxy) dataSource).getTargetDataSource();<z>
= dataSource;<z>
protected AbstractNamedValueMethodArgumentResolver(ConversionService conversionService,<z>
{<z>
?<z>
;<z>
beanFactory;<z>
null) : null);<z>
{<z>
firstHandler;<z>
(handler != null) {<z>
handlerBlock = handler.handlerPc;<z>
handlerRangeBlock = handler.startPc;<z>
handlerRangeEnd = handler.endPc;<z>
) {<z>
{<z>
.outgoingEdges =<z>
.EXCEPTION, handlerBlock, handlerRangeBlock.outgoingEdges);<z>
else {<z>
.nextEdge.nextEdge =<z>
new Edge(<z>
nextEdge.nextEdge);<z>
handlerRangeBlock.nextBasicBlock;<z>
;<z>
hasSubroutines) {<z>
;<z>
.markSubroutine(numSubroutines);<z>
<= numSubroutines; ++currentSubroutine) {<z>
Label basicBlock = firstBasicBlock;<z>
null) {<z>
Label.FLAG_SUBROUTINE_CALLER) != 0<z>
.subroutineId == currentSubroutine) {<z>
successor;<z>
== 0) {<z>
.markSubroutine(++numSubroutines);<z>
= basicBlock.nextBasicBlock;<z>
basicBlock = firstBasicBlock;<z>
(basicBlock != null) {<z>
FLAG_SUBROUTINE_CALLER) != 0) {<z>
.outgoingEdges.nextEdge.successor;<z>
basicBlock);<z>
nextBasicBlock;<z>
;<z>
;<z>
;<z>
Label.EMPTY_LIST) {<z>
listOfBlocksToProcess;<z>
listOfBlocksToProcess.nextListElement;<z>
inputStackSize;<z>
outputStackMax;<z>
) {<z>
;<z>
= basicBlock.outgoingEdges;<z>
Label.FLAG_SUBROUTINE_CALLER) != 0) {<z>
outgoingEdge.nextEdge;<z>
) {<z>
;<z>
(successorBlock.nextListElement == null) {<z>
=<z>
outgoingEdge.info);<z>
.nextListElement = listOfBlocksToProcess;<z>
successorBlock;<z>
.nextEdge;<z>
maxStackSize;<z>
{<z>
);<z>
) {<z>
, value);<z>
values;<z>
void initRouterFunction() {<z>
;<z>
RouterFunction> beans =<z>
this.detectHandlerFunctionsInAncestorContexts ?<z>
applicationContext, RouterFunction.class) :<z>
.class));<z>
<>(beans.values());<z>
orElse(null);<z>
;<z>
IOException {<z>
(object instanceof MappingJacksonValue mappingJacksonValue) {<z>
object = mappingJacksonValue.getValue();<z>
return super.getDefaultContentType(object);<z>
) {<z>
(getEntityManagerFactory() == null) {<z>
("'entityManagerFactory' or 'persistenceUnitName' is required");<z>
EntityManagerFactoryInfo) {<z>
EntityManagerFactoryInfo) getEntityManagerFactory();<z>
();<z>
) {<z>
dataSource);<z>
);<z>
{<z>
setJpaDialect(jpaDialect);<z>
protected String getDefaultEncoding(MimeMessage mimeMessage) {<z>
if (mimeMessage instanceof SmartMimeMessage smartMimeMessage) {<z>
();<z>
null;<z>
Nullable Encoder<?> encoder) {<z>
{<z>
= ResolvableType.forInstance(value);<z>
);<z>
encodeValue(<z>
dataMimeType, EMPTY_HINTS);<z>
RowCallbackHandler rch)<z>
throws DataAccessException {<z>
(paramMap), rch);<z>
void refreshSharedConnection() throws JMSException {<z>
synchronized (this.sharedConnectionMonitor) {<z>
releaseConnection(<z>
);<z>
sharedConnection = null;<z>
();<z>
.sharedConnectionStarted) {<z>
);<z>
) {<z>
{<z>
if (objectError instanceof FieldError) {<z>
return (FieldError) objectError;<z>
;<z>
{<z>
!= null) {<z>
);<z>
partComplete(boolean finalPart) {<z>
);<z>
{<z>
;<z>
name, final String descriptor) {<z>
Symbol.CONSTANT_NAME_AND_TYPE_TAG;<z>
= hash(tag, name, descriptor);<z>
hashCode);<z>
!= null) {<z>
if (entry.tag == tag<z>
entry.hashCode == hashCode<z>
.equals(name)<z>
)) {<z>
return entry.index;<z>
;<z>
(descriptor));<z>
, hashCode)).index;<z>
domain(String name, String expected) {<z>
name).getDomain();<z>
exchangeResult.assertWithDiagnostics(() -> {<z>
" domain";<z>
, path);<z>
;<z>
responseSpec;<z>
protected void initInterceptors() {<z>
isEmpty()) {<z>
interceptors.size(); i++) {<z>
.interceptors.get(i);<z>
if (interceptor == null) {<z>
new IllegalArgumentException("Entry number " + i + " in interceptors array is null");<z>
);<z>
convertToInternal(Object payload, @Nullable MessageHeaders headers,<z>
Nullable Object conversionHint) {<z>
?> view = getSerializationView(conversionHint);<z>
) {<z>
ByteArrayOutputStream out = new ByteArrayOutputStream(1024);<z>
;<z>
encoding)) {<z>
null) {<z>
).writeValue(generator, payload);<z>
.writeValue(generator, payload);<z>
= out.toByteArray();<z>
1024);<z>
view != null) {<z>
, payload);<z>
);<z>
writer.toString();<z>
catch (IOException ex) {<z>
ex.getMessage(), ex);<z>
return payload;<z>
> parseExpressions(String... params) {<z>
) {<z>
.emptySet();<z>
);<z>
params) {<z>
;<z>
;<z>
(Map<String, String> oldVariables,<z>
) {<z>
) {<z>
(oldVariables);<z>
;<z>
mergedVariables;<z>
return oldVariables;<z>
{<z>
= (MockClientHttpRequest) request;<z>
(mockRequest);<z>
catch (ParseException ex) {<z>
);<z>
,<z>
, Object> attributes) {<z>
, wsHandler, attributes);<z>
{<z>
);<z>
original.returnValue;<z>
.returnType = original.returnType;<z>
) {<z>
= operation;<z>
= target;<z>
= args;<z>
args);<z>
postProcessBeforeInit() {<z>
this.inited || this.initedViaDeclaredInitMethod) {<z>
RuntimeException("Factory called postProcessBeforeInit after afterPropertiesSet");<z>
(this.postProcessedBeforeInit) {<z>
;<z>
.postProcessedBeforeInit = true;<z>
() {<z>
if (this.length == null) {<z>
!= null ?<z>
"#").length() : 0);<z>
.length;<z>
setThreadCallbacks(Callback[] callbacks) {<z>
Object) callbacks);<z>
{<z>
(e);<z>
InvocationTargetException e) {<z>
);<z>
A extends Annotation> boolean checkAnnotatedParamNoReactiveWrapper(<z>
<?>> typePredicate) {<z>
(annotationType);<z>
{<z>
false;<z>
);<z>
parameter.getNestedParameterType();<z>
getAdapterRegistry().getAdapter(type);<z>
(adapter != null) {<z>
assertHasValues(adapter, parameter);<z>
parameter = parameter.nested();<z>
parameter.getNestedParameterType();<z>
test(annotation, type)) {<z>
(adapter == null) {<z>
;<z>
;<z>
return false;<z>
(String name, PageContext pageContext) {<z>
+ name;<z>
attributeName);<z>
+ 1 : 1);<z>
;<z>
currentCount);<z>
registerCorsConfigurations(<z>
corsConfigurations,<z>
Object source) {<z>
.containsBeanDefinition(CORS_CONFIGURATION_BEAN_NAME)) {<z>
.class);<z>
corsDef.setSource(source);<z>
(BeanDefinition.ROLE_INFRASTRUCTURE);<z>
if (corsConfigurations != null) {<z>
;<z>
().registerBeanDefinition(CORS_CONFIGURATION_BEAN_NAME, corsDef);<z>
;<z>
) {<z>
.getRegistry().getBeanDefinition(CORS_CONFIGURATION_BEAN_NAME);<z>
).addIndexedArgumentValue(0, corsConfigurations);<z>
);<z>
(MethodMatcher mm1, MethodMatcher mm2) {<z>
(mm1, "First MethodMatcher must not be null");<z>
Assert.notNull(mm2, "Second MethodMatcher must not be null");<z>
= mm1;<z>
.mm2 = mm2;<z>
) throws ClassNotFoundException, NoSuchMethodException {<z>
staticMethod != null) {<z>
.lastIndexOf('.');<z>
== this.staticMethod.length()) {<z>
(<z>
;<z>
0, lastDotIndex);<z>
(lastDotIndex + 1);<z>
targetClass = resolveClassName(className);<z>
targetMethod = methodName;<z>
= getTargetClass();<z>
getTargetMethod();<z>
.notNull(targetClass, "Either 'targetClass' or 'targetObject' is required");<z>
notNull(targetMethod, "Property 'targetMethod' is required");<z>
] arguments = getArguments();<z>
>[arguments.length];<z>
arguments.length; ++i) {<z>
;<z>
= targetClass.getMethod(targetMethod, argTypes);<z>
(NoSuchMethodException ex) {<z>
methodObject = findMatchingMethod();<z>
(this.methodObject == null) {<z>
ex;<z>
BeanDefinitionBuilder builder) {<z>
element));<z>
;<z>
element, DEFS_ELEMENT);<z>
.isEmpty()) {<z>
> attributeSourceDefinitions = parseDefinitionsSources(cacheDefs, parserContext);<z>
);<z>
addPropertyValue("cacheOperationSources",<z>
));<z>
values() {<z>
null) {<z>
);<z>
this.values;<z>
() {<z>
propertyNames == null) {<z>
>();<z>
this.beanWrapper.getPropertyDescriptors();<z>
: props) {<z>
)) {<z>
));<z>
propertyNames = StringUtils.toStringArray(names);<z>
;<z>
{<z>
"BindMarkersFactory must not be null");<z>
this.bindMarkers = bindMarkers;<z>
this;<z>
CharSequence text, MediaType mediaType, DataBufferFactory bufferFactory) {<z>
"Expected MediaType with charset");<z>
.getCharset());<z>
bytes);<z>
className) throws IOException {<z>
), true));<z>
, AnnotatedElement source,<z>
<C, R> processor) {<z>
if (source instanceof Class) {<z>
searchStrategy, processor);<z>
(source instanceof Method) {<z>
);<z>
processor);<z>
) {<z>
();<z>
> cacheLimit) {<z>
1)) {<z>
remove();<z>
destinationCache.remove(head);<z>
)) > cacheLimit);<z>
) throws Throwable {<z>
{<z>
getJoinPointMatch(), returnValue, null);<z>
{<z>
if (parent == null) {<z>
;<z>
parentSession = parentRequest.getSession(false);<z>
(parentSession != null) {<z>
localSession = request.getSession();<z>
"No local HttpSession");<z>
parentSession.getAttributeNames();<z>
while (attrNames.hasMoreElements()) {<z>
();<z>
(attrName);<z>
attrValue);<z>
parentRequest.getHeaderNames();<z>
hasMoreElements()) {<z>
;<z>
= parentRequest.getHeaders(attrName);<z>
(attrValues.hasMoreElements()) {<z>
= attrValues.nextElement();<z>
;<z>
;<z>
forEach(request::addParameter);<z>
);<z>
parentCookies)) {<z>
parentCookies);<z>
);<z>
)) {<z>
);<z>
(parentAttrName));<z>
public boolean cancel(boolean mayInterruptIfRunning) {<z>
(mayInterruptIfRunning);<z>
mayInterruptIfRunning) {<z>
);<z>
return cancelled;<z>
final int parameterCount, final boolean visible) {<z>
!= null) {<z>
, visible);<z>
ValueRange range) {<z>
getMaximum()) {<z>
.getMinimum());<z>
;<z>
) + 1);<z>
|= (minMask & maxMask);<z>
brokerChannel(AbstractSubscribableChannel clientInboundChannel,<z>
AbstractSubscribableChannel clientOutboundChannel, TaskExecutor brokerChannelExecutor) {<z>
= getBrokerRegistry(clientInboundChannel, clientOutboundChannel);<z>
getBrokerChannelRegistration();<z>
registration.hasTaskExecutor() ?<z>
;<z>
ImmutableMessageChannelInterceptor());<z>
)));<z>
));<z>
return channel;<z>
,<z>
ServletServerHttpRequest request) throws IOException {<z>
, factory, bufferSize, request);<z>
public ReactorNettyWebSocketClient(<z>
Supplier<WebsocketClientSpec.Builder> builderSupplier) {<z>
httpClient, "HttpClient is required");<z>
.notNull(builderSupplier, "WebsocketClientSpec.Builder is required");<z>
httpClient = httpClient;<z>
.specBuilderSupplier = builderSupplier;<z>
public boolean invalidate() {<z>
;<z>
);<z>
;<z>
Nullable LockMode lockMode) throws DataAccessException {<z>
(session -> {<z>
lockMode != null) {<z>
LockOptions(lockMode));<z>
entityName, id);<z>
);<z>
) {<z>
beanFactory != null) {<z>
);<z>
;<z>
private SuspendedResourcesHolder(<z>
Object suspendedResources, List<TransactionSynchronization> suspendedSynchronizations,<z>
boolean wasActive) {<z>
.suspendedResources = suspendedResources;<z>
suspendedSynchronizations;<z>
.name = name;<z>
.readOnly = readOnly;<z>
this.isolationLevel = isolationLevel;<z>
= wasActive;<z>
) {<z>
responseStream == null) {<z>
);<z>
);<z>
close();<z>
Exception ex) {<z>
public AdvisorComponentDefinition(<z>
BeanDefinition pointcutDefinition) {<z>
(advisorBeanName, "'advisorBeanName' must not be null");<z>
, "'advisorDefinition' must not be null");<z>
= advisorBeanName;<z>
this.advisorDefinition = advisorDefinition;<z>
();<z>
BeanReference) pvs.get("adviceBeanName");<z>
, "Missing 'adviceBeanName' property");<z>
!= null) {<z>
new BeanReference[] {adviceReference};<z>
advisorDefinition, pointcutDefinition};<z>
.description = buildDescription(adviceReference, pointcutDefinition);<z>
pvs.get("pointcut");<z>
state(pointcutReference != null, "Missing 'pointcut' property");<z>
new BeanReference[] {adviceReference, pointcutReference};<z>
new BeanDefinition[] {advisorDefinition};<z>
pointcutReference);<z>
public void beforeCompletion() {<z>
(shouldUnbindAtCompletion()) {<z>
.unbindResource(this.resourceKey);<z>
false;<z>
shouldReleaseBeforeCompletion()) {<z>
);<z>
JMSException {<z>
defaultResponseDestination instanceof Destination) {<z>
.defaultResponseDestination;<z>
.defaultResponseDestination instanceof DestinationNameHolder nameHolder) {<z>
nameHolder.isTopic);<z>
return null;<z>
Object other) {<z>
other) {<z>
true;<z>
(!(other instanceof RuntimeBeanNameReference that)) {<z>
false;<z>
beanName.equals(that.beanName);<z>
{<z>
null) {<z>
;<z>
else if (this.inputStream != null) {<z>
(<z>
;<z>
content != null) {<z>
(this.content);<z>
) ?<z>
(sourceStream, this.characterEncoding) :<z>
InputStreamReader(sourceStream);<z>
= new BufferedReader(sourceReader);<z>
EMPTY_BUFFERED_READER;<z>
.reader;<z>
ServerResponse>> route(ServerRequest request) {<z>
.fromIterable(this.routerFunctions)<z>
(routerFunction -> routerFunction.route(request))<z>
next();<z>
String requestPath,<z>
locations, ResourceResolverChain chain) {<z>
(request, requestPath, locations);<z>
null) {<z>
resource;<z>
getAcceptEncoding(request);<z>
== null) {<z>
resource;<z>
.contentCodings) {<z>
)) {<z>
;<z>
(resource, coding, extension);<z>
)) {<z>
encoded;<z>
ex) {<z>
()) {<z>
() + "]", ex);<z>
resource;<z>
T> requiredType, @Nullable Field field)<z>
TypeMismatchException {<z>
(value, requiredType,<z>
: TypeDescriptor.valueOf(requiredType)));<z>
{<z>
PersistenceUnit.class))) {<z>
return InjectionMetadata.EMPTY;<z>
> elements = new ArrayList<>();<z>
targetClass = clazz;<z>
;<z>
ReflectionUtils.doWithLocalFields(targetClass, field -> {<z>
PersistenceContext.class) ||<z>
class)) {<z>
getModifiers())) {<z>
("Persistence annotations are not supported on static fields");<z>
, field, null));<z>
});<z>
, method -> {<z>
);<z>
BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {<z>
(PersistenceContext.class) ||<z>
.isAnnotationPresent(PersistenceUnit.class)) &&<z>
) {<z>
) {<z>
);<z>
.getParameterCount() != 1) {<z>
new IllegalStateException("Persistence annotation requires a single-arg method: " + method);<z>
;<z>
, bridgedMethod, pd));<z>
);<z>
.addAll(0, currElements);<z>
);<z>
!= Object.class);<z>
elements, clazz);<z>
{<z>
hasText(text)) {<z>
text, LocaleContextHolder.getLocale()));<z>
ex) {<z>
;<z>
ex) {<z>
"Parse attempt failed for value [" + text + "]", ex);<z>
setValue(null);<z>
{<z>
) {<z>
.customizeContext(context, mergedConfig);<z>
public void refresh() throws BeansException, IllegalStateException {<z>
.startupShutdownMonitor) {<z>
.start("spring.context.refresh");<z>
();<z>
beanFactory = obtainFreshBeanFactory();<z>
prepareBeanFactory(beanFactory);<z>
);<z>
;<z>
invokeBeanFactoryPostProcessors(beanFactory);<z>
;<z>
end();<z>
initMessageSource();<z>
);<z>
);<z>
();<z>
;<z>
;<z>
{<z>
(logger.isWarnEnabled()) {<z>
.warn("Exception encountered during context initialization - " +<z>
+ ex);<z>
;<z>
(ex);<z>
;<z>
();<z>
contextRefresh.end();<z>
Throwable[] getRelatedCauses() {<z>
if (this.relatedCauses == null) {<z>
null;<z>
.toArray(new Throwable[0]);<z>
(ProcessingEnvironment env) {<z>
= new ArrayList<>();<z>
TypeHelper typeHelper = new TypeHelper(env);<z>
new IndexedStereotypesProvider(typeHelper));<z>
.add(new StandardStereotypesProvider(typeHelper));<z>
.add(new PackageInfoStereotypesProvider());<z>
result;<z>
Function<Context, Context> contextModifier) {<z>
.contextModifier != null ?<z>
(contextModifier) : contextModifier);<z>
this;<z>
DataBufferFactory factory,<z>
<Void> completionSink) {<z>
info, factory, completionSink);<z>
> responseMono, Supplier<HttpRequest> requestSupplier) {<z>
responseMono;<z>
this.requestSupplier = requestSupplier;<z>
add(DEFAULT_STATUS_HANDLER);<z>
other) {<z>
if (this == other) {<z>
true;<z>
!(other instanceof TypeDescriptor otherDesc)) {<z>
return false;<z>
getType()) {<z>
false;<z>
if (!annotationsMatch(otherDesc)) {<z>
false;<z>
{<z>
));<z>
isMap()) {<z>
otherDesc.getMapKeyTypeDescriptor()) &&<z>
));<z>
true;<z>
public DummyThemeSource() {<z>
new StaticMessageSource();<z>
);<z>
.ENGLISH, "theme test message {0}");<z>
ModelAndView handleConversionNotSupported(ConversionNotSupportedException ex,<z>
Object handler) throws IOException {<z>
response);<z>
new ModelAndView();<z>
int countOccurrencesOf(String str, String sub) {<z>
hasLength(sub)) {<z>
0;<z>
0;<z>
;<z>
;<z>
1) {<z>
count;<z>
sub.length();<z>
return count;<z>
public AccessorLValue(PropertyOrFieldReference propertyOrFieldReference, TypedValue activeContextObject,<z>
evalContext, boolean autoGrowNullReferences) {<z>
ref = propertyOrFieldReference;<z>
;<z>
evalContext;<z>
;<z>
protected long getNextKey() throws DataAccessException {<z>
(getDataSource());<z>
= null;<z>
;<z>
con.createStatement();<z>
.applyTransactionTimeout(stmt, getDataSource());<z>
;<z>
{<z>
rs.getLong(1);<z>
DataAccessResourceFailureException("Sequence query did not return a result");<z>
catch (SQLException ex) {<z>
throw new DataAccessResourceFailureException("Could not obtain sequence value", ex);<z>
(rs);<z>
);<z>
, getDataSource());<z>
Object key) throws IllegalStateException {<z>
TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);<z>
value = doUnbindResource(actualKey);<z>
null) {<z>
+ actualKey + "] bound to thread");<z>
value;<z>
{<z>
();<z>
(method != null) {<z>
valueOf(method);<z>
return null;<z>
removeAttributes() {<z>
.errorMessagesWereExposed) {<z>
(this.oldMessages != null) {<z>
;<z>
oldMessages = null;<z>
PageContext.PAGE_SCOPE);<z>
getPropertyValue(PropertyTokenHolder tokens) throws BeansException {<z>
String propertyName = tokens.canonicalName;<z>
;<z>
(actualName);<z>
) {<z>
, this.nestedPath + propertyName);<z>
;<z>
(tokens.keys != null) {<z>
== null) {<z>
if (isAutoGrowNestedPaths()) {<z>
.actualName));<z>
.nestedPath + propertyName,<z>
;<z>
;<z>
keys.length; i++) {<z>
;<z>
if (value == null) {<z>
getRootClass(), this.nestedPath + propertyName,<z>
+ "': returned null");<z>
) {<z>
int index = Integer.parseInt(key);<z>
indexedPropertyName.toString());<z>
.get(value, index);<z>
{<z>
parseInt(key);<z>
>) value;<z>
ph, i + 1);<z>
= list.get(index);<z>
(value instanceof Set) {<z>
;<z>
.parseInt(key);<z>
{<z>
.nestedPath + propertyName,<z>
"Cannot get element with index " + index + " from Set of size " +<z>
) + ", accessed using property path '" + propertyName + "'");<z>
();<z>
hasNext(); j++) {<z>
;<z>
j == index) {<z>
;<z>
if (value instanceof Map) {<z>
>) value;<z>
resolveGeneric(0);<z>
;<z>
, mapKeyType, typeDescriptor);<z>
convertedMapKey);<z>
.nestedPath + propertyName,<z>
propertyName +<z>
+ "]");<z>
).append(PROPERTY_KEY_SUFFIX);<z>
return value;<z>
{<z>
.nestedPath + propertyName,<z>
"Index of out of bounds in property path '" + propertyName + "'", ex);<z>
NumberFormatException | TypeMismatchException ex) {<z>
+ propertyName,<z>
);<z>
ex) {<z>
, this.nestedPath + propertyName,<z>
+ "' threw exception", ex);<z>
Exception ex) {<z>
), this.nestedPath + propertyName,<z>
"Illegal attempt to get property '" + actualName + "' threw exception", ex);<z>
(@Nullable BeanDefinitionRegistry source) {<z>
) {<z>
ConfigurableListableBeanFactory) source;<z>
ConfigurableApplicationContext) {<z>
));<z>
;<z>
SpelNodeImpl operandExpression) {<z>
null) {<z>
;<z>
configMember) {<z>
postProcessingLock) {<z>
(this.externallyManagedConfigMembers == null) {<z>
<>(1);<z>
configMember);<z>
) {<z>
(targetTypeAndInfo >>> 24) {<z>
case CLASS_TYPE_PARAMETER:<z>
case METHOD_TYPE_PARAMETER:<z>
:<z>
);<z>
case FIELD:<z>
:<z>
case METHOD_RECEIVER:<z>
;<z>
CAST:<z>
CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:<z>
case METHOD_INVOCATION_TYPE_ARGUMENT:<z>
:<z>
METHOD_REFERENCE_TYPE_ARGUMENT:<z>
;<z>
CLASS_EXTENDS:<z>
case CLASS_TYPE_PARAMETER_BOUND:<z>
case METHOD_TYPE_PARAMETER_BOUND:<z>
THROWS:<z>
case EXCEPTION_PARAMETER:<z>
:<z>
:<z>
:<z>
METHOD_REFERENCE:<z>
> 8);<z>
IllegalArgumentException();<z>
NamingException {<z>
{<z>
throw new IllegalArgumentException("Property 'jndiName' is required");<z>
boolean[] array) {<z>
== null) {<z>
0;<z>
;<z>
boolean element : array) {<z>
element);<z>
;<z>
> consumer) {<z>
this.useGlobalResources = true;<z>
.globalResourcesConsumer != null ?<z>
;<z>
endPos, String value) {<z>
super(payload, startPos, endPos);<z>
length() - 1);<z>
;<z>
, "\"");<z>
new TypedValue(valueWithinQuotes);<z>
.exitTypeDescriptor = "Ljava/lang/String";<z>
elementType,<z>
, Map<String, Object> hints) {<z>
).flatMap(resource -><z>
hints));<z>
, String msg) {<z>
beanName + "': " + msg);<z>
beanName = beanName;<z>
.resourceDescription = null;<z>
private int positionOf(@Nullable Token t) {<z>
== null) {<z>
.expressionString.length();<z>
;<z>
) {<z>
(VALUE_TYPE_ATTRIBUTE);<z>
;<z>
(nl.getLength());<z>
.setSource(extractSource(collectionEle));<z>
defaultElementType);<z>
setMergeEnabled(parseMergeAttribute(collectionEle));<z>
);<z>
target;<z>
> getSerializationView(@Nullable Object conversionHint) {<z>
param) {<z>
= (param.getParameterIndex() >= 0 ?<z>
.getMethodAnnotation(JsonView.class));<z>
) {<z>
);<z>
instanceof JsonView) {<z>
JsonView) conversionHint, conversionHint);<z>
else if (conversionHint instanceof Class) {<z>
<?>) conversionHint;<z>
null;<z>
noCache() {<z>
CacheControl cc = new CacheControl();<z>
= true;<z>
cc;<z>
IOException {<z>
();<z>
null, "'url' not set");<z>
());<z>
Field getField() {<z>
;<z>
.hasLength(name)) {<z>
return null;<z>
;<z>
> declaringClass = declaringClass();<z>
) {<z>
;<z>
== null) {<z>
StringUtils.uncapitalize(name));<z>
if (field == null) {<z>
));<z>
return field;<z>
Deque<TypedValue> initScopeRootObjects() {<z>
== null) {<z>
>();<z>
;<z>
EntityManager em, EntityManagerFactory emf) {<z>
emf instanceof EntityManagerFactoryInfo emfInfo) {<z>
emfInfo.getJpaDialect();<z>
!= null) {<z>
em,<z>
,<z>
));<z>
null;<z>
String basePackage) {<z>
;<z>
);<z>
(TypeFilter filter : this.includeFilters) {<z>
);<z>
null) {<z>
"Failed to extract stereotype from " + filter);<z>
));<z>
boolean traceEnabled = logger.isTraceEnabled();<z>
;<z>
types) {<z>
= getMetadataReaderFactory().getMetadataReader(type);<z>
(metadataReader)) {<z>
(metadataReader);<z>
;<z>
if (isCandidateComponent(sbd)) {<z>
debugEnabled) {<z>
logger.debug("Using candidate component class from index: " + type);<z>
candidates.add(sbd);<z>
debugEnabled) {<z>
logger.debug("Ignored because not a concrete top-level class: " + type);<z>
if (traceEnabled) {<z>
"Ignored because matching an exclude filter: " + type);<z>
(IOException ex) {<z>
);<z>
candidates;<z>
) {<z>
(sourceType, targetType);<z>
converterCache.get(key);<z>
) {<z>
null);<z>
.converters.find(sourceType, targetType);<z>
== null) {<z>
sourceType, targetType);<z>
!= null) {<z>
key, converter);<z>
;<z>
;<z>
null;<z>
Object object) {<z>
;<z>
object;<z>
, this.wrappedObject);<z>
;<z>
AnnotatedElement source, boolean defensive) {<z>
= false;<z>
= declaredAnnotationCache.get(source);<z>
if (annotations != null) {<z>
true;<z>
);<z>
length != 0) {<z>
= true;<z>
annotations.length; i++) {<z>
Annotation annotation = annotations[i];<z>
)) ||<z>
) {<z>
= null;<z>
allIgnored = false;<z>
? NO_ANNOTATIONS : annotations);<z>
Member) {<z>
(source, annotations);<z>
= true;<z>
== 0 || !cached) {<z>
;<z>
.clone();<z>
int statusCode, @Nullable HttpHeaders headers,<z>
Flux<DataBuffer> body,<z>
{<z>
,<z>
"Expected either headers or an original response with headers.");<z>
isTrue(cookies != null || originalResponse != null,<z>
"Expected either cookies or an original response with cookies.");<z>
= statusCode;<z>
.readOnlyHttpHeaders(headers) : null);<z>
unmodifiableMultiValueMap(cookies) : null);<z>
this.body = body;<z>
.originalResponse = originalResponse;<z>
original) {<z>
{<z>
return null;<z>
= null;<z>
Throwable cause = original.getCause();<z>
null && cause != rootCause) {<z>
rootCause = cause;<z>
cause.getCause();<z>
;<z>
getOrder() {<z>
if (this.order == null) {<z>
;<z>
;<z>
String) {<z>
beanOrName;<z>
targetBeanName = ScopedProxyUtils.getTargetBeanName(beanName);<z>
.containsBean(targetBeanName);<z>
&& !ScopedProxyUtils.isScopedTarget(beanName)) {<z>
= resolveBean();<z>
resolveBean();<z>
Ordered ordered) {<z>
ordered.getOrder();<z>
{<z>
BeanDefinition bd = cbf.getMergedBeanDefinition(beanName);<z>
{<z>
Method factoryMethod = rbd.getResolvedFactoryMethod();<z>
factoryMethod != null) {<z>
order = OrderUtils.getOrder(factoryMethod);<z>
) {<z>
if (this.order == null) {<z>
this.beanType != null) {<z>
.LOWEST_PRECEDENCE);<z>
.LOWEST_PRECEDENCE;<z>
return this.order;<z>
